<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"> <!--320-->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

    <link rel="icon" href="../../mapt/images/favicon.ico">

    <link rel="stylesheet" href="../../mapt/css/font-awesome.css">
    <link rel="stylesheet" href="../../mapt/css/google-fonts.css">
    <link rel="stylesheet" href="../../mapt/css/devicon.css">

    <link rel="stylesheet" href="../../mapt/css/bootstrap.css">
    <link rel="stylesheet" href="../../mapt/css/bootstrap-xl.css">
    <link rel="stylesheet" href="../../mapt/css/magnific-popup.css">
    <link rel="stylesheet" href="../../mapt/css/prism.css">
    <link rel="stylesheet" href="../../mapt/css/hljs-github.css">

    <link rel="stylesheet" href="../../mapt/css/mapt.css">
    <link rel="stylesheet" href="../../mapt/css/custom.css">

    <script src="../../mapt/js/jquery.js"></script>
    <script src="../../mapt/js/bootstrap.js"></script>
    <script src="../../mapt/js/jquery.magnific-popup.js"></script>
    <script src="../../mapt/js/highlight.min.js"></script>

    <script src="../../mapt/js/custom.js"></script>
    
    <title>.NET 4.5 Parallel Extensions Cookbook</title>
</head>

<body class="home-body">
    <div id="wrapper">
        <div id="sidebar-wrapper">    
            <ul class="sidebar-nav">
                <div class="list-group" id="sidebar-nav" role="tablist">
                    <li>
                        <a href="../../index.html" class="sidenav-menu-holder back-btn" id="back-link">
                            <span class="sidenav-menu">Book List</span>
                            <span class="pull-left mr5"><i class="fa fa-chevron-left"></i></span>
                        </a>
                    </li>
                    
                    <li class="book-info copyright">
                        <span class="info text-nowrap"><span class="copyleft">&copy;</span><span><strong>RuTracker</strong>.org</span></span>
                    </li>          
                    <li class="book-info copyright">
                        <span class="info text-nowrap">Pub date: <strong>26 Jul 2013</strong></span>
                    </li>         
                    <li class="book-info">
                        <span class="info text-nowrap">Price: â‚¬<strong>23.99</strong></span>
                        <span class="info text-nowrap">ISBN: <strong>9781849690225</strong></span>
                    </li>     
            
                    <li>
                        <a href="graphics/cover.jpg" class="sidenav-menu-holder cover-img">
                            <img src="graphics/cover.jpg" class="cover-image">
                        </a>
                    </li>        
            
                    <div class="book_navigation">
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse1">
                                <div class="section-name">1: Getting Started with Task Parallel Library</div>
                            </a>
                        </li>
                        <div id="collapse1" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="1" class="sub-nav">
                                <a href="#ch01">
                                    <div class="section-name">Chapter 1: Getting Started with Task Parallel Library</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec08" class="sub-nav">
                                <a href="#ch01lvl1sec08">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec09" class="sub-nav">
                                <a href="#ch01lvl1sec09">                    
                                    <div class="section-name">Creating a task</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec10" class="sub-nav">
                                <a href="#ch01lvl1sec10">                    
                                    <div class="section-name">Waiting for tasks to finish</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec11" class="sub-nav">
                                <a href="#ch01lvl1sec11">                    
                                    <div class="section-name">Returning results from a task</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec12" class="sub-nav">
                                <a href="#ch01lvl1sec12">                    
                                    <div class="section-name">Passing data to a task</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec13" class="sub-nav">
                                <a href="#ch01lvl1sec13">                    
                                    <div class="section-name">Creating a child task</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec14" class="sub-nav">
                                <a href="#ch01lvl1sec14">                    
                                    <div class="section-name">Lazy task execution</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec15" class="sub-nav">
                                <a href="#ch01lvl1sec15">                    
                                    <div class="section-name">Handling task exceptions using try/catch block</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec16" class="sub-nav">
                                <a href="#ch01lvl1sec16">                    
                                    <div class="section-name">Handling task exceptions with AggregateException.Handle</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec17" class="sub-nav">
                                <a href="#ch01lvl1sec17">                    
                                    <div class="section-name">Cancelling a task</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec18" class="sub-nav">
                                <a href="#ch01lvl1sec18">                    
                                    <div class="section-name">Cancelling one of many tasks</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse2">
                                <div class="section-name">2: Implementing Continuations</div>
                            </a>
                        </li>
                        <div id="collapse2" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="2" class="sub-nav">
                                <a href="#ch02">
                                    <div class="section-name">Chapter 2: Implementing Continuations</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec19" class="sub-nav">
                                <a href="#ch02lvl1sec19">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec20" class="sub-nav">
                                <a href="#ch02lvl1sec20">                    
                                    <div class="section-name">Continuing a task</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec21" class="sub-nav">
                                <a href="#ch02lvl1sec21">                    
                                    <div class="section-name">Passing task results to a continuation</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec22" class="sub-nav">
                                <a href="#ch02lvl1sec22">                    
                                    <div class="section-name">Continue &amp;quot;WhenAny&amp;quot; and &amp;quot;WhenAll&amp;quot;</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec23" class="sub-nav">
                                <a href="#ch02lvl1sec23">                    
                                    <div class="section-name">Specifying when a continuation will run</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec24" class="sub-nav">
                                <a href="#ch02lvl1sec24">                    
                                    <div class="section-name">Using a continuation for exception handling</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec25" class="sub-nav">
                                <a href="#ch02lvl1sec25">                    
                                    <div class="section-name">Cancelling a continuation</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec26" class="sub-nav">
                                <a href="#ch02lvl1sec26">                    
                                    <div class="section-name">Using a continuation to chain multiple tasks</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec27" class="sub-nav">
                                <a href="#ch02lvl1sec27">                    
                                    <div class="section-name">Using a continuation to update a UI</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse3">
                                <div class="section-name">3: Learning Concurrency with Parallel Loops</div>
                            </a>
                        </li>
                        <div id="collapse3" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="3" class="sub-nav">
                                <a href="#ch03">
                                    <div class="section-name">Chapter 3: Learning Concurrency with Parallel Loops</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec28" class="sub-nav">
                                <a href="#ch03lvl1sec28">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec29" class="sub-nav">
                                <a href="#ch03lvl1sec29">                    
                                    <div class="section-name">Creating a basic parallel for loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec30" class="sub-nav">
                                <a href="#ch03lvl1sec30">                    
                                    <div class="section-name">Creating a basic parallel foreach loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec31" class="sub-nav">
                                <a href="#ch03lvl1sec31">                    
                                    <div class="section-name">Breaking a parallel loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec32" class="sub-nav">
                                <a href="#ch03lvl1sec32">                    
                                    <div class="section-name">Stopping a parallel loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec33" class="sub-nav">
                                <a href="#ch03lvl1sec33">                    
                                    <div class="section-name">Cancelling a parallel loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec34" class="sub-nav">
                                <a href="#ch03lvl1sec34">                    
                                    <div class="section-name">Handling exceptions in a parallel loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec35" class="sub-nav">
                                <a href="#ch03lvl1sec35">                    
                                    <div class="section-name">Controlling the degree of parallelism in a loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec36" class="sub-nav">
                                <a href="#ch03lvl1sec36">                    
                                    <div class="section-name">Partitioning data in a parallel loop</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec37" class="sub-nav">
                                <a href="#ch03lvl1sec37">                    
                                    <div class="section-name">Using Thread Local Storage</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse4">
                                <div class="section-name">4: Parallel LINQ</div>
                            </a>
                        </li>
                        <div id="collapse4" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="4" class="sub-nav">
                                <a href="#ch04">
                                    <div class="section-name">Chapter 4: Parallel LINQ</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec38" class="sub-nav">
                                <a href="#ch04lvl1sec38">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec39" class="sub-nav">
                                <a href="#ch04lvl1sec39">                    
                                    <div class="section-name">Creating a basic parallel query</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec40" class="sub-nav">
                                <a href="#ch04lvl1sec40">                    
                                    <div class="section-name">Preserving order in parallel LINQ</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec41" class="sub-nav">
                                <a href="#ch04lvl1sec41">                    
                                    <div class="section-name">Forcing parallel execution</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec42" class="sub-nav">
                                <a href="#ch04lvl1sec42">                    
                                    <div class="section-name">Limiting parallelism in a query</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec43" class="sub-nav">
                                <a href="#ch04lvl1sec43">                    
                                    <div class="section-name">Processing query results</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec44" class="sub-nav">
                                <a href="#ch04lvl1sec44">                    
                                    <div class="section-name">Specifying merge options</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec45" class="sub-nav">
                                <a href="#ch04lvl1sec45">                    
                                    <div class="section-name">Range projection with parallel LINQ</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec46" class="sub-nav">
                                <a href="#ch04lvl1sec46">                    
                                    <div class="section-name">Handling exceptions in parallel LINQ</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec47" class="sub-nav">
                                <a href="#ch04lvl1sec47">                    
                                    <div class="section-name">Cancelling a parallel LINQ query</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec48" class="sub-nav">
                                <a href="#ch04lvl1sec48">                    
                                    <div class="section-name">Performing reduction operations</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec49" class="sub-nav">
                                <a href="#ch04lvl1sec49">                    
                                    <div class="section-name">Creating a custom partitioner</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse5">
                                <div class="section-name">5: Concurrent Collections</div>
                            </a>
                        </li>
                        <div id="collapse5" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="5" class="sub-nav">
                                <a href="#ch05">
                                    <div class="section-name">Chapter 5: Concurrent Collections</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec50" class="sub-nav">
                                <a href="#ch05lvl1sec50">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec51" class="sub-nav">
                                <a href="#ch05lvl1sec51">                    
                                    <div class="section-name">Adding and removing items to BlockingCollection</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec52" class="sub-nav">
                                <a href="#ch05lvl1sec52">                    
                                    <div class="section-name">Iterating a BlockingCollection with GetConsumingEnumerable</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec53" class="sub-nav">
                                <a href="#ch05lvl1sec53">                    
                                    <div class="section-name">Performing LIFO operations with ConcurrentStack</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec54" class="sub-nav">
                                <a href="#ch05lvl1sec54">                    
                                    <div class="section-name">Thread safe data lookups with ConcurrentDictionary</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec55" class="sub-nav">
                                <a href="#ch05lvl1sec55">                    
                                    <div class="section-name">Cancelling an operation in a concurrent collection</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec56" class="sub-nav">
                                <a href="#ch05lvl1sec56">                    
                                    <div class="section-name">Working with multiple producers and consumers</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec57" class="sub-nav">
                                <a href="#ch05lvl1sec57">                    
                                    <div class="section-name">Creating object pool with ConcurrentStack</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec58" class="sub-nav">
                                <a href="#ch05lvl1sec58">                    
                                    <div class="section-name">Adding blocking and bounding with IProducerConsumerCollection</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec59" class="sub-nav">
                                <a href="#ch05lvl1sec59">                    
                                    <div class="section-name">Using multiple concurrent collections to create a pipeline</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse6">
                                <div class="section-name">6: Synchronization Primitives</div>
                            </a>
                        </li>
                        <div id="collapse6" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="6" class="sub-nav">
                                <a href="#ch06">
                                    <div class="section-name">Chapter 6: Synchronization Primitives</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec60" class="sub-nav">
                                <a href="#ch06lvl1sec60">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec61" class="sub-nav">
                                <a href="#ch06lvl1sec61">                    
                                    <div class="section-name">Using monitor</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec62" class="sub-nav">
                                <a href="#ch06lvl1sec62">                    
                                    <div class="section-name">Using a mutual exclusion lock</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec63" class="sub-nav">
                                <a href="#ch06lvl1sec63">                    
                                    <div class="section-name">Using SpinLock for synchronization</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec64" class="sub-nav">
                                <a href="#ch06lvl1sec64">                    
                                    <div class="section-name">Interlocked operations</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec65" class="sub-nav">
                                <a href="#ch06lvl1sec65">                    
                                    <div class="section-name">Synchronizing multiple tasks with a Barrier</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec66" class="sub-nav">
                                <a href="#ch06lvl1sec66">                    
                                    <div class="section-name">Using ReaderWriterLockSlim</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec67" class="sub-nav">
                                <a href="#ch06lvl1sec67">                    
                                    <div class="section-name">Using WaitHandles with Mutex</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec68" class="sub-nav">
                                <a href="#ch06lvl1sec68">                    
                                    <div class="section-name">Waiting for multiple threads with CountdownEvent</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec69" class="sub-nav">
                                <a href="#ch06lvl1sec69">                    
                                    <div class="section-name">Using ManualResetEventSlim to spin and wait</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec70" class="sub-nav">
                                <a href="#ch06lvl1sec70">                    
                                    <div class="section-name">Using SemaphoreSlim to limit access</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse7">
                                <div class="section-name">7: Profiling and Debugging</div>
                            </a>
                        </li>
                        <div id="collapse7" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="7" class="sub-nav">
                                <a href="#ch07">
                                    <div class="section-name">Chapter 7: Profiling and Debugging</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec71" class="sub-nav">
                                <a href="#ch07lvl1sec71">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec72" class="sub-nav">
                                <a href="#ch07lvl1sec72">                    
                                    <div class="section-name">Using the Threads and Call Stack windows</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec73" class="sub-nav">
                                <a href="#ch07lvl1sec73">                    
                                    <div class="section-name">Using the Parallel Stacks window</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec74" class="sub-nav">
                                <a href="#ch07lvl1sec74">                    
                                    <div class="section-name">Watching values in a thread with Parallel Watch window</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec75" class="sub-nav">
                                <a href="#ch07lvl1sec75">                    
                                    <div class="section-name">Detecting deadlocks with the Parallel Tasks window</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec76" class="sub-nav">
                                <a href="#ch07lvl1sec76">                    
                                    <div class="section-name">Measure CPU utilization with Concurrency Visualizer</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec77" class="sub-nav">
                                <a href="#ch07lvl1sec77">                    
                                    <div class="section-name">Using Concurrency Visualizer Threads view</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec78" class="sub-nav">
                                <a href="#ch07lvl1sec78">                    
                                    <div class="section-name">Using Concurrency Visualizer Cores view</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse8">
                                <div class="section-name">8: Async</div>
                            </a>
                        </li>
                        <div id="collapse8" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="8" class="sub-nav">
                                <a href="#ch08">
                                    <div class="section-name">Chapter 8: Async</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec79" class="sub-nav">
                                <a href="#ch08lvl1sec79">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec80" class="sub-nav">
                                <a href="#ch08lvl1sec80">                    
                                    <div class="section-name">Creating an async method</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec81" class="sub-nav">
                                <a href="#ch08lvl1sec81">                    
                                    <div class="section-name">Handling Exceptions in asynchronous code</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec82" class="sub-nav">
                                <a href="#ch08lvl1sec82">                    
                                    <div class="section-name">Cancelling an asynchronous operation</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec83" class="sub-nav">
                                <a href="#ch08lvl1sec83">                    
                                    <div class="section-name">Cancelling async operation after timeout period</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec84" class="sub-nav">
                                <a href="#ch08lvl1sec84">                    
                                    <div class="section-name">Processing multiple async tasks as they complete</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec85" class="sub-nav">
                                <a href="#ch08lvl1sec85">                    
                                    <div class="section-name">Improving performance of async solution with Task.WhenAll</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec86" class="sub-nav">
                                <a href="#ch08lvl1sec86">                    
                                    <div class="section-name">Using async for file access</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec87" class="sub-nav">
                                <a href="#ch08lvl1sec87">                    
                                    <div class="section-name">Checking the progress of an asynchronous task</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse9">
                                <div class="section-name">9: Dataflow Library</div>
                            </a>
                        </li>
                        <div id="collapse9" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="9" class="sub-nav">
                                <a href="#ch09">
                                    <div class="section-name">Chapter 9: Dataflow Library</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec88" class="sub-nav">
                                <a href="#ch09lvl1sec88">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec89" class="sub-nav">
                                <a href="#ch09lvl1sec89">                    
                                    <div class="section-name">Reading from and writing to a dataflow block synchronously</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec90" class="sub-nav">
                                <a href="#ch09lvl1sec90">                    
                                    <div class="section-name">Reading from and writing to a dataflow block asynchronously</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec91" class="sub-nav">
                                <a href="#ch09lvl1sec91">                    
                                    <div class="section-name">Implementing a producer-consumer dataflow pattern</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec92" class="sub-nav">
                                <a href="#ch09lvl1sec92">                    
                                    <div class="section-name">Creating a dataflow pipeline</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec93" class="sub-nav">
                                <a href="#ch09lvl1sec93">                    
                                    <div class="section-name">Cancelling a dataflow block</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec94" class="sub-nav">
                                <a href="#ch09lvl1sec94">                    
                                    <div class="section-name">Specifying the degree of parallelism</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec95" class="sub-nav">
                                <a href="#ch09lvl1sec95">                    
                                    <div class="section-name">Unlink dataflow blocks</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec96" class="sub-nav">
                                <a href="#ch09lvl1sec96">                    
                                    <div class="section-name">Using JoinBlock to read from multiple data sources</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapsebackindex">
                                <div class="section-name">Appendix A: Index</div>
                            </a>
                        </li>
                        <div id="collapsebackindex" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="backindex" class="sub-nav">
                                <a href="#backindex">
                                    <div class="section-name">Chapter Appendix A: Index</div>
                                </a>
                            </li>
                        </div>
                    </div>
                </div>
            </ul>
        </div>
        
        <div id="page-content-wrapper" class="book-page">
            <a href="#" id="menu-toggle" class="toggle-nav"><i class="fa fa-bars fa-2x mr5"></i></a>
            
            <a href="#" id="back_to_top" class="back-to-top"><img src="../../mapt/images/kopimi.svg"></a>
            
            <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10">
                <div class="btn-group pull-right mt15 mb30" role="group">
                    <a href="#home" class="btn btn-default">
                        <i class="fa fa-share fa-lg no-text-padding"></i>
                        <span class="hidden-xs ml5">Book Home</span>
                    </a>
                    <button class="btn btn-default" data-nid="12752" id="code-download">
                        <i class="fa fa-file fa-lg"></i>
                        <span class="hidden-xs ml5">Download Code Files</span>
                    </button>
                </div>
            </div>
            <div class="clearfix"></div>
            
            <div id="book-wrapper" class="container-fluid">
                <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10" id="home">
                    <h2 class="product-title">.NET 4.5 Parallel Extensions Cookbook</h2>
                    <hr>
                    <div class="row">
                        <div class="col-sm-12">
                            <h5 class="mt10">By Bryan Freeman</h5>
                            <div>
                                <p class="mb20"><b>If youâ€™re an experienced C# developer, this book will give you the know-how to exploit the power of multicore processors. Its 80 recipes provide an in-depth guide to using .NET 4.5 to enhance application performance and scalability.</b></p>
                                <a href="#ch01" class="btn btn-info btn-lg pull-right hidden-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <a href="#ch01" class="btn btn-info btn-lg btn-block mt20 mb20 visible-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <div class="clearfix"></div>
                                <div class="col-sm-12">
                                    <ul id="myTabs" class="nav nav-tabs nav-justified hidden-xs mt20" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab" data-toggle="tab">
                                                <h5>Info</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab" data-toggle="tab">
                                                <h5>Contents</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab" data-toggle="tab">
                                                <h5>Author</h5>
                                            </a>
                                        </li>
                                    </ul>
                
                                    <ul id="myTabsMobile" class="nav nav-pills text-center nav-stacked visible-xs mb60" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab-responsive" data-toggle="tab">
                                                Info
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab-responsive" data-toggle="tab">
                                                Contents
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab-responsive" data-toggle="tab">
                                                Author
                                            </a>
                                        </li>
                                    </ul>
                
                                    <div id="myTabContent" class="tab-content pt30">
                                    
                                        <div role="tabpanel" class="tab-pane active fade in" id="info">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Features</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Features</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li>Create multithreaded applications using .NET Framework 4.5</li>
                <li>Get introduced to .NET 4.5 parallel extensions and familiarized with .NET parallel loops</li>
                <li>Use new data structures introduced by .NET Framework 4.5 to simplify complex synchronisation problems</li>
                <li>Practical recipes on everything you will need to create task-based parallel programs</li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Learning</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Learning</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li>Create a task using Parallel.Invoke, Task.Factory, and Task.Start</li>
                <li>Work with declarative data parallelism using Parallel Language Integrated Query (PLINQ) and its aggregate functions</li>
                <li>Perform independent operations on the member data of a collection using parallel loops</li>
                <li>Coordinate the activities of multiple tasks using new lightweight synchronization primitives</li>
                <li>Learn to use Visual Studio 2012 debugging and profiling capabilities related to parallel programming</li>
                <li>Maintain a responsive UI using asynchronous tasks</li>
                <li>Create a pipeline using multiple concurrent collections</li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">About</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>About</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <p>.NET parallel extensions brings the power of parallel and asynchronous programming to a much wider developer audience than ever before. This book will give a developer with no multithreaded development experience the ability to write highly scalable parallel applications that take advantage of modern multicore processors.If you are an experienced .NET developer who wants to put parallel extensions to work in your applications, this book is for you.</p>
                <p>".NET 4.5 Parallel Extensions Cookbook" is a practical, hands-on guide that provides you with a number of clear step-by-step recipes that will introduce parallelism into your applications and take advantage of modern multicore processors. This book is a crash course in using the extensions, with theory and concepts kept to a minimum.</p>
                <p>".NET 4.5 Parallel Extensions Cookbook" offers a wide-ranging presentation of parallel development concepts, and provides a working knowledge of key technologies that are important to developers who want to take advantage of multi-core architectures.</p>
                <p>You will learn how to compose a series of producer/consumer tasks into a pipeline that can process data elements received from a real-time event stream. You will also learn how to connect the stages of pipelines together using the concurrent collections. You will learn everything you need to know to transform the multicore power found in modern processors into application performance and scalability.</p>
                                            </div>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade in" id="content">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Contents</h5>
                                                <hr>
                                            </div>
                                            <ul>
                                                <div>
                                                    <li data-chapter="1">
                                                        <div class="section-name">1: Getting Started with Task Parallel Library</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="1" class="chapter-section">
                                                                    <a href="#ch01">        
                                                                        <div class="section-name">Chapter 1: Getting Started with Task Parallel Library</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec08" class="chapter-section">
                                                                    <a href="#ch01lvl1sec08">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec09" class="chapter-section">
                                                                    <a href="#ch01lvl1sec09">                    
                                                                        <div class="section-name">Creating a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec10" class="chapter-section">
                                                                    <a href="#ch01lvl1sec10">                    
                                                                        <div class="section-name">Waiting for tasks to finish</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec11" class="chapter-section">
                                                                    <a href="#ch01lvl1sec11">                    
                                                                        <div class="section-name">Returning results from a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec12" class="chapter-section">
                                                                    <a href="#ch01lvl1sec12">                    
                                                                        <div class="section-name">Passing data to a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec13" class="chapter-section">
                                                                    <a href="#ch01lvl1sec13">                    
                                                                        <div class="section-name">Creating a child task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec14" class="chapter-section">
                                                                    <a href="#ch01lvl1sec14">                    
                                                                        <div class="section-name">Lazy task execution</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec15" class="chapter-section">
                                                                    <a href="#ch01lvl1sec15">                    
                                                                        <div class="section-name">Handling task exceptions using try/catch block</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec16" class="chapter-section">
                                                                    <a href="#ch01lvl1sec16">                    
                                                                        <div class="section-name">Handling task exceptions with AggregateException.Handle</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec17" class="chapter-section">
                                                                    <a href="#ch01lvl1sec17">                    
                                                                        <div class="section-name">Cancelling a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec18" class="chapter-section">
                                                                    <a href="#ch01lvl1sec18">                    
                                                                        <div class="section-name">Cancelling one of many tasks</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="2">
                                                        <div class="section-name">2: Implementing Continuations</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="2" class="chapter-section">
                                                                    <a href="#ch02">        
                                                                        <div class="section-name">Chapter 2: Implementing Continuations</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec19" class="chapter-section">
                                                                    <a href="#ch02lvl1sec19">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec20" class="chapter-section">
                                                                    <a href="#ch02lvl1sec20">                    
                                                                        <div class="section-name">Continuing a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec21" class="chapter-section">
                                                                    <a href="#ch02lvl1sec21">                    
                                                                        <div class="section-name">Passing task results to a continuation</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec22" class="chapter-section">
                                                                    <a href="#ch02lvl1sec22">                    
                                                                        <div class="section-name">Continue &amp;quot;WhenAny&amp;quot; and &amp;quot;WhenAll&amp;quot;</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec23" class="chapter-section">
                                                                    <a href="#ch02lvl1sec23">                    
                                                                        <div class="section-name">Specifying when a continuation will run</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec24" class="chapter-section">
                                                                    <a href="#ch02lvl1sec24">                    
                                                                        <div class="section-name">Using a continuation for exception handling</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec25" class="chapter-section">
                                                                    <a href="#ch02lvl1sec25">                    
                                                                        <div class="section-name">Cancelling a continuation</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec26" class="chapter-section">
                                                                    <a href="#ch02lvl1sec26">                    
                                                                        <div class="section-name">Using a continuation to chain multiple tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec27" class="chapter-section">
                                                                    <a href="#ch02lvl1sec27">                    
                                                                        <div class="section-name">Using a continuation to update a UI</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="3">
                                                        <div class="section-name">3: Learning Concurrency with Parallel Loops</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="3" class="chapter-section">
                                                                    <a href="#ch03">        
                                                                        <div class="section-name">Chapter 3: Learning Concurrency with Parallel Loops</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec28" class="chapter-section">
                                                                    <a href="#ch03lvl1sec28">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec29" class="chapter-section">
                                                                    <a href="#ch03lvl1sec29">                    
                                                                        <div class="section-name">Creating a basic parallel for loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec30" class="chapter-section">
                                                                    <a href="#ch03lvl1sec30">                    
                                                                        <div class="section-name">Creating a basic parallel foreach loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec31" class="chapter-section">
                                                                    <a href="#ch03lvl1sec31">                    
                                                                        <div class="section-name">Breaking a parallel loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec32" class="chapter-section">
                                                                    <a href="#ch03lvl1sec32">                    
                                                                        <div class="section-name">Stopping a parallel loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec33" class="chapter-section">
                                                                    <a href="#ch03lvl1sec33">                    
                                                                        <div class="section-name">Cancelling a parallel loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec34" class="chapter-section">
                                                                    <a href="#ch03lvl1sec34">                    
                                                                        <div class="section-name">Handling exceptions in a parallel loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec35" class="chapter-section">
                                                                    <a href="#ch03lvl1sec35">                    
                                                                        <div class="section-name">Controlling the degree of parallelism in a loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec36" class="chapter-section">
                                                                    <a href="#ch03lvl1sec36">                    
                                                                        <div class="section-name">Partitioning data in a parallel loop</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec37" class="chapter-section">
                                                                    <a href="#ch03lvl1sec37">                    
                                                                        <div class="section-name">Using Thread Local Storage</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="4">
                                                        <div class="section-name">4: Parallel LINQ</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="4" class="chapter-section">
                                                                    <a href="#ch04">        
                                                                        <div class="section-name">Chapter 4: Parallel LINQ</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec38" class="chapter-section">
                                                                    <a href="#ch04lvl1sec38">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec39" class="chapter-section">
                                                                    <a href="#ch04lvl1sec39">                    
                                                                        <div class="section-name">Creating a basic parallel query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec40" class="chapter-section">
                                                                    <a href="#ch04lvl1sec40">                    
                                                                        <div class="section-name">Preserving order in parallel LINQ</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec41" class="chapter-section">
                                                                    <a href="#ch04lvl1sec41">                    
                                                                        <div class="section-name">Forcing parallel execution</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec42" class="chapter-section">
                                                                    <a href="#ch04lvl1sec42">                    
                                                                        <div class="section-name">Limiting parallelism in a query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec43" class="chapter-section">
                                                                    <a href="#ch04lvl1sec43">                    
                                                                        <div class="section-name">Processing query results</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec44" class="chapter-section">
                                                                    <a href="#ch04lvl1sec44">                    
                                                                        <div class="section-name">Specifying merge options</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec45" class="chapter-section">
                                                                    <a href="#ch04lvl1sec45">                    
                                                                        <div class="section-name">Range projection with parallel LINQ</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec46" class="chapter-section">
                                                                    <a href="#ch04lvl1sec46">                    
                                                                        <div class="section-name">Handling exceptions in parallel LINQ</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec47" class="chapter-section">
                                                                    <a href="#ch04lvl1sec47">                    
                                                                        <div class="section-name">Cancelling a parallel LINQ query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec48" class="chapter-section">
                                                                    <a href="#ch04lvl1sec48">                    
                                                                        <div class="section-name">Performing reduction operations</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec49" class="chapter-section">
                                                                    <a href="#ch04lvl1sec49">                    
                                                                        <div class="section-name">Creating a custom partitioner</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="5">
                                                        <div class="section-name">5: Concurrent Collections</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="5" class="chapter-section">
                                                                    <a href="#ch05">        
                                                                        <div class="section-name">Chapter 5: Concurrent Collections</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec50" class="chapter-section">
                                                                    <a href="#ch05lvl1sec50">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec51" class="chapter-section">
                                                                    <a href="#ch05lvl1sec51">                    
                                                                        <div class="section-name">Adding and removing items to BlockingCollection</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec52" class="chapter-section">
                                                                    <a href="#ch05lvl1sec52">                    
                                                                        <div class="section-name">Iterating a BlockingCollection with GetConsumingEnumerable</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec53" class="chapter-section">
                                                                    <a href="#ch05lvl1sec53">                    
                                                                        <div class="section-name">Performing LIFO operations with ConcurrentStack</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec54" class="chapter-section">
                                                                    <a href="#ch05lvl1sec54">                    
                                                                        <div class="section-name">Thread safe data lookups with ConcurrentDictionary</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec55" class="chapter-section">
                                                                    <a href="#ch05lvl1sec55">                    
                                                                        <div class="section-name">Cancelling an operation in a concurrent collection</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec56" class="chapter-section">
                                                                    <a href="#ch05lvl1sec56">                    
                                                                        <div class="section-name">Working with multiple producers and consumers</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec57" class="chapter-section">
                                                                    <a href="#ch05lvl1sec57">                    
                                                                        <div class="section-name">Creating object pool with ConcurrentStack</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec58" class="chapter-section">
                                                                    <a href="#ch05lvl1sec58">                    
                                                                        <div class="section-name">Adding blocking and bounding with IProducerConsumerCollection</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec59" class="chapter-section">
                                                                    <a href="#ch05lvl1sec59">                    
                                                                        <div class="section-name">Using multiple concurrent collections to create a pipeline</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="6">
                                                        <div class="section-name">6: Synchronization Primitives</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="6" class="chapter-section">
                                                                    <a href="#ch06">        
                                                                        <div class="section-name">Chapter 6: Synchronization Primitives</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec60" class="chapter-section">
                                                                    <a href="#ch06lvl1sec60">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec61" class="chapter-section">
                                                                    <a href="#ch06lvl1sec61">                    
                                                                        <div class="section-name">Using monitor</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec62" class="chapter-section">
                                                                    <a href="#ch06lvl1sec62">                    
                                                                        <div class="section-name">Using a mutual exclusion lock</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec63" class="chapter-section">
                                                                    <a href="#ch06lvl1sec63">                    
                                                                        <div class="section-name">Using SpinLock for synchronization</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec64" class="chapter-section">
                                                                    <a href="#ch06lvl1sec64">                    
                                                                        <div class="section-name">Interlocked operations</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec65" class="chapter-section">
                                                                    <a href="#ch06lvl1sec65">                    
                                                                        <div class="section-name">Synchronizing multiple tasks with a Barrier</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec66" class="chapter-section">
                                                                    <a href="#ch06lvl1sec66">                    
                                                                        <div class="section-name">Using ReaderWriterLockSlim</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec67" class="chapter-section">
                                                                    <a href="#ch06lvl1sec67">                    
                                                                        <div class="section-name">Using WaitHandles with Mutex</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec68" class="chapter-section">
                                                                    <a href="#ch06lvl1sec68">                    
                                                                        <div class="section-name">Waiting for multiple threads with CountdownEvent</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec69" class="chapter-section">
                                                                    <a href="#ch06lvl1sec69">                    
                                                                        <div class="section-name">Using ManualResetEventSlim to spin and wait</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec70" class="chapter-section">
                                                                    <a href="#ch06lvl1sec70">                    
                                                                        <div class="section-name">Using SemaphoreSlim to limit access</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="7">
                                                        <div class="section-name">7: Profiling and Debugging</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="7" class="chapter-section">
                                                                    <a href="#ch07">        
                                                                        <div class="section-name">Chapter 7: Profiling and Debugging</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec71" class="chapter-section">
                                                                    <a href="#ch07lvl1sec71">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec72" class="chapter-section">
                                                                    <a href="#ch07lvl1sec72">                    
                                                                        <div class="section-name">Using the Threads and Call Stack windows</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec73" class="chapter-section">
                                                                    <a href="#ch07lvl1sec73">                    
                                                                        <div class="section-name">Using the Parallel Stacks window</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec74" class="chapter-section">
                                                                    <a href="#ch07lvl1sec74">                    
                                                                        <div class="section-name">Watching values in a thread with Parallel Watch window</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec75" class="chapter-section">
                                                                    <a href="#ch07lvl1sec75">                    
                                                                        <div class="section-name">Detecting deadlocks with the Parallel Tasks window</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec76" class="chapter-section">
                                                                    <a href="#ch07lvl1sec76">                    
                                                                        <div class="section-name">Measure CPU utilization with Concurrency Visualizer</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec77" class="chapter-section">
                                                                    <a href="#ch07lvl1sec77">                    
                                                                        <div class="section-name">Using Concurrency Visualizer Threads view</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec78" class="chapter-section">
                                                                    <a href="#ch07lvl1sec78">                    
                                                                        <div class="section-name">Using Concurrency Visualizer Cores view</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="8">
                                                        <div class="section-name">8: Async</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="8" class="chapter-section">
                                                                    <a href="#ch08">        
                                                                        <div class="section-name">Chapter 8: Async</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec79" class="chapter-section">
                                                                    <a href="#ch08lvl1sec79">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec80" class="chapter-section">
                                                                    <a href="#ch08lvl1sec80">                    
                                                                        <div class="section-name">Creating an async method</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec81" class="chapter-section">
                                                                    <a href="#ch08lvl1sec81">                    
                                                                        <div class="section-name">Handling Exceptions in asynchronous code</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec82" class="chapter-section">
                                                                    <a href="#ch08lvl1sec82">                    
                                                                        <div class="section-name">Cancelling an asynchronous operation</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec83" class="chapter-section">
                                                                    <a href="#ch08lvl1sec83">                    
                                                                        <div class="section-name">Cancelling async operation after timeout period</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec84" class="chapter-section">
                                                                    <a href="#ch08lvl1sec84">                    
                                                                        <div class="section-name">Processing multiple async tasks as they complete</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec85" class="chapter-section">
                                                                    <a href="#ch08lvl1sec85">                    
                                                                        <div class="section-name">Improving performance of async solution with Task.WhenAll</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec86" class="chapter-section">
                                                                    <a href="#ch08lvl1sec86">                    
                                                                        <div class="section-name">Using async for file access</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec87" class="chapter-section">
                                                                    <a href="#ch08lvl1sec87">                    
                                                                        <div class="section-name">Checking the progress of an asynchronous task</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="9">
                                                        <div class="section-name">9: Dataflow Library</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="9" class="chapter-section">
                                                                    <a href="#ch09">        
                                                                        <div class="section-name">Chapter 9: Dataflow Library</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec88" class="chapter-section">
                                                                    <a href="#ch09lvl1sec88">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec89" class="chapter-section">
                                                                    <a href="#ch09lvl1sec89">                    
                                                                        <div class="section-name">Reading from and writing to a dataflow block synchronously</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec90" class="chapter-section">
                                                                    <a href="#ch09lvl1sec90">                    
                                                                        <div class="section-name">Reading from and writing to a dataflow block asynchronously</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec91" class="chapter-section">
                                                                    <a href="#ch09lvl1sec91">                    
                                                                        <div class="section-name">Implementing a producer-consumer dataflow pattern</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec92" class="chapter-section">
                                                                    <a href="#ch09lvl1sec92">                    
                                                                        <div class="section-name">Creating a dataflow pipeline</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec93" class="chapter-section">
                                                                    <a href="#ch09lvl1sec93">                    
                                                                        <div class="section-name">Cancelling a dataflow block</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec94" class="chapter-section">
                                                                    <a href="#ch09lvl1sec94">                    
                                                                        <div class="section-name">Specifying the degree of parallelism</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec95" class="chapter-section">
                                                                    <a href="#ch09lvl1sec95">                    
                                                                        <div class="section-name">Unlink dataflow blocks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec96" class="chapter-section">
                                                                    <a href="#ch09lvl1sec96">                    
                                                                        <div class="section-name">Using JoinBlock to read from multiple data sources</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="backindex">
                                                        <div class="section-name">Appendix A: Index</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="backindex" class="chapter-section">
                                                                    <a href="#backindex">
                                                                        <div class="section-name">Chapter Appendix A: Index</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                            </ul>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade" id="author">
                                            <div class="visible-xs">
                                                <h4 class="mobile-title">About the Author</h4>
                                                <hr>
                                            </div>
                                            <p><strong>Bryan Freeman</strong></p>
                                            <div>
                                                Bryan Freeman is a developer, architect, and writer on Parallel and Distributed Technologies. With over 15 years of experience delivering solutions across industry sectors such as healthcare, finance, and transportation, he specializes in technologies such as Microsoft .NET, Windows Communication Foundation, Windows Workflow, and Windows Azure to help clients deliver business value and drive revenue while reducing operational costs.
                
                As an active speaker, writer, and blogger, Bryan is a passionate community advocate for those who develop solutions based on .NET technologies. He is also an active member of the Scottsdale Institute and the Veterans of Foreign Wars.
                                            </div>
                                        </div>
                                        
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="next-wrapper">
                        <div class="row ns">
                            <hr />
                            <span class="hidden-xs">
                                <h4 class="pull-left">
                                    <strong>Up Next: </strong><span class="section-title"></span>
                                </h4>
                                <a href="#" class="btn btn-primary pull-right btn-lg">
                                    Next Section
                                </a>
                            </span>
                            <span class="visible-xs">
                                <a href="#" class="btn btn-primary btn-block btn-lg">
                                    Next Section
                                </a>
                            </span>
                        </div>
                        <div class="row ns">
                            <hr>
                        </div>
                    </div>
                </div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch01"></a>ChapterÂ 1.Â Getting Started with Task Parallel Library</h2></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating a task</p></li><li style="list-style-type: disc"><p>Waiting for tasks to finish</p></li><li style="list-style-type: disc"><p>Returning results from a task</p></li><li style="list-style-type: disc"><p>Passing data to a task</p></li><li style="list-style-type: disc"><p>Creating a child task</p></li><li style="list-style-type: disc"><p>Lazy task execution</p></li><li style="list-style-type: disc"><p>Handling task exceptions using try/catch block</p></li><li style="list-style-type: disc"><p>Handling task exceptions with AggregateException.Handle</p></li><li style="list-style-type: disc"><p>Cancelling a task</p></li><li style="list-style-type: disc"><p>Cancelling one of many tasks</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec08"></a>Introduction</h2></div></div><hr /></div><p>At the beginning of the personal computer era, there was no concept of multiple threads offered by an operating system. Typically, operating system code and application code ran on a single thread of execution. The problem with this was that if a single application misbehaved, or simply took a long time to execute, the whole machine would stall, and often had to be rebooted.</p><p>As the development of the Windows operating systems progressed, Microsoft realized that they needed to improve this situation. In the Windows NT kernel, each application runs in its own process. A process is a collection of resources in which a virtual address space is allocated for each application. The advent of these processes ensured that code and data being used by one application could not be accessed and corrupted by another application, thus improving the reliability of the system.</p><p>Each process in Windows was also given its own thread. A thread is an operating system construct that functions like a virtual CPU. At any given moment, one of these threads is allowed to run on the physical CPU for a slice of time. When the time for a thread to run expires, it is swapped off of the CPU for another thread. Therefore, if a single thread enters an infinite loop, it can't monopolize all of the CPU time on the system. At the end of its time slice, it will be switched out for another thread.</p><p>Over the years, computers with multiple processors began to appear. These multiple processor machines were able to execute multiple threads at once. It became possible for an application to spawn new threads to run a compute-bound process asynchronously, thus gaining a performance improvement.</p><p>Over the past few years, the trend in processor development has shifted from making processors faster and faster, to making processors with multiple CPU cores on a single physical processor chip. Individuals who purchase these new machines expect their investment to pay off in terms of applications which are able to run efficiently across the available processor cores. Maximizing the utilization of the computing resources provided by the next generation of multi-core processors requires a change in the way the code is written.</p><p>The .NET framework has supported writing multi-threaded applications from the beginning, but the complexity of doing so has remained just out of reach for many .NET developers. To fully take the advantage of multi-threading, you needed to know quite a bit about how Windows works under the hood. For starters, you had to create and manage your own threads, which can be a demanding task as the number of threads in an application grows, and can often be the source of hard-to-find bugs.</p><p>Finally, help has arrived. Starting in .NET 4.0, Microsoft introduced the .NET Parallel Extensions, which gave us a new runtime, new class library types (the <span class="strong"><strong>Task Parallel Library</strong></span>
<a id="id0" class="indexterm"></a> (<span class="strong"><strong>TPL</strong></span>)), and new diagnostic tools to help with the inherent complexities of parallel programming.</p><p>The TPL isn't just a collection of new types. It's a completely new way of thinking about parallel programming. No longer do we need to think in terms of threads. With the TPL, we can now think in terms of <code class="literal">task</code>. With this new task-based model, we just need to figure out the pieces of our application that can execute concurrently, and convert those pieces into tasks. The runtime will take care of managing and creating all of the underlying threads that actually do the work. The <code class="literal">System.Threading.Task</code> class<a id="id1" class="indexterm"></a>
<a id="id2" class="indexterm"></a> in itself is just a wrapper for passing a delegate, which is a data structure that refers to a <code class="literal">static</code> method<a id="id3" class="indexterm"></a> or to a class instance, and an instance method of that class.</p><p>A TPL <code class="literal">task</code> still uses the classic thread pool internally, but the heavy lifting of spinning up new threads to carry out the <code class="literal">tasks</code> and determining the optimum number of threads required to take full advantage of the hardware, is all done by the runtime.</p><p>In this chapter, we will take a look at the basics of creating a parallel <code class="literal">task</code>. You will learn how to pass data into a <code class="literal">Task</code> using the <code class="literal">Task</code> state object, returning data from a <code class="literal">Task</code>, cancelling the <code class="literal">Task</code>, and handling exceptions within a <code class="literal">Task</code>.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec09"></a>Creating a task</h2></div></div><hr /></div><p>
<code class="literal">Tasks</code> are an abstraction in the .NET framework to represent asynchronous units of work. In some ways, a task resembles the creation of a classic .NET thread, but provides a higher level of abstraction,<a id="id4" class="indexterm"></a> which makes your code easier to write and read.</p><p>We will look at the three basic ways to create and run a new task.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">Parallel.Invoke()</code> method: <a id="id5" class="indexterm"></a>This method<a id="id6" class="indexterm"></a> provides an easy way to run any number of concurrent statements</p></li><li style="list-style-type: disc"><p>The <code class="literal">Task.Start()</code> method<a id="id7" class="indexterm"></a>: This method <a id="id8" class="indexterm"></a>starts a task and schedules it for execution with <code class="literal">TaskScheduler</code>
</p></li><li style="list-style-type: disc"><p>The <code class="literal">Task.Factory.StartNew()</code> method<a id="id9" class="indexterm"></a>: This method<a id="id10" class="indexterm"></a> creates and starts a task using <code class="literal">Task.Factory</code>
</p></li></ul></div><p>In this recipe, we will create a new task using each of these three methods. To give our tasks something to do, we will be using <code class="literal">WebClient</code> to read the text of three classic books. We will then split the words of each book into a string array, and display a count of the words in each book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec07"></a>How to do itâ€¦</h3></div></div></div><p>Ok, let's start building a <code class="literal">Console</code> application that demonstrates<a id="id11" class="indexterm"></a> the various ways to create a parallel task.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Launch Visual Studio 2012.</p></li><li><p>Start a new project using the C# <span class="strong"><strong>Console Application</strong></span> project template, and assign <code class="literal">SimpleTasks</code> as the <span class="strong"><strong>Solution name</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_01.jpg" /></div></li><li><p>Add the following <code class="literal">using</code> statements<a id="id12" class="indexterm"></a> at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip02"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></li><li><p>First, let's create a task using <code class="literal">Parallel.Invoke</code>. Add the following code to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";

Parallel.Invoke(() =&gt;
    {
    Console.WriteLine("Starting first task using Parallel.Invoke");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words =client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Origin of Species word count: {0}", wordArray.Count());
    client.Dispose();
    }
);</pre></div></li><li><p>Next, let's start <code class="literal">task</code> using the <a id="id13" class="indexterm"></a>
<code class="literal">Start</code> method of the <code class="literal">Task</code> object. Add the following code to the <code class="literal">Main</code> method <a id="id14" class="indexterm"></a>of the <code class="literal">Program</code> class just below the code for the previous step:</p><div class="informalexample"><pre class="programlisting">var secondTask = new Task(() =&gt;
    {
    Console.WriteLine("Starting second task using Task.Start");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/16328/16328-8.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Beowulf word count: {0}", wordArray.Count());
    client.Dispose();
    } 
  );
secondTask.Start();</pre></div></li><li><p>Finally, let's create <code class="literal">task</code> using <code class="literal">Task.Factory.StartNew</code>. Add the following code to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
    {
    Console.WriteLine("Starting third task using Task.Factory.StartNew");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/4300/4300.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Ulysses word count: {0}", wordArray.Count());
    client.Dispose();
    }
);
//wait for Enter key to exit
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following<a id="id15" class="indexterm"></a> screenshot. Note that the exact order of the text you see may vary as <code class="literal">tasks</code> run asynchronously:</p><div class="mediaobject"><img src="graphics/0225OT_01_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>How it worksâ€¦</h3></div></div></div><p>The <a id="id16" class="indexterm"></a>
<code class="literal">Parallel.Invoke</code> method <a id="id17" class="indexterm"></a>can implicitly create and run any number of statements concurrently by passing an action delegate for each delegate of work to be done.</p><div class="informalexample"><pre class="programlisting">Parallel.Invoke(( )=&gt;DoSomething( ), ( )=&gt;DoSomethingElse( ));</pre></div><p>It is worth noting however, that the number of <code class="literal">tasks</code> actually created by <code class="literal">Parallel.Invoke</code> may or may not be equal to the number of delegates passed in, especially if there are a large number of delegates.</p><p>Using <code class="literal">Task.Start()</code> or <code class="literal">Task.Factory.StartNew()</code> creates new tasks explicitly. The new <code class="literal">tasks</code> will be allocated threads by the <code class="literal">ThreadPool</code> class, which handles the actual creation of the threads the <code class="literal">tasks</code> use for carrying out their work. As developers, we are shielded from all of this thread creation work, because it is done for us by the <code class="literal">Task</code> object.</p><p>When you create a task, you are really just creating a wrapper around a delegate of work to be performed. The <a id="id18" class="indexterm"></a>delegate can be a named delegate and anonymous method, or a lambda expression.</p><p>So, which of these methods of creating <code class="literal">task</code> is the best? <code class="literal">Task.Factory.StartNew</code> is usually the preferred method, because it is more efficient in terms of the synchronization costs. Some amount of synchronization cost is incurred when using <code class="literal">Thread.Start</code>, because it is necessary to ensure that another thread is not simultaneously calling start on the same <code class="literal">Task</code> object. When using <code class="literal">Task.Factory.StartNew</code>, we know that the task has already been scheduled by the time <code class="literal">task</code> reference is handed back to our code.</p><p>Note also that you can't call <code class="literal">Start()</code> on a task that has already run and completed. If you need the tasks to do the work again, you need to create new <code class="literal">task</code> with the same delegate of work.</p><p>For the remainder of this book, we will primarily be using <code class="literal">Task.Factory.StartNew</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Waiting for tasks to finish</h2></div></div><hr /></div><p>When developing a parallel application, you will often have situations where a task must be completed before the main thread can continue processing. The Task Parallel Library includes several methods that allow you to wait for one or more parallel <code class="literal">tasks</code> to complete. This recipe will cover two such methods:<a id="id19" class="indexterm"></a> <code class="literal">Task.Wait()</code> and <code class="literal">Task.WaitAll()</code>.<a id="id20" class="indexterm"></a>
</p><p>In this recipe we will be creating three tasks, all of which read in the text classic books and produce a <code class="literal">word count</code>. After we create the first task, we will wait for it to complete using <code class="literal">Task.Wait()</code>, before starting the second and third task. We will then wait for both the second and third tasks to complete using <code class="literal">Task.WaitAll()</code> before writing a message to the console.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec09"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a <code class="literal">Console</code> application<a id="id21" class="indexterm"></a> that demonstrates how to wait for <code class="literal">task</code> completion.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Launch Visual Studio 2012.</p></li><li><p>Start a new<a id="id22" class="indexterm"></a> project using the C# <span class="strong"><strong>Console Application</strong></span> project template, and assign <code class="literal">WordCount</code> as the <span class="strong"><strong>Solution name</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_01_03.jpg" /></div></li><li><p>Add the<a id="id23" class="indexterm"></a> following <a id="id24" class="indexterm"></a>
<code class="literal">using</code> statements at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, add a character array containing the basic punctuation marks. We will use this array in <code class="literal">string.Split()</code> to eliminate punctuation marks. Also add a string <code class="literal">constant</code> for the <code class="literal">user-agent</code> header of the <code class="literal">WebClient</code>.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";</pre></div></li><li><p>OK, now let's create our first task. This task will use <code class="literal">WebClient</code> to read the <span class="emphasis"><em>Origin of Species</em></span> by Darwin, and get its word count. Enter the following code in <a id="id25" class="indexterm"></a>the <code class="literal">Main</code> method of the <code class="literal">Program</code> class just below the previous statement:</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt;
    {
    Console.WriteLine("Starting first task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Origin of Species word count: {0}", wordArray.Count());
    }
);</pre></div></li><li><p>Now, just <a id="id26" class="indexterm"></a>below the previous task, write the following<a id="id27" class="indexterm"></a> statements to wait on the task, and write a message to the <code class="literal">Console</code> application:</p><div class="informalexample"><pre class="programlisting">task1.Wait();
Console.WriteLine("Task 1 complete. Creating Task 2 and Task 3.");</pre></div></li><li><p>Below the previous statement, enter the code to create the second and third tasks. These tasks are very similar to the first task.</p><div class="informalexample"><pre class="programlisting">var task2 = Task.Factory.StartNew(() =&gt;
{
  Console.WriteLine("Starting second task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/16328/16328-8.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Beowulf word count: {0}", wordArray.Count());
 });

var task3 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Starting third task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/4300/4300.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Ulysses word count: {0}", wordArray.Count());
});</pre></div></li><li><p>Finally, let's use <code class="literal">Task.WaitAll()</code> to wait for the second and third task to complete,<a id="id28" class="indexterm"></a> then prompt the user to exit the program. <code class="literal">Task.WaitAll()</code> takes an array of <code class="literal">task</code> as its parameter, and can be used to wait for any number of tasks to complete.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(task2,task3);
Console.WriteLine("All tasks complete.");
Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual<a id="id29" class="indexterm"></a> Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see<a id="id30" class="indexterm"></a> output similar to the following screenshot. Note that the exact order of the last few lines of text may still vary depending on the execution order of the second and third tasks.</p><div class="mediaobject"><img src="graphics/0225OT_01_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>How it worksâ€¦</h3></div></div></div><p>Although <code class="literal">Task.Wait() </code>and <code class="literal">Task.WaitAll()</code> are fairly self-explanatory, both have several overloads that offer different functionalities.</p><p>
<code class="literal">Task.Wait()</code> can take<a id="id31" class="indexterm"></a> either an <code class="literal">Int32</code> or <code class="literal">TimeSpan</code> parameter to specify a specific period of time to wait. It can also accept a <code class="literal">CancellationToken</code> token parameter for cancellation, which will be covered later in the chapter.</p><p>
<code class="literal">Task.WaitAll()</code> <a id="id32" class="indexterm"></a>always takes an array of <code class="literal">Task</code> as its first parameter, and has a second parameter which can be an <code class="literal">Int32</code> or <code class="literal">TimeSpan</code> as in <code class="literal">Task.Wait</code>.</p><p>Another useful <a id="id33" class="indexterm"></a>method not shown in the recipe is <code class="literal">Task.WaitAny()</code>. <code class="literal">WaitAny</code> is very similar to <code class="literal">WaitAll</code>, except that it waits for only one <code class="literal">Task</code> in the array of <code class="literal">Task</code> to complete. The first <code class="literal">Task</code> of <code class="literal">Task</code> array to finish, completes the wait condition, and execution of the main thread is allowed to move forward.</p><p>It is important to note that when you call one of the <code class="literal">Wait</code> methods, the runtime will check to see if the task you are waiting on has started executing. If <code class="literal">task</code> has started executing, then the thread that called <code class="literal">Wait</code> will block until <code class="literal">task</code> has finished executing. However, if <code class="literal">task</code> has not started running, then the runtime may execute the task using the thread that calls <code class="literal">Wait</code>.</p><p>The various overloads and behaviors of <code class="literal">Task.Wait</code>, <code class="literal">Task.WaitAll</code>, and <code class="literal">Task.WaitAny</code> are shown in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">Wait()</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for the task to complete execution.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">Wait(CancellationToken)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for the task to complete execution or <code class="literal">CancellationToken</code> to be set.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">Wait(Int32)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for task to complete or number of milliseconds to pass. A value of <code class="literal">-1</code> waits indefinitely.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">Wait(TimeSpan)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for<a id="id34" class="indexterm"></a> the task to complete execution or specified timespan to pass.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">Wait(Int32, CancellationToken)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for task to complete, number of milliseconds to pass, or <code class="literal">CancellationToken</code> to be set.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAll(Task[])</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for all of the tasks in array to complete execution. <a id="id35" class="indexterm"></a>
</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAll(Task[], Int32)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for all of the tasks in the array to complete execution or number of milliseconds to pass. A value of <code class="literal">-1</code> waits indefinitely.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAll(Task[], CancellationToken)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for all of the tasks in array to complete execution or for a <code class="literal">CancellationToken</code> to be set.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAll(Task[], TimeSpan)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for all of the tasks in array to complete execution or specified timespan to pass.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAll(Task[], Int32, CancellationToken)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for all of the tasks in array to complete execution, number of milliseconds to pass, or <code class="literal">CancellationToken</code> to be set.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAny(Task[])</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for any of the tasks in the array to complete execution.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAny(Task[], Int32)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for<a id="id36" class="indexterm"></a> any of the tasks in array to complete execution or number of milliseconds to pass. A value of <code class="literal">-1</code> waits indefinitely.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAny(Task[], CancellationToken)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for<a id="id37" class="indexterm"></a> any of the tasks in array to complete execution or for a <code class="literal">CancellationToken</code> to be set.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAny(Task[], TimeSpan)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits for any of the tasks in array to complete execution or specified timespan to pass.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">WaitAny(Task[], Int32, CancellationToken)</code>
</p>
</td><td style="" align="left" valign="top">
<p>Waits<a id="id38" class="indexterm"></a> for any of the tasks in array to complete execution, number of milliseconds to pass, or <code class="literal">CancellationToken</code> to be set.</p>
</td></tr></tbody></table></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Returning results from a task</h2></div></div><hr /></div><p>So far, our tasks<a id="id39" class="indexterm"></a> have not returned any values. However, it is often necessary to return a result from a task so it can be used in another part of our application. This functionality is provided by the <code class="literal">Result</code> property<a id="id40" class="indexterm"></a> of <code class="literal">Task&lt;TResult</code>&gt;.</p><p>In this recipe, we will be creating a solution similar with tasks similar to the previous solution, but each of our three tasks<a id="id41" class="indexterm"></a> return a result which can then be used to display the word count to the user.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>How to do itâ€¦</h3></div></div></div><p>Let's go to Visual Studio and see how we can return result values from our tasks.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the C# <span class="strong"><strong>Console Application</strong></span> project template, and assign <code class="literal">WordCount2</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> statements are at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, add a character array containing the basic punctuation marks. We will use this array in <code class="literal">string.Split()</code> to eliminate punctuation marks. Also add a string constant for the <code class="literal">WebClient</code> <code class="literal">user-agent</code> header.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";  </pre></div></li><li><p>Start by <a id="id42" class="indexterm"></a>creating <a id="id43" class="indexterm"></a>three tasks of type <code class="literal">Task&lt;int&gt;</code> named <code class="literal">task1</code>, <code class="literal">task2</code>, and <code class="literal">task3</code>. Your tasks should look as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">Task&lt;int&gt; task1 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Starting first task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
});

Task&lt;int&gt; task2 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Starting second task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/16328/16328-8.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
});

 Task&lt;int&gt; task3 = Task.Factory.StartNew(()
 {
    Console.WriteLine("Starting third task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/4300/4300.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
});</pre></div></li><li><p>Immediately below your tasks, add <code class="literal">Console.Writeline()</code> statements that use <code class="literal">Task.Result</code> to display the results to the user. The remainder of the <code class="literal">Main</code> method <a id="id44" class="indexterm"></a>should now look as shown in the <a id="id45" class="indexterm"></a>following code snippet:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("task1 is complete. Origin of Species word count: {0}",task1.Result);
Console.WriteLine("task2 is complete. Beowulf word count: {0}", task2.Result);
Console.WriteLine("task3 is complete. Ulysses word count: {0}", task3.Result);
Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following:</p><div class="mediaobject"><img src="graphics/0225OT_01_05.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">Task&lt;TResult&gt;</code> subclasses the standard <code class="literal">Task</code> class and provides the additional feature of the ability to return a value. This is done by switching from providing an <code class="literal">Action</code> delegate to providing a <code class="literal">Func&lt;TResult&gt;</code> delegate.</p><p>It is worth <a id="id46" class="indexterm"></a>noting that calling the <code class="literal">Task.Result</code> accessor will ensure that the asynchronous operation is complete before returning, so this is another method of waiting for a task to complete.<a id="id47" class="indexterm"></a> Once the result of <code class="literal">Task</code> is available, it will be stored and returned immediately on later calls to the <code class="literal">Result</code> accessor.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec12"></a>Passing data to a task</h2></div></div><hr /></div><p>You can supply the data used by <code class="literal">task</code> by passing an instance of <code class="literal">System.Action&lt;object&gt;</code> and an object representing the data to be used by the action.</p><p>In this recipe, we will<a id="id48" class="indexterm"></a> be revisiting our WordCount example, but this time we will be parameterizing the data the tasks will act upon.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>How to do itâ€¦</h3></div></div></div><p>The ability to pass<a id="id49" class="indexterm"></a> data into a task allows us to create a single task that can operate on multiple pieces of input data. Let's create a <code class="literal">Console</code> application so we can see how this works:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the C# <span class="strong"><strong>Console Application </strong></span>project template and assign <code class="literal">WordCount3</code>
<span class="strong"><strong> </strong></span>as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> statements at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using System.Collections.Generic;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, add a character array containing the basic punctuation marks. We will use this array in <code class="literal">string.Split()</code> to eliminate punctuation marks. Also add a constant string for the <code class="literal">WebClients</code> user-agent task.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";</pre></div></li><li><p>For this recipe, let's create a <code class="literal">new Dictionary</code> instance that can hold our book titles and URLs. Immediately after the previous statement, add the following code to create and initialize the <code class="literal">dictionary</code>:</p><div class="informalexample"><pre class="programlisting">var dictionary = new Dictionary&lt;string, string&gt;
{
    {"Origin of Species", "http://www.gutenberg.org/files/2009/2009.txt"},
    {"Beowulf", "http://www.gutenberg.org/files/16328/16328-8.txt"},
    {"Ulysses", "http://www.gutenberg.org/files/4300/4300.txt"}
};</pre></div></li><li><p>This time <a id="id50" class="indexterm"></a>we will be creating anonymous tasks in a loop. We still would like to wait for the tasks to complete before prompting the user to exit the program. We need a collection to hold our tasks, so we can pass them to <code class="literal">Task.WaitAll()</code> and wait for completion. Below the previous statement, create a <code class="literal">List&lt;Task&gt;</code> to hold our tasks.</p><div class="informalexample"><pre class="programlisting">var tasks = new List&lt;Task&gt;();</pre></div></li><li><p>Next, <a id="id51" class="indexterm"></a>we want to create a <code class="literal">for</code> loop to loop through <code class="literal">KeyValuePairs</code> in the dictionary. Let's put the <code class="literal">for</code> loop below the previous statement.</p><div class="informalexample"><pre class="programlisting">foreach (var  pair in dictionary)
{
}</pre></div></li><li><p>Inside the body of your <code class="literal">for</code> loop, put the definition of <code class="literal">task</code>, and add it to your task list as follows. Note the <code class="literal">KeyValuePair</code> being passed into <code class="literal">task</code> is in the form of an object. In the delegate body, we cast this object back to a <code class="literal">KeyValuePair</code>. Other than that, task is pretty much the same.</p><div class="informalexample"><pre class="programlisting">tasks.Add( Task.Factory.StartNew((stateObj) =&gt;
{
    var taskData = (KeyValuePair&lt;string, string&gt;)stateObj;
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(taskData.Value);
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Word count for {0}: {1}", taskData.Key, wordArray.Count());
},pair));</pre></div></li><li><p>After the <code class="literal">for</code> loop, let's finish things up by waiting on the tasks to complete using <code class="literal">Task.WaitAll()</code> and prompting the user to exit. The last few lines should be as follows:</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(tasks.ToArray());
Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual <a id="id52" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>How it worksâ€¦</h3></div></div></div><p>By passing data to <code class="literal">Task</code> using the state feature, we now have a very powerful model for task creation, because we can create many tasks at once, each having the same code statements in the body and passing in the data that <code class="literal">Task</code> operates on. It also makes our code much more<a id="id53" class="indexterm"></a> concise and readable.</p><p>In our <a id="id54" class="indexterm"></a>application we need to pass two items of data into the <code class="literal">task</code>: a book title and the URL of the book, so we created <code class="literal">dictionary</code>.</p><div class="informalexample"><pre class="programlisting">var dictionary = new Dictionary&lt;string, string&gt;
{
    {"Origin of Species", "http://www.gutenberg.org/files/2009/2009.txt"},
    {"Beowulf", "http://www.gutenberg.org/files/16328/16328-8.txt"},
    {"Ulysses", "http://www.gutenberg.org/files/4300/4300.txt"}
};</pre></div><p>We would also want to wait on all of these tasks to complete before we prompt the user to exit, so we need to create a collection that can be converted to an array of tasks to hold our <code class="literal">Task</code> objects.<a id="id55" class="indexterm"></a> In this case, we made a list of tasks. In the body of our look that creates the tasks, we will add the tasks to the list.</p><div class="informalexample"><pre class="programlisting">var tasks = new List&lt;Task&gt;();

foreach (var pair in dictionary)
{
    tasks.Add( //TASK DECLARATION HERE   ));
}</pre></div><p>In our loop, we will pass in each of  <code class="literal">KeyValuePairs</code> in <code class="literal">dictionary</code> as an object, using the <code class="literal">Task(Action&lt;Object&gt;, Object)</code> constructor. This syntax is just a bit odd because you actually refer to the <code class="literal">state</code> object twice.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew((stateObj) =&gt;
{
    // TASK Body
},pair ));}</pre></div><p>The key takeaway<a id="id56" class="indexterm"></a> here is that the only way to pass data to a <code class="literal">Task</code> constructor is using <code class="literal">Action&lt;Object&gt;</code>. To use the members of a specific type, you must convert or explicitly cast the data back to the desired type in the body of the <code class="literal">Task</code>.</p><div class="informalexample"><pre class="programlisting">var taskData = (KeyValuePair&lt;string, string&gt;)stateObj;</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec13"></a>Creating a child task</h2></div></div><hr /></div><p>Code that is running a task can create another task with the <code class="literal">TaskCreationOptions.AttachedToParent set</code>. In this case, the new task becomes a child of the original or parent task.</p><p>In this recipe, we will be <a id="id57" class="indexterm"></a>using a simplified version of the WordCount solution that uses a parent task to get the text of one book into a string array, and then spins up a child task to print the results.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>How to do itâ€¦</h3></div></div></div><p>Let's return to <a id="id58" class="indexterm"></a>our WordCount solution, so we can see how to create a child task and attach it to a parent.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the C# <span class="strong"><strong>Console Application </strong></span>project template, and assign <code class="literal">WordCount4</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> statements at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, add a character array containing the basic punctuation marks. We will use this array in <code class="literal">string.Split()</code> to eliminate<a id="id59" class="indexterm"></a> punctuation marks. Also, add a constant string for the <code class="literal">WebClient</code> <code class="literal">user-agent</code> header.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";</pre></div></li><li><p>First, let's create the basic structure of our parent task. This is very similar to the other<a id="id60" class="indexterm"></a> tasks we have created so far, and takes no parameters, and returns no values.</p><div class="informalexample"><pre class="programlisting">Task parent = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Parent task starting");
    const string uri = "http://www.gutenberg.org/files/2009/2009.txt";
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var book = client.DownloadString(uri);
    var wordArray = book.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    // Child Task will go here
});</pre></div></li><li><p>Next, right after the comment in the parent task, let's create a child task to print the results and set the <code class="literal">AttachedToParent </code>option.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(()=&gt;
{
    Console.WriteLine("Child task starting");
    Console.WriteLine("Word count for Origin of Species: {0}",wordArray.Count());
    Console.WriteLine("Attached child task completed.");
},TaskCreationOptions.AttachedToParent);</pre></div></li><li><p>Finally, just below the close of the parent task, let's wait for the parent task to complete, and prompt the user to exit the application with the following code:</p><div class="informalexample"><pre class="programlisting">parent.Wait();
Console.WriteLine("Parent task completed.");
Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>That's pretty much it. In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec16"></a>How it worksâ€¦</h3></div></div></div><p>Using <code class="literal">TaskCreationOptions.AttachedToParent</code> expresses structured parallelism. The parent task<a id="id61" class="indexterm"></a> will wait for the child task to finish, so at the end of<a id="id62" class="indexterm"></a> our program, all we have to do is wait for the parent task.</p><p>The nested child task, itself, is just an ordinary <code class="literal">task</code> created in the delegate of another <code class="literal">task</code>. A parent task may create any number of child tasks, limited only by system resources.</p><p>You can also create a nested task without using <code class="literal">TaskCreationOptions.AttachedToParent</code>. The only real difference is that the nested tasks created without this option are essentially independent from the outer task. A task created with the <code class="literal">TaskCreationOptions.AttachedToParent</code> option set is very closely synchronized with the parent.</p><p>The outer task could also use the <code class="literal">DenyChildAttach </code>option<a id="id63" class="indexterm"></a> to prevent other tasks from attaching as child tasks. However, the same outer task could still create an independent nested task.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>Lazy task execution</h2></div></div><hr /></div><p>Lazy initialization of an object <a id="id64" class="indexterm"></a>means that object creation is deferred until the object is actually used by your program. If you have a parallel task that you want to execute only when the value returned from the task is actually needed, you can combine lazy task execution with the <code class="literal">Task.Factory.StartNew</code> method.</p><p>In this recipe, we will <a id="id65" class="indexterm"></a>return to our, by now familiar WordCount solution, to show you how to execute a parallel task and compute a word count for our book, only when we display the result to the console.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec17"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a console <a id="id66" class="indexterm"></a>application that demonstrates how we can defer task creation until the result of the task is needed.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the C# <span class="strong"><strong>Console Application</strong></span> project template, and assign <code class="literal">WordCount5</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> statements at the top of your <code class="literal">Program</code> class.</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>The first step is to declare <code class="literal">System.Threading.Task&lt;int&gt;</code> for lazy initialization. In the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, put a <code class="literal">Lazy</code> declaration as follows:</p><div class="informalexample"><pre class="programlisting">var lazyCount = new Lazy&lt;Task&lt;int&gt;&gt;(()=
{
  //Task declaration and body go here
});</pre></div></li><li><p>Inside the <code class="literal">Lazy</code> initialization declaration, place the code to create to task. The entire statement should now look as the following code snippet:</p><div class="informalexample"><pre class="programlisting">Task&lt;int&gt;.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Executing the task.");
    char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
    const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
    const string uri = "http://www.gutenberg.org/files/2009/2009.txt";
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(uri);
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
}));</pre></div></li><li><p>Now we<a id="id67" class="indexterm"></a> just need to write the result to the <code class="literal">Console</code>. Just add the following code to the end of your program:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Calling the lazy variable");
Console.WriteLine("Origin of species word count: {0}",lazyCount.Value.Result );
Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>All done. In <a id="id68" class="indexterm"></a>Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec18"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">System.Lazy&lt;T&gt;</code> creates a thread safe Lazy initialization of an object. Lazy initialization is primarily used to improve performance and avoid computational overhead until necessary. You can pass a delegate (remember that System Threading Task is just a wrapper around a delegate) to the <code class="literal">System.Lazy</code> constructor, and as we have done in this recipe, you can use a lambda expression to specify a <code class="literal">factory</code> method for object creation. This keeps all of the initialization code in one place.</p><p>
<code class="literal">Lazy</code> initialization<a id="id69" class="indexterm"></a> occurs the first time the <code class="literal">System.Lazy&lt;T&gt;.Value</code> property is accessed.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec15"></a>Handling task exceptions using try/catch block</h2></div></div><hr /></div><p>Let's face it; sometimes things just go wrong with our code. Even with the simplified parallel programming <a id="id70" class="indexterm"></a>model provided by the TPL, we still need to be able to handle our exceptions.</p><p>Tasks use <code class="literal">System.AggregateException</code> to consolidate multiple failures into a single exception object. In this recipe, we will take a look at the simplest way to handle <code class="literal">System.AggregateException</code> in our <code class="literal">tasks</code>: the <code class="literal">try</code>/<code class="literal">catch</code> blocks.</p><p>The try-catch statement <a id="id71" class="indexterm"></a>consists of a try block followed by one of more catch blocks, which specify handlers for different exceptions. The try block contains the guarded code that may cause the exception.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec19"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime exception is thrown, and intercepts the exception before it gets to our handler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>user-unhandled </strong></span>checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_01_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>How to do itâ€¦</h3></div></div></div><p>Let's return to our WordCount solution so we can see how to handle an <code class="literal">AggregateException</code> thrown by a parallel task.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new <a id="id72" class="indexterm"></a>project using the C# <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">WordCount6</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the <a id="id73" class="indexterm"></a>following <code class="literal">using</code> statements are at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>For this recipe, we will just need a single task. The task will be very similar to our other word count tasks, but in this one we will simulate a problem with the <code class="literal">System.Net.WebClient</code> by creating and throwing a <code class="literal">System.Net.WebException</code>. In the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, create <code class="literal">System.Task</code> that looks as the following <code class="literal">Task</code>:</p><div class="informalexample"><pre class="programlisting">Task&lt;int&gt; task1 = Task.Factory.StartNew(() =&gt;
{
    const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
    Console.WriteLine("Starting the task.");
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
    var ex = new WebException("Unable to download book contents");
    throw ex;
    return 0;
});</pre></div></li><li><p>Just below the <code class="literal">Task</code>, let's put in our <code class="literal">try</code>/<code class="literal">catch</code> blocks as shown in the following code snippet. In the <code class="literal">catch</code> block, we will want to specifically catch <code class="literal">System.AggregateException</code>.</p><div class="informalexample"><pre class="programlisting">try
{
}
catch (AggregateException aggEx)
{ 
}</pre></div></li><li><p>Now let's implement the body of our <code class="literal">try</code> block. The body of the <code class="literal">try</code> block should be<a id="id74" class="indexterm"></a> as shown in the following code snippet. There are a couple of subtle but important concepts<a id="id75" class="indexterm"></a> in here that will be explained later in the chapter.</p><div class="informalexample"><pre class="programlisting">try
{
    task1.Wait();
    if (!task1.IsFaulted)
    {
     Console.WriteLine("Task complete. Origin of Species word count: {0}",task1.Result);
    }
}</pre></div></li><li><p>Next, let's implement the body of our <code class="literal">catch</code> block. It should look as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">catch (AggregateException aggEx)
{
    foreach (var ex in aggEx.InnerExceptions)
    {
      Console.WriteLine("Caught exception: {0}", ex.Message);
    }
}</pre></div></li><li><p>After the <code class="literal">catch</code> block, let's finish up by prompting the user to exit, and waiting on the user to hit <span class="emphasis"><em>Enter</em></span>.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_10.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>How it worksâ€¦</h3></div></div></div><p>All of this stuff has<a id="id76" class="indexterm"></a> been pretty self-explanatory so far, but handling exceptions in task involves a couple of subtleties that need to be pointed out.</p><p>The task itself is pretty straightforward. Other than throwing the <code class="literal">System.Net.WebException</code>, there is nothing out of the ordinary here.</p><p>Let's take a<a id="id77" class="indexterm"></a> closer look at the try/catch blocks. The first statement in the <code class="literal">try</code> block <code class="literal">System.Threading.Task.Wait()</code> to wait on task completion. However, there is another purpose here. Unhandled exceptions thrown inside a <code class="literal">task</code> are swallowed by the runtime and wrapped up in <code class="literal">System.AggregateException</code>. It is your job to handle this.</p><p>The TPL also has the concept of <code class="literal">AggregateException</code> being observed. If <code class="literal">AggregateException</code> is raised by your task, it will only be handled if it is currently being observed. This is very important to understand. If you never take an action that causes the exceptions to be observed, you are going to have a problem. When the <code class="literal">Task</code> object is garbage collected, the <code class="literal">Finalize</code> method of the <code class="literal">task</code> will see that the <code class="literal">task</code> had unobserved exceptions, and it will throw<code class="literal">System.AggregateException</code>. You will not be able to catch an exception thrown by the finalizer thread and your process will be terminated.</p><p>So how to you observe an <code class="literal">AggregateException</code>, you ask? The <code class="literal">Systm.Threading.Task</code> class has a few methods and properties call triggers that cause <code class="literal">System.AggregateException</code> to be observed. A few of these are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Task.Wait</p></li><li style="list-style-type: disc"><p>Task.WaitAny</p></li><li style="list-style-type: disc"><p>Task.WaitAll</p></li><li style="list-style-type: disc"><p>Task.Result</p></li></ul></div><p>Using any of these <code class="literal">trigger</code> methods indicates to the runtime that you are interested in observing any <code class="literal">System.AggregateException</code> that occurs. If you do not use one of the <code class="literal">trigger</code> methods on the <code class="literal">Task</code> class, the TPL will not raise any <code class="literal">AggregateException</code>, and an<a id="id78" class="indexterm"></a> unhandled exception will occur.</p><p>Now, let's take a look at the <code class="literal">catch</code> block. <code class="literal">System.AggregateException</code> can wrap many individual exception objects. In our <code class="literal">catch</code> block, we need to loop through <code class="literal">AggregateException.InnerExceptions</code> to take a look at all of the individual exceptions that <a id="id79" class="indexterm"></a>occurred in a task.</p><p>It is important to note that there is really no way to correlate an exception from the <code class="literal">AggregateExcetion.InnerExceptions</code> collection back to the particular <code class="literal">task</code> that threw an exception. All you really know is that some operation threw an <code class="literal">Exception</code>.</p><p>
<code class="literal">System.AggregateException</code> overrides the <code class="literal">GetBaseException</code> method of exception, and returns the innermost exception, which is the initial cause of the problem.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec16"></a>Handling task exceptions with AggregateException.Handle</h2></div></div><hr /></div><p>In this recipe, we will look at another way to handle <code class="literal">System.AggregateException</code>, by using the <code class="literal">AggregateException.Handle</code> method. The <code class="literal">Handler</code> method invokes a handler function for each <a id="id80" class="indexterm"></a>exception wrapped in <code class="literal">AggregateException</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe, we<a id="id81" class="indexterm"></a> need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime exception is thrown and intercepts the exception before it gets to our handler. </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>user-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look at how we can use <code class="literal">AggregateException.Handle</code> to provide an alternate method to handling exceptions in a parallel application.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>For this recipe, we will return to our <span class="strong"><strong>WordCount6</strong></span> project, and modify it to handle our exceptions in a different way. Start Visual Studio 2012 and open the <span class="strong"><strong>WordCount6</strong></span> project.</p></li><li><p>The first step is to define <a id="id82" class="indexterm"></a>our handler function that will be invoked when we call <code class="literal">AggregateException.Handle</code>. Following the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, add a<a id="id83" class="indexterm"></a> new <code class="literal">private static handler</code> method that returns a bool. It should look as the following code snippet:</p><div class="informalexample"><pre class="programlisting">private static bool HandleWebExceptions(Exception ex)
{
    if (ex is WebException)
    {
      Console.WriteLine(("Caught WebException: {0}", ex.Message);
      return true;
    }
    else
    {
      Console.WriteLine("Caught exception: {0}", ex.Message);
      return false;
    }
}</pre></div></li><li><p>The only other step here is to replace the body of your <code class="literal">catch</code> block with a call to <code class="literal">System.AggregateException.Handle</code>, passing in the <code class="literal">HandleWebExceptions </code>predicate. The updated <code class="literal">try</code>/<code class="literal">catch</code> block should look as follows:</p><div class="informalexample"><pre class="programlisting">try
{
    task1.Wait();   
    if (!task1.IsFaulted)
    {
      Console.WriteLine("Task complete. Origin of Species word count: {0}",task1.Result);
    }
}
catch (AggregateException aggEx)
{
    aggEx.Handle(HandleWebExceptions);                
}</pre></div></li><li><p>Those are the only modifications necessary. In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the <a id="id84" class="indexterm"></a>project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_11.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec24"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">AggregateException.Handle()</code> takes a predicate that you supply, and the predicate will be invoked once for every exception wrapped in <code class="literal">System.AggregateException</code>.</p><p>The predicate<a id="id85" class="indexterm"></a> itself<a id="id86" class="indexterm"></a> just needs to contain the logic to handle the various exception types that you expect, and to return true or false to indicate whether the exception was handled.</p><p>If any of the exceptions went unhandled, they will be wrapped in a new <code class="literal">System.AggregateException</code> and thrown.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec17"></a>Cancelling a task</h2></div></div><hr /></div><p>Up to this point, we <a id="id87" class="indexterm"></a>have focused on creating, running, and handling exceptions in <code class="literal">tasks</code>. Now we will begin to take a look at using <code class="literal">System.Threading.CancellationTokenSource</code> and <code class="literal">System.Threading.CancellationToken</code> to cancel <code class="literal">tasks</code>.</p><p>This recipe will show how to cancel a single task.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec25"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a <a id="id88" class="indexterm"></a>console application that shows how to cancel a parallel task.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the C# <span class="strong"><strong>Console Application</strong></span> project template, and assign <code class="literal">WordCount7</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> statements at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start by creating <code class="literal">CancellationTokenSource </code>and getting our <code class="literal">CancellationToken</code>. In the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, add the following statements:</p><div class="informalexample"><pre class="programlisting">//Create a cancellation token source
CancellationTokenSource tokenSource = new CancellationTokenSource();
//get the cancellation token
CancellationToken token = tokenSource.Token;</pre></div></li><li><p>Now we need to create our <code class="literal">Task</code> and pass <code class="literal">CancellationToken</code> into the constructor. Right after the previous line, put in the following <code class="literal">Task</code> definition:</p><div class="informalexample"><pre class="programlisting">Task&lt;int&gt; task1 = Task.Factory.StartNew(() =&gt;
{
    // The body of the task goes here                
}, token);  </pre></div></li><li><p>In the body of our <code class="literal">Task</code>, we need to check the <code class="literal">IsCancellationRequested</code> property of <code class="literal">CancellationToken</code>. If it has been, we dispose of our resource and throw <code class="literal">OperationCancelledException</code>. If not, we do our usual work. Enter the following code into the body of <code class="literal">Task</code>:</p><div class="informalexample"><pre class="programlisting">//wait a bit for the cancellation
Thread.Sleep(2000);
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
var client = new WebClient();
client.Headers.Add("user-agent", headerText);
if(token.IsCancellationRequested)
{
    client.Dispose();
    throw new OperationCanceledException(token);
}
else
{
    var book = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
    char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
    Console.WriteLine("Starting the task.");
    var wordArray = book.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
}</pre></div></li><li><p>Right after the task, put in the following lines to write the cancellation status to the <code class="literal">Console</code>, and then call the <code class="literal">Cancel</code> method of <code class="literal">TokenSource</code>.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Has the task been cancelled?: {0}", task1.IsCanceled);
//Cancel the token source
tokenSource.Cancel();</pre></div></li><li><p>The following<a id="id89" class="indexterm"></a> are the last statements put in a condition to check whether the task has been cancelled or faulted before we try to write out the results:</p><div class="informalexample"><pre class="programlisting">if (!task1.IsCanceled || !task1.IsFaulted)
{
    try
    {
        if (!task1.IsFaulted)
        {
          Console.WriteLine("Origin of Specied word count: {0}", task1.Result);
        }
    }
    catch (AggregateException aggEx)
    {
    foreach (Exception ex in aggEx.InnerExceptions)
    {
          Console.WriteLine("Caught exception: {0}", ex.Message);
    }
    }
}
else
{
    Console.WriteLine("The task has been cancelled");
}</pre></div></li><li><p>Lastly, we'll finish up by prompting the user to exit and waiting for the input.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_12.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec26"></a>How it worksâ€¦</h3></div></div></div><p>The basic idea of cancelling <code class="literal">task</code> is that we create <code class="literal">CancellationTokenSource</code>, obtain <code class="literal">CancellationToken</code> from it, and then pass <code class="literal">CancellationToken</code> onto the <code class="literal">Task</code> constructor. Once <a id="id90" class="indexterm"></a>we have done that, we can call the <code class="literal">Cancel</code> method on the <code class="literal">CancellationTokenSource</code> to cancel the task.</p><p>That's all easy enough. However, inside <code class="literal">task</code> we have a couple of options on how to handle the cancellation.</p><p>If your task has resources that need to be cleaned up (such as the <code class="literal">WebClient</code>), you need to check the cancellation tokens <code class="literal">IsCancellationRequested</code> property<a id="id91" class="indexterm"></a>, then dispose of the resources, and throw a new <code class="literal">OperationCancelledException</code>.</p><p>The other option, if your task doesn't use resources which need to be explicitly cleaned up, is to use the token <code class="literal">ThrowIsCancellationRequested()</code>, which will ensure the task transitions to a status of cancelled in a single statement.</p><p>If you need to execute <code class="literal">task</code> and prevent it from being cancelled, you can obtain a special <code class="literal">CancellationToken</code> that is not associated with any <code class="literal">CancellationTokenSource</code> from the static <code class="literal">CancellationToken.None</code> property, and pass this token to <code class="literal">Task</code>. Since there is no associated <code class="literal">CancellationTokenSource</code>, it is not possible to call <code class="literal">Cancel</code> for this token, and any<a id="id92" class="indexterm"></a> code that is checking the <code class="literal">CancellationToken.IsCancellationRequested</code> property will always get back a false.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec27"></a>There's moreâ€¦</h3></div></div></div><p>You can register one or more methods to be called when <code class="literal">CancellationTokenSource</code> is cancelled, by registering a <code class="literal">callback</code> method with the <code class="literal">CancellationToken.Register</code> method. You just need to pass <code class="literal">Action&lt;Object&gt;</code>, and optionally, a state value will be passed to <code class="literal">callback</code> and a <code class="literal">Boolean</code>, indicating whether to invoke the delegate using <code class="literal">SynchronizationContext</code> of the calling thread to the <code class="literal">Register</code> method. Passing in a value of false means the thread that calls <code class="literal">Cancel</code> will invoke the registered methods synchronously. If you pass true, the callbacks will be sent to <code class="literal">SynchronizationContext</code>, which determines which thread will invoke the callbacks.</p><div class="informalexample"><pre class="programlisting">var source = new CancellationTokenSource();
source.Token.Register(()=&gt;
{
  Console.WriteLine("The operation has been cancelled.");
});</pre></div><p>The <code class="literal">Register</code> method<a id="id93" class="indexterm"></a> of <code class="literal">CancellationToken</code> returns a <code class="literal">CancellationTokenRegistration</code> object. To remove a registered callback from <code class="literal">CancellationTokenSource</code>, so it doesn't get invoked, call the <code class="literal">Dispose</code> method of the <code class="literal">CancellationTokenRegistration</code> object.</p><p>You can also create <code class="literal">CancellationTokenSource</code> by linking other <code class="literal">CancellationTokenSource</code> objects together. The new composite <code class="literal">CancellationTokenSource</code> will be cancelled, if any of the linked <code class="literal">CancellationTokenSource</code> objects are cancelled.</p><div class="informalexample"><pre class="programlisting">var source1 = new CancellationTokenSource();
var source2 = new CancellationTokenSource();
var linkedSource = CancellationTokenSource.CreateLinkedTokenSource(source1.Token, source2.Token);</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec18"></a>Cancelling one of many tasks</h2></div></div><hr /></div><p>Now that we have<a id="id94" class="indexterm"></a> seen how to cancel a task, let's take a look at how we can use <code class="literal">CancellationToken</code> to cancel multiple tasks with a single call to <code class="literal">CancellationTokenSource.Cancel()</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec28"></a>How to do itâ€¦</h3></div></div></div><p>Now let's return to<a id="id95" class="indexterm"></a> our WordCount example and create a <code class="literal">Console</code> application that provides for the cancellation of multiple tasks with single <code class="literal">CancellationToken</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the C# <span class="strong"><strong>Console Application</strong></span> project template, and assign <code class="literal">WordCount8</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> statements at the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's create a <code class="literal">helper</code> method to display errors and cancellation status. Since we have multiple tasks, it's better to have this logic all in one place. Following the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, create a <code class="literal">static</code> method call <code class="literal">HandleExceptions</code> which will display the errors and task status to the user.</p><div class="informalexample"><pre class="programlisting">private static void DisplayException(Task task, AggregateException outerEx, string bookName)
{
    foreach (Exception innerEx in outerEx.InnerExceptions)
    {
      Console.WriteLine("Handled exception for {0}:{1}",bookName,innerEx.Message);
    }
    Console.WriteLine("Cancellation status for book {0}: {1}", bookName, task.IsCanceled);
}</pre></div></li><li><p>Next, at the top of the <code class="literal">Main</code> method, create <code class="literal">CancellationTokenSource </code>and get our <code class="literal">CancellationToken</code>.</p><div class="informalexample"><pre class="programlisting">//Create a cancellation token source
CancellationTokenSource tokenSource = new CancellationTokenSource();
//get the cancellation token
CancellationToken token = tokenSource.Token;</pre></div></li><li><p>Now we <a id="id96" class="indexterm"></a>need to create our tasks and our array of <code class="literal">delimiters</code>. The tasks are the same as in the recipe for cancelling a single task. The key here is that we are passing the<a id="id97" class="indexterm"></a> same <code class="literal">CancellationToken</code> in for all three tasks.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT<code class="literal"> 6.1; Trident/6.0)";</code>

 Task&lt;int&gt; task1 = Task.Factory.StartNew(() =&gt;
{
    // wait for the cancellation to happen
    Thread.Sleep(2000);
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    if (token.IsCancellationRequested)
    {
      client.Dispose();
      throw new OperationCanceledException(token);
    }
    else
    {
      var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
      Console.WriteLine("Starting the task for Origin of Species.");
      var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
      return wordArray.Count();
    }
},token);


 Task&lt;int&gt; task2 = Task.Factory.StartNew(() =&gt;
{
    // wait for the cancellation to happen
    Thread.Sleep(2000);
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    if (token.IsCancellationRequested)
    {
      client.Dispose();
      throw new OperationCanceledException(token);
    }
    else
    {
      var words = client.DownloadString(@"http://www.gutenberg.org/files/16328/16328-8.txt");
      Console.WriteLine("Starting the task for Beowulf.");
      var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
      return wordArray.Count();
    };
},token);

Task&lt;int&gt; task3 = Task.Factory.StartNew(() =&gt;
{
    // wait for the cancellation to happen
    Thread.Sleep(2000);
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    if (token.IsCancellationRequested)
    {
      client.Dispose();
      throw new OperationCanceledException(token);
    }
    else
    {
      var words = client.DownloadString(@"http://www.gutenberg.org/files/4300/4300.txt");
      Console.WriteLine("Starting the task for Ulysses.");
      var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
      return wordArray.Count();
    };
},token);</pre></div></li><li><p>OK, let's finish up by calling <code class="literal">CancellationTokenSource.Cancel()</code> , checking the results, and catching the exceptions. The remainder of the <code class="literal">Main</code> method <a id="id98" class="indexterm"></a>should <a id="id99" class="indexterm"></a>look as the following code snippet:</p><div class="informalexample"><pre class="programlisting">//Cancel the token source
tokenSource.Cancel();
try
{
    if (!task1.IsFaulted || !task1.IsCanceled)
    {
      Console.WriteLine("Origin of Specied word count: {0}", task1.Result);
    }
}
catch(AggregateException outerEx1)
{
    DisplayException(task1, outerEx1, "Origin of Species");
}
try
{
    if (!task2.IsFaulted || !task2.IsCanceled)
    {
      Console.WriteLine("Beowulf word count: {0}", task2.Result);
    }
}
catch (AggregateException outerEx2)
{
    DisplayException(task2, outerEx2, "Beowulf");
}
try
{
    if (!task3.IsFaulted || !task3.IsCanceled)
    {
      Console.WriteLine("Ulysses word count: {0}", task3.Result);
    }
}
catch (AggregateException outerEx3)
{
   DisplayException(task3, outerEx3, "Ulysses");
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_01_13.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec29"></a>How it worksâ€¦</h3></div></div></div><p>Functionally, <a id="id100" class="indexterm"></a>cancelling multiple tasks is the same as cancelling a single task. In fact, the Parallel Extensions team has put a lot of work into making cancellation of various parallel structures very similar, as you will see as we go through the book.</p><p>All that is <a id="id101" class="indexterm"></a>necessary to cancel multiple tasks is to create <code class="literal">CancellationToken</code>, then pass that token into all of the tasks you wish to cancel as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">CancellationTokenSource tokenSource = new CancellationTokenSource();
CancellationToken token = tokenSource.Token;

Task&lt;int&gt; task1 = Task.Factory.StartNew(() =&gt;
{
  ...
},token);
Task&lt;int&gt; task, = Task.Factory.StartNew(() =&gt;
{
  ...
},token);

tokenSource.Cancel();</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch02"></a>ChapterÂ 2.Â Implementing Continuations</h2></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Continuing a task</p></li><li style="list-style-type: disc"><p>Passing task results to a continuation</p></li><li style="list-style-type: disc"><p>Continue "WhenAny" and "WhenAll"</p></li><li style="list-style-type: disc"><p>Specifying when a continuation will run</p></li><li style="list-style-type: disc"><p>Using a continuation for exception handling</p></li><li style="list-style-type: disc"><p>Cancelling a continuation</p></li><li style="list-style-type: disc"><p>Using a continuation to chain multiple tasks</p></li><li style="list-style-type: disc"><p>Using a continuation to update a UI</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Introduction</h2></div></div><hr /></div><p>When you are writing an application that has tasks and that execute in parallel, it is common to have some parallel tasks that depend on the results of other tasks. These tasks should not be started until the earlier tasks, known as antecedents, have been completed.</p><p>In fact, to write truly scalable software, you should not have threads that block. Calling <code class="literal">Wait</code> or querying <code class="literal">Task.Result</code>, when the task has not finished running, will cause your threads to block. Fortunately, there is a better way.</p><p>Prior to the introduction of the <a id="id102" class="indexterm"></a>
<span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>), this type of interdependent thread execution was done with callbacks, where a method was called, and one of its parameters was a delegate to execute when the task completed. This provided a viable solution to the dependency problems but quickly became very complex in the real-world application. This is especially true if, for example, you had a task that needed to run after several other tasks had completed.</p><p>With the TPL, a simpler solution exists in the form of continuation tasks. These tasks are linked to their antecedents, and are automatically started after the earlier tasks have been completed.</p><p>What makes <a id="id103" class="indexterm"></a>continuations so powerful is that, you can create continuations that run when a task or a group of tasks completes throws an exception, or gets cancelled. As you will see in this chapter, continuations can even provide a means to synchronize the asynchronous method results with the user interface running on another thread.</p><p>We will start the chapter with a basic, simple continuation that runs when a single task completes. From there, we will look at using continuations to control a collection of tasks, using continuations to handle exceptions, and using continuations to chain multiple tasks together. We will finish the chapter by creating a <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>) application, using a continuation to marshal data created in a <a id="id104" class="indexterm"></a>task back to the user interface.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Continuing a task</h2></div></div><hr /></div><p>In its simplest form, a <a id="id105" class="indexterm"></a>continuation is an action that runs asynchronously after a target task, called an antecedent, completes.</p><p>In the first recipe of this chapter, we will build a basic continuation. We will accomplish this by using the <code class="literal">Task.ContinueWith(Action&lt;Task&gt;)</code> method<a id="id106" class="indexterm"></a>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec30"></a>How to do itâ€¦</h3></div></div></div><p>Let's go to Visual Studio and create a console application that runs a task continuation after our word count task completes. The steps to create a console application are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation1</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>Now let's put a try/catch block and some basic exception handling. The <code class="literal">Main</code> method of the program class, at this point, should look as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">static void Main()
{
  try
  {
  // The Task and Continuation will go here
  }
  catch (AggregateException aEx)
  {
    foreach (Exception ex in aEx.InnerExceptions)
    {
      Console.WriteLine("An exception has occured: {0}" + ex.Message);
    }
  }
}</pre></div></li><li><p>Inside the <code class="literal">try</code> block, create a <code class="literal">WebClient</code> object and set the user-agent header as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var client = new WebClient();</strong></span>
<span class="strong"><strong>const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";</strong></span>
<span class="strong"><strong>client.Headers.Add("user-agent", headerText);</strong></span>
</pre></div></li><li><p>Next, in the<a id="id107" class="indexterm"></a> body of the <code class="literal">try</code> block, let's create an anonymous <code class="literal">Task</code> (no name), followed by a <code class="literal">.ContinueWith()</code> right after the closing parenthesis of the <code class="literal">Task</code>. The antecedent <code class="literal">Task</code> doesn't return any results in this recipe.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
}).ContinueWith(obj =&gt;
{
}).Wait();</pre></div></li><li><p>Finally, we need to create the body of the <code class="literal">Task</code> and the continuation. The <code class="literal">Task</code> will execute one of our familiar word counts. The continuation will be used to clean up the reference to the <code class="literal">WebClient</code> object after the antecedent task completes. After the continuation, prompt the user to exit.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
  {
    Console.WriteLine("Antecedent running.");
    char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };                        
    var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    Console.WriteLine("Word count for Origin of Species: {0}", wordArray.Count());
  }
).ContinueWith(antecedent =&gt;
  {
    Console.WriteLine("Continuation running");
    client.Dispose();
  }).Wait();</pre></div></li><li><p>In Visual<a id="id108" class="indexterm"></a> Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_01.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec31"></a>How it worksâ€¦</h3></div></div></div><p>There isn't a lot to explain about this basic continuation, but there are a couple of small points to note.</p><p>For this recipe, we created an anonymous <code class="literal">Task</code> and made the call to <code class="literal">ContinueWith</code> right after the closing parenthesis of the task as follows:</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
}).ContinueWith(obj =&gt;
{
}).Wait();</pre></div><p>We could just as well have created a named task and made the call to <code class="literal">ContinueWith</code> in a separate statement shown as follows:</p><div class="informalexample"><pre class="programlisting">Task task1 = Task.Factory.StartNew(() =&gt;
{
});
task1.ContinueWith(obj =&gt;
{
}).Wait();</pre></div><p>Also, notice that we can wait for a continuation using the <code class="literal">Wait()</code> method; in the same way we could wait for a <code class="literal">Task</code> (however, you will not normally do this in practice. It causes the thread to<a id="id109" class="indexterm"></a> block waiting for the continuation to complete. In general, you want to avoid causing your threads to block). In fact, tasks and continuations aren't much different and have many of the same instance methods and properties.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Passing task results to a continuation</h2></div></div><hr /></div><p>In this recipe, we will see how we can pass the results returned from an antecedent <code class="literal">Task</code> to a continuation.</p><p>Our antecedent <code class="literal">Task</code> is going<a id="id110" class="indexterm"></a> to read in the contents of a book as a <a id="id111" class="indexterm"></a>string and display a word count to the user. The continuation, which will run after the antecedent completes, will take the string array returned by the antecedent and perform a LINQ query which will find the five most frequently used words.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec32"></a>How to do itâ€¦</h3></div></div></div><p>Let's start Visual Studio and build a Console Application that shows how to pass results from the antecedent to a continuation. The steps are given as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation2</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>To begin with, let's put some basic stuff in the class. We will need a character array of delimiters so that we can parse out the words properly. Also, we need a try/catch block and some basic exception handling. The <code class="literal">Main</code> method of the Program class, at this point, should look as follows:</p><div class="informalexample"><pre class="programlisting">static void Main()
{
    char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
    try
    {
    // The Task and Continuation will go here
    }
    catch (AggregateException aEx)
    {
      foreach (Exception ex in aEx.InnerExceptions)
      {
        Console.WriteLine("An exception has occured: {0}" + ex.Message);
      }
    }
}</pre></div></li><li><p>Now let's create a task called <code class="literal">task1</code> that returns an array of strings as its result. The <a id="id112" class="indexterm"></a>purpose of <code class="literal">task1</code> will be to create <code class="literal">System.Net.WebClient</code> which will read in the text of the book as a string. Once the string is parsed and put into a <a id="id113" class="indexterm"></a>string array, we will display the word count to the user by using the <code class="literal">Count</code> method of the array, and then return the array in the tasks result so that it can be used in our continuation. Create the task inside the <code class="literal">try</code> block. The body of the <code class="literal">try</code> block should now look something like the following code:</p><div class="informalexample"><pre class="programlisting">try
{
    Task&lt;string[]&gt; task1 = Task.Factory.StartNew(() =&gt;
    {
      var client = new WebClient();
      const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
      client.Headers.Add("user-agent",headerText);
      var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
      string[] wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
      Console.WriteLine("Word count for Origin of Species: {0}", wordArray.Count());
      Console.WriteLine();
      return wordArray;
    }
}</pre></div></li><li><p>Next, we are going to create our continuation using the <code class="literal">Task.ContinueWith()</code> method. Our continuation will have a <code class="literal">Task&lt;string[]&gt; state</code> parameter. The body of the continuation will perform a Linq query on the string array to sort all of the words contained in the array by the number of times the words occur. We will then execute another Linq operation to<a id="id114" class="indexterm"></a> take the top five most frequently used words and write them to the console. Finally, we will <a id="id115" class="indexterm"></a>want to wait on the continuation to complete with the <code class="literal">Wait()</code> method. Create the task continuation right after the body of the antecedent task.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent =&gt;
{
  var wordsByUsage = antecedent.Result.Where(word =&gt; word.Length &gt; 5)
  .GroupBy(word =&gt; word)
  .OrderByDescending(grouping =&gt; grouping.Count())
  .Select(grouping =&gt; grouping.Key);
  var commonWords = (wordsByUsage.Take(5)).ToArray();
  Console.WriteLine("The 5 most commonly used words in Origin of Species:");
  Console.WriteLine("----------------------------------------------------");
  foreach (var word in commonWords)
  {
    Console.WriteLine(word);
  }
}).Wait();</pre></div></li><li><p>OK, the last step for this recipe is to let the user know that our application is finished and prompt them to exit. Put that code right after the continuation. It should be the last lines in the <code class="literal">try</code> block.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine();
Console.WriteLine("Complete. Please hit &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec33"></a>How it worksâ€¦</h3></div></div></div><p>The continuation in this recipe was created using the <code class="literal">ContinueWith</code> method of an existing task instance<a id="id116" class="indexterm"></a> as we did in the previous recipe. In this<a id="id117" class="indexterm"></a> recipe however, we use a Lambda expression to pass in a <code class="literal">Task&lt;string[]&gt;</code> parameter representing the antecedent <code class="literal">Task</code>.</p><div class="informalexample"><pre class="programlisting">Task&lt;string[]&gt; task1 = Task.Factory.StartNew(() =&gt;
{
  //Task Action
}); 
task1.ContinueWith(antecedent =&gt;
{
  //Continuation Action
});</pre></div><p>Notice that the continuation accesses the result of the antecedent using the <code class="literal">Task.Result</code> property. If this looks familiar, it should. You access the results of a task in nearly the same way in a continuation as you would in any piece of your code, that is, by accessing the <code class="literal">Result</code> property of a <code class="literal">Task</code>. The Parallel Extensions team has made the coding experience very consistent across all parallel operations.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent =&gt;
{
  var wordsByUsage = antecedent.Result.Where(word =&gt; word.Length &gt; 5)
  .GroupBy(word =&gt; word)
  .OrderByDescending(grouping =&gt; grouping.Count())
  .Select(grouping =&gt; grouping.Key);
  var commonWords = (wordsByUsage.Take(5)).ToArray();
  Console.WriteLine("The 5 most commonly used words in Origin of Species:");
  Console.WriteLine("----------------------------------------------------");
  foreach (var word in commonWords)
  {
    Console.WriteLine(word);
  }
});</pre></div><p>Lastly, we wait for<a id="id118" class="indexterm"></a> the continuation to complete before <a id="id119" class="indexterm"></a>prompting the user to exit.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Continue "WhenAny" and "WhenAll"</h2></div></div><hr /></div><p>In this recipe we will move from continuing single tasks to setting up continuations for groups of tasks. The two methods we will be looking at are <code class="literal">WhenAny</code> and <code class="literal">WhenAll</code>. Both methods are static members of the <code class="literal">Task.Factory</code> class, and take an array of tasks and <code class="literal">Action&lt;Task&gt;</code> as their parameters.</p><p>First we will look at the <code class="literal">WhenAny</code> continuations.<a id="id120" class="indexterm"></a> The basic idea here is that we have a group of tasks and we only want to wait for the first and fastest of the group to <a id="id121" class="indexterm"></a>complete its work before moving on. In our case, we will be downloading the text of three different books, and performing a word count on each. When the first task completes we will display the word count of the winner to the user.</p><p>After that we will change to <code class="literal">WhenAll</code> and display the results of all three word counts to the user.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec34"></a>How to do itâ€¦</h3></div></div></div><p>Let's build a solution that shows how to conditionally continue a task. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation3</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method of your program class, let's create a character array of delimiters we can use to split our words with, a string constant for the user agent header of our web client, and a <code class="literal">Dictionary&lt;string, string&gt;</code> method to hold our book titles and URLs. The dictionary will serve as the state object <a id="id122" class="indexterm"></a>parameter for our tasks, which will be created in a <code class="literal">foreach</code> loop.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
var dictionary = new Dictionary&lt;string, string&gt;
{
  {"Origin of Species", "http://www.gutenberg.org/files/2009/2009.txt"},
    {"Beowulf", "http://www.gutenberg.org/files/16328/16328-8.txt"},
    {"Ulysses", "http://www.gutenberg.org/files/4300/4300.txt"}
};</pre></div></li><li><p>Next, let's create <a id="id123" class="indexterm"></a> a try/catch block with some basic error handling.</p><div class="informalexample"><pre class="programlisting">try
{
  // Loop to create and Continuation will go here
}
catch (AggregateException aEx)
{
  foreach (Exception ex in aEx.InnerExceptions)
  {
    Console.WriteLine("An exception has occured: {0}" + ex.Message);
  }
}</pre></div></li><li><p>Inside the <code class="literal">try</code> block, let's create a new list of <code class="literal">Task&lt;KeyValuePair&lt;string, string&gt;&gt;</code>. Of course, this will be the list of our tasks. Each task will take a <code class="literal">KeyValuePair</code> from the dictionary we created in step 3 as their state parameters.</p><div class="informalexample"><pre class="programlisting">var tasks = new List&lt;Task&lt;KeyValuePair&lt;string, int&gt;&gt;&gt;();</pre></div></li><li><p>Now let's create our task in a <code class="literal">foreach</code> loop. Each task will read the text of a book from a string, split the string into a character array, and do a word count. Our antecedent tasks return a <code class="literal">KeyValuePair&lt;string, int&gt;</code> with the book title and the word count for each book.</p><div class="informalexample"><pre class="programlisting">foreach (var pair in dictionary)
{
  tasks.Add(Task.Factory.StartNew(stateObj =&gt;
  {
    var taskData = (KeyValuePair&lt;string, string&gt;)stateObj;
    Console.WriteLine("Starting task for {0}", taskData.Key);
    var client = new WebClient();
    client.Headers.Add("user-agent", headerText);
    var words = client.DownloadString(taskData.Value);
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return new KeyValuePair&lt;string, int&gt;(taskData.Key, wordArray.Count());
  }, pair));
}</pre></div></li><li><p>Now let's create<a id="id124" class="indexterm"></a>  the continuation by calling the <code class="literal">Task.Factory.WhenAny</code> method. The continuations will just display the title and word <a id="id125" class="indexterm"></a>count of the winner to the user.</p><div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAny(tasks.ToArray(), antecedent =&gt;
{
    Console.WriteLine("And the winner is: {0}", antecedent.Result.Key);
    Console.WriteLine("Word count: {0}", antecedent.Result.Value);
}).Wait();</pre></div></li><li><p>Lastly, after the catch block, prompt the user to exit and wait for the input.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Complete. Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following. Your winner may vary.</p><div class="mediaobject"><img src="graphics/0225OT_02_03.jpg" /></div></li><li><p>Before<a id="id126" class="indexterm"></a>  moving on, let's change our code a bit and continue when all of our tasks complete. All we need to do is change our method call from <code class="literal">Task.Factory.WhenAny</code> to <code class="literal">Task.Factory.WhenAll</code>, change the name of the continuation parameter from <code class="literal">antecedent</code> to <code class="literal">antecedents</code> to reflect plurality, and<a id="id127" class="indexterm"></a> create a <code class="literal">foreach</code> loop in the body of the continuation to loop through the results.</p><div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(), antecedents =&gt;
{
    foreach (var antecedent in antecedents)
    {
        Console.WriteLine("Book Title: {0}", antecedent.Result.Key);
        Console.WriteLine("Word count: {0}", antecedent.Result.Value);
    }
}).Wait();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec35"></a>How it worksâ€¦</h3></div></div></div><p>The continuations in<a id="id128" class="indexterm"></a> this recipe are created a bit differently from the continuations that we have created in previous tasks. Instead of calling the<a id="id129" class="indexterm"></a>  instance method <code class="literal">ContinueWith</code> on a <code class="literal">Task</code> variable, we are calling the <code class="literal">ContinueWhenAny</code> and <code class="literal">ContinueWhenAll</code> static methods on <code class="literal">Task.FactoryClass</code>.</p><div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(), antecedents =&gt;
{
});</pre></div><p>The <code class="literal">ContinueWhenAny</code> and <code class="literal">ContinueWhenAll</code> methods have a different parameter lists than <code class="literal">Task.ContinueWith</code>.</p><p>
<code class="literal">ContinueWhenAny</code> takes an array of <code class="literal">Task</code> as its first parameter and a single <code class="literal">Action&lt;Task&gt;</code> delegate as its second parameter.</p><div class="informalexample"><pre class="programlisting">ContinueWhenAny(Task[], Action&lt;Task&gt;)</pre></div><p>
<code class="literal">ContinueWhenAll</code> takes the same array of <code class="literal">Task</code> as its first parameter and <code class="literal">Action&lt;Task[]&gt;</code> as its second parameter.</p><div class="informalexample"><pre class="programlisting">ContinueWhenAll(Task[], Action&lt;Task[]&gt;)</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec23"></a>Specifying when a continuation will run</h2></div></div><hr /></div><p>One of the most powerful <a id="id130" class="indexterm"></a>features of task continuations is the ability to create multiple continuations for a task, and specify the exact conditions under which each continuation will be invoked by using the <code class="literal">Task.TaskContinuationOptions</code> enumeration.</p><p>When you create a continuation for a task, you can use <code class="literal">Task.ContinueWith</code> overload that takes the <code class="literal">TaskContinuationOptions</code> enumeration to specify that the continuation will only run if the antecedent <code class="literal">Task</code> completed, was cancelled, or is faulted. The enumeration also has<a id="id131" class="indexterm"></a> members that specify when a continuation should not run.</p><p>In this recipe, we will be looking at two simple tasks, each with two continuations. One of the continuations for each task will run when the task completes, and one will run when the task is cancelled.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec36"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's create a console application that continues tasks conditionally. The steps to create a console application are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation4</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>At the top of the <code class="literal">Main</code> method, create two <code class="literal">CancellationTokenSource</code> objects and get a <code class="literal">CancellationToken</code> from each one of them.</p><div class="informalexample"><pre class="programlisting">var tokenSource1 = new CancellationTokenSource();
var token1 = tokenSource1.Token;

 var tokenSource2 = new CancellationTokenSource();
 var token2 = tokenSource2.Token;</pre></div></li><li><p>Next, let's create a try/catch block with some basic error handling.</p><div class="informalexample"><pre class="programlisting">try
{
    // Tasks and Continuations will go here
}
catch (AggregateException aEx)
{
    foreach (Exception ex in aEx.InnerExceptions)
    {
      Console.WriteLine("An exception has occured: {0}" + ex.Message);
    }
}</pre></div></li><li><p>Inside the <code class="literal">try</code> block, let's create two simple tasks. Both tasks just write a message to the console. <a id="id132" class="indexterm"></a>Also create two continuations for each task using <code class="literal">TaskContinuationOptions.OnlyOnRanToCompletion</code> and <code class="literal">Task ContinuationOption.OnlyOnFaulted</code>.</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Task #1 is running.");
    //wait a bit
    Thread.Sleep(2000);
}, token1);

task1.ContinueWith(antecedent =&gt; Console.WriteLine("Task #1 completion continuation."), TaskContinuationOptions.OnlyOnRanToCompletion);
task1.ContinueWith(antecedent =&gt; Console.WriteLine("Task #1 cancellation continuation."), TaskContinuationOptions.OnlyOnCanceled);
                
var task2 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Task #2 is running.");
    //wait a bit
    Thread.Sleep(2000);
}, token2);

task2.ContinueWith(antecedent =&gt; Console.WriteLine("Task #2 completion continuation."), TaskContinuationOptions.OnlyOnRanToCompletion);
task2.ContinueWith(antecedent =&gt; Console.WriteLine("Task #2 cancellation continuation."), TaskContinuationOptions.OnlyOnCanceled);</pre></div></li><li><p>Lastly, after the <code class="literal">catch</code> block, let's cancel the token and wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">tokenSource2.Cancel();
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_05.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec37"></a>How it worksâ€¦</h3></div></div></div><p>In this very simple example, we started by creating two <code class="literal">CancellationTokenSource</code> objects and getting a <a id="id133" class="indexterm"></a>cancellation token source from each. If we had created a <code class="literal">CancellationTokenSource</code> object and passed the token into both tasks, both tasks would have been cancelled when we cancelled the token. In our case, we just wanted to cancel one of the two tasks.</p><p>The tasks themselves are very simple. They just wait for a bit to give us some time to cancel the token and display a message to the console. We pass one <code class="literal">CancellationToken</code> into each task as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Task #1 is running.");
    //wait a bit
    Thread.Sleep(2000);
}, token1);

var task2 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Task #2 is running.");
    //wait a bit
    Task2.Delay(2000);
}, token2);</pre></div><p>Both of the continuations just display a message to the console, and both are created with a member of the <code class="literal">Task.TaskContinuationOptions</code> enumerator. The first continuation is fired when the task runs to completion and the second continuation fires when the task is cancelled.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent =&gt; Console.WriteLine("Task #1 completion continuation."),         TaskContinuationOptions.OnlyOnRanToCompletion);

task1.ContinueWith(antecedent =&gt; Console.WriteLine("Task #1 cancellation continuation."), TaskContinuationOptions.OnlyOnCanceled);</pre></div><p>We cancel the token for <code class="literal">task2</code>, but not for <code class="literal">task1</code> and the corresponding continuation for each executes, and we <a id="id134" class="indexterm"></a>can see the message written on to the console.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec38"></a>There's moreâ€¦</h3></div></div></div><p>The <code class="literal">TaskContinuationOptions</code> enumeration has several members which control under which condition a continuation is triggered. The following table contains a list of these members. Note that this is not a complete list of continuation options. The complete list of continuation options can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcontinuationoptions.aspx</a>. The <code class="literal">OnlyOnFaulted</code> member will have its own recipe later in the chapter.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">NotOnRanToCompletion</code>
<a id="id135" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>The continuation should not be<a id="id136" class="indexterm"></a> scheduled if the task ran to completion.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">NotOnFaulted</code>
<a id="id137" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>The continuation should not be scheduled if the task faulted.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">NotOnCancelled</code>
<a id="id138" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>The continuation should not be triggered if the task was cancelled.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">OnlyOnRanToCompletion</code>
<a id="id139" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>The continuation should be scheduled if the task ran to completion.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">OnlyOnFaulted</code>
<a id="id140" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>The continuation should be scheduled if the task faulted.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">OnlyOnCancelled</code>
<a id="id141" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>The continuation should be triggered if the task was cancelled.</p>
</td></tr></tbody></table></div><p>The <code class="literal">TaskContinuationOptions</code> enumeration can be treated as a bit field and a bitwise combination can be performed on its members.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec24"></a>Using a continuation for exception handling</h2></div></div><hr /></div><p>In the <span class="emphasis"><em>Handling task exceptions using try/catch</em></span> recipe, in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Getting Started With Task Parallel Library</em></span> we looked at how to handle exceptions in task. In addition to the techniques used in that recipe, you can<a id="id142" class="indexterm"></a> also use continuations to handle task exceptions. By using a continuation, we can handle errors in a cleaner, less inline way. An exception handling continuation allows for centralizing exception handling logic in cases where you would want to provide logging or other exception related code.</p><p>The basic concept is<a id="id143" class="indexterm"></a> to use the <code class="literal">Task.TaskContinuationOptions</code> enumeration so we can create a continuation that will be scheduled if the task ran to completion, and another continuation that will be scheduled if the task is put into a faulted state.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec39"></a>Getting Ready</h3></div></div></div><p>For this recipe we need to turn off the <span class="strong"><strong>Visual Studio 2012 Exception Assistant</strong></span>. The Exception Assistant appears whenever a run-time exception is thrown and intercepts the exception before it gets to our handler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_02_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec40"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's go to Visual Studio and see how to use a continuation for exception handling. The steps are given <a id="id144" class="indexterm"></a>as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project <a id="id145" class="indexterm"></a>using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation5</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives at the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of your program class, create a <code class="literal">Task</code>. The task doesn't need to accept a state parameter or return anything. In the body of the <code class="literal">Task</code>, create the try/finally blocks. In order to have a resource to dispose of, create a new WebClient in the <code class="literal">try</code> block, and then throw an exception. In the <code class="literal">finally</code> block, call the dispose method of the WebClient. Other than that, the exact details don't matter much.</p><div class="informalexample"><pre class="programlisting">Task task1 = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine("Starting the task.");
    var client = new WebClient();
    const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
    client.Headers.Add("user-agent", headerText);
    try
    {
        var book = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
        var ex = new WebException("Unable to download book contents");
        throw ex;
    }
    finally
    {
        client.Dispose();
        Console.WriteLine("WebClient disposed.");
    }
});</pre></div></li><li><p>Immediately following the <code class="literal">Task</code>, use <code class="literal">TaskContinuationOptions.OnlyOnRanToCompletion</code> to create a trivial continuation to run when the task completes successfully. This continuation only needs to write a message to the console.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent=&gt; 
{
    Console.WriteLine("The task ran to   completion."),
}, TaskContinuationOptions.OnlyOnRanToCompletion);</pre></div></li><li><p>Next use <code class="literal">TaskContinuationOptions.OnlyOnFaulted</code> to create a continuation<a id="id146" class="indexterm"></a> that only runs when <code class="literal">task1</code> throws<a id="id147" class="indexterm"></a> a fault. After the continuation, add <code class="literal">Console.Readline</code> to wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent =&gt;
{
    Console.WriteLine("The task faulted.");
    var aEx = antecedent.Exception;
    if (aEx != null)
    foreach (var ex in aEx.InnerExceptions)
    {
        Console.WriteLine("Handled Exception: {0}",ex.Message);
    }
}, TaskContinuationOptions.OnlyOnFaulted);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec41"></a>How it worksâ€¦</h3></div></div></div><p>Creating a continuation that will run when a <code class="literal">Task</code> is in a faulted state, works the same as setting any of the other <a id="id148" class="indexterm"></a>enumerations in <code class="literal">TaskContinuationOptions</code> on a continuation.</p><p>In order to properly clean up resources used by the <code class="literal">Task</code>, we created <code class="literal">try/finally</code> blocks in our task and disposed of the WebClient in the <code class="literal">finally</code> block:</p><div class="informalexample"><pre class="programlisting">finally
{
    client.Dispose();
    Console.WriteLine("WebClient disposed.");
}</pre></div><p>Our exception handling<a id="id149" class="indexterm"></a> continuation checks to see if the <code class="literal">AggregateException</code> is null before looping through the <code class="literal">InnerExceptions</code> collection, and writing the result to the console. The null check isn't strictly necessary because the antecedent task needs to be in a faulted state before the continuation is scheduled, but it is a good defensive coding practice none the less:</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent =&gt;
{
    Console.WriteLine("The task faulted.");
    var aEx = antecedent.Exception;
    if (aEx != null)
        foreach (var ex in aEx.InnerExceptions)
        {
            Console.WriteLine("Handled Exception: {0}",ex.Message);
        }
}, TaskContinuationOptions.OnlyOnFaulted);
Console.ReadLine();</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec25"></a>Cancelling a continuation</h2></div></div><hr /></div><p>Cancelling a continuation follows the same basic rules as cancelling a <code class="literal">Task</code>. If a <code class="literal">Task</code> and its continuation are two parts of the same operation, you can pass the same cancellation token to both the <code class="literal">Task</code> and the continuation.</p><p>In this recipe we will have a <a id="id150" class="indexterm"></a>simple <code class="literal">Task</code> that creates a list of numbers and a continuation that squares the numbers and return a result. After a few seconds of running, we will use the token to cancel both the <code class="literal">Task</code> and the continuation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec42"></a>Getting Ready</h3></div></div></div><p>Since cancelling a <code class="literal">Task</code> or continuation raises and <code class="literal">OperationCanceledException</code> we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime exception is thrown, and intercepts the exception before it gets to our handler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_02_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec43"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's build a console<a id="id151" class="indexterm"></a> application so that we can see how to cancel a continuation. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation6</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class.</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of your program class, let's start by creating our <code class="literal">CancellationTokenSource</code> and getting a token. We will pass this token to both the antecedent <code class="literal">Task</code> and the continuation.</p><div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();
var token = tokenSource.Token;</pre></div></li><li><p>Next let's add try/catch/finally blocks to the <code class="literal">Main</code> method, just under the previous lines. Add some basic error handling to the <code class="literal">catch</code> block and dispose of the <code class="literal">CancellationTokenSource</code> in the <code class="literal">finally</code> block.</p><div class="informalexample"><pre class="programlisting">try
{
//Task and Continuation go here
}
catch (AggregateException aEx)
{
    foreach (var ex in aEx.InnerExceptions)
    {
        Console.WriteLine("An exception has occured: " + ex.Message);
    }
}
finally
{
    tokenSource.Dispose();
}</pre></div></li><li><p>Inside the <code class="literal">try</code> block, create a task that accepts an object state parameter. The parameter will <a id="id152" class="indexterm"></a>determine the size of our number list. We will cast it to <code class="literal">Int32</code> and create a <code class="literal">for</code> loop to add numbers to our list. Also, pass the token created in step 1 to the task constructor.</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(state =&gt;
{
    Console.WriteLine("Task has started.");
    var result = new List&lt;Int32&gt;();
    for (var i = 0; i &lt; (Int32) state; i++)
    {
        token.ThrowIfCancellationRequested();
        result.Add(i);
        Thread.Sleep(100); //sleep to simulate some work
    }
    return result;
}, 5000,token);</pre></div></li><li><p>After the <code class="literal">Task</code>, let's create our continuation. The continuation will receive the results from the antecedent <code class="literal">Task</code>, loop through the list, and square the numbers. Pass the same <code class="literal">CancellationToken</code> into the continuations constructor.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith(antecedent =&gt;
{
    Console.WriteLine("Continuation has started.");
    var antecedentResult = antecedent.Result;
    var squares = new List&lt;int&gt;();
    foreach (var value in antecedentResult)
    {
        token.ThrowIfCancellationRequested();
        squares.Add(value*value);
        Thread.Sleep(100);//sleep to simulate some more work
    }
    return squares;
},token);</pre></div></li><li><p>At the end of the <code class="literal">try</code> block, we need to sleep the thread a bit to give the <code class="literal">Task</code> and continuation <a id="id153" class="indexterm"></a>some time to run, and then we will cancel the token. Finally we will call the <code class="literal">Wait</code> method on <code class="literal">task1</code>.</p><div class="informalexample"><pre class="programlisting">Thread.Sleep(2000); //wait for 2 seconds
tokenSource.Cancel();
task1.Wait();</pre></div></li><li><p>Last, after the end of the <code class="literal">finally</code> block, write a message to the console that we are finished and wait for the user input.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Complete. Press enter to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec44"></a>How it worksâ€¦</h3></div></div></div><p>When an antecedent task throws an <code class="literal">OperationCancelledException</code> in response to a cancellation request, as long as the continuation uses the same <code class="literal">CancellationToken</code>, the cancellation request will be treated as an acknowledgement of co-operative cancellation and both the antecedent task and the continuation will go into a cancelled state.</p><p>This is pretty easy to <a id="id154" class="indexterm"></a>accomplish. We just need to get a <code class="literal">CancellationToken</code> from a <code class="literal">CancellationTokenSource</code>, and pass the token to the constructors for both the antecedent <code class="literal">Task</code> and the continuation.</p><div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();
var token = tokenSource.Token;

var task1 = Task.Factory.StartNew(state =&gt;
{
    // Task body
}, 5000,token);

task1.ContinueWith(antecedent =&gt;
{
    //Continuation body
},token);</pre></div><p>Inside the body of the loops in our <code class="literal">Task</code> and the continuation, we need to poll for cancellation and throw an <code class="literal">OperationCancelledException</code> if the token gets cancelled. This can be done in one line of code with the <code class="literal">ThrowIfCancellationRequested</code> method of the <code class="literal">CancellationToken</code> object.</p><div class="informalexample"><pre class="programlisting">foreach (var value in antecedentResult)
{
    token.ThrowIfCancellationRequested();
    squares.Add(value*value);
    Thread.Sleep(100);//sleep to simulate some more work
}</pre></div><p>Lastly, we just need to make sure we are handling <code class="literal">AggregateExceptions</code> in our <code class="literal">catch</code> block.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec26"></a>Using a continuation to chain multiple tasks</h2></div></div><hr /></div><p>Another feature of continuations is that you can continue continuations in order to chain tasks together to any length. The pipeline<a id="id155" class="indexterm"></a> pattern can be implemented with a series of tasks and continuations. You can think of a pipeline as an assembly<a id="id156" class="indexterm"></a> line in a factory. At the frontend of a pipeline, a producer task generates the data to be operated on, and each of the chained consumer stages operates on or changes the produced data.</p><p>In this recipe we will return to our word count example to create a simple three stage pipeline using continuations with <code class="literal">TaskContinuationOptions.OnlyOnRanToCompletion</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec45"></a>How to do itâ€¦</h3></div></div></div><p>Open up Visual Studio, <a id="id157" class="indexterm"></a>and let's see how to chain tasks together into a pipeline. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Continuation7</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start this application by adding try/catch blocks in the <code class="literal">Main</code> method of the program class. In the <code class="literal">catch</code> block add some handling for any <code class="literal">AggregateException</code> raised by the tasks. At the end of the <code class="literal">catch</code> block, write a message to the console to tell the user we are finished and wait for input to exit.</p><div class="informalexample"><pre class="programlisting">try
{
//Task and continuations go here
}
catch (AggregateException aEx)
{
    foreach (var ex in aEx.InnerExceptions)
    {
        Console.WriteLine("An exception has occured: {0}", ex.Message);
    }
}
Console.WriteLine();
Console.WriteLine("Complete. Please hit &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>Now we need to create a <code class="literal">producer</code> task that reads in the text of a book, and returns a string array, <a id="id158" class="indexterm"></a>which the consumer continuations will consume.</p><div class="informalexample"><pre class="programlisting">var producer = Task.Factory.StartNew(() =&gt;
{
    char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
    var client = new WebClient();
    const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
    client.Headers.Add("user-agent", headerText);
    try
    {
        var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
        var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
        Console.WriteLine("Word count for Origin of Species: {0}", wordArray.Count());
        Console.WriteLine();
        return wordArray;
    }
    finally
    {
        client.Dispose();
    }
});</pre></div></li><li><p>The first consumer will <a id="id159" class="indexterm"></a>perform a Linq query on the results of the producer to find the five most commonly used words.</p><div class="informalexample"><pre class="programlisting">Task&lt;string[]&gt; consumer1 = producer.ContinueWith(antecedent =&gt;
{
    var wordsByUsage =antecedent.Result.Where(word =&gt; word.Length &gt; 5)
        .GroupBy(word =&gt; word)
        .OrderByDescending(grouping =&gt; grouping.Count())
        .Select(grouping =&gt; grouping.Key);
    var commonWords = (wordsByUsage.Take(5)).ToArray();
    Console.WriteLine("The 5 most commonly used words in Origin of Species:");
    Console.WriteLine("----------------------------------------------------");
    foreach (var word in commonWords)
    {
        Console.WriteLine(word);
    }
    Console.WriteLine();
    return antecedent.Result;
}, TaskContinuationOptions.OnlyOnRanToCompletion);
The second <a id="id160" class="indexterm"></a>consumer will perform another Linq query to find the longest word used.
Task consumer2 = consumer1.ContinueWith(antecedent =&gt;
{
    var longestWord = (antecedent.Result.OrderByDescending(w =&gt; w.Length)).First();
    Console.WriteLine("The longest word is: {0}", longestWord);
}, TaskContinuationOptions.OnlyOnRanToCompletion);
consumer2.Wait();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run<a id="id161" class="indexterm"></a> the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec46"></a>How it worksâ€¦</h3></div></div></div><p>The task and continuations we used in this example are pretty much the same as the tasks we have created in other recipes. The primary difference is how we chained them together and the length <a id="id162" class="indexterm"></a>of the chain. Our antecedent task produces and returns a string array, and then we have a continuation that finds the five most commonly used words, finally we continue the continuation to find the longest word.</p><p>Note that we also use <code class="literal">TaskContinuationOptions.OnlyOnRanToCompletion</code> because we only want the consumers to be scheduled to run when the previous task succeeded. To be a more complete solution, we would want to use <code class="literal">TaskContinuationOptions.OnlyOnFaulted</code> to set up a continuation for the failure path as well.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec27"></a>Using a continuation to update a UI</h2></div></div><hr /></div><p>A common challenge when developing multithreaded WPF applications is that the UI controls have thread affinity, meaning<a id="id163" class="indexterm"></a> they can only be updated by the thread that created them. This is usually the main thread of the application.</p><p>The TPL, however, <a id="id164" class="indexterm"></a>offers a clean way to marshal the results from a TPL task to the correct thread for updating the UI. It accomplishes this with the <code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code> method which creates a <code class="literal">TaskScheduler</code> associated with the current <code class="literal">SyncronizationContext</code>.</p><p>In this recipe we are going to create a WPF application which will start a task to get the word count of a book. <a id="id165" class="indexterm"></a>The task will have a continuation that is created in the correct synchronization context by calling <code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code>. The continuation will perform the UI update.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec47"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a WPF application and see how we can use the TPL marshal data to the UI thread.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">Continuation8</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Open the <code class="literal">MainWindow.xaml.cs</code> file and ensure the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>Go back to <code class="literal">MainWindow.xaml</code> and replace the XAML with the following code to create the UI layout:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="Continuation8.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button Content="Get Word Count" 
            HorizontalAlignment="Left" 
            Margin="207,236,0,0" 
            VerticalAlignment="Top" 
            Width="96" 
            Click="Button_Click_1"/&gt;
        &lt;Label x:Name="lblWordCount" 
            Content="" 
            HorizontalAlignment="Left" 
            Margin="121,148,0,0" 
            VerticalAlignment="Top" 
            RenderTransformOrigin="0.094,0.923" 
            Width="278"/&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div><div class="mediaobject"><img src="graphics/0225OT_02_10.jpg" /></div></li><li><p>Now add a <code class="literal">Label</code> from<a id="id166" class="indexterm"></a> the toolbox to <a id="id167" class="indexterm"></a>your window. Change the <span class="strong"><strong>Name</strong></span> property to <code class="literal">lblWordCount</code> and remove the default value from the <span class="strong"><strong>Content</strong></span> property.</p><div class="mediaobject"><img src="graphics/0225OT_02_12.jpg" /></div></li><li><p>OK, now double click on the <span class="strong"><strong>Get Word Count</strong></span> button on your form to open up <code class="literal">Mai</code>
<code class="literal">nWindow.xaml.cs</code> in the <code class="literal">Button_Click_1</code> event handler. This is where we will create our task and continuation.</p></li><li><p>In the <code class="literal">Button_Click_1</code> event handler, create a <code class="literal">Task</code> that reads the content of a book into a <a id="id168" class="indexterm"></a>string array. The <code class="literal">Task</code> will return a string array result which will be used in a continuation to display the<a id="id169" class="indexterm"></a> word count to the UI. The <code class="literal">Task</code> will be continued with a continuation created with <code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code> called in the constructor:</p><div class="informalexample"><pre class="programlisting">private void Button_Click_1(object sender, RoutedEventArgs e)
{
    Task.Factory.StartNew(() =&gt;
    {
        char[] delimiters = {' ', ',', '.', ';', ':', '-', '_', '/', '\u000A'};
        var client = new WebClient();
        const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
        client.Headers.Add("user-agent", headerText);
        try
        {
            var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
            var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
            return wordArray;
        }
        finally
        {
            client.Dispose();
        }
    }).ContinueWith(antecedent =&gt;
    {
        lblWordCount.Content = String.Concat("Origin of Species word count: ",antecedent.Result.Count().ToString());
    }, TaskScheduler.FromCurrentSynchronizationContext());
}</pre></div></li><li><p>In Visual Studio 2012,<a id="id170" class="indexterm"></a> press <span class="emphasis"><em>F5</em></span> to run the project. Your application windows should look something as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_02_13.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec48"></a>How it worksâ€¦</h3></div></div></div><p>Tasks run on instances of the <code class="literal">TaskScheduler</code> class. Two implementations of <code class="literal">TaskScheduler</code> are<a id="id171" class="indexterm"></a> included as <a id="id172" class="indexterm"></a>part of the .NET Framework 4.5. One is the default scheduler, which is integrated with the .NET ThreadPool. The other is the type of <code class="literal">TaskScheduler</code> returned from the static method <code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code>.</p><p>
<code class="literal">SynchronizationContext</code> provides two methods, <code class="literal">Send</code> and <code class="literal">Post</code>, both of which accept a delegate to be executed. <code class="literal">Send</code> synchronously invokes the delegate, and <code class="literal">Post</code> asynchronously invokes the delegate.</p><p>UI controls should only be accessed by the thread that created them, usually the main UI thread. So, if a thread working in the background wants to update something in the UI, it needs to marshal that data back to the UI thread so that the controls can be accessed safely. In WPF, you would do this with the target thread's <code class="literal">Dispatcher</code> and corresponding <code class="literal">Invoke/BeginInvoke</code> methods<a id="id173" class="indexterm"></a>. With the .NET 4.5 TPL, a new type may be derived from <code class="literal">SynchronizationContext</code> such that its <code class="literal">Send</code> method synchronously marshals a delegate to the right thread for execution, and <code class="literal">Post</code> does the same but asynchronously.</p><p>UI frameworks like WPF publish<a id="id174" class="indexterm"></a> an instance of their <code class="literal">SynchronizationContext</code> derived class to <code class="literal">SynchronizationContext.Current</code>. Your code can then get <code class="literal">SynchronizationContext.Current</code> and use it to marshal work.</p><p>
<code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code> creates a <code class="literal">TaskScheduler</code> that wraps the <code class="literal">SynchronizationContext</code> returned from <code class="literal">SynchronizationContext.Current</code>. In doing so, this gives you a <code class="literal">TaskScheduler</code> that will execute <code class="literal">Tasks</code> on the current <code class="literal">SynchronizationContext</code>. This means you can create tasks that are able to access UI controls safely by running them on the right scheduler.</p><p>Since we can create<a id="id175" class="indexterm"></a> a <code class="literal">Task</code> or continuation with a derived <code class="literal">TaskScheduler</code>, we can create the continuation with a scheduler that will execute the continuation on the proper context to update the UI.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
}).ContinueWith(antecedent =&gt;
{
}, TaskScheduler.FromCurrentSynchronizationContext());</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch03"></a>ChapterÂ 3.Â Learning Concurrency with Parallel Loops</h2></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating a basic parallel for loop</p></li><li style="list-style-type: disc"><p>Creating a basic parallel foreach loop</p></li><li style="list-style-type: disc"><p>Breaking a parallel loop</p></li><li style="list-style-type: disc"><p>Stopping a parallel loop</p></li><li style="list-style-type: disc"><p>Cancelling a parallel loop</p></li><li style="list-style-type: disc"><p>Handling exceptions in a parallel loop</p></li><li style="list-style-type: disc"><p>Controlling the degree of parallelism in a loop</p></li><li style="list-style-type: disc"><p>Partitioning data in a parallel loop</p></li><li style="list-style-type: disc"><p>Using Thread Local Storage</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec28"></a>Introduction</h2></div></div><hr /></div><p>Most developers frequently write sequential code in the form of loops where they are doing something to each of the items in a collection of data. Loops are often an ideal place to introduce parallelism, because most of the time, the items in the collections are not related to each other, and we usually want to perform the same independent operation on all the items in a collection. However, parallelism comes with overhead. The individual loop iterations must perform enough work to justify the overhead of parallelism.</p><p>The <span class="strong"><strong>.NET 4.5 Parallel Extensions</strong></span>
<a id="id176" class="indexterm"></a> includes methods that simulate both parallel <code class="literal">For</code> and parallel <code class="literal">ForEach</code> loops, and both look very much like the loop syntax you already use for sequential loops. In fact, it is quite easy to change a sequential loop into a parallel loop which can complete faster on a computer with multiple cores.</p><p>In this chapter, we will be taking a look at how to use parallel <code class="literal">For</code> and parallel <code class="literal">ForEach</code> loops in your programs.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>Creating a basic parallel for loop</h2></div></div><hr /></div><p>In this recipe, we will take a look at<a id="id177" class="indexterm"></a> the syntax of a basic parallel <code class="literal">for</code> loop and compare its performance against a sequential <code class="literal">for</code> loop.</p><p>For our comparison we will create a console application with two methods. Both methods will loop over a very large array of numbers and use the <code class="literal">Math.Sqrt()</code> method to calculate the square root of each number in the array. One of our methods will use a sequential <code class="literal">for</code> loop to process the array, the other will use a parallel <code class="literal">for</code> loop.</p><p>Our program will time both operations and will display the results to the console when both loops finish.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec49"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's open up <a id="id178" class="indexterm"></a>Visual Studio and create some parallel loops. The steps for creating the parallel <code class="literal">for</code> loops are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ParallelFor</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's implement the <code class="literal">Main</code> method of the program class. We are going to create a <code class="literal">StopWatch</code> object to perform the timing, create a large array of random numbers, and then call the methods to run the loops.</p><div class="informalexample"><pre class="programlisting">var stopWatch = new Stopwatch();
var random = new Random();
var numberList numberArray = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next(1, 10000000)).ToArray();
stopWatch.Start();
SequentialLoop(numberArraynumberList.ToArray());
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for sequential loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

stopWatch.Reset();
stopWatch.Start();
ParallelLoop(numberArraynumberList.ToArray());
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for parallel loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
Console.ReadKey();</pre></div></li><li><p>Next let's create <a id="id179" class="indexterm"></a>our <code class="literal">SequentialLoop</code> method<a id="id180" class="indexterm"></a> which, as you might have guessed, executes a sequential <code class="literal">for</code> loop that calculates the square root of each number in the array.</p><div class="informalexample"><pre class="programlisting">private static void SequentialLoop(Int32[] array)
{
    for (var i = 0; i &lt; array.Length; i++)
    {
        var temp = Math.Sqrt(array[i]);
    }
}</pre></div></li><li><p>Now we just need to create our <code class="literal">ParallelLoop</code> method which uses a parallel <code class="literal">for</code> loop to calculate the square root of each number in the array.</p><div class="informalexample"><pre class="programlisting">private static void ParallelLoop(Int32[] array)
{
    Parallel.For(0, array.Length, i =&gt;
    {
        var temp = Math.Sqrt(array[i]);
    });
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_01.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec50"></a>How it worksâ€¦</h3></div></div></div><p>As you can see from<a id="id181" class="indexterm"></a> the preceding results, on my quad-core machine there were some performance improvements with the parallel loop, but not as much as you might have expected. It is possible that on your machine the sequential loop might have even outperformed the parallel loop. If this is the case, it probably means that the overhead of creating the threads and performing the context switches to execute the threads on the CPU outweighed the benefits of parallelizing the loop. As the chapter continues, we will look at how we can improve the performance of our loops a bit more. For now, we are just focusing on the basics of the parallel for loop syntax.</p><p>In this recipe, we used the basic overload of the static <code class="literal">For</code> method of the <code class="literal">Parallel</code> class to create our loop. At this level the syntax looks very much like that of a sequential for loop.</p><div class="informalexample"><pre class="programlisting">Parallel.For(int fromInclusive, int toExclusive, Action&lt;int&gt; body );</pre></div><p>The first two parameters forms the range the loop will iterate over. Note that <code class="literal">from</code> is an inclusive parameter and <code class="literal">to</code> is exclusive. So, if our first parameter is 0 and our second parameter is 10, our loop will iterate from 0 to 9.</p><p>The third parameter is a delegate of type <code class="literal">Action&lt;int&gt;</code> which always returns <code class="literal">void</code>. In this recipe, we use a Lambda expression for the delegate.</p><div class="informalexample"><pre class="programlisting">Parallel.For(0, array.Length, i =&gt;
{
    var temp = Math.Sqrt(array[i]);
});</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Creating a basic parallel foreach loop</h2></div></div><hr /></div><p>In this recipe we will take a look at the syntax of a basic parallel foreach loop and compare its performance against that of a sequential foreach loop.</p><p>For our comparison, like the previous recipe, we will create a Console Application with two methods which both loop over a very large array of numbers and use the <code class="literal">Math.Sqrt()</code> method<a id="id182" class="indexterm"></a> to calculate<a id="id183" class="indexterm"></a> the square root of each number in the array. One of our methods will use a sequential foreach loop to process the array, the other will use a parallel foreach loop.</p><p>Our program will time both operations and we will display the results to the console when both loops finish.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec51"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's go to Visual <a id="id184" class="indexterm"></a>Studio and see how to create parallel for loops. The steps to create parallel ForEach loops are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ParallelForEach</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start off by putting some code in the <code class="literal">Main</code> method of the program class to create a <code class="literal">StopWatch</code> object to perform the timing, create a large array of random numbers, and then call the two methods to run the loops.</p><div class="informalexample"><pre class="programlisting">var stopWatch = new Stopwatch();

var random = new Random()();
var numberList = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next(1, 10000000));
stopWatch.Start();
SequentialLoop(numberList);
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for sequential loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

stopWatch.Reset();
stopWatch.Start();
ParallelForLoop(numberList);
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for parallel loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
Console.ReadKey();</pre></div></li><li><p>Next we need<a id="id185" class="indexterm"></a> to create our <code class="literal">SequentialLoop</code> method<a id="id186" class="indexterm"></a> to execute a sequential <code class="literal">foreach</code> loop that calculates the square root of each number in the array.</p><div class="informalexample"><pre class="programlisting">private static void SequentialLoop(IEnumerable&lt;int&gt; numberList)
{
    foreach (var currentNumber in numberList)
    {
        var temp = Math.Sqrt(currentNumber);
    }
}</pre></div></li><li><p>Now let's create our <code class="literal">ParallelLoop</code> method which uses a parallel <code class="literal">ForEach</code> loop to calculate the square root of each number in the array.</p><div class="informalexample"><pre class="programlisting">private static void ParallelForLoop(IEnumerable&lt;int&gt; numberList)
{
    Parallel.ForEach(numberList, currentNumber =&gt;
    {
        var temp = Math.Sqrt(currentNumber);
    });
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec52"></a>How it worksâ€¦</h3></div></div></div><p>This time the <a id="id187" class="indexterm"></a>sequential loop outperformed the parallel loop by a bit, at least on my machine.</p><p>In this recipe, we used the basic overload of the static <code class="literal">ForEach</code> method of the <code class="literal">Parallel</code> class to create our loop:</p><div class="informalexample"><pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, Action&lt;TSource&gt;)</pre></div><p>Basically, this is just a source that implements <code class="literal">IEnumerable&lt;T&gt;</code> and a delegate. In our case we used a Lambda expression for the delegate.</p><div class="informalexample"><pre class="programlisting">Parallel.ForEach(numberList, currentNumber =&gt;
{
    var temp = Math.Sqrt(currentNumber);
});</pre></div><p>Other than the type of loop we used and the parameter types, the code in this project is very much like that of our parallel for loop recipe.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec31"></a>Breaking a parallel loop</h2></div></div><hr /></div><p>Occasionally when writing loops, <a id="id188" class="indexterm"></a>we will want to break out of the loop under certain conditions. In a sequential loop we would accomplish this breakout with a C# <code class="literal">break</code> statement. However, a break statement is only valid when enclosed within an iteration statement like a foreach loop. When we run a parallel foreach, we are not running an iteration statement. It is actually a delegate running in a method.</p><p>In this recipe we will we learn how to use a TPL class called <code class="literal">ParallelLoopState</code> to break out of a parallel<a id="id189" class="indexterm"></a> ForEach loop. <code class="literal">ParallelLoopState</code> is a class that allows concurrently running loop bodies to interact with each other. It also provides us with a way to break out of a loop. When the loop breaks or completes, we will check the completion status of our loop using the <code class="literal">ParallelLoopResult</code> structure.</p><p>We are going to create a Console Application to download the contents of a book and split the individual words into a list of strings. We will then loop through the list of strings looking for a specific word. When we find the word we are looking for, we will use <code class="literal">ParallelLoopState</code> to break out of the loop.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec53"></a>How to do itâ€¦</h3></div></div></div><p>Now let's take a look at how to cancel a parallel loop. The steps to cancel a parallel loop are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">BreakALoop</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's add some code to the <code class="literal">Main</code> method of our program class to use a <code class="literal">WebClient</code> to download the contents of the book and split the words of the book into a string array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
 var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
 var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).ToList();</pre></div></li><li><p>Next, let's create our loop. The loop needs to process the list of strings looking for the word "immutability". When we find it, use <code class="literal">ParallelLoopState.Break</code> to break out of the loop.</p><div class="informalexample"><pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord,  loopState) =&gt;
{
    if (currentWord.Equals("immutability"))
    {
        Console.WriteLine(currentWord);
        loopState.Break();
    }
});</pre></div></li><li><p>We will finish<a id="id190" class="indexterm"></a> adding a couple of lines to display the loop iteration we broke on, the completion status of the loop, and wait for the user to exit.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Loop LowestBreak Iteration : {0}", loopResult.LowestBreakIteration.ToString());
Console.WriteLine("Loop Completed : {0}", loopResult.IsCompleted.ToString());
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_03.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec54"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, we used a different overload of <code class="literal">Parallel.ForEach</code>. This overload takes an <code class="literal">Action</code> delegate with the source and a loop state parameter.</p><div class="informalexample"><pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, Action&lt;TSource, ParallelLoopState&gt;)</pre></div><p>In the body of our<a id="id191" class="indexterm"></a> loop, we used the loop state parameter to cancel the loop.</p><div class="informalexample"><pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord,  loopState) =&gt;
{
    if (currentWord.Equals("immutability"))
    {
        Console.WriteLine(currentWord);
        loopState.Break();
    }
});</pre></div><p>Note that we didn't instantiate the <code class="literal">ParallelLoopState</code> parameter that we passed into the loop. It was created and provided to us by the <code class="literal">Parallel</code> class. We just have to change our Lambda expression to indicate that we want to use the loop state parameter.</p><p>The <code class="literal">Parallel.ForEach</code> method<a id="id192" class="indexterm"></a> returns a <code class="literal">ParallelLoopResult</code> structure (<code class="literal">var loopResult</code>). This structure has a couple of very useful properties. One of which is <code class="literal">IsCompleted</code> that gets the loop completion status. A value of true indicates that all iterations of the loop were executed and the loop didn't receive a request to end prematurely. <code class="literal">LowestBreakIteration</code> gets the index of the lowest iteration from which <code class="literal">Break</code> was called.</p><p>There is an important difference between breaking from a parallel loop and a sequential loop. When breaking a sequential loop, the break statement will immediately terminate the loop. <code class="literal">ParallelLoopState.Break</code> has a different behavior. What we are actually doing is signaling that we would like the loop terminated at the system's earliest convenience. The issue is that we are not processing a single element at a time. If we call <code class="literal">ParallelLoopState.Break</code> in one of our threads, other threads are likely to still be executing. Some code will continue to run for a short time after you request to terminate the loop.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec32"></a>Stopping a parallel loop</h2></div></div><hr /></div><p>When you break from a parallel loop, the application will actually continue to process any elements of the collection that were found prior to the element that was being processed when the <code class="literal">ParallelLoopState.Break</code> method was called. Sometimes this behavior is not desirable <a id="id193" class="indexterm"></a>and we want to end the loop immediately, without processing any loop iterations that are currently running.</p><p>In this recipe, we will look at how to use the <code class="literal">ParallelLoopState.Stop</code> method to request that the processing of elements terminate as soon as possible without guaranteeing that any other elements will be processed. We will again be using <code class="literal">WebClient</code> to download the contents of a book, and splitting the words into a sorted list of strings. We will loop through the<a id="id194" class="indexterm"></a> list looking for the word "immutability". When we find it, we will stop the loop.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec55"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's start Visual Studio and see how to stop a parallel loop. The steps to stop a parallel loop are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">StopALoop</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's add some code to the <code class="literal">Main</code> method of our program class to use a <code class="literal">WebClient</code> to download the contents of the book, and split the words of the book into a string array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/','"','(',')', '\u000A' };
var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).Where(word =&gt; word.Length &gt; 5).ToList();
wordList.Sort();</pre></div></li><li><p>Next, let's create our loop. The loop needs to process the list of strings looking for the word "immutability". When we find it, use <code class="literal">ParallelLoopState.Stop</code> to stop the loop.</p><div class="informalexample"><pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord, loopState) =&gt;
{
    if (!currentWord.Equals("immutability"))
        Console.WriteLine(currentWord);
    else
    {
        loopState.Stop();
        Console.WriteLine(currentWord);
        Console.WriteLine("Loop stopped: {0}", loopState.IsStopped.ToString());
    }
});</pre></div></li><li><p>We will <a id="id195" class="indexterm"></a>finish adding a couple of lines to display the loops' completion status and wait for user's input to exit.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Loop Completed : {0}", loopResult.IsCompleted.ToString());
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec56"></a>How it worksâ€¦</h3></div></div></div><p>As in the previous<a id="id196" class="indexterm"></a> recipe, we used the overload of <code class="literal">Parallel.ForEach</code> that takes an <code class="literal">Action</code> delegate with the source and a loop state parameter.</p><div class="informalexample"><pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, Action&lt;TSource, ParallelLoopState&gt;)</pre></div><p>In the body of our loop, we used the loop state parameter to stop the loop. We also used the <code class="literal">ParallelLoopState.IsStopped</code> property<a id="id197" class="indexterm"></a> to display the status of our loop.</p><div class="informalexample"><pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord, loopState) =&gt;
{
    if (!currentWord.Equals("immutability"))
        Console.WriteLine(currentWord);
    else
    {
        loopState.Stop();
        Console.WriteLine(currentWord);
        Console.WriteLine("Loop stopped: {0}", loopState.IsStopped.ToString());
    }
});</pre></div><p>As you can see<a id="id198" class="indexterm"></a> from the preceding results, the elements of the list that were currently in process when we stopped the loop, still get written to the console. However, <code class="literal">ParallelLoopState.Stop</code> does stop the loop more quickly than <code class="literal">ParallelLoopState.Break</code> and is better to use in a situation where you are searching for an element of a condition in the collection.</p><p>Both <code class="literal">ParallelLoopState.Break</code> and <code class="literal">ParallelLoopState.Stop</code> behave differently from a break statement in a sequential loop. We are asking the application to process more than one thing at a time and we can no longer count on the sequence. It is easy to parallelize loops with the TPL, but it should be approached with caution because we can no longer rely on the order of the results.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec33"></a>Cancelling a parallel loop</h2></div></div><hr /></div><p>As we've seen in<a id="id199" class="indexterm"></a> previous recipes, to create a task that can be cancelled, you pass in a cancellation token from a <code class="literal">CancellationTokenSource</code> object. If you then make a call to the <code class="literal">CancellationTokenSource.Cancel</code> method, the token signals all of the tasks that use it should terminate. The linked tasks detect this signal via the token and stop their activity in a safe manner.</p><p>Parallel loops support the same cancellation token mechanism as parallel tasks. In a parallel loop, you supply the <code class="literal">CancellationToken</code> to the method in the <code class="literal">ParallelOptions</code> parameter.</p><p>This recipe will download the contents of a book and split the words into a list of strings. We will then use a parallel loop to iterate through the words writing each to the console. However, we will create a separate task that sleeps for a few seconds and then calls the <code class="literal">CancellationTokenSource.Cancel</code> method<a id="id200" class="indexterm"></a> which will cancel the loop.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec57"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a Console Application in Visual Studio so that we can see how to break a loop. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">BreakALoop</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the <a id="id201" class="indexterm"></a>following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method of the program class, let's create a <code class="literal">CancellationTokenSource</code> and then add the <code class="literal">CancellationToken</code> to a <code class="literal">ParallelOptions</code> object.</p><div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();
var options = new ParallelOptions
{
    CancellationToken = tokenSource.Token
};</pre></div></li><li><p>Next, just below the previous lines, create a simple task that sleeps for a few seconds and then calls the <code class="literal">Cancel</code> method on the <code class="literal">CancellationTokenSource</code>.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    Thread.Sleep(new TimeSpan(0,0,5));
    tokenSource.Cancel();
});</pre></div></li><li><p>Now create a <code class="literal">WebClient</code> to download the text of a book, and split the words from the book into a list of strings.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '"', '(', ')', '\u000A' };
var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
 var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).Where(word =&gt; word.Length &gt; 5).ToList();
wordList.Sort();</pre></div></li><li><p>Finally, let's create a simple parallel <code class="literal">foreach</code> loop that writes the strings to the console. The loop should be in a try/catch and we should be catching <code class="literal">OperationCancelledException</code> and <code class="literal">AggregateException</code>.</p><div class="informalexample"><pre class="programlisting">try
{
    var loopResult = Parallel.ForEach(wordList, options, (currentWord, loopState) =&gt; Console.WriteLine(currentWord));
    Console.WriteLine("Loop Completed : {0}", loopResult.IsCompleted.ToString());
}
catch (OperationCanceledException)
{
    Console.WriteLine("Operation Cancelled");
}
catch (AggregateException)
{
    Console.WriteLine("Operation Cancelled");
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012,<a id="id202" class="indexterm"></a> press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_05.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec58"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe we are using another overload of the <code class="literal">Parallel.ForEach</code> method that accepts an <code class="literal">IEnumerable</code> source, a <code class="literal">ParallelOptions</code> object, and an <code class="literal">Action</code> delegate.</p><div class="informalexample"><pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, ParallelOptions, Action&lt;TSource&gt;)</pre></div><p>The difference between cancelling a task and cancelling a parallel loop is how we pass in the <code class="literal">CancellationToken</code>. With a task, a <code class="literal">CancellationToken</code> is passed directly into the constructor of the task. For a parallel loop, we set the <code class="literal">CancellationToken</code> property of a <code class="literal">ParallelOptions</code>
<a id="id203" class="indexterm"></a> object with our <code class="literal">CancellationToken</code>, and then pass the <code class="literal">ParallelOptions</code> object into the parallel loop method.</p><p>If the token that signals the cancellation is the same token that is set on the <code class="literal">ParallelOptions</code> instance, then the parallel loop will throw an <code class="literal">OperationCanceledException</code> on cancellation. If a different token causes cancellation, the loop will throw an <code class="literal">AggregateException</code> with an <code class="literal">OperationCanceledException</code> as an <code class="literal">InnerException</code>. Both should be handled in your <code class="literal">catch</code> blocks.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec34"></a>Handling exceptions in a parallel loop</h2></div></div><hr /></div><p>When a sequential loop throws an <a id="id204" class="indexterm"></a>exception, the normal flow of the loop is interrupted. Control will be passed to a <code class="literal">catch</code> block or, if left unhandled, <a id="id205" class="indexterm"></a>the exception is passed to the .NET runtime, and the process is aborted.</p><p>Parallel <code class="literal">For</code> and <code class="literal">ForEach</code> loops are similar in that they do not have any special mechanism to handle exceptions that might be thrown. It is up to us to handle any exceptions which might be thrown on one or multiple threads by wrapping all exceptions from the loop in an <code class="literal">AggregateException</code>.</p><p>In this recipe, we will create a simple parallel <code class="literal">For</code> loop that loops through a range of numbers, writing the values to the console. If the number being processed is higher than a set number, we will throw a new <code class="literal">ArgumentException</code> which we will then store in a queue and later throw as part of an <code class="literal">AggregateException</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec59"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime exception is thrown, and intercepts the exception before it gets to our handler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</p></li><li><p>Uncheck the<a id="id206" class="indexterm"></a> <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_03_10.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec60"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look at <a id="id207" class="indexterm"></a>how to handle exceptions in parallel loops. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">LoopExceptions</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the program class, create a try/catch block. The <code class="literal">catch</code> block should have some code for looping through <code class="literal">AggregateException.InnerExceptions</code> and displaying the wrapped exception messages to the console.</p><div class="informalexample"><pre class="programlisting">try
{
    // Parallel for loop           
}
catch (AggregateException aggregate)
{
    // Loop through the exceptions and display to console
    foreach (var ex in aggregate.InnerExceptions)
    {
      Console.WriteLine("An exception was caught:  {0}",ex.InnerException.Message);
    }
}

// Wait for user input before exiting
Console.ReadLine();</pre></div></li><li><p>Inside the <a id="id208" class="indexterm"></a>
<code class="literal">try</code> block, define a variable of type <code class="literal">ConcurrentCollection&lt;Exception&gt;</code>. This will be the container to hold our exceptions until we are ready to wrap them in an <code class="literal">AggregateException</code>.</p><div class="informalexample"><pre class="programlisting">var exceptionQueue = new ConcurrentQueue&lt;Exception&gt;();</pre></div></li><li><p>Finally, <a id="id209" class="indexterm"></a>let's create a simple parallel <code class="literal">ForEach</code> loop that loops from 0 to 100. If the loop encounters a number greater than 95, it should throw an <code class="literal">ArgumentException</code>. The body of the loop needs a try/catch block to catch the argument exception to enqueue it.</p><div class="informalexample"><pre class="programlisting">Parallel.For(0, 100, number =&gt;
{
    try
    {
        if (number &gt; 95)
        {
          throw new ArgumentException(String.Format("The number {0} is invalid. Must be smaller than 95.",number.ToString()));
        }
        Console.WriteLine(number.ToString());
    }
    catch (Exception ex)
    {
        exceptionQueue.Enqueue(ex);  
    }
    if(exceptionQueue.Count &gt; 0)
        throw new AggregateException(exceptionQueue);
});</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec61"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, the <a id="id210" class="indexterm"></a>outer <code class="literal">catch</code> block handles <code class="literal">AggregateException</code> which can wrap many individual exception objects. Any one or all the actual<a id="id211" class="indexterm"></a> threads created by calling <code class="literal">Parallel.For</code> could throw an <code class="literal">AggregateException</code>. In our <code class="literal">catch</code> block, we need to loop through <code class="literal">AggregateException.InnerExceptions</code> to process individual exceptions that occurred.</p><div class="informalexample"><pre class="programlisting">catch (AggregateException aggregate)
{
    foreach (var ex in aggregate.InnerExceptions)
    {
      Console.WriteLine("An exception was caught: {0}",ex.InnerException.Message);
    }
}</pre></div><p>We have also created a try/catch block in the body of the parallel loop. This <code class="literal">catch</code> block catches any type of exception thrown in the loop and simply enqueues it in a <code class="literal">ConcurrentQueue&lt;Exception&gt;</code>. <code class="literal">ConcurrentQueue&lt;T&gt;</code> is a thread-safe first-in-first-out collection that implements <code class="literal">IEnumerable&lt;T&gt;</code>. <code class="literal">AggregateException</code> has a constructor overload that accepts <code class="literal">IEnumerable&lt;Exception&gt;</code>, so we can wrap our exception collection in <code class="literal">AggregateException</code> by passing the <code class="literal">ConcurrentCollection</code> to the constructor.</p><div class="informalexample"><pre class="programlisting">catch (Exception ex)
{
    exceptionQueue.Enqueue(ex);  
}
if(exceptionQueue.Count &gt; 0)
    throw new AggregateException(exceptionQueue);</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec35"></a>Controlling the degree of parallelism in a loop</h2></div></div><hr /></div><p>By default, <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> utilize as many threads as the underlying thread scheduler will provide. Usually it is good enough to let the system manage how iterations of a <a id="id212" class="indexterm"></a>parallel loop are mapped to your computer's cores. Sometimes, however, you might want more control over the maximum number of threads that are used. For example, if you know that an algorithm you are using won't <a id="id213" class="indexterm"></a>scale beyond a certain number of cores; you might want to limit the cores used in order to avoid wasting cycles.</p><p>The number of tasks created by <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> is often greater than the number of available cores. However, you can limit the maximum number of tasks used concurrently by specifying the <a id="id214" class="indexterm"></a>
<code class="literal">MaxDegreeOfParallelism</code> property of a <code class="literal">ParallelOptions</code> object.</p><p>In this recipe, we are going to create a large array of integers. We will then pass this array to a couple of parallel <code class="literal">For</code> loops. One loop will run with the default degree of parallelism, and the other will be limited to four threads. We will display the time it takes to run each loop to see if there is any performance difference between the two.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec62"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look at how we can control the degree of parallelism in a parallel loop. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">DegreeOfParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the program class, let's create a method named <code class="literal">DefaultParallelism</code> that takes an array of <code class="literal">Int32</code> as a parameter. The method calls <code class="literal">Parallel.For</code> and loops through the array calculating the square root of each element.</p><div class="informalexample"><pre class="programlisting">private static void DefaultParallelism(Int32[] array)
{
    Parallel.For(0, array.Length, i =&gt;
    {
        var temp = Math.Sqrt(array[i]);
    });
}</pre></div></li><li><p>Next, let's create another method named <code class="literal">LimitedParallelism</code> that takes the same type of <a id="id215" class="indexterm"></a>parameter. This method will also call <code class="literal">Parallel.For</code> and loop through the array calculating the<a id="id216" class="indexterm"></a> square root of each element. The only difference is that this method will also create a <code class="literal">ParallelOptions</code> object with the <code class="literal">MaxDegreeOfParallelism</code> property set to <code class="literal">4</code>.</p><div class="informalexample"><pre class="programlisting">private static void LimitedParallelism(Int32[] array)
{
    var options = new ParallelOptions()
    {
        MaxDegreeOfParallelism = 4
    };

    Parallel.For(0, array.Length, options, i =&gt;
    {
        var temp = Math.Sqrt(array[i]);
    });
}</pre></div></li><li><p>Finally, in the <code class="literal">Main</code> method, we need to create a large array of <code class="literal">Int32</code> and initialize the array elements to random numbers. We also need to set up a <code class="literal">StopWatch</code> object so we can capture some time and call the two methods.</p><div class="informalexample"><pre class="programlisting">static void Main()
{
    var stopWatch = new Stopwatch();

    var random = new Random();
    var numberList numberArray = Enumerable.Range(1, 1000000).OrderBy(i =&gt; random.Next(1, 1000000)).ToArray();

    stopWatch.Start();
    DefaultParallelism(numberListnumberArray.ToArray());
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for default parallelism: {0}", stopWatch.ElapsedMilliseconds.ToString());

    stopWatch.Reset();
    stopWatch.Start();
    LimitedParallelism(numberList.ToArray());
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for MaxDegreeOfParallelism: {0}", stopWatch.ElapsedMilliseconds.ToString());

    Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
    Console.ReadKey();
}</pre></div></li><li><p>In Visual <a id="id217" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar<a id="id218" class="indexterm"></a> to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec63"></a>How it worksâ€¦</h3></div></div></div><p>This recipe doesn't have an algorithm that benefits from controlling the degree of parallelism, but in certain long running loop bodies, the ThreadPool's heuristics will be unable to determine the right number of threads to utilize, and could end up injecting many more than is appropriate.</p><p>The degree of parallelism is controlled by creating a <code class="literal">ParallelOptions</code> object and setting the <code class="literal">MaxDegreeOfParallelism</code> property<a id="id219" class="indexterm"></a>.</p><div class="informalexample"><pre class="programlisting">var options = new ParallelOptions()
{
        MaxDegreeOfParallelism = 4
};</pre></div><p>Once created, the<a id="id220" class="indexterm"></a> <code class="literal">ParallelOptions</code> object can<a id="id221" class="indexterm"></a> be passed into one of the many overloads of <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> that accept <code class="literal">ParallelOptions</code>.</p><div class="informalexample"><pre class="programlisting">Parallel.For(0, array.Length, options, i =&gt;
{
    var temp = Math.Sqrt(array[i]);
});</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec36"></a>Partitioning data in a parallel loop</h2></div></div><hr /></div><p>When creating a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> loops, we are effectively queuing up a delegate of work that will eventually be run on a ThreadPool worker thread. The amount of<a id="id222" class="indexterm"></a> time taken to create and swap out these delegate payloads can have a very adverse effect on performance, especially when we create loops with small delegate bodies.</p><p>There is a default <code class="literal">Partitioner&lt;T&gt;</code> class that uses a default partitioning algorithm that takes into account the number of cores on your system and other factors, but default portioning may or may not yield the best results.</p><p>The .NET 4.5 Parallel Extensions also allows us to create our own custom partitioning chunks so that the workload of a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> is broken up into of a size that we specify in our code. We are effectively creating a custom partitioning algorithm.</p><p>In this recipe we are going to create three parallel loops that each iterate over a large array of integers. One of the loops will use no data partitioning, one will use the default partitioner, and one will use a custom partition. We will capture the time it takes each loop to iterate over the array and display the results.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec64"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how we can partition data for a parallel loop. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">PartitionData</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the program class, let's create a method called <code class="literal">NoPartitioning</code> that takes an array <a id="id223" class="indexterm"></a>of integers as a parameter. As the name indicates, this method will use no partitioning and will just iterate over the elements in the array calculating the square root of each element.</p><div class="informalexample"><pre class="programlisting">private static void NoPartitioning(Int32[] numbers)
{
    Parallel.ForEach(numbers, currentNumber =&gt;
    {
       var temp = Math.Sqrt(currentNumber);
    });
}</pre></div></li><li><p>Next, we need to create a method called <code class="literal">DefaultPartition</code>. Like the other method, this one will take an array of integers as its parameter and will iterate over the array calculating the square root of each element in the array. This method will use the <code class="literal">Partitioner.Create</code> method<a id="id224" class="indexterm"></a> to create a partition for the data.</p><div class="informalexample"><pre class="programlisting">private static void DefaultPartitioning(Int32[] numbers)
{
    var partitioner = Partitioner.Create(numbers);
    Parallel.ForEach(partitioner, currentNumber =&gt;
    {
        var temp = Math.Sqrt(currentNumber);
    });
}</pre></div></li><li><p>Now let's create a method called <code class="literal">CustomPartitioning</code>. This method will use a different overload of <code class="literal">Partitioner.Create</code> which allows us to specify the range size we want to use.</p><div class="informalexample"><pre class="programlisting">private static void CustomPartitioning(Int32[] numbers)
{
    var partitioner = Partitioner.Create(0, numbers.Count(), 100000);
    Parallel.ForEach(partitioner, range =&gt;
    {
        for (var index = range.Item1; index &lt; range.Item2; index++)
        {
            var temp = Math.Sqrt(numbers[index]);
        }
    });
}</pre></div></li><li><p>Finally, in the <code class="literal">Main</code> method<a id="id225" class="indexterm"></a>, we need to create a large array of <code class="literal">Int32</code> and initialize the array elements<a id="id226" class="indexterm"></a> to random numbers. We also need to set up a <code class="literal">StopWatch</code> object so we can capture some time and call the three methods.</p><div class="informalexample"><pre class="programlisting">static void Main()
{
    var stopWatch = new Stopwatch();

    var random = new Random();
    var numberArray = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next(1, 10000000)).ToArray();
    stopWatch.Start();
    NoPartitioning(numberArray);
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for no partitioning: {0}", stopWatch.ElapsedMilliseconds.ToString());

    stopWatch.Reset();
    stopWatch.Start();
    DefaultPartitioning(numberArray);
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for default partitioning: {0}", stopWatch.ElapsedMilliseconds.ToString());

    stopWatch.Reset();
    stopWatch.Start();
    CustomPartitioning(numberArray);
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for custom partitioning: {0}", stopWatch.ElapsedMilliseconds.ToString());

    Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
    Console.ReadKey();
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec65"></a>How it worksâ€¦</h3></div></div></div><p>As you can see from the <a id="id227" class="indexterm"></a>preceding screenshot, there was quite a performance improvement realized from using custom partitioning.</p><p>In this recipe, the <a id="id228" class="indexterm"></a>
<code class="literal">NoPartitioning</code> method iterates through the array performing the <code class="literal">Math.Sqrt</code> operation on each element with no partitioning of the array at all. The body of the loop is handed to the <code class="literal">Parallel.ForEach</code> method as a delegate, and the body of a parallel loop is so small that the cost of the delegate invocation on each loop's iteration is very significant. As a result, the performance is not very good.</p><p>In the <code class="literal">DefaultPartitioning</code> method<a id="id229" class="indexterm"></a>, we used one of the <code class="literal">Create</code> method overloads of the <code class="literal">Partitioner</code> class to create an <code class="literal">IEnumerable&lt;T&gt;</code> of range partitions over the source array. The benefit of doing this is that the delegate invocation cost is incurred only once per range, rather than once per element. As you can see, that resulted in a pretty nice performance improvement.</p><div class="informalexample"><pre class="programlisting">private static void DefaultPartitioning(Int32[] numbers)
{
    var partitioner = Partitioner.Create(numbers);
    Parallel.ForEach(partitioner, currentNumber =&gt;
    {
        var temp = Math.Sqrt(currentNumber);
    });
}</pre></div><p>In the <code class="literal">CustomPartitioning</code> method, <a id="id230" class="indexterm"></a>we use a different overload of <code class="literal">Partitioner.Create</code> to create a custom partition that chunks a range that we specified.</p><div class="informalexample"><pre class="programlisting">public static OrderablePartitioner&lt;Tuple&lt;int, int&gt;&gt; Create(
    int fromInclusive,
    int toExclusive,
    int rangeSize
)</pre></div><p>Basically we told the <a id="id231" class="indexterm"></a>partitioner to create a partition from 0 to <code class="literal">numbers.Count()</code> with a chunk size of 1,00,000. In other words, we partitioned the array into ten equal parts. The performance improvement was pretty substantial.</p><p>The key lesson here is that the overhead of delegate invocation, particularly in loops with small bodies, can be very significant. Consider using either the default partitioning scheme, or a custom chunk partitioner to improve the performance of your parallel loops.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec37"></a>Using Thread Local Storage</h2></div></div><hr /></div><p>Computers are pretty good at counting. Sometimes we need to create loops that accumulate a running count of the occurrence of some piece data. How would we manage something like that when using <code class="literal">Parallel.For</code> or <code class="literal">Parallel.Foreach</code> loops? We could have any number of threads counting at the same time.</p><p>What we need to accomplish<a id="id232" class="indexterm"></a> this is <span class="strong"><strong>Thread Local Storage</strong></span>. Thread Local Storage gives us the ability to store and retrieve states in each separate task that is created by a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> loop, and avoid the overhead of synchronizing accesses to a shared state variable.</p><p>Thread Local Storage is a programming method that uses static memory local to a thread. This is sometimes needed because normally all threads in a process share the same address space. In other words, data in a static or global variable is normally always located at the same memory location, when referred to from the same process. TLS variables are on the call and are local to threads, because each thread has its own stack.</p><p>In this recipe, we are going to see how we can use the thread-local variables to store the value of a word count in each thread created by <code class="literal">Parallel.ForEach</code> loop. After the loops finish, we will then write the final result only once to a shared variable.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec66"></a>How to do itâ€¦</h3></div></div></div><p>Ok, let's take a look <a id="id233" class="indexterm"></a>at how we can use the Thread Local Storage in our parallel loops. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ThreadLocalStorage</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's add <a id="id234" class="indexterm"></a>some code to the <code class="literal">Main</code> method of the program<a id="id235" class="indexterm"></a> class to use <code class="literal">WebClient</code> to download the text of a book, and split the words of the book into an array of strings. Also, we will create an <code class="literal">integer</code> variable which will hold our word count.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).ToList();

//word count total
Int32 total = 0;</pre></div></li><li><p>Next, let's create a parallel <code class="literal">ForEach</code> loop<a id="id236" class="indexterm"></a> that takes an array of <code class="literal">String</code>, has an <code class="literal">Int32</code> thread-local variable, and passes its <code class="literal">Int32</code> result to an <code class="literal">Interlocked.Add</code> method.<a id="id237" class="indexterm"></a>
</p><div class="informalexample"><pre class="programlisting">Parallel.ForEach&lt;String, Int32&gt;(wordList, () =&gt; 0, 
    (word, loopstate, count) =&gt;  // method invoked on each iteration of loop
    {
        if (word.Equals("species"))
        {
            count++; // increment the count
        }
        return count;
    },(result)=&gt;Interlocked.Add(ref total, result));
 // executed when all loops have completed</pre></div></li><li><p>Let's finish up by displaying the result and waiting for user input.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("The word species occured {0} times.",total.ToString());
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_03_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec67"></a>How it worksâ€¦</h3></div></div></div><p>Using a thread-local<a id="id238" class="indexterm"></a> variable in a parallel <code class="literal">ForEach</code> loop means that we have to use the <code class="literal">Parallel.ForEach</code> method overload that takes two type parameters and two function parameters. Our first parameter is the type of the elements in our source (<code class="literal">String</code>). The second parameter specifies the type of our thread-local variable (<code class="literal">Int32</code>). The third parameter is a <code class="literal">Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt;</code> delegate that is invoked on each loop iteration. The fourth parameter is an <code class="literal">Action&lt;T&gt;</code> delegate that the method will invoke when all loops are finished.</p><div class="informalexample"><pre class="programlisting">ForEach&lt;TSource, TLocal&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TLocal&gt;, Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt;, Action&lt;TLocal&gt;)</pre></div><p>In the body of our loop, the loop passes our input parameters to our function delegate. The parameters are the current element, a <a id="id239" class="indexterm"></a>
<code class="literal">ParallelLoopState</code> variable and the thread local variable.</p><div class="informalexample"><pre class="programlisting">(word, loopstate, count) =&gt;  // method invoked on each iteration of loop
{
if (word.Equals("species"))
{
   count++; // increment the count
}
return count;
}</pre></div><p>After the loop completes, we return our thread-local variable and it gets passed to the <code class="literal">Action&lt;T&gt;</code> delegate where <a id="id240" class="indexterm"></a>we add it to our shared state variable using <code class="literal">Interlocked.Add()</code>:</p><div class="informalexample"><pre class="programlisting">(result)=&gt;Interlocked.Add(ref total, result));</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch04"></a>ChapterÂ 4.Â Parallel LINQ</h2></div></div></div><p>In this chapter, we are going to cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating a basic parallel query</p></li><li style="list-style-type: disc"><p>Preserving order in parallel LINQ</p></li><li style="list-style-type: disc"><p>Forcing parallel execution</p></li><li style="list-style-type: disc"><p>Limiting parallelism in a query</p></li><li style="list-style-type: disc"><p>Processing query results</p></li><li style="list-style-type: disc"><p>Specifying merge options</p></li><li style="list-style-type: disc"><p>Range projection with parallel LINQ</p></li><li style="list-style-type: disc"><p>Handling exceptions in parallel LINQ</p></li><li style="list-style-type: disc"><p>Cancelling a parallel LINQ query</p></li><li style="list-style-type: disc"><p>Performing reduction operations</p></li><li style="list-style-type: disc"><p>Creating a custom partitioner</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec38"></a>Introduction</h2></div></div><hr /></div><p>
<span class="strong"><strong>Language Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>) offers<a id="id241" class="indexterm"></a> developers syntax for performing queries on collection of data. Using LINQ you can traverse, filter, sort, and return projected sets of items. When you use LINQ to objects, all of the items in your data collection are processed sequentially by a single thread.</p><p>Parallel LINQ is a <a id="id242" class="indexterm"></a>parallel implementation of LINQ to objects, which can turn your sequential queries into parallel queries, potentially improving performance.</p><p>Internally, parallel LINQ uses tasks queued to default <code class="literal">TaskScheduler</code> to extend the processing of the source collection's items across available processors, so that multiple items are processed concurrently.</p><p>In this chapter, we are going to see how parallel LINQ can potentially improve query performance<a id="id243" class="indexterm"></a> for large collections of items, or for long compute-bound processing of items.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec39"></a>Creating a basic parallel query</h2></div></div><hr /></div><p>In this recipe, we will take a look at creating a basic parallel query by using the <code class="literal">AsParallel</code> method<a id="id244" class="indexterm"></a> of the <code class="literal">System.Linq.ParallelEnumerable</code> class.</p><p>We are going to create a <a id="id245" class="indexterm"></a>
<code class="literal">Console</code> application that initializes a collection of employees, and then queries the employee collection looking for a specific job title.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec68"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's go to Visual<a id="id246" class="indexterm"></a> Studio and start creating some parallel LINQ queries.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">SimplePLINQ</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre></div></li><li><p>First, we need to create an <code class="literal">Employee</code> class just below the <code class="literal">Program</code> Class. Create an <code class="literal">Employee</code> class definition with <code class="literal">Id</code>, <code class="literal">Title</code>, <code class="literal">FirstName</code>, and <code class="literal">LastName</code> properties.</p><div class="informalexample"><pre class="programlisting">public class Employee
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create and initialize an array of <code class="literal">employees</code>.</p><div class="informalexample"><pre class="programlisting">var employees = newList&lt;Employee&gt;
{
  new Employee{Id=1, Title="Developer", FirstName="Mark", LastName="Smith"},
  new Employee{Id=2, Title="Director", FirstName="Kate", LastName="Williams"},
  new Employee{Id=3, Title="Manager", FirstName="Karen", LastName="Davis"},
  new Employee{Id=4, Title="Developer", FirstName="Maria", LastName="Santos"},
  new Employee{Id=5, Title="Developer", FirstName="Thomas", LastName="Arnold"},
  new Employee{Id=6, Title="Tester", FirstName="Marcus", LastName="Gomez"},
  new Employee{I =7, Title="IT Engineer", FirstName="Simon", LastName="Clark"},
  new Employee{Id=8, Title="Tester", FirstName="Karmen", LastName="Wright"},
  new Employee{Id=9, Title="Manager", FirstName="William", LastName="Jacobs"},
  new Employee{Id=10, Title="IT Engineer", FirstName="Sam", LastName="Orwell"},
  new Employee{Id=11, Title="Developer", FirstName="Tony", LastName="Meyers"},
  new Employee{Id=12, Title="Developer", FirstName="Karen", LastName="Smith"},
  new Employee{Id=13, Title="Tester", FirstName="Juan", LastName="Rodriguez"},
  new Employee{Id=14, Title="Developer", FirstName="Sanjay", LastName="Bhat"},
  new Employee{Id=15, Title="Manager", FirstName="Abid", LastName="Naseem"}
};</pre></div></li><li><p>Next, we will <a id="id247" class="indexterm"></a>create a parallel LINQ query that selects all employees where their title is <code class="literal">Developer</code>.</p><div class="informalexample"><pre class="programlisting">var results = from e in employees.AsParallel()
                where e.Title.Equals("Developer")
                select e;</pre></div><div class="informalexample"><pre class="programlisting">Finally, let's loop through the results and display them to the <code class="literal">Console</code>, then wait for user input to exit.
foreach (var employee in results)
{
    Console.WriteLine("Id:{0}  Title:{1}  First Name:{2}  Last Name:{3}",
        employee.Id, employee.Title, employee.FirstName, employee.LastName);
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_01.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec69"></a>How it worksâ€¦</h3></div></div></div><p>The small collection<a id="id248" class="indexterm"></a> of employees we created for this example is too small to benefit from parallelizing the query, but the key thing to notice in the example is the use of the <code class="literal">AsParallel extension</code> method<a id="id249" class="indexterm"></a> which binds the query to parallel LINQ, and specifies that the rest of the query should be parallelized if possible.</p><div class="informalexample"><pre class="programlisting">var results = from e in employees.AsParallel()
                where e.Title.Equals("Developer")
                select e;</pre></div><p>The <code class="literal">System.Linq.ParallelEnumerable</code> class<a id="id250" class="indexterm"></a> implements all of the parallel LINQ functionality, and exposes parallel versions of <code class="literal">Select</code>, <code class="literal">Single</code>, <code class="literal">Skip</code>, <code class="literal">OrderBy</code>, and so on. All of these methods are extension methods that extend <code class="literal">ParallelQuery&lt;TSource&gt;</code>. The <code class="literal">AsParallel</code> extension method converts your sequential query based on <code class="literal">IEnumerable&lt;T&gt;</code> to a parallel query based on <code class="literal">ParallelQuery&lt;T&gt;</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec40"></a>Preserving order in parallel LINQ</h2></div></div><hr /></div><p>By default, PLINQ <a id="id251" class="indexterm"></a>does not preserve the order out of a source collection. Because PLINQ processes items in a data collection concurrently using multiple threads, the items are returned unordered. This is by design, because maintaining the original ordering of a sequence adds overhead, and in most cases, that overhead may not be necessary.</p><p>However, when you need to preserve order, PLINQ provides a simple way to accomplish it. In this recipe, we are going to create a <code class="literal">Console</code> application that creates two collections of numbers, performs <a id="id252" class="indexterm"></a>an ordered query on one collection, and the default unordered query on the other collection, and looks at the results.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec70"></a>How to do itâ€¦</h3></div></div></div><p>Let's open up Visual Studio and see how to preserve order on parallel LINQ queries.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">PreserveOrder</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;</pre></div></li><li><p>Let's start off by creating a <code class="literal">UnorderedQuery</code> method<a id="id253" class="indexterm"></a> just below the <code class="literal">Main</code> method of the <code class="literal">Program</code> class. This method will query a large range of integers for numbers that are evenly divisible by 5, and will take the first 10 of those numbers as the result.</p><div class="informalexample"><pre class="programlisting">private static void UnorderedQuery(IEnumerable&lt;int&gt; source)
{
    Console.WriteLine("Unordered results");
    var query = (from numbers in source.AsParallel()
        where numbers%5 == 0
        select numbers).Take(10);

    foreach (var number in query)
        Console.WriteLine(number);
}</pre></div></li><li><p>Next we need to create our <code class="literal">OrderedQuery</code> method<a id="id254" class="indexterm"></a> which will perform the same query as the previous step, except it will use the <code class="literal">AsOrdered</code> extension method to preserve the original order.</p><div class="informalexample"><pre class="programlisting">private static void OrderedQuery(IEnumerable&lt;int&gt; source)
{
    Console.WriteLine("Ordered results");
    var query = (from numbers in source.AsParallel().AsOrdered()
        where numbers % 5 == 0
        select numbers).Take(10);

    foreach (var number in query)
        Console.WriteLine(number);
}</pre></div></li><li><p>Now let's add some code to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class to create your source lists of numbers and to call each of the methods.</p><div class="informalexample"><pre class="programlisting">var source1 = Enumerable.Range(1, 100000);
UnorderedQuery(source1);

Console.WriteLine();

var source2 = Enumerable.Range(1, 100000);
OrderedQuery(source2);

Console.ReadLine();</pre></div></li><li><p>In Visual <a id="id255" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_02.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec71"></a>How it worksâ€¦</h3></div></div></div><p>If you need to have parallel LINQ, preserve the order of items as they are processed, then you can call the <code class="literal">AsOrdered</code> method of the <code class="literal">ParallelEnumerable</code> class.</p><div class="informalexample"><pre class="programlisting">var query = (from numbers in source.AsParallel().AsOrdered()
        where numbers % 5 == 0
        select numbers).Take(10);</pre></div><p>When you call this method, the threads spawned for the query will process the items of a collection in groups,<a id="id256" class="indexterm"></a> then the groups are merged back together preserving order but hurting performance.</p><p>The operators <code class="literal">Distinct</code>, <code class="literal">Intersect</code>, <code class="literal">Union</code>, <code class="literal">Join</code>, <code class="literal">Except</code>, <code class="literal">GroupBy</code>, <code class="literal">GroupJoin</code>, and <code class="literal">ToLookup</code> produce unordered operations. If you need to enforce ordering after one of these operations, you just need to call the <code class="literal">AsOrdered</code> method.</p><p>Conversely, the operators <code class="literal">OrderBy</code>, <code class="literal">OrderByDescending</code>, <code class="literal">ThenBy</code>, and <code class="literal">ThenByDescending</code> produce ordered operations. If you need to go back to unordered processing and improve performance, PLINQ provides a <code class="literal">AsUnordered</code> method<a id="id257" class="indexterm"></a> you can call.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec41"></a>Forcing parallel execution</h2></div></div><hr /></div><p>Parallel LINQ looks for opportunities to parallelize a query, but not all queries run faster in parallel. For example, a <a id="id258" class="indexterm"></a>query that contains a single delegate that does only a little bit of work will usually run faster sequentially, because the overhead of parallelizing outweighs the benefits gained from parallelizing it.</p><p>For the most part, parallel LINQ does a really good job of determining what should be parallelized and what should run sequentially, based on its examination of the shape of the query. However, the algorithm it uses is not perfect, and you might need to instruct PLINQ to run your query in parallel.</p><p>In this recipe, we will build a <code class="literal">Console</code> application that creates a query which PLINQ will determine whether it needs to be executed sequentially. We will then force the query to run in parallel using the <code class="literal">WithExecutionMode</code> method<a id="id259" class="indexterm"></a>. Finally, we will capture the time it takes for both queries to run and compare the results.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec72"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how to force a PLINQ query to execute in parallel.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">ForceParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;</pre></div></li><li><p>First, let's create a method in your <code class="literal">Program</code> class called <code class="literal">NoForcedParallelism</code> that creates a PLINQ query with a small delegate of work that PLINQ will evaluate and determine what needs to be executed sequentially.</p><div class="informalexample"><pre class="programlisting">private static void NoForcedParallelism()
{
    Enumerable.Range(0, 1000).AsParallel()
                .Where(x =&gt;
                {
                    Thread.SpinWait(1000000);
                    return true;
                })
                .Select((x, i) =&gt; i)
                .ToArray();
}</pre></div></li><li><p>Next, let's create a method in the <code class="literal">Program</code> class called <code class="literal">ForcedParallism</code> which runs <a id="id260" class="indexterm"></a>the same query, but forces PLINQ to execute it in parallel by calling the <code class="literal">WithExecutionMode</code> method<a id="id261" class="indexterm"></a> and passing it a <code class="literal">ParallelExecutionMode.ForceParallelism</code> enumeration.</p><div class="informalexample"><pre class="programlisting">private static void ForcedParallelism()
{
    Enumerable.Range(0, 1000).AsParallel()
            .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
            .Where(x =&gt;
            {
                Thread.SpinWait(1000000);
                return true;
            })
            .Select((x, i) =&gt; i)
            .ToArray();
}</pre></div></li><li><p>We will finish up by adding some code to the <code class="literal">Main</code> method to create <code class="literal">stopWatch</code> to capture the timing of the two methods, then run the methods and compare the results.</p><div class="informalexample"><pre class="programlisting">private static void Main()
{
   var stopWatch = new Stopwatch();
   stopWatch.Start();
   NoForcedParallelism();
   stopWatch.Stop();
   Console.WriteLine("Query with no forced parallelism ran in {0} ms.",
		stopWatch.ElapsedMilliseconds);
   stopWatch.Reset();
   stopWatch.Start();
   ForcedParallelism();
   stopWatch.Stop();
   Console.WriteLine("Query with forced parallelism ran in {0} ms.", 
		stopWatch.ElapsedMilliseconds);
   Console.ReadLine();
}</pre></div></li><li><p>In Visual Studio<a id="id262" class="indexterm"></a> 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_03.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec73"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, we can see that PLINQ wrongly decided that the query would run faster sequentially. When we forced the query to run in parallel, the performance improvement was significant.</p><p>We instructed PLINQ not to fall back to sequential execution when it detects certain query shapes by calling the <code class="literal">WithExecutionMode</code> method<a id="id263" class="indexterm"></a> of <code class="literal">System.Linq.ParallelQuery</code>, and passing it <code class="literal">ParallelExecutionMode.ForceParallelism</code> enumeration value.</p><div class="informalexample"><pre class="programlisting">Enumerable.Range(0, 1000).AsParallel()
    <span class="strong"><strong>.WithExecutionMode(ParallelExecutionMode.ForceParallelism)</strong></span>
    .Where(x =&gt;
    {
        Thread.SpinWait(1000000);
        return true;
    })
    .Select((x, i) =&gt; i)
    .ToArray();</pre></div><p>Why did PLINQ determine that the query should be executed sequentially in the first place? It is mainly a <a id="id264" class="indexterm"></a>factor to determine the shape of the query which has a single delegate of work. It also has to do with this query using the <code class="literal">positional Select</code> operator. Positional-related operators may require <code class="literal">ForceParallelism</code> in PLINQ that includes <code class="literal">positional Select</code>, <code class="literal">positional Where</code>, <code class="literal">positional SelectMany</code>, <code class="literal">Take</code>, <code class="literal">Skip</code>, <code class="literal">TakeWhile</code>, and <code class="literal">SkipWhile</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec42"></a>Limiting parallelism in a query</h2></div></div><hr /></div><p>By default, parallel LINQ<a id="id265" class="indexterm"></a> will try to take advantage of all of the processor cores offered by your CPU. Usually, this is what you want. However, there could be situations where you want to limit the number of threads used to run queries<a id="id266" class="indexterm"></a> and keep some cores available for other work.</p><p>In this recipe, we are going to create a query that uses the <code class="literal">WithDegreeOfParallelism</code> method<a id="id267" class="indexterm"></a> to explicitly set the number of threads that a parallel query uses.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec74"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how to limit the degree of parallelism of a query.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">LimitParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;</pre></div></li><li><p>Let's add a PLINQ query to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class that works the processors. For now, we will use the <code class="literal">WithExecutionMode</code> method to force the query to run in parallel, but will not set a limit on the parallelization.</p><div class="informalexample"><pre class="programlisting">private static void Main()
{
       
    var result = Enumerable.Range(0, 10000).AsParallel()
        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
        .Where(x =&gt;
      {
                Thread.SpinWait(1000000);
                return true;
            })
        .Select((x, i) =&gt; i)
        .ToArray();

        foreach (var number in result)
            Console.WriteLine("Result: {0}",number);

        Console.ReadLine();
}</pre></div></li><li><p>If you have a multi-core <a id="id268" class="indexterm"></a>processor on your machine, start up the <span class="strong"><strong>Task Manager</strong></span>, click on the <span class="strong"><strong>Performance</strong></span> tab, and watch CPU <a id="id269" class="indexterm"></a>usage. In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see processor usage as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_04.png.jpg" /></div></li><li><p>Now let's edit the PLINQ query to call the <a id="id270" class="indexterm"></a>
<code class="literal">WithDegreeOfParallelism</code> method to limit the number of processor cores used. You might want to change the value you pass into the method to be a number<a id="id271" class="indexterm"></a> that is relevant to the number of processor cores available to you. You can specify a number greater than the number <a id="id272" class="indexterm"></a>of processor cores available on your machine, but this will likely lead to more context switching.</p><div class="informalexample"><pre class="programlisting">var result = Enumerable.Range(0, 10000).AsParallel()
        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
        .WithDegreeOfParallelism(2)
        .Where(x =&gt;
            {
                Thread.SpinWait(1000000);
                return true;
            })
        .Select((x, i) =&gt; i)
        .ToArray();                       </pre></div></li><li><p>Now start up the <span class="strong"><strong>Task Manager</strong></span> again, click on the <span class="strong"><strong>Performance</strong></span> tab, and watch CPU usage. In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see<a id="id273" class="indexterm"></a> reduced processor usage. Note that the threads <a id="id274" class="indexterm"></a>created will not necessarily spend all of their time on a single core, but the overall usage will go down.</p><div class="mediaobject"><img src="graphics/0225OT_04_05.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec75"></a>How it worksâ€¦</h3></div></div></div><p>The <code class="literal">WithDegreeOfParallelism</code> method<a id="id275" class="indexterm"></a> probably isn't something that you will use very often. You might want to use it in situations where you need to leave some CPU time available to perform other tasks. You could also pass a number that is greater than the number of cores on your machine, in cases where the query will be performing synchronous I/O, because the threads will be blocking.</p><p>Setting the degree of parallelism is simply a matter of calling the method and passing in the number<a id="id276" class="indexterm"></a> of threads <a id="id277" class="indexterm"></a> you want PLINQ to use.</p><div class="informalexample"><pre class="programlisting">var result = Enumerable.Range(0, 10000).AsParallel()
        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
<span class="strong"><strong>        .WithDegreeOfParallelism(2)</strong></span>
        â€¦
        .Select((x, i) =&gt; i)
        .ToArray();                       </pre></div><p>The default value of the <code class="literal">WithDegreeOfParallism</code> method is the processor count of your machine.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec43"></a>Processing query results</h2></div></div><hr /></div><p>One of the nice features of parallel LINQ is that it collates the results from a parallelized query into a single output sequence.<a id="id278" class="indexterm"></a> Often though, all your program does with the query's output data is run a function over each element using a <code class="literal">foreach</code> loop or similar. In such cases, particularly in cases where you don't care about the order in which elements are processed, you can improve performance by using the ParallelEnumerable's <code class="literal">ForAll</code> method to process the results in parallel.</p><p>In this recipe, we will perform a query on a range of numbers, and then use <code class="literal">ParallelForAll</code> to iterate over the results in parallel, calculating the square of each number.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec76"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's open up Visual Studio and see how to process the results of a parallel query.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">ProcessResults</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create a concurrent collection of integers to hold the result of our calculation, and generate a range of numbers for the query.</p><div class="informalexample"><pre class="programlisting">var result = new ConcurrentBag&lt;Int32&gt;();
var source = Enumerable.Range(1, 100000);</pre></div></li><li><p>Next, just below the previous lines, create a PLINQ query that queries the first 100 numbers that are evenly divisible by 5 out of the source range.</p><div class="informalexample"><pre class="programlisting">var query = (from numbers in source.AsParallel()
        where numbers % 5 == 0
        select numbers).Take(100);</pre></div></li><li><p>Now let's <a id="id279" class="indexterm"></a>call the <code class="literal">ParallelEnumerable.ForAll</code> method<a id="id280" class="indexterm"></a> to process our query results in parallel. We are just going to calculate the square of each number and add the result to our collection.</p><div class="informalexample"><pre class="programlisting">query.ForAll(r =&gt; 
    {
        result.Add(r * r);
    });</pre></div></li><li><p>Finally, let's loop through the collection and print the results to <code class="literal">Console</code>.</p><div class="informalexample"><pre class="programlisting">foreach (var value in result)
{
     Console.WriteLine("Result squared: {0}", value );
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_06.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec77"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, we are using <code class="literal">ParallelEnumerable.ForAll&lt;TSource&gt;</code> to iterate through and process the results of our query in parallel. The <code class="literal">ForAll</code> method runs a delegate over every output<a id="id281" class="indexterm"></a> element of a <code class="literal">ParallelQuery</code>.</p><div class="informalexample"><pre class="programlisting">query.ForAll(r =&gt; 
    {
        result.Add(r * r);
    });</pre></div><p>The <code class="literal">ForAll</code> method<a id="id282" class="indexterm"></a> hooks right into parallel LINQ's internals, bypassing the steps of collating, and enumerating the results which can save considerable processing time.</p><p>You might wonder why we used the <code class="literal">ForAll</code> method to calculate the square of our results and add them to the collection; just to use a sequential <code class="literal">foreach</code> loop to write the results to <code class="literal">Console</code>. Besides the obvious answer that this is just a simple example, you wouldn't want to write to <code class="literal">Console</code> inside a <code class="literal">ForAll</code> method<a id="id283" class="indexterm"></a> because .NET serializes all access to <code class="literal">Console</code>, and would force the whole thing to run sequentially.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec44"></a>Specifying merge options</h2></div></div><hr /></div><p>When parallel LINQ executes a query, it partitions the source data and assigns each partition to a separate thread. If the results are consumed by a single thread, such as a <code class="literal">foreach</code> loop, then the results from each partition must be merged back into one result set. The kind<a id="id284" class="indexterm"></a> of merge that is performed depends on the operators used in the query. For operators that produce ordered results, the results from all the threads are completely buffered before being merged back together. Your application's consuming thread might have to wait for a while before seeing the final result. If you don't care about order, or want to use a different buffering scheme to improve results, your query can use the <code class="literal">WithMergeOptions</code> extension method to provide a hint to PLINQ about how you would like the results to be buffered.</p><p>In this recipe, we will query some numbers out of a range, and loop through the results using a couple of different buffering options, and observe the effects.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec78"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look<a id="id285" class="indexterm"></a> at how to specify the merge option of a PLINQ query.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">MergeOptions</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;</pre></div></li><li><p>Let's start by creating our source number range in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class.</p><div class="informalexample"><pre class="programlisting">var numbers = ParallelEnumerable.Range(0, 1000);</pre></div></li><li><p>Now let's create a PLINQ query to select the numbers in the range that are evenly divisible <a id="id286" class="indexterm"></a>by 5, and use the <code class="literal">WithMergeOption</code> method to specify fully buffered merging of the results.</p><div class="informalexample"><pre class="programlisting">var result = numbers.AsParallel()
        .WithMergeOptions(ParallelMergeOptions.FullyBuffered)
        .Where(number =&gt; number % 5 == 0);</pre></div></li><li><p>Next, let's use a <code class="literal">foreach</code> loop to iterate through the results and print them to <code class="literal">Console</code>.</p><div class="informalexample"><pre class="programlisting">foreach (var number in result)
{
    Console.WriteLine("Result: {0}",number);
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the <span class="strong"><strong>Ordered Results</strong></span> shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_07.png.jpg" /></div></li><li><p>Now let's use the <code class="literal">WithMergeOption</code> method<a id="id287" class="indexterm"></a> to specify no buffering for the results.</p><div class="informalexample"><pre class="programlisting">var result = numbers.AsParallel()
        .WithMergeOptions(ParallelMergeOptions.NotBuffered)
        .Where(number =&gt; number % 5 == 0);</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the unordered results in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_08.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec79"></a>How it worksâ€¦</h3></div></div></div><p>The <code class="literal">WithMergeOptions</code> method<a id="id288" class="indexterm"></a> takes the <code class="literal">ParallelMergeOptions</code> enumeration as a parameter. You can specify one of the following options for how the query output is yielded and when the <a id="id289" class="indexterm"></a>results can be consumed:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Not Buffered</strong></span>: Each <a id="id290" class="indexterm"></a>processed element of the query is returned from each thread as soon as it is produced. If the <code class="literal">AsOrdered</code> operator is present, ordering is preserved, but if <code class="literal">AsOrdered</code> is not present, then the results are yielded as soon as they are available. This option yields the fastest results.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Auto Buffered</strong></span>: The elements<a id="id291" class="indexterm"></a> are collected into a buffer and periodically yielded to the consuming thread. This is a middle ground approach to buffering.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Fully Buffered</strong></span>: All of the elements<a id="id292" class="indexterm"></a> are collected in a buffer before any elements are yielded to the consuming thread.</p></li></ul></div><p>When you use <code class="literal">WithMergeOptions</code>, you are giving PLINQ a hint about the buffering scheme you want it to use. If a particular query cannot support the requested option, your request will be ignored.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec45"></a>Range projection with parallel LINQ</h2></div></div><hr /></div><p>While using sequential LINQ, it is very common to use range projection to obtain a range of values. Parallel LINQ <a id="id293" class="indexterm"></a>provides us with a way to do this too. If you need to generate a very large range of numbers which do not necessarily need to be in sequence, you can use the <code class="literal">Range</code> method of <code class="literal">ParallelEnumerable</code> to create the sequence.</p><p>In this short recipe, we will use <code class="literal">ParallelEnumerable.Range</code> to generate some numbers over a very large range.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec80"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's go to Visual Studio and see how to use parallel LINQ to generate a range of numbers.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">RangeProjection</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method, let's use <code class="literal">ParallelEnumerable.Range</code> to create a range of numbers between 1 and 1000 that are divisible by 5.</p><div class="informalexample"><pre class="programlisting">var numbers = ParallelEnumerable.Range(1, 1000)
        .Where(x =&gt; x % 5 != 0)
        .Select(i =&gt; i);</pre></div></li><li><p>Now let's just loop through the results to display them to the <code class="literal">Console</code> and wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">foreach (var number in numbers)
{
    Console.WriteLine("Result: {0}",number);
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_09.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec81"></a>How it worksâ€¦</h3></div></div></div><p>The code for this <a id="id294" class="indexterm"></a>recipe is fairly easy to understand. One important point to note is that the implicit cast to <code class="literal">ParallelQuery&lt;int&gt;</code> creates a parallel execution instead of a sequential one, and there is no particular ordering of the numbers in the result.</p><p>Of course, order can be preserved by calling <code class="literal">AsOrdered</code> on the query, but if ordering is important to you, just generate the range using sequential LINQ projection, and avoid the overhead of parallel execution.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec46"></a>Handling exceptions in parallel LINQ</h2></div></div><hr /></div><p>Handling exceptions<a id="id295" class="indexterm"></a> in parallel LINQ is not much different from handling exceptions in tasks, continuation, or anywhere else in your parallel code. You need to use <code class="literal">try</code>/<code class="literal">catch</code> and make sure to catch <code class="literal">AggregateException</code>. With parallel LINQ, the really important part is to use the try/catch around where you enumerate or use your results.</p><p>In this recipe, we are going to create a simple parallel LINQ query that returns a list of employees and throws <code class="literal">InvalidOperationException</code>, which we will handle when we iterate through the results.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec82"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears <a id="id296" class="indexterm"></a>whenever a runtime <code class="literal">Exception</code> is thrown, and intercepts the <code class="literal">Exception</code> before it gets to our handler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and click on <span class="strong"><strong>Exception</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_04_10.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec83"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at how to handle exceptions in a parallel LINQ query.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">HandleExceptions</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre></div></li><li><p>First, let's create an <code class="literal">Employee</code> class. Add the following class definition to your <code class="literal">Program.cs</code> file, just below the <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">public class Employee
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method <a id="id297" class="indexterm"></a>of the <code class="literal">Program</code> class, let's create and initialize an array of <code class="literal">employees</code>.</p><div class="informalexample"><pre class="programlisting">var employees = new[]
{
  new Employee{Id=1, Title="Developer", FirstName="Mark", LastName="Smith"},
  new Employee{Id=2, Title="Director", FirstName="Kate", LastName="Williams"},
  new Employee{Id=3, Title="Manager", FirstName="Karen", LastName="Davis"},
  new Employee{Id=4, Title="Developer", FirstName="Maria", LastName="Santos"},
  new Employee{Id=5, Title="Developer", FirstName="Thomas", LastName="Arnold"},
  new Employee{Id=6, Title="Tester", FirstName="Marcus", LastName="Gomez"},
  new Employee{I =7, Title="IT Engineer", FirstName="Simon", LastName="Clark"},
  new Employee{Id=8, Title="Tester", FirstName="Karmen", LastName="Wright"},
  new Employee{Id=9, Title="Manager", FirstName="William", LastName="Jacobs"},
  new Employee{Id=10, Title="IT Engineer", FirstName="Sam", LastName="Orwell"},
  new Employee{Id=11, Title="Developer", FirstName="Tony", LastName="Meyers"},
  new Employee{Id=12, Title="Developer", FirstName="Karen", LastName="Smith"},
  new Employee{Id=13, Title="Tester", FirstName="Juan", LastName="Rodriguez"},
  new Employee{Id=14, Title="Developer", FirstName="Sanjay", LastName="Bhat"},
  new Employee{Id=15, Title="Manager", FirstName="Abid", LastName="Naseem"}
  new Employee{Id=16, Title="Developer",FirstName="Kevin", LastName="Strong"}
};</pre></div></li><li><p>Next, create a PLINQ query that selects all employees and throws <code class="literal">InvalidOperationException</code> when it encounters an <code class="literal">employee Id</code> that is greater than <code class="literal">15</code>.</p><div class="informalexample"><pre class="programlisting">var results = employees.AsParallel()
    .Select(employee =&gt;
    {
    if (employee.Id &gt; 15)
    throw new InvalidOperationException("Invalid employee. Id &gt; 15.");
    return employee;
    });</pre></div></li><li><p>Finally, let's create a <code class="literal">try</code>/<code class="literal">catch</code> block. In the <code class="literal">try</code> block, create a <code class="literal">foreach</code> loop to iterate <a id="id298" class="indexterm"></a>through the results. In the <code class="literal">catch</code> block, you need to handle <code class="literal">AggregateException</code> and display the <code class="literal">Exception</code> to <code class="literal">Console</code>. Finish up by waiting for user input before exiting the program.</p><div class="informalexample"><pre class="programlisting">try
{
    foreach (var employee in results)
    {
        Console.WriteLine("Id:{0}  Title:{1}  First Name:{2}  Last Name:{3}",
            employee.Id, employee.Title, employee.FirstName, employee.LastName);
    }
}
catch (AggregateException aggregateException)
{
    foreach (var exception in aggregateException.InnerExceptions)
    {
        Console.WriteLine("The query threw an exception: {0}", exception.Message);
    }
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_11.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec84"></a>How it worksâ€¦</h3></div></div></div><p>As you can see, the steps for handling exceptions that occur in a parallel LINQ query are very consistent with <a id="id299" class="indexterm"></a>handling exceptions that occur in other parts of our parallel code. Any <code class="literal">Exception</code> that occurs will be added to the <code class="literal">InnerExceptions</code> collection of an <code class="literal">AggregateException</code>. So, we need to be ready to catch <code class="literal">AggregateException</code> and examine the individual <code class="literal">Exception</code> items in the <code class="literal">InnerExceptions</code> collection.</p><p>In this recipe, we just placed a <code class="literal">try</code>/<code class="literal">catch</code> block around the loop that iterates through our results, and handled <code class="literal">AggregateException</code> in the <code class="literal">catch</code> block.</p><div class="informalexample"><pre class="programlisting">try
{
    foreach (var employee in results)
    {
        ...
    }
}
catch (AggregateException aggregateException)
{
    foreach (var exception in aggregateException.InnerExceptions)
    {
        Console.WriteLine("The query threw an exception: {0}", exception.Message);
    }
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec47"></a>Cancelling a parallel LINQ query</h2></div></div><hr /></div><p>Like tasks and continuations, parallel LINQ queries are cancelled by using <code class="literal">CancellationToken</code> which <a id="id300" class="indexterm"></a>you obtain from <code class="literal">CancellationTokenSource</code>. A minor difference in cancelling a parallel LINQ query is in how you register a <code class="literal">CancellationToken</code> with the <code class="literal">WithCancellation(tokenSource.Token)</code> extension method.</p><p>In this recipe, we are going to create a cancellable parallel query that selects the square of numbers from a large range of random numbers. We are then going to create a separate task to cancel the query from.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec85"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime <code class="literal">Exception</code> is thrown and intercepts the <code class="literal">Exception</code> before it gets to our handler. </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exception</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_04_10.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec86"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at how to cancel a parallel LINQ query.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new <a id="id301" class="indexterm"></a>project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">CancelQuery</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's add some code to the <code class="literal">Main</code> method of the <code class="literal">Program</code> class to create our <code class="literal">CancellationTokenSource</code> object. We also need to initialize a large range of random numbers that will be the source for the query.</p><div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();
var random = new Random();
var numberList = ParallelEnumerable.Range(1, 100000).OrderBy(i =&gt; random.Next());</pre></div></li><li><p>Next, let's create a parallel LINQ query that uses the <code class="literal">WithCancellation </code>extension method to accept a cancellation token and uses the <code class="literal">Math.Pow</code> method to select the square of each number.</p><div class="informalexample"><pre class="programlisting">var results = numberList
    .AsParallel()
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .WithCancellation(tokenSource.Token)
    .Select(number =&gt; Math.Pow(number, 2));</pre></div></li><li><p>Now let's create a task that will sleep for 1 second to give the query time to start, and then it will call the <code class="literal">CancellationTokenSource.Cancel</code> method<a id="id302" class="indexterm"></a> to cancel the token.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    Thread.Sleep(1000);
    tokenSource.Cancel();
    Console.WriteLine("Cancelling query.");
});</pre></div></li><li><p>Finally, let's create a <code class="literal">try</code> block and a couple of <code class="literal">catch</code> blocks. The <code class="literal">try</code> block will just contain a <code class="literal">foreach</code> loop, to loop through the results of the query. The first <code class="literal">catch</code> block needs to catch <code class="literal">OperationCancelledException</code> and display a message to <code class="literal">Console</code>. The second <code class="literal">catch</code> block needs to catch <code class="literal">AggregateException</code> and display all <code class="literal">InnerException</code> messages to the <code class="literal">Console</code>. Lastly, let's wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">try
{
    foreach (var number in results)
    {
        Console.WriteLine("Result: {0}", number);
    }
}
catch (OperationCanceledException)
{
    Console.WriteLine("The operation was cancelled");
}
catch (AggregateException aggregateException)
{
    foreach (var exception in aggregateException.InnerExceptions)
    {
        Console.WriteLine("Handled exception: {0}",exception.Message);
    }
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012,<a id="id303" class="indexterm"></a> press <span class="emphasis"><em>F5</em></span> to run the project. You should see output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_12.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec87"></a>How it worksâ€¦</h3></div></div></div><p>We used two separate <code class="literal">catch</code> blocks in this recipe because the parallel LINQ framework does not roll <code class="literal">OperationCanceledExceptions</code> into <code class="literal">AggregateException</code>; the <code class="literal">OperationCanceledException</code> must be handled in a separate <code class="literal">catch</code> block or it will be left unhandled.</p><p>If you have one or more<a id="id304" class="indexterm"></a> delegates, throw <code class="literal">OperationCanceledException</code> by using <code class="literal">CancellationToken</code>, but don't throw any other exception. Then, parallel LINQ will just throw a single <code class="literal">OperationCanceledException</code> rather than <code class="literal">System.AggregateException</code>. However, if a delegate throws <code class="literal">OperationCanceledException</code> and another delegate throws another <code class="literal">Exception</code> type, then both exceptions will be rolled into <code class="literal">AggregateException</code>. So, whenever you create a PLINQ query using the <code class="literal">WithCancellation</code> extension method, it is recommended that you create two <code class="literal">catch</code> blocks: one for <code class="literal">OperationCancelledException</code> and one for <code class="literal">AggregateException</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec48"></a>Performing reduction operations</h2></div></div><hr /></div><p>Like sequential LINQ, parallel LINQ provides many common aggregation operations such as sum, average, min, <a id="id305" class="indexterm"></a>and max. It is pretty easy to perform aggregate operations by using one of LINQs extension methods.</p><p>Sometimes, however, we need to perform a custom aggregation of our source data, either because we need to perform a calculation that isn't provided in one of the standard aggregation extension methods, or because we need to apply custom logic to the calculation.</p><p>For such cases, parallel LINQ provides us with a <code class="literal">aggregate</code> method which can apply a custom accumulator function in parallel over a sequence of data.</p><p>In this recipe, we are going to create a custom aggregation operation that calculates the average of a large range of numbers.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec88"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how to perform custom aggregation with PLINQ.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">Average</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;</pre></div></li><li><p>First, let's add some code to the <code class="literal">Main</code> method to create a range of random numbers.</p><div class="informalexample"><pre class="programlisting">var random = new Random();
var numbers = ParallelEnumerable.Range(1, 1000).OrderBy(i =&gt; random.Next()).ToArray();</pre></div></li><li><p>Now let's create a PLINQ query that calls the <code class="literal">Aggregate</code> extension method of <code class="literal">ParallelEnumerable</code> passing delegate to calculate the average to the <code class="literal">intermediateReduceFunc</code>, <code class="literal">finalReduceFunc</code>, and <code class="literal">resultSelector</code> parameters. <a id="id306" class="indexterm"></a>Display the results to <code class="literal">Console</code> and wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">var result = numbers.AsParallel().Aggregate(() =&gt; new double[2],
    (accumulator, elem) =&gt; { accumulator[0] += elem; accumulator[1]++; return accumulator; },
    (accumulator1, accumulator2) =&gt; { accumulator1[0] += accumulator2[0]; accumulator1[1] += accumulator2[1]; return accumulator1; },
    accumulator =&gt; accumulator[0] / accumulator[1]);</pre></div></li><li><p>Finish up by displaying the results to the <code class="literal">Console</code> and waiting for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Result: {0}",result);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_13.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec89"></a>How it worksâ€¦</h3></div></div></div><p>An aggregation operation is an operation that iterates over a sequence of input data elements, maintaining <a id="id307" class="indexterm"></a>an accumulator that contains an intermediate result. At each step, a reduction function takes the current element and accumulator value as inputs, and yields a value that will overwrite the accumulator. The final accumulator value is the result of the computation.</p><p>The <code class="literal">ParallelEnumerable</code> class <a id="id308" class="indexterm"></a>provides several overloads of the <code class="literal">aggregate</code> extension method. We are using the following overload:</p><div class="informalexample"><pre class="programlisting">public static TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(
  this ParallelQuery&lt;TSource&gt; source,
  Func&lt;TAccumulate&gt; seedFactory,
  Func&lt;TAccumulate, TSource, TAccumulate&gt; updateAccumulatorFunc,
  Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; combineAccumulatorsFunc,
  Func&lt;TAccumulate, TResult&gt; resultSelector
)</pre></div><p>The <code class="literal">seedFactory</code> function<a id="id309" class="indexterm"></a> returns the initial accumulator value. The <code class="literal">updateAccumularorFunc</code> parameter is an <a id="id310" class="indexterm"></a>
<code class="literal">accumulator</code> function to be invoked on each element in a partition. The <code class="literal">combineAccumulatorsFunc</code> parameter is an <code class="literal">accumulator</code> function<a id="id311" class="indexterm"></a> to be invoked on the yielded accumulator result from each partition. Finally, the <code class="literal">resultSelector</code> parameter<a id="id312" class="indexterm"></a> is a function to transform the final accumulator value into the result value.</p><p>We have provided our own delegate for each of these function parameters.</p><div class="informalexample"><pre class="programlisting">numbers.AsParallel().Aggregate(() =&gt; new double[2], //Seed factory
    (accumulator, elem) =&gt;  //Update accumulator function
  { 
    accumulator[0] += elem; 
    accumulator[1]++; 
    return accumulator; 
  },
    (accumulator1, accumulator2) =&gt;  //Combine accumulator function
  { 
    accumulator1[0] += accumulator2[0]; 
    accumulator1[1] += accumulator2[1]; 
    return accumulator1; 
  },
    accumulator =&gt; accumulator[0] / accumulator[1]); //Result selector function</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec49"></a>Creating a custom partitioner</h2></div></div><hr /></div><p>To parallelize an operation on a data source, one of the essential steps is to partition the source into multiple sections that can be accessed concurrently by multiple threads. Parallel LINQ provides default partitioners that work quite well for most parallel queries. However, for more advanced<a id="id313" class="indexterm"></a> scenarios, you can also create your own partitioner.</p><p>For the recipe, we will create a custom static partitioner which will split our data source into a variable number of partitioned chunks. The exact number of partitions will be specified by TPL itself, and will be made available to our custom partitioner by overriding the <code class="literal">Partitioner&lt;T&gt;</code> method. We will then test the performance of a query that uses default partitioning against the performance of a query using our custom partitioner.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec90"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look <a id="id314" class="indexterm"></a>at how to partition data for a parallel query.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template, and assign <code class="literal">CustomPartitioner</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add a new class the project and name it <code class="literal">CustomPartitioner.cs</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">CustomPartitioner</code> class:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;
using System.Collections.Generic;</pre></div></li><li><p>Apply a generic type parameter to the <a id="id315" class="indexterm"></a>
<code class="literal">CustomPartitioner</code> class, and declare <code class="literal">Partitioner&lt;T&gt;</code> as its base class. Optionally, mark the class visibility as internal.</p><div class="informalexample"><pre class="programlisting">internal class CustomPartitioner&lt;T&gt; : Partitioner&lt;T&gt;
{

}</pre></div></li><li><p>Create a private source field of type array of <code class="literal">T</code> and initialize the source data with the <code class="literal">Class</code> constructor.</p><div class="informalexample"><pre class="programlisting">internal class CustomPartitioner&lt;T&gt; : Partitioner&lt;T&gt;
{
  private readonly T[] _source;

    // Class constructor. Initializes source data to array
  public CustomPartitioner(T[] sourceData)
    {
        _source = sourceData;
    }
}</pre></div></li><li><p>Override the <code class="literal">SupportsDynamicPartitions</code> property<a id="id316" class="indexterm"></a> of the base class to return <code class="literal">false</code>. This partitioner can only allocate partitions statically.</p><div class="informalexample"><pre class="programlisting">public override bool SupportsDynamicPartitions
{
    get
    {
        return false;
    }
}</pre></div></li><li><p>Add a <code class="literal">GetItems</code> method that returns <code class="literal">IEnumerator&lt;T&gt;</code> for the items in the source.</p><div class="informalexample"><pre class="programlisting">internal IEnumerator&lt;T&gt; GetItems(int start, int end)
{
    for (var index = start; index &lt; end; index++)
        yield return _source[index];
}</pre></div></li><li><p>Finish up<a id="id317" class="indexterm"></a> the <code class="literal">CustomPartitioner</code> class by overriding the <code class="literal">GetPartitions</code> method<a id="id318" class="indexterm"></a> of the base class. This method will return <code class="literal">List&lt;IEnumerable&lt;T&gt;&gt;</code> which is a list of our partitioned data.</p><div class="informalexample"><pre class="programlisting">public override IList&lt;IEnumerator&lt;T&gt;&gt; GetPartitions(int partitionCount)
{
    IList&lt;IEnumerator&lt;T&gt;&gt; partitionedData = new List&lt;IEnumerator&lt;T&gt;&gt;();
    var items = _source.Length / partitionCount;
    for (var index = 0; index &lt; partitionCount - 1; index++)
    {
        partitionedData.Add(GetItems(index * items, (index + 1) * items));
    }
    partitionedData.Add(GetItems((partitionCount - 1) * items, _source.Length));
    return partitionedData;
}</pre></div></li></ol></div><p>That's it for the <code class="literal">CustomPartitioner</code> class<a id="id319" class="indexterm"></a>. Now let's go to the <code class="literal">Program</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following <code class="literal">using</code> directives to the top of the class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class add some code to create a large array of <a id="id320" class="indexterm"></a>random numbers that we will use for the source of our query. Also, create a <code class="literal">stopWatch</code> object, which we will use to capture our performance numbers.</p><div class="informalexample"><pre class="programlisting">var stopWatch = new Stopwatch();
var random = new Random();
var source = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next()).ToArray();</pre></div></li><li><p>Next, let's start <code class="literal">stopWatch</code> and run a query against the source data to select the square of each number. This query uses default partitioning.</p><div class="informalexample"><pre class="programlisting">stopWatch.Start();
source.AsParallel()
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .Select(item =&gt; Math.Sqrt(item));
    stopWatch.Stop();
    Console.WriteLine("PLINQ with no partioner ran in {0} ticks", stopWatch.ElapsedTicks );</pre></div></li><li><p>Finally, let's reset <code class="literal">stopWatch</code>, run the query with our custom partitioner, display the results, and wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">var partitioner = new CustomPartitioner&lt;int&gt;(source);

stopWatch.Reset();
stopWatch.Start();

partitioner.AsParallel()
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .Select(item =&gt; Math.Sqrt(item));
            
stopWatch.Stop();
Console.WriteLine("PLINQ with custom partioner ran in {0} ticks", stopWatch.ElapsedTicks);

Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_04_14.png.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec91"></a>How it worksâ€¦</h3></div></div></div><p>In some cases, it might be worthwhile to create your own partitioner, but for the most part, the default partitioning <a id="id321" class="indexterm"></a>works pretty well.</p><p>To create a basic custom partitioner, derive a class from <code class="literal">Partitioner&lt;TSource&gt;</code> which is located in <code class="literal">System.Collections.Concurrent</code>, and override a couple of virtual methods and a virtual property getter.</p><p>We provided an override for the <a id="id322" class="indexterm"></a>
<code class="literal">SupportsDynamicPartitions</code> property to indicate that our simple custom partitioner only supports static partitions by returning <code class="literal">true</code>.</p><div class="informalexample"><pre class="programlisting">public override bool SupportsDynamicPartitions
{
    get
    {
        return false;
    }
}</pre></div><p>If we had indicated that this partitioner does support dynamic partitions, we would want to provide an override for the <code class="literal">GetDynamicPartitions</code> method<a id="id323" class="indexterm"></a>, which can be called instead of <code class="literal">GetPartitions</code> for dynamic partitioners.</p><p>In our case, we just had to provide an override for <code class="literal">GetPartitions</code>. This method returns <code class="literal">IList(IEnumerator(TSource))</code> which represents our actual partitioned data.</p><div class="informalexample"><pre class="programlisting">public override IList&lt;IEnumerator&lt;T&gt;&gt; GetPartitions(int partitionCount)
{
    IList&lt;IEnumerator&lt;T&gt;&gt; partitionedData = new List&lt;IEnumerator&lt;T&gt;&gt;();
    var items = _source.Length / partitionCount;
    for (var index = 0; index &lt; partitionCount - 1; index++)
    {
        partitionedData.Add(GetItems(index * items, (index + 1) * items));
    }
    partitionedData.Add(GetItems((partitionCount - 1) * items, _source.Length));
    return partitionedData;
}</pre></div><p>Lastly, we provided a <code class="literal">GetItems</code> method<a id="id324" class="indexterm"></a> which is a helper that <code class="literal">GetPartitions</code> uses to get an enumerator for the<a id="id325" class="indexterm"></a> items in our source data.</p><div class="informalexample"><pre class="programlisting">internal IEnumerator&lt;T&gt; GetItems(int start, int end)
{
    for (var index = start; index &lt; end; index++)
        yield return _source[index];
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch05"></a>ChapterÂ 5.Â Concurrent Collections</h2></div></div></div><p>In this chapter, we are going to cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Adding and removing items to <code class="literal">BlockingCollection</code>
</p></li><li style="list-style-type: disc"><p>Iterating a <code class="literal">BlockingCollection</code> with <code class="literal">GetConsumingEnumerable</code>
</p></li><li style="list-style-type: disc"><p>Performing LIFO operations with <code class="literal">ConcurrentStack</code>
</p></li><li style="list-style-type: disc"><p>Thread safe data lookups with <code class="literal">ConcurrentDictionary</code>
</p></li><li style="list-style-type: disc"><p>Cancelling an operation in a concurrent collection</p></li><li style="list-style-type: disc"><p>Working with multiple producers and consumers</p></li><li style="list-style-type: disc"><p>Creating object pool with <code class="literal">ConcurrentStack</code>
</p></li><li style="list-style-type: disc"><p>Adding blocking and bounding with <code class="literal">IProducerConsumerCollection</code>
</p></li><li style="list-style-type: disc"><p>Using multiple concurrent collections to create a pipeline</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec50"></a>Introduction</h2></div></div><hr /></div><p>Although<a id="id326" class="indexterm"></a> <code class="literal">System.Collections</code> namespace offers a wide range of collections; the only thing which limits our use of them in a multi-threaded or parallel environment is that they are not thread safe. A non thread safe collection could lead to race conditions, which is a condition that occurs when two or more threads can access shared data and try to change it at the same time, producing unexpected errors.</p><p>Concurrent collections in .NET Framework 4.5 allow the developers to create type safe as well as thread safe collections. These collection classes form an essential part of the parallel programming feature and are available under the namespace <a id="id327" class="indexterm"></a>
<code class="literal">System.Collections.Concurrent</code>.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec51"></a>Adding and removing items to BlockingCollection</h2></div></div><hr /></div><p>
<code class="literal">BlockingCollection&lt;T&gt;</code> is a thread safe collection class that provides blocking and bounding functionality. Bounding means that you can set the maximum capacity of a collection, which enables you to control the maximum size of the collection in the memory.</p><p>Multiple threads can add items<a id="id328" class="indexterm"></a> to a collection concurrently, but if the collection reaches capacity, the producing threads will block until items are removed. Multiple<a id="id329" class="indexterm"></a> consumers can remove items from the collection concurrently. If the collection becomes empty, consumption will block until more items are produced and added to the collection.</p><p>In this recipe,<a id="id330" class="indexterm"></a> we will take a look at the basics of adding<a id="id331" class="indexterm"></a> items to, and removing items from <code class="literal">BlockingCollection</code>.</p><p>We are going to create a <code class="literal">Console</code> application that initializes a range of integers and creates a parallel task to add the numbers to a blocking collection. Another parallel task will be created to remove items from the collection.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec92"></a>How to do itâ€¦</h3></div></div></div><p>Let's start Visual Studio and see how to add and remove items with <code class="literal">BlockingCollection</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">BlockingCollection</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create our range of input data and our blocking collection.</p><div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
var numbers = new BlockingCollection&lt;int&gt;(100);</pre></div></li><li><p>Now let's create simple producer <code class="literal">Task</code> which will use a <code class="literal">for</code> loop to iterate through the numbers of our source data and add them to the blocking collection. After we are finished with the loop, use the <code class="literal">CompleteAdding</code> method of <code class="literal">BlockingCollection</code> to indicate we are done producing data.</p><div class="informalexample"><pre class="programlisting">// A simple blocking producer 
Task.Factory.StartNew( ()=&gt;
{
    foreach (var item in data)
    {
        numbers.Add(item);
        Console.WriteLine("Adding:{0} Item Count={1}", item, numbers.Count);
    }
    numbers.CompleteAdding();
});</pre></div></li><li><p>Next, let's create<a id="id332" class="indexterm"></a> a simple consumer <code class="literal">Task</code> that uses a <code class="literal">while</code> loop to take items from <code class="literal">BlockingCollection</code> and<a id="id333" class="indexterm"></a> write the output to <code class="literal">Console</code>. Finish up by waiting for user input before exiting.</p><div class="informalexample"><pre class="programlisting">// A simple blocking consumer.
Task.Factory.StartNew(() =&gt;
{
        int item = -1;
        while (!numbers.IsCompleted)
        {
            try
            {
                item = numbers.Take();
            }
            catch (InvalidOperationException)
            {
                Console.WriteLine("Nothing to take");
                break;
            }
            Console.WriteLine("Taking:{0} ", item);
            // wait for a bit
             Thread.SpinWait(1000);
    }

    Console.WriteLine("\rNo more items to take.");
});

Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_01.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec93"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, we see how<a id="id334" class="indexterm"></a> to add items to and remove items from <code class="literal">BlockingCollection</code>. <code class="literal">BlockingCollection</code> is actually a wrapper for <code class="literal">IProducerConsumer&lt;T&gt;</code>, and provides the blocking and bounding capabilities for thread safe <a id="id335" class="indexterm"></a>collections. <code class="literal">BlockingCollection</code> takes <code class="literal">IProducerConsumerCollection</code> in its constructor, or uses <code class="literal">ConcurrentQueue</code> by default.</p><p>Adding the source data to the collection was easy enough. We just had to loop through the source data and call the <code class="literal">Add</code> method of <code class="literal">BlockingCollection</code> to add the item. When we are finished adding items to the collection, we call the <code class="literal">CompleteAdding</code> method. After a collection has been marked as complete for adding, no more adding will be permitted, and threads removing items from the collection will not wait when the collection is empty.</p><div class="informalexample"><pre class="programlisting">foreach (var item in data)
{
    numbers.Add(item);
    Console.WriteLine("Adding:{0} Item Count={1}", item, numbers.Count);
}
numbers.CompleteAdding();</pre></div><p>Consumer <code class="literal">Task</code> uses the <code class="literal">IsCompleted</code> property of <code class="literal">BlockingCollection</code> to control a <code class="literal">while</code> loop. The <code class="literal">IsCompleted</code> property, as you would expect, indicates if <code class="literal">BlockingCollection</code> has been marked as complete for adding, and is empty. Inside the <code class="literal">while</code> loop, we just use <a id="id336" class="indexterm"></a>the <code class="literal">Take</code> method to take an item from the <a id="id337" class="indexterm"></a>collection and display it on the <code class="literal">Console</code> application.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    while (!numbers.IsCompleted)
    {
        try
        {
            item = numbers.Take();
        }
        catch (InvalidOperationException)
        {
            Console.WriteLine("Nothing to take");
            break;
        }
    ...
    }
Console.WriteLine("\rNo more items to take.");
});</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec52"></a>Iterating a BlockingCollection with GetConsumingEnumerable</h2></div></div><hr /></div><p>
<code class="literal">BlockingCollection</code> provides us with an easier alternative for looping through a collection, and removing items without setting up a <code class="literal">while</code> loop, and checking the <code class="literal">IsCompleted</code> property. <code class="literal">BlockingCollection</code> gives us the ability to do a simple <code class="literal">foreach</code> loop with the <code class="literal">GetConsumingEnumerable</code> method.</p><p>In this recipe, we <a id="id338" class="indexterm"></a>are going to create a <code class="literal">Console</code> application that initializes a range of source data and spins up a producer task to <a id="id339" class="indexterm"></a>add the data to the collection. The consumer of the collection data will use the <code class="literal">GetConsumingEnumerable</code> method to get <code class="literal">IEnumerable&lt;T&gt;</code> for items in the collection.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec94"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look at how to iterate over a <code class="literal">BlockingCollection</code> with <code class="literal">GetConsumingEnumerable</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Enumerate</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create our range of input data and our blocking collection.</p><div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
var numbers = new BlockingCollection&lt;int&gt;(100);</pre></div></li><li><p>Next<a id="id340" class="indexterm"></a> let's create a simple producer <code class="literal">Task</code> which will use a <code class="literal">for</code> loop to iterate through <a id="id341" class="indexterm"></a>the numbers of our source data and add them to the blocking collection.</p><div class="informalexample"><pre class="programlisting">// A simple blocking producer 
Task.Factory.StartNew( ()=&gt;
{
    foreach (var item in data)
    {
        numbers.Add(item);
        Console.WriteLine("Adding:{0} Item Count={1}", item, numbers.Count);
    }
    numbers.CompleteAdding();
});</pre></div></li><li><p>Finally, let's create a consumer <code class="literal">Task</code> which will iterate through the collection with a <code class="literal">foreach</code> loop by calling the <code class="literal">GetConsumingEnumerable</code> method of blocking collection. Finish up by waiting for user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var item in numbers.GetConsumingEnumerable())
    {                        
        Console.Write("\nConsuming item: {0}", item);                       
    }                    
});
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec95"></a>How it worksâ€¦</h3></div></div></div><p>Producer <code class="literal">Task</code> in this recipe is exactly the same as producer <code class="literal">Task</code> created in the first recipe. <a id="id342" class="indexterm"></a> The only real change to take note<a id="id343" class="indexterm"></a> of is that we no longer have to set up a <code class="literal">while</code> loop to take items from the collection, as we did in the first recipe.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    while (!numbers.IsCompleted)
    {
        try
        {
            item = numbers.Take();
        }
        catch (InvalidOperationException)
        {
            Console.WriteLine("Nothing to take");
            break;
        }
    ...
    }
Console.WriteLine("\rNo more items to take.");
});</pre></div><p>By calling<a id="id344" class="indexterm"></a> the <code class="literal">GetConsumingEnumerable</code> method of <code class="literal">BlockingCollection</code>, we can now use much cleaner<a id="id345" class="indexterm"></a> <code class="literal">foreach</code> loop syntax.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var item in result.GetConsumingEnumerable())
    {                        
        Console.Write("\nConsuming item: {0}", item);                       
    }                    
});
Console.ReadLine();</pre></div><p>The<a id="id346" class="indexterm"></a> <code class="literal">GetConsumingEnumerable</code> method takes a snapshot of the current state of the underlying collection and returns <code class="literal">IEnumerable&lt;T&gt;</code> for the collection items.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec53"></a>Performing LIFO operations with ConcurrentStack</h2></div></div><hr /></div><p>
<code class="literal">ConcurrentStack</code> is the thread safe counterpart of <code class="literal">Systems.Collections.Generic.Stack</code>, which is the standard <span class="strong"><strong>Last-In-First-Out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) container in the .NET Framework. For algorithms that favor stack usage such as depth-first searches, a<a id="id347" class="indexterm"></a> thread safe stack is a big benefit.</p><p>In this recipe we are <a id="id348" class="indexterm"></a>going to take a look at the basic usage of <code class="literal">ConcurrentStack</code>. Our <code class="literal">Console</code> application for this recipe will initialize a range of data, which a simple producer <code class="literal">Task</code> will push onto the stack. Consumer <code class="literal">Task</code> will concurrently pop items from the stack and write them to <code class="literal">Console</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec96"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at performing LIFO operations with <code class="literal">ConcurrentStack</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start<a id="id349" class="indexterm"></a> a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ConcurrentStack</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the<a id="id350" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create our range of input data and our blocking collection.</p><div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
ConcurrentStack&lt;int&gt; stack = new ConcurrentStack&lt;int&gt;();</pre></div></li><li><p>Next, let's create a simple producer task which will use a <code class="literal">for</code> loop to iterate through the numbers of our source data and pop them onto the stack.</p><div class="informalexample"><pre class="programlisting">// producer 
Task.Factory.StartNew(() =&gt;
{
    foreach (var item in data)
    {
        stack.Push(item);
        Console.WriteLine("Pushing item onto stack:{0} Item Count={1}", 
      item, stack.Count);
    }
});</pre></div></li><li><p>Now let's create a consumer <code class="literal">Task</code> which will use a <code class="literal">while</code> loop to pop items off the stack while the <code class="literal">IsEmpty</code> property of the stack is false. Finish by waiting for user input before exiting.</p><div class="informalexample"><pre class="programlisting">//consumer
Task.Factory.StartNew(() =&gt;
{
    Thread.SpinWait(1000000);
    while (!stack.IsEmpty)
    {
        int result = 0;
        stack.TryPop(out result);
        Console.WriteLine("Popping item from stack:{0} Item Count={1}", 
      result, stack.Count);
    }
});
Console.ReadLine();</pre></div></li><li><p>In Visual <a id="id351" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to <a id="id352" class="indexterm"></a>run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_03.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec97"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">ConcurrentStack</code> achieves thread safe access by using the <code class="literal">System.Threading.Interlocked</code> operations. Interlocked operations provide a simple mechanism for synchronizing access to variables shared by multiple threads. Interlocked operations are also very fast.</p><p>For the most part, <code class="literal">ConcurrentStack</code> behaves like <code class="literal">System.Collections.Generic.Stack</code>. To push an item onto the stack, you just use the <code class="literal">Push</code> method.</p><div class="informalexample"><pre class="programlisting">foreach (var item in data)
{
    stack.Push(item);
    Console.WriteLine("Pushing item onto stack:{0} Item Count={1}", 
    item, stack.Count);
}</pre></div><p>However, the <code class="literal">Pop</code>
<a id="id353" class="indexterm"></a> method was<a id="id354" class="indexterm"></a> removed in favor of <code class="literal">TryPop</code>. <code class="literal">TryPop</code> returns <code class="literal">true</code> if an item existed and was popped, otherwise it returns <code class="literal">false</code>. The <code class="literal">out</code> parameter contains the object removed if the pop was successful, otherwise it is indeterminate.</p><div class="informalexample"><pre class="programlisting">while (!stack.IsEmpty)
{
    int result = 0;
    stack.TryPop(out result);
    Console.WriteLine("Popping item from stack:{0} Item Count={1}", 
    result, stack.Count);
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec54"></a>Thread safe data lookups with ConcurrentDictionary</h2></div></div><hr /></div><p>
<code class="literal">ConcurrentDictionary</code> is the thread safe counterpart to the generic <code class="literal">dictionary</code> collection. Both are designed for quick lookups of data based on a key. However, <code class="literal">ConcurrentDictionary</code> allows us to interleave both reads and updates. <code class="literal">ConcurrentDictionary</code> <a id="id355" class="indexterm"></a>achieves its thread safety with no common lock to improve efficiency. It actually uses a series of locks to provide concurrent updates, and has lockless reads.</p><p>In this recipe, we will create <a id="id356" class="indexterm"></a>
<code class="literal">ConcurrentDictionary</code> and initialize it with a small set of key value pairs. Our <code class="literal">dictionary</code> will be concurrently updated by one task and read by another.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec98"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look at how to use <code class="literal">ConcurrentDictionary</code> for data lookups.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ConcurrentDictionary</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's <a id="id357" class="indexterm"></a>create <a id="id358" class="indexterm"></a>our <code class="literal">ConcurrentDictionary</code> and initialize it with some data.</p><div class="informalexample"><pre class="programlisting">var dictionary = new ConcurrentDictionary&lt;string, int&gt;();
dictionary["A"] = 1;
dictionary["B"] = 2;
dictionary["C"] = 3;
dictionary["D"] = 4;
dictionary["E"] = 5;
dictionary["F"] = 6;
dictionary["G"] = 7;
dictionary["H"] = 8;
dictionary["I"] = 9;
dictionary["J"] = 10;
dictionary["K"] = 11;
dictionary["L"] = 12;
dictionary["M"] = 13;
dictionary["N"] = 14;
dictionary["O"] = 15;</pre></div></li><li><p>Now let's create <code class="literal">Task</code> to update <code class="literal">dictionary</code> on a separate thread.</p><div class="informalexample"><pre class="programlisting">// update dictionary on a separate thread
Task.Factory.StartNew(() =&gt;
{
    foreach (var pair in dictionary)
    {
        var newValue = pair.Value + 1;
        dictionary.TryUpdate(pair.Key,newValue,pair.Value);
        Console.WriteLine("Updated key: {0} value:{1}", pair.Key, newValue);
    }   
});</pre></div></li><li><p>Now let's create another <code class="literal">Task</code> which will be concurrently reading from <code class="literal">dictionary</code>.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var pair in dictionary)
    {
        Console.WriteLine("Reading key: {0} value:{1}",pair.Key,pair.Value);
    }
});            

Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec99"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">ConcurrentDictionary</code> behaves like <code class="literal">dictionary</code> counterpart with slight differences. We are updating <code class="literal">dictionary</code> using the <code class="literal">TryUpdate</code> method. This method was added to provide us with <a id="id359" class="indexterm"></a>an atomic operation to check if the item exists, and if not, add it while still under an atomic lock.</p><div class="informalexample"><pre class="programlisting">foreach (var pair in dictionary)
    {
        var newValue = pair.Value + 1;
        dictionary.TryUpdate(pair.Key,newValue,pair.Value);
        Console.WriteLine("Updated key: {0} value:{1}", pair.Key, newValue);
    }</pre></div><p>We are reading <code class="literal">dictionary</code> directly from the <code class="literal">Key</code> and <code class="literal">Value</code> properties of each <code class="literal">KeyValuePair</code> in the<a id="id360" class="indexterm"></a> collection.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec55"></a>Cancelling an operation in a concurrent collection</h2></div></div><hr /></div><p>When working with <code class="literal">BlockingCollection</code>, most <code class="literal">Add</code> and <code class="literal">Take</code> operations are performed in a loop.<a id="id361" class="indexterm"></a> The <code class="literal">TryAdd</code> and <code class="literal">TryTake</code> methods of <code class="literal">BlockingCollection</code> can accept a <code class="literal">CancellationToken</code> parameter so that we can respond to cancellation requests and break out of a loop.</p><p>In this recipe, we are going to create a <code class="literal">Console</code> application that has producer <code class="literal">Task</code> and consumer <code class="literal">Task</code>. The producer will be adding items to <code class="literal">BlockingCollection</code> using <code class="literal">TryAdd</code>, and the consumer<a id="id362" class="indexterm"></a> will be removing items using <code class="literal">Try</code>.</p><p>After the producer and consumer get started, we will call the <code class="literal">Cancel</code> method on a token source to see how we can use the <code class="literal">TryAdd</code> and <code class="literal">TryTake</code> overloads to handle cancellation of our operation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec100"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime <code class="literal">Exception</code> is thrown, and intercepts the <code class="literal">Exception</code> before it gets to our handler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_05_05.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec101"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how <a id="id363" class="indexterm"></a>to cancel a concurrent collection operation.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">CancelOperation</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the<a id="id364" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create a source range of numbers, instantiate our <code class="literal">CancellationTokenSource</code> and obtain <code class="literal">CancellationToken</code>.</p><div class="informalexample"><pre class="programlisting">var data = Enumerable.Range(0, 100);
var numbers = new BlockingCollection&lt;int&gt;(100);
var tokenSource = new CancellationTokenSource();
var token = tokenSource.Token;</pre></div></li><li><p>Next, just below the previous lines, create a producer <code class="literal">Task</code> and pass in <code class="literal">CancellationToken</code>. The producer should add items to <code class="literal">BlockingCollection</code> by calling <code class="literal">TryAdd</code> inside a <code class="literal">try</code>/<code class="literal">catch</code> block. The <code class="literal">catch</code> block should handle <code class="literal">OperationCancelledException</code>.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    foreach (var item in data)
    {
    try
    {
      numbers.TryAdd(item,5,token);
      Console.WriteLine("Adding:{0} Item Count={1}", 
        item, numbers.Count);
    }
    catch(OperationCanceledException)
    {
      Console.WriteLine("Adding operation has been cancelled");
      numbers.CompleteAdding();
      break;
    }
    }
    numbers.CompleteAdding();
},token);</pre></div></li><li><p>Now let's create a <a id="id365" class="indexterm"></a>consumer <code class="literal">Task</code> and pass in <code class="literal">CancellationToken</code>. The consumer task should take<a id="id366" class="indexterm"></a> items from <code class="literal">BlockingCollection</code> by calling <code class="literal">TryTake</code> inside a <code class="literal">try</code>/<code class="literal">catch</code> block. The <code class="literal">catch</code> block should handle <code class="literal">OperationCancelledException</code>.</p><div class="informalexample"><pre class="programlisting">// A simple blocking consumer.
Task.Factory.StartNew(() =&gt;
{
    
  while (!numbers.IsCompleted)
  {
    try
    {
      numbers.TryTake(out item,5,token);
    }
    catch (OperationCanceledException)
    {
      Console.WriteLine("Take operation has been cancelled");
      break;
    }
    Console.WriteLine("Taking:{0} ", item);
    // wait for a bit
    Thread.SpinWait(10000);
  }
  Console.WriteLine("\rNo more items to take.");
},token);</pre></div></li><li><p>Finally, let's have the main thread wait for a bit, then call the <code class="literal">Cancel</code> method of <code class="literal">CancellationTokenSource</code>. Wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">Thread.SpinWait(2000000);
tokenSource.Cancel();
Console.ReadLine();</pre></div></li><li><p>In Visual <a id="id367" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to<a id="id368" class="indexterm"></a> run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec102"></a>How it worksâ€¦</h3></div></div></div><p>Responding to <a id="id369" class="indexterm"></a>cancellations when working with <code class="literal">BlockingCollection</code> is pretty consistent with other classes in the Task Parallel Library.</p><p>In the producer task, we use the overload of <code class="literal">TryAdd</code> that accepts an out parameter, a timeout parameter and <code class="literal">CancellationToken</code>. We also call <code class="literal">TryAdd</code> in a <code class="literal">try</code>/<code class="literal">catch</code> block, so we can respond to <code class="literal">OperationCancelledException</code>. When the operation is cancelled, we call <code class="literal">CompleteAdding</code> to indicate we will be adding more items and execute a <code class="literal">break</code> statement to break out of the loop.</p><div class="informalexample"><pre class="programlisting">foreach (var item in data)
{
  try
  {
    numbers.TryAdd(item,5,token);
    Console.WriteLine("Adding:{0} Item Count={1}", 
              item, numbers.Count);
  }
  catch(OperationCanceledException)
  {
    Console.WriteLine("Adding operation has been cancelled");
    numbers.CompleteAdding();
    break;
  }
}</pre></div><p>Things are very <a id="id370" class="indexterm"></a>similar on the consumer side. We pass<a id="id371" class="indexterm"></a> <code class="literal">CancellationToken</code> into <code class="literal">TryTake</code> and handle <code class="literal">OperationCancelledException</code> in our <code class="literal">catch</code> block. When the operation is cancelled, we issue a <code class="literal">break</code> statement to break out of the loop.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec56"></a>Working with multiple producers and consumers</h2></div></div><hr /></div><p>It is possible to use single <code class="literal">BlockingCollection</code> as a buffer between multiple producers and consumers.</p><p>In this recipe, we are going to build a <code class="literal">Console</code> application that will create multiple producer tasks which <a id="id372" class="indexterm"></a>perform an expensive math operation on<a id="id373" class="indexterm"></a> a small range of numbers. We will also have two consumer tasks that loop through the <code class="literal">BlockingCollection</code> buffer and display the results.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec103"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at using a single <code class="literal">BlockingCollection</code> with multiple producers and consumers.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">MultiptleProducerConsumer</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class which performs our expensive math operation.</p><div class="informalexample"><pre class="programlisting">private static double CalcSumRoot(int root)
{
  double result = 0;
  for (int i = 1; i &lt; 10000000; i++)
  {
    result += Math.Exp(Math.Log(i) / root);
  }
  return result;
}</pre></div></li><li><p>Now let's create another <code class="literal">static</code> method on the <code class="literal">Program</code> class that the consumers<a id="id374" class="indexterm"></a> will use to display the results to the <a id="id375" class="indexterm"></a>
<code class="literal">Console</code> application. This method will call <code class="literal">GetConsumingEnumerable</code> on <code class="literal">BlockingCollection</code> and loop through the collection.</p><div class="informalexample"><pre class="programlisting">private static void DisplayResults(BlockingCollection&lt;double&gt; results)
{
  foreach (var item in results.GetConsumingEnumerable())
  {
    Console.Write("\nConsuming item: {0}", item);
  }
}</pre></div></li><li><p>Next, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's define our <code class="literal">BlockingCollection</code> buffer and create <code class="literal">List&lt;Task&gt;</code>, so we can coordinate our multiple tasks, and create a couple of simple consumer <code class="literal">tasks</code> that will use the <code class="literal">DisplayResults</code> method to print out the results.</p><div class="informalexample"><pre class="programlisting">var results = new BlockingCollection&lt;double&gt;();
var tasks = new List&lt;Task&gt;();
var consume1 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume2 = Task.Factory.StartNew(() =&gt; DisplayResults(results));</pre></div></li><li><p>Now we need to create a <code class="literal">for</code> loop that loops from one to twenty-five, creating producer tasks that use the <a id="id376" class="indexterm"></a>
<code class="literal">CalcSumRoot</code> method to calculate the result, and then add the result to <code class="literal">BlockingCollection</code> by calling <code class="literal">TryAdd</code>. The loop must also add all of producer <code class="literal">tasks</code> to the <code class="literal">Task</code> list.</p><div class="informalexample"><pre class="programlisting">for (int item = 1; item &lt; 25; item++)
{
  var value = item;
  var compute = Task.Factory.StartNew(() =&gt;
  {
    var calcResult = CalcSumRoot(value);
    Console.Write("\nProducing item: {0}", calcResult);
    results.TryAdd(calcResult);
  });
  tasks.Add(compute);
}</pre></div></li><li><p>Finally, let's create a continuation to run after all producer <code class="literal">tasks</code> that are complete. The <a id="id377" class="indexterm"></a>continuation simply calls the <code class="literal">CompleteAdding</code> method<a id="id378" class="indexterm"></a> of <code class="literal">BlockingCollection</code> to indicate that we are done adding items<a id="id379" class="indexterm"></a> to the collection. Finish up by waiting for user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(),
result =&gt;
{
  results.CompleteAdding();
  Console.Write("\nCompleted adding.");
});

Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the ordered results in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec104"></a>How it worksâ€¦</h3></div></div></div><p>By default, <code class="literal">BlockingCollection</code> uses <code class="literal">ConcurrentQueue&lt;T&gt;</code> as the backing store. <code class="literal">ConcurrentQueue</code> takes care of thread synchronization and <code class="literal">BlockingCollection</code> does a non-busy wait while <a id="id380" class="indexterm"></a>trying to take an item from the collection. That is, if the consumer calls <code class="literal">TryTake</code> when there are no items in the queue, it does a non-busy wait <a id="id381" class="indexterm"></a>until any items are available.</p><p>In this recipe, we are spinning up producer <code class="literal">tasks</code> in a <code class="literal">for</code> loop. Each producer <code class="literal">task</code> is calling the <code class="literal">CalcSumRoot</code> method<a id="id382" class="indexterm"></a> which is a fairly expensive math operation. Our consumers are simply displaying the output to the screen. As a result, our two consumer <code class="literal">tasks</code> are probably spending most of their time in a non busy wait state.</p><p>The producers and consumers are pretty simple, but we needed a way to call <code class="literal">CompleteAdding</code> after all producer <code class="literal">tasks</code> have finished. We handled this by adding all of our producer <code class="literal">Task</code> objects to <code class="literal">List&lt;Task&gt;</code>, and calling the <code class="literal">ContinueWhenAll</code> method of <code class="literal">Task.Factory</code>, so our continuation only runs when all of the producers complete. The only job of the continuation is to call the <code class="literal">CompleteAdding</code> method of <code class="literal">BlockingCollection</code>.</p><div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(),
result =&gt;
{
  results.CompleteAdding();
  Console.Write("\nCompleted adding.");
});

Console.ReadLine();</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec57"></a>Creating object pool with ConcurrentStack</h2></div></div><hr /></div><p>An object pool is a set of pre-initialized objects that your application can use, rather than creating and destroying all of the objects it needs. If the instantiation cost of an object type is high, your application might benefit from a pool of objects.</p><p>In this recipe, we are going to create an object pool based on <code class="literal">ConcurrentStack</code>. <code class="literal">ConcurrentStack</code> will<a id="id383" class="indexterm"></a> handle concurrent access issues using fast interlocked operations, and will dispense our objects in a LIFO manner. We <a id="id384" class="indexterm"></a>will also have an object pool client which creates three tasks. One creates objects and puts them in the pool, the other two tasks request objects from the pool on different threads.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec105"></a>How to do itâ€¦</h3></div></div></div><p>Let's see how we can use <code class="literal">ConcurrentStack</code> to build a pool of pre-initialized objects.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ObjectPool</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Let's start by creating <a id="id385" class="indexterm"></a>our object pool<a id="id386" class="indexterm"></a> class. Right-click on the <code class="literal">ObjectPool</code> project in the <span class="strong"><strong>Solution Explorer</strong></span> and click on <span class="strong"><strong>Add</strong></span>, then choose<span class="strong"><strong> New Item</strong></span>. Select <span class="strong"><strong>Visual C# Items</strong></span>, and <span class="strong"><strong>Class.</strong></span> Enter <code class="literal">ConcurrentObjectPool</code> as the name of the class.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">ConcurrentObjectPool</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;</pre></div></li><li><p>We want our object pool to work with any type, so add a generic type parameter after the class name.</p><div class="informalexample"><pre class="programlisting">public class ConcurrentObjectPool&lt;T&gt;
{
}</pre></div></li><li><p>Our <code class="literal">ObjectPool</code> class<a id="id387" class="indexterm"></a> is going to need a couple of private state fields. We need a <code class="literal">ConcurrentStack</code> field which will provide our backing store and a <code class="literal">Func&lt;T&gt;</code> field which will hold an object creation function the pool can use to generate objects when the pool is empty. Inside the class declaration, add the following fields:</p><div class="informalexample"><pre class="programlisting">private ConcurrentStack&lt;T&gt; _objects;
private Func&lt;T&gt; _objectInitializer;</pre></div></li><li><p>Now we need a constructor for the <code class="literal">ConcurrentObjectPool</code> class. The constructor should take a <code class="literal">Func&lt;T&gt;</code> argument for the object generator and should instantiate a new <code class="literal">ConcurrentStack</code> object as the backing store.</p><div class="informalexample"><pre class="programlisting">public ConcurrentObjectPool(Func&lt;T&gt; objectInitializer)
{
  _objects = new ConcurrentStack&lt;T&gt;();
  _objectInitializer = objectInitializer;
}</pre></div></li><li><p>Now we need a <code class="literal">GetObject</code> method which will return a new object to the client. The <code class="literal">GetObject</code> method will try to pop an object off the stack. If it can't pop one off the stack, it will use <code class="literal">objectInitializer</code> to instantiate a new object.</p><div class="informalexample"><pre class="programlisting">public T GetObject()
{
  T item;
  if (_objects.TryPop(out item)) return item;
  return _objectInitializer();
}</pre></div></li><li><p>The last step for <a id="id388" class="indexterm"></a>our object pool is <a id="id389" class="indexterm"></a>a <code class="literal">PutObject</code> method that takes a generic item parameter and pushes it on the stack.</p><div class="informalexample"><pre class="programlisting">public void PutObject(T item)
{
  _objects.Push(item);
}</pre></div></li><li><p>Now we need to create the <code class="literal">Console</code> application that will use the object pool. Go back to <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives at the top of the file:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Text;
using System.Threading.Tasks;</pre></div></li><li><p>The first step is to instantiate our object pool. In the <code class="literal">main</code> method of the program class, create a <code class="literal">ConcurrentObjectPool</code> object and pass in a function that creates a new <code class="literal">StringBuilder</code> object as the constructor parameter.</p><div class="informalexample"><pre class="programlisting">var pool = new ConcurrentObjectPool&lt;StringBuilder&gt;(()=&gt;
  new StringBuilder("Pooled Object created by objectInitializer"));</pre></div></li><li><p>Now let's create a task that creates some objects and places them in <code class="literal">pool</code> using the <code class="literal">PutObject</code> method.</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt;
{
  for (var index = 0; index &lt; 10; index++)
  {
    StringBuilder newObject = new StringBuilder(string.Concat("Pooled object", 
          index.ToString()));
    Console.WriteLine("Putting pooled object: {0}", index.ToString());
    pool.PutObject(newObject);
  }
});</pre></div></li><li><p>Finally, let's create two continuation tasks that run after the first task is completed. <a id="id390" class="indexterm"></a>Both tasks just request<a id="id391" class="indexterm"></a> objects from the object <code class="literal">pool</code> using the <code class="literal">GetObject</code> method.</p><div class="informalexample"><pre class="programlisting">task1.ContinueWith((antecedent)=&gt;
{
  for (var index = 0; index &lt; 10; index++)
  {
    var pooledObject = pool.GetObject();
    Console.WriteLine("First Task: {0}", pooledObject.ToString());                    
  }
});

task1.ContinueWith((antecedent) =&gt;
{
  for (var index = 0; index &lt; 10; index++)
  {
    var pooledObject = pool.GetObject();
    Console.WriteLine("Second Tasks: {0}", pooledObject.ToString());
  }
});</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec106"></a>How it worksâ€¦</h3></div></div></div><p>There are other features we could have added to our object <code class="literal">pool</code>, such as controlling the concurrency level and/or using thread local segments to store our objects, but this simple implementation does<a id="id392" class="indexterm"></a> the job for our purposes.</p><p>The constructor <a id="id393" class="indexterm"></a>of the object <code class="literal">pool</code> takes a function argument that it can use to generate an object if the pool is empty, and stores the function in a private <code class="literal">objectInitializer</code> field. We are just pooling <code class="literal">StringBuilder</code> objects in this sample, so we passed in the following function:</p><div class="informalexample"><pre class="programlisting"> ()=&gt;new StringBuilder("Pooled Object created by objectInitializer")</pre></div><p>Our <code class="literal">GetObject</code> method<a id="id394" class="indexterm"></a>, which the client uses to get objects from <code class="literal">pool</code>, just uses the <code class="literal">TryPop</code> method of <code class="literal">ConcurrentStack</code> to return an object. If <code class="literal">TryPop</code> fails to return anything because the stack is empty, we just return the result of the <code class="literal">objectInitializer</code> function.</p><div class="informalexample"><pre class="programlisting">public T GetObject()
{
  T item;
  if (_objects.TryPop(out item)) return item;
  return _objectInitializer();
}</pre></div><p>The <code class="literal">PutObject</code> method<a id="id395" class="indexterm"></a> probably doesn't require much explanation. It just uses the <code class="literal">Push</code> method of <code class="literal">ConcurrentStack</code> to push an object onto the stack.</p><p>Given that we chose to use <code class="literal">ConcurrentStack</code>, our object references are returned in a LIFO fashion. We could have chosen another type of backing store if this didn't work for us. For example, we could have chosen to use <code class="literal">ConcurrentQueue</code> as a backing store to have items returned in a <a id="id396" class="indexterm"></a>
<span class="strong"><strong>First-In-First-Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) fashion, or we could have used <code class="literal">ConcurrentBag</code> to provide unordered storage.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec58"></a>Adding blocking and bounding with IProducerConsumerCollection</h2></div></div><hr /></div><p>By default, <code class="literal">BlockingCollection</code> uses <code class="literal">ConcurrentQueue</code> as its backing store. However, you can add blocking and <a id="id397" class="indexterm"></a>bounding functionality to any custom or derived collection class by implementing the <a id="id398" class="indexterm"></a>
<code class="literal">IProducerConsumerCollection</code> interface in the class. You can then use an instance of the custom <a id="id399" class="indexterm"></a>collection class as the backing store for <code class="literal">BlockingCollection</code>.</p><p>In this recipe, we are going to<a id="id400" class="indexterm"></a> create a custom priority queue and use the custom queue as the backing store for <code class="literal">BlockingCollection</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec107"></a>How to do itâ€¦</h3></div></div></div><p>Let's examine how we can use <code class="literal">IProducerConsumerColletion</code> to add blocking and bounding <a id="id401" class="indexterm"></a>functionality to a <a id="id402" class="indexterm"></a>custom collection.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <span class="strong"><strong>CustomBlockingBounding</strong></span> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>First, let's add a <code class="literal">Class</code> file for our custom queue. Right-click on the <span class="strong"><strong>CustomBlockingBounding </strong></span>project and click on <span class="strong"><strong>Add Item</strong></span>, and then click on <span class="strong"><strong>Add New Item</strong></span> and then click on <span class="strong"><strong>Class</strong></span>. Name the new class <code class="literal">PriorityQueue.cs</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">PriorityQueue</code> class:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections;
using System;
using System.Threading;</pre></div></li><li><p>Below the <code class="literal">PriorityQueue</code> class<a id="id403" class="indexterm"></a>, let's create an enumeration for our queue priority levels. We just want to use low, medium, and high as the possible priority levels.</p><div class="informalexample"><pre class="programlisting">public enum QueuePriorityLevel
{
  High = 0,
  Medium = 1,
  Low = 2
}</pre></div></li><li><p>Our custom collection class will hold <code class="literal">KeyValuePairs</code> of the queue priority level and the data queued. Add priority level and queued data generic type parameters to <code class="literal">Class</code> and declare the <code class="literal">IProducerConsumerCollection</code> interface.</p><div class="informalexample"><pre class="programlisting">public class PriorityQueue&lt;PriorityLevel, TValue&gt;: 
  IProducerConsumerCollection&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;
{

}</pre></div></li><li><p>Next, we need some private fields for the <code class="literal">PriorityQueue</code> class. We will need three <code class="literal">ConcurrentQueue&lt;QueuePriorityLevel, TValue&gt;</code> fields; one each for the low, <a id="id404" class="indexterm"></a>medium, and high priority queues. We will need an array of <a id="id405" class="indexterm"></a>
<code class="literal">ConcurrentQueue</code> to hold all of the queues and an integer count variable.</p><div class="informalexample"><pre class="programlisting">private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _lowPriotityQueue = null;
private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _mediumPriotityQueue = null;
private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _highPriotityQueue = null;
private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;[] _queues = null;
private int _count = 0;</pre></div></li><li><p>Now let's add a <a id="id406" class="indexterm"></a>default constructor to the <code class="literal">PriorityQueue</code> class that initializes all of our fields.</p><div class="informalexample"><pre class="programlisting">public PriorityQueue()
{
  _lowPriotityQueue = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel,TValue&gt;&gt;();
  _mediumPriotityQueue = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel,TValue&gt;&gt;();
  _highPriotityQueue = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel,TValue&gt;&gt;();
  _queues = new ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;[3]
  {
    _lowPriotityQueue,
    _mediumPriotityQueue,
    _highPriotityQueue
  };
}</pre></div></li><li><p>Next, we need to provide an implementation for several of the <code class="literal">IProducerConsumerCollection</code> interface members. Let's start with the <code class="literal">CopyTo</code> method. <a id="id407" class="indexterm"></a>This method makes a copy of our collection array to a destination array.</p><div class="informalexample"><pre class="programlisting">public void CopyTo(KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] array, int index)
{
  if (array == null) throw new ArgumentNullException();

  KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] temp = this.ToArray();
  for (int i = 0; i &lt; array.Length &amp;&amp; i &lt; temp.Length; i++)
    array[i] = temp[i];
}</pre></div></li><li><p>Now we <a id="id408" class="indexterm"></a>need to<a id="id409" class="indexterm"></a> provide<a id="id410" class="indexterm"></a> an implementation for the <a id="id411" class="indexterm"></a>
<code class="literal">ToArray</code> method which returns an array of <code class="literal">KeyValuePairs</code>.</p><div class="informalexample"><pre class="programlisting">public KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] ToArray()
{
  KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[] result;

  lock (_queues)
  {
    result = new KeyValuePair&lt;QueuePriorityLevel, TValue&gt;[this.Count];
    int index = 0;
    foreach (var q in _queues)
    {
      if (q.Count &gt; 0)
      {
        q.CopyTo(result, index);
        index += q.Count;
      }
    }
    return result;
  }
}</pre></div></li><li><p>Now we are getting to the key <code class="literal">IProducerConsumerCollection</code> method implementations. We need to provide an implementation for the <code class="literal">TryAdd</code> method<a id="id412" class="indexterm"></a> which is going to determine our private <code class="literal">ConcurrentQueue</code> collections to add the new item to, and then add the item, and use <code class="literal">Interlocked.Increment</code> to increment the count.</p><div class="informalexample"><pre class="programlisting">public bool TryAdd(KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  int priority = (int) item.Key;
  _queues[priority].Enqueue(item);
  Interlocked.Increment(ref _count);
  return true;
}</pre></div></li><li><p>The <code class="literal">TryTake</code> method<a id="id413" class="indexterm"></a> implementation needs to loop through the backing <code class="literal">ConcurrentQueues</code> in priority order, and try to take the first available item from one<a id="id414" class="indexterm"></a> of the <a id="id415" class="indexterm"></a>queues,<a id="id416" class="indexterm"></a> and decrement the count.</p><div class="informalexample"><pre class="programlisting">public bool TryTake(out KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  bool success = false;

  for (int i = 0; i &lt;= 2; i++)
  {
    lock (_queues)
    {
      success = _queues[i].TryDequeue(out item);
      if (success)
      {
        Interlocked.Decrement(ref _count);
        return true;
      }
    }
  }

  item = new KeyValuePair&lt;QueuePriorityLevel, TValue&gt;(0, default(TValue));
  return false;
}</pre></div></li><li><p>Next we need to implement the <code class="literal">GetEnumerator</code> methods required to implement <code class="literal">IEnumerable</code>.</p><div class="informalexample"><pre class="programlisting">public IEnumerator&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; GetEnumerator()
{
  for (int i = 0; i &lt;= 2; i++)
  {
    foreach (var item in _queues[i])
      yield return item;
  }
}

IEnumerator IEnumerable.GetEnumerator()
{
  return GetEnumerator();
}</pre></div></li><li><p>We're almost done with the collection. The last thing we need to do is implement a simple <a id="id417" class="indexterm"></a>getter for the <code class="literal">count</code> field. There is no need to provide an implementation for the other <code class="literal">IProducerConsumerCollection</code> members.</p><div class="informalexample"><pre class="programlisting">public int Count
{
  get { return _count; }
}</pre></div></li><li><p>Ok, let's <a id="id418" class="indexterm"></a>move on to our <code class="literal">Console</code> application which will use the custom <code class="literal">queue</code> class. <a id="id419" class="indexterm"></a>Open <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of the class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, start with some local variable declarations for a <code class="literal">PriorityQueue</code> variable, a <code class="literal">BlockingCollection</code> variable that takes the <code class="literal">PriorityQueue</code> variable as a constructor argument, and a list of tasks which will hold references to our producer and consumer <code class="literal">tasks</code>.</p><div class="informalexample"><pre class="programlisting">var queue = new PriorityQueue&lt;QueuePriorityLevel, int&gt;();
var bc = new BlockingCollection&lt;KeyValuePair&lt;QueuePriorityLevel, int&gt;&gt;(queue);
var tasks = new List&lt;Task&gt;();</pre></div></li><li><p>Our <code class="literal">Console</code> application<a id="id420" class="indexterm"></a> has a producer task which will add items to the priority queue with a random priority level. The consumer task will remove items from the queue in priority order and write the results to <code class="literal">Console</code>. Let's start with the <code class="literal">producer</code> task.</p><div class="informalexample"><pre class="programlisting">var producer = Task.Factory.StartNew(() =&gt;
{
  Random r = new Random();
  int itemsToAdd = 50;
  int count = 0;
  for (int i = 0; i &lt; itemsToAdd; i++ )
  {
    Thread.SpinWait(10000);
    // Generate random priority level
    QueuePriorityLevel[] values = (QueuePriorityLevel[])Enum.GetValues(typeof(QueuePriorityLevel));
    var priority = values[new Random().Next(0, values.Length)];                    
    var item = new KeyValuePair&lt;QueuePriorityLevel, int&gt;(priority, count++);
    bc.Add(item);
    Console.WriteLine("added priority {0}, data={1}", priority, item.Value);
  }
  Console.WriteLine("Producer is finished.");
 }).ContinueWith( (antecedent)=&gt;
   {
     bc.CompleteAdding();
   });</pre></div></li><li><p>Right after <a id="id421" class="indexterm"></a>the <code class="literal">producer</code> task, make a call to <code class="literal">Thread.SpinWait</code> to make the main thread wait for<a id="id422" class="indexterm"></a> a bit before starting the <code class="literal">consumer</code> task.</p><div class="informalexample"><pre class="programlisting">Thread.SpinWait(100000);</pre></div></li><li><p>Now let's add the<a id="id423" class="indexterm"></a> <code class="literal">consumer</code> task which will pull items from the queue and display the results to the <code class="literal">Console</code> application.</p><div class="informalexample"><pre class="programlisting">var consumer = Task.Factory.StartNew(() =&gt;
{
  while (!bc.IsCompleted )
  {
     KeyValuePair&lt;QueuePriorityLevel, int&gt; item = new KeyValuePair&lt;QueuePriorityLevel, int&gt;();
    bool success = false;
    success = bc.TryTake(out item);
    if (success)
    {
    Console.WriteLine("removed Priority = {0} data = {1} Collection Count= {2}", item.Key, item.Value, bc.Count);
    }
    else
      Console.WriteLine("No items remaining. count = {0}", bc.Count);
  }
  Console.WriteLine("Exited consumer loop");
});</pre></div></li><li><p>Finish up by adding the <code class="literal">producer</code> and <code class="literal">consumer</code> tasks to the list of <code class="literal">tasks</code>. Wait on both tasks to complete by calling <code class="literal">Task.WaitAll</code> inside a <code class="literal">try</code>/<code class="literal">catch</code> block. In the<a id="id424" class="indexterm"></a> <code class="literal">catch</code> block, handle any <code class="literal">AggregateException</code> that may be thrown. Lastly, wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">tasks.Add(producer);
tasks.Add(consumer);

try
{
  Task.WaitAll(tasks.ToArray());
}

catch (AggregateException ae)
{
  foreach (var v in ae.InnerExceptions)
    Console.WriteLine(v.Message);
}

Console.ReadLine();</pre></div></li><li><p>In Visual <a id="id425" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following<a id="id426" class="indexterm"></a> screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec108"></a>How it worksâ€¦</h3></div></div></div><p>There were a lot of codes in <a id="id427" class="indexterm"></a>this recipe, but the key points of the implementation can be distilled to just a few <code class="literal">IProducerConsumerCollection</code> interface method implementations.</p><p>
<code class="literal">IProducerConsumerCollection&lt;T&gt;</code> defines a handful of methods for manipulating thread safe collections for producer/consumer usage.</p><p>To create our custom <a id="id428" class="indexterm"></a>collection <a id="id429" class="indexterm"></a>class, we just implemented the <code class="literal">IProducerConsumerCollection</code> interface on our custom <code class="literal">PriorityQueue</code> class and used some <code class="literal">ConcurrentQueue</code> fields as our backing stores.</p><div class="informalexample"><pre class="programlisting">public class PriorityQueue&lt;PriorityLevel, TValue&gt;: 
    IProducerConsumerCollection&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;
{
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _lowPriotityQueue = null;
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _mediumPriotityQueue = null;
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt; _highPriotityQueue = null;
  private ConcurrentQueue&lt;KeyValuePair&lt;QueuePriorityLevel, TValue&gt;&gt;[] _queues = null;
  private int _count = 0;	
  ...  
}</pre></div><p>The actual implementation of the <a id="id430" class="indexterm"></a>
<code class="literal">IProducerConsumerCollection.TryAdd</code> method is pretty simple. We just determine the queue to place the item in by casting our <code class="literal">QueuePriorityLevel</code> <a id="id431" class="indexterm"></a>enumeration to an integer, then enqueue the item. We then do <code class="literal">Interlocked.Increment</code> on our count field. <code class="literal">Interlocked.Increment</code> does a thread safe increment of the count field.</p><div class="informalexample"><pre class="programlisting">public bool TryAdd(KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  int priority = (int) item.Key;
  _queues[priority].Enqueue(item);
  Interlocked.Increment(ref _count);
  return true;
}</pre></div><p>
<code class="literal">TryTake</code> isn't much more complex. We just loop through our three private backing queues in order of priority and remove the first item we come to. <code class="literal">TryTake</code> returns a bool to indicate of it was successful in taking an item.</p><div class="informalexample"><pre class="programlisting">public bool TryTake(out KeyValuePair&lt;QueuePriorityLevel, TValue&gt; item)
{
  bool success = false;

  for (int i = 0; i &lt;= 2; i++)
  {
    lock (_queues)
    {
      success = _queues[i].TryDequeue(out item);
      if (success)
      {
        Interlocked.Decrement(ref _count);
        return true;
      }
    }
  }
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec59"></a>Using multiple concurrent collections to create a pipeline</h2></div></div><hr /></div><p>A pipeline is like an assembly line in a factory. With the pipeline pattern, data is processed in a sequential order where the output from the first stage becomes the input for the second stage and so on. <a id="id432" class="indexterm"></a>Pipelines use parallel tasks and concurrent queues to process a series of input values.</p><p>In this recipe, we are<a id="id433" class="indexterm"></a> going to create a simple pipeline that creates a range of numbers, doubles the numbers in the range, and then writes the results to <code class="literal">Console</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec109"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how to create a pipeline by using multiple concurrent collections.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Pipeline</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's add a <code class="literal">static</code> method to the <code class="literal">Program</code> class to create the range. This method needs a <code class="literal">BlockingCollection</code> parameter. It will simply add items to <code class="literal">BlockingCollection</code> in a loop.</p><div class="informalexample"><pre class="programlisting">static void CreateRange(BlockingCollection&lt;int&gt; result)
{
  try
  {
    for (int i = 1; i &lt; 10; i++)
    {
      result.Add(i);
      Console.WriteLine("Create Range {0}", i);
    }
  }
  finally
  {
    result.CompleteAdding();
  }
}</pre></div></li><li><p>Next, let's create a <code class="literal">static</code> method to square the range. This method will take two <code class="literal">BlockingCollection</code> parameters and will square each of the items in the source collection and place them in the result collection.</p><div class="informalexample"><pre class="programlisting">static void SquareTheRange(BlockingCollection&lt;int&gt; source, BlockingCollection&lt;int&gt; result)
{
  try
  {
    foreach (var value in source.GetConsumingEnumerable())
    {
      result.Add((int)(value * value));
    }
  }
  finally
  {
    result.CompleteAdding();
  }
}</pre></div></li><li><p>Now let's <a id="id434" class="indexterm"></a>create a <code class="literal">static</code> method to display the results. This method will take a <code class="literal">BlockingCollection</code> parameter<a id="id435" class="indexterm"></a> <a id="id436" class="indexterm"></a>and will loop through its items and write the values to the <code class="literal">Console</code> application.</p><div class="informalexample"><pre class="programlisting">{
  foreach (var value in input.GetConsumingEnumerable())
  {
    Console.WriteLine("The result is {0}", value);
  }
}</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, declare the two <code class="literal">BlockingCollection&lt;int&gt;</code> variables. These blocking collections will be the data buffers for the pipeline.</p><div class="informalexample"><pre class="programlisting">var bufferA = new BlockingCollection&lt;int&gt;(10);
var bufferB = new BlockingCollection&lt;int&gt;(10);</pre></div></li><li><p>Create and start three tasks to call each of our three methods passing in the <code class="literal">BlockingCollection</code> buffers required for each method.</p><div class="informalexample"><pre class="programlisting">var createStage = Task.Factory.StartNew(() =&gt; 
  {
    CreateRange(bufferA);
  },TaskCreationOptions.LongRunning);
var squareStage = Task.Factory.StartNew(() =&gt; 
  {
    SquareTheRange(bufferA, bufferB);
  },TaskCreationOptions.LongRunning );

var displayStage = Task.Factory.StartNew(() =&gt; 
  {
    DisplayResults(bufferB);
  },TaskCreationOptions.LongRunning);</pre></div></li><li><p>Finally, wait <a id="id437" class="indexterm"></a>for all three tasks to complete by calling <code class="literal">Task.WaitAll</code>. Wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(createStage, squareStage, displayStage);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, <a id="id438" class="indexterm"></a>press <span class="emphasis"><em>F5</em></span> to run the project. You should see the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_05_10.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec110"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, we created a simple pipeline composed of three stages. Each stage reads from and/or writes to a particular buffer. If your machine has more available processor cores than there are stages in the pipeline, the stages can run in parallel. The concurrent queues used by <code class="literal">BlockingCollection</code> will buffer all shared inputs and outputs.</p><p>Each stage in the pipeline can add items to its output buffer as long as there is room. If the buffer is full, the pipeline stage waits for space to become available before adding an item. The stages can <a id="id439" class="indexterm"></a>also wait on inputs from the previous stage.</p><p>The stages that produce data use <code class="literal">BlockingCollection.CompleteAdding</code> to signal that they are finished adding data. This tells the consumer that it can end its processing loop after all previously added data has been removed or processed.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch06"></a>ChapterÂ 6.Â Synchronization Primitives</h2></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using monitor</p></li><li style="list-style-type: disc"><p>Using mutual exclusion lock</p></li><li style="list-style-type: disc"><p>Using <code class="literal">SpinLock</code> for synchronization</p></li><li style="list-style-type: disc"><p>Interlocked operations</p></li><li style="list-style-type: disc"><p>Synchronizing multiple tasks with a Barrier</p></li><li style="list-style-type: disc"><p>Using <code class="literal">ReaderWriterLockSlim</code> </p></li><li style="list-style-type: disc"><p>Using <code class="literal">WaitHandles</code> with Mutex</p></li><li style="list-style-type: disc"><p>Waiting for multiple threads with <code class="literal">CountdownEvent</code>
</p></li><li style="list-style-type: disc"><p>Using <code class="literal">ManualResetEventSlim</code> to spin and wait</p></li><li style="list-style-type: disc"><p>Using <code class="literal">SemaphoreSlim</code> to limit access</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec60"></a>Introduction</h2></div></div><hr /></div><p>This chapter is about coordinating the work that is performed by parallel tasks.</p><p>When concurrent tasks read from and write to variables without an appropriate synchronization mechanism, a <span class="strong"><strong>race condition</strong></span>
<a id="id440" class="indexterm"></a> has the potential to appear. Race conditions can produce inconsistent results in your program, and can be very difficult to detect and correct.</p><p>Let's take a second to understand what a race condition is. Consider a scenario that has two parallel tasks; task1 and task2. Each task tries to read and increment the value of a public variable. Task1 reads the original value of the variable, let's say 10, and increments the value to 11. At the same time task1 is reading the value of the variable but before it increments the value, task2 reads the same value of 10 and increments to 11. The final value of the variable ends up being 11 instead of the correct value of 12.</p><p>
<span class="strong"><strong>.NET framework 4.5</strong></span> offers several new data structures for parallel programming that simplify complex synchronization <a id="id441" class="indexterm"></a>problems. Knowledge of these synchronization primitives will enable you to implement more complex algorithms and solve many of the issues associated with multithreaded programming. It is important to learn the various alternatives so that you can choose the most appropriate one for scenarios that require communication and synchronization among multiple tasks.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec61"></a>Using monitor</h2></div></div><hr /></div><p>A monitor, like the lock <a id="id442" class="indexterm"></a>statement, is a mechanism for ensuring that only one thread at a time may be running in a critical section of code. A monitor has a lock, and only one thread at a time may acquire it. To run in a critical section of code, a thread must have acquired the monitor. While a thread owns the lock for an object, no other thread can acquire that lock.</p><p>For this recipe, we are going to create an application that uses a <code class="literal">ConsoleWriter</code> class with a <code class="literal">WriteNumbers</code> method to write some numbers out to the Console. Three parallel tasks will each be trying to write some numbers to the Console, and we will use monitor to control access to the critical section of code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec111"></a>How to do itâ€¦</h3></div></div></div><p>Have a look at the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project<a id="id443" class="indexterm"></a> using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">MonitorExample</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add a new class to your project and name the class <code class="literal">ConsoleWriter.cs</code>.</p></li><li><p>Add the following code snippet using the directives to the top of your <code class="literal">ConsoleWriter</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;</pre></div></li><li><p>First, inside the declaration of your <code class="literal">ConsoleWriter</code> class, create a private member variable of type object which we will use as our lock object.</p><div class="informalexample"><pre class="programlisting">public class ConsoleWriter
{
  private object _locker = new object(); 
}</pre></div></li><li><p>Now let's create a method of the <code class="literal">ConsoleWriter</code> class<a id="id444" class="indexterm"></a> called <code class="literal">WriteNumbersUnprotected</code>. This is a simple method that executes a <code class="literal">for</code> loop. Each iteration of the loop will write the number of the loop index to the Console. As you might have guessed by the method name, we will not use monitor to lock the critical section of this method.</p><div class="informalexample"><pre class="programlisting">public void WriteNumbersUnprotected()
{
  for (int numbers = 0; numbers &lt; 5; numbers++)
  {
    Thread.Sleep(100);
    Console.Write(numbers + ",");
  }
  Console.WriteLine();
}</pre></div></li><li><p>Now let's create a<a id="id445" class="indexterm"></a> method on the <code class="literal">ConsoleWriter</code> class named <code class="literal">WriteNumbers</code>. This method will have the same functionality as the previous method we created. However, this method will use monitor to ensure that only a single thread can enter the critical section of code.</p><div class="informalexample"><pre class="programlisting">public void WriteNumbers()
{
  Monitor.Enter(_locker);
  try
  {
    for (int number = 0; number &lt;= 5; number++)
    {
      Thread.Sleep(100);
      Console.Write(number + ",");
    }
    Console.WriteLine();
  }
  finally
  {
    Monitor.Exit(_locker);
  }
}</pre></div></li><li><p>Now let's go back to the <code class="literal">Program</code> class. Add the following code snippet using directives to the top of the <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, start by creating, and instantiating an instance of <code class="literal">ConsoleWriter</code>. Also create a list of tasks which we will use to hold a reference to our tasks.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{  
  var writer = new ConsoleWriter();
  var taskList = new List&lt;Task&gt;();	
}</pre></div></li><li><p>Now let's create a <code class="literal">for</code> loop that creates and starts three tasks. The task will each call the <a id="id446" class="indexterm"></a>
<code class="literal">WriteNumbersUnprotected</code> method<a id="id447" class="indexterm"></a> of the shared <code class="literal">ConsoleWriter</code> object.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 3; i++)
{
  taskList.Add(Task.Factory.StartNew(()=&gt;
    {
      writer.WriteNumbersUnprotected();
    }));                
}</pre></div></li><li><p>Finish up the <code class="literal">Main</code> method of the <code class="literal">Program</code> class by waiting on the tasks to complete and waiting on user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(taskList.ToArray());
Console.WriteLine("Finished. Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>Now, in Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You will probably see some pretty ugly output because more than one thread is calling the method at a time. Have look at the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_03.jpg" /></div></li><li><p>Let's fix this by going back to our tasks in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class and change <a id="id448" class="indexterm"></a>them now to call the <code class="literal">WriteNumbers</code> method which protects the critical section of code with monitor.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 3; i++)
{
  taskList.Add(Task.Factory.StartNew(()=&gt;
    {
      writer.WriteNumbers();
    }));                
}</pre></div></li><li><p>Let's press <span class="emphasis"><em>F5</em></span> again to run the project. This time you should see more orderly output because only one thread at a time can be in the critical section. This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec112"></a>How it worksâ€¦</h3></div></div></div><p>Lock and monitor are very similar. In fact, the <code class="literal">lock</code> keyword is implemented using the <code class="literal">Monitor</code> class. When using <code class="literal">Monitor</code>, the developer has to be a bit more careful to explicitly remove the lock using <code class="literal">exit</code>. Lock calls <code class="literal">Enter</code> and <code class="literal">Exit</code> implicitly, but when using <code class="literal">Monitor</code> they have to be called by the developer. It is best practice to call <code class="literal">exit</code> in a <code class="literal">finally</code> block to ensure the lock will be released in the event of an <code class="literal">Exception</code>.</p><div class="informalexample"><pre class="programlisting">Monitor.Enter(_locker);
try
{
	// Critical Section
}
finally
{
  Monitor.Exit(_locker);</pre></div><p>Using <code class="literal">lock</code> is generally preferred over using <code class="literal">Monitor</code> directly. This is because lock is more concise and lock ensures that the underlying monitor is released, even if the protected code <a id="id449" class="indexterm"></a>throws an <code class="literal">Exception</code>.</p><p>However, the <code class="literal">lock</code> keyword isn't quite as fully-featured as the <code class="literal">Monitor</code> class. For example, <code class="literal">Monitor</code> has a <code class="literal">TryEnter</code> method that can wait for a <code class="literal">lock</code> for a specified period of time instead of waiting infinitely.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec62"></a>Using a mutual exclusion lock</h2></div></div><hr /></div><p>Locking is essential in parallel programs. <a id="id450" class="indexterm"></a>It restricts code from being executed by more than one thread at the same time. Exclusive locking is used to ensure<a id="id451" class="indexterm"></a> that only one thread can enter a particular section of code at a time.</p><p>The simplest way to use synchronization in c# is with the <code class="literal">lock</code> keyword. The <code class="literal">lock</code> keyword works by marking a block of code as a critical section by obtaining a mutual exclusion lock for an object running a statement and then releasing the lock.</p><p>In this recipe, we are going to create a class that represents a bank account. An object of this class will be shared by a couple of parallel tasks that will be making a series of withdrawals for random amounts. The critical section of code in the <code class="literal">Withdraw</code> method that updates the balance of the shared account object will be protected by a <code class="literal">lock</code> statement.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec113"></a>How to do itâ€¦</h3></div></div></div><p>Let's go to Visual Studio 2012 and take a look at the following steps on how to use mutual exclusion locks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">LockExample</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add a new class to the project and name the class <code class="literal">Account.cs</code>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Account</code> class:</p><div class="informalexample"><pre class="programlisting">using System.Text;
using System.Threading.Tasks;</pre></div></li><li><p>Add a private field of type <code class="literal">double</code> to the <code class="literal">Account</code> class to store the balance of the account and a private object that will be used for locking.</p><div class="informalexample"><pre class="programlisting">private double _balance;
private object _locker = new object();</pre></div></li><li><p>Next let's <a id="id452" class="indexterm"></a>add a constructor to the <code class="literal">Account</code> class. This constructor should accept a parameter of type <code class="literal">double</code> and should initialize the <code class="literal">balance</code> field.</p><div class="informalexample"><pre class="programlisting">public Account(double initialBalance)
<code class="literal">{</code>
<code class="literal">  _balance = initialBalance;</code>
<code class="literal">}</code>
</pre></div></li><li><p>Now let's <a id="id453" class="indexterm"></a>create a <code class="literal">Withdraw</code> method for the account. If the account has a negative balance, the <code class="literal">Withdraw</code> method should throw an error. Otherwise, the <code class="literal">Withdraw</code> method should obtain a mutual exclusion lock on the <code class="literal">Account</code> object and deduct the requested amount from the balance.</p><div class="informalexample"><pre class="programlisting">public double Withdraw(double amount)
{

  if (_balance &lt; 0)
  throw new Exception("Account has a negative balance.");
  }

  lock (_locker)
  {
    if (_balance &gt;= amount)
    {
      Console.WriteLine("Starting balance :  " + _balance);
      Console.WriteLine("Withdraw  amount : -" + amount);
      _balance = _balance - amount;
      Console.WriteLine("Current balance :  " + _balance);
      return amount;
    }
    else
    {
      return 0;
    }
  }
}</pre></div></li><li><p>Now let's go back to our <code class="literal">Program</code> class. Make sure to add the following code snippet using directives that are at the top of the <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;</pre></div></li><li><p>Create a static <code class="literal">DoTransactions</code> method for the <code class="literal">Program</code> class. The <code class="literal">DoTransactions</code>
<a id="id454" class="indexterm"></a> method should loop ten times<a id="id455" class="indexterm"></a> doing a withdrawal of a random amount.</p><div class="informalexample"><pre class="programlisting">static void DoTransactions(Account account)
{
  Random r = new Random();
  for (int i = 0; i &lt; 10; i++)
  {
    account.Withdraw((double)r.Next(1, 100));
  }
}</pre></div></li><li><p>Finally, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create a shared account object and two tasks that will concurrently execute the withdrawals. Finish up by waiting for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  Account account = new Account(1000);
  Task task1 = Task.Factory.StartNew(() =&gt; DoTransactions(account));
  Task task2 = Task.Factory.StartNew(() =&gt; DoTransactions(account));
  Console.ReadLine();
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec114"></a>How it worksâ€¦</h3></div></div></div><p>The <code class="literal">lock</code> keyword<a id="id456" class="indexterm"></a> is a c# language shortcut for using the <code class="literal">System.Threading</code>.<code class="literal">Monitor</code> class.<a id="id457" class="indexterm"></a> Basically, the <code class="literal">lock</code> keyword ensures that threads cannot enter a critical section of code while another thread<a id="id458" class="indexterm"></a> is in the critical section; the following is the code contained in the scope of the <code class="literal">lock</code> statement:</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"></a>Tip</h3><p>A critical section is simply a piece of code that accesses a shared resource that must not be concurrently accessed by more than one thread.</p></div><div class="informalexample"><pre class="programlisting">lock (this)
{
  //This is the critical section
}</pre></div><p>If a thread tries to enter a locked section of code, it will block and wait until the locked object is released. The lock will be released when the locking thread exits the scope of the lock. The <code class="literal">lock</code> keyword calls <code class="literal">System.Threading.Monitor.Enter</code> at the start of the scope and <code class="literal">System.Threading.Monitor.Exit</code> at the end of the scope.</p><p>Notice that we created a private lockable object to lock on instead of locking on the instance of the <code class="literal">Account</code> class. This is the best practice. In general, you should avoid locking on a public type or on instances of objects that are beyond your code's control. If another programmer locks your class to synchronize their data, a deadlock can occur. A deadlock is a situation in which two or more competing threads are waiting for each other to finish their work and release a lock, and thus neither one ever does. Note also that locks can only be obtained on reference types.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec63"></a>Using SpinLock for synchronization</h2></div></div><hr /></div><p>
<span class="strong"><strong>SpinLock</strong></span>
<a id="id459" class="indexterm"></a> is a special purpose lock that should only be used when lock contention is relatively rare and when lock-hold times are always very short. Unlike monitor and other lock types that work by using what is essentially a wait event; SpinLock sits in a loop and repeatedly checks until the lock becomes available. The SpinLock can be faster than a monitor lock because it reduces thread context switches. However, because the thread is spinning in a loop, a<a id="id460" class="indexterm"></a> SpinLock can cause high CPU usage if locks are held for a long time.</p><p>In this recipe, we are going to revisit our bank account solution which will have a shared bank account object that will be updated by multiple tasks in parallel. Each of the tasks will have access to the shared account object and will manage concurrency using SpinLock.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec115"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a new Console <a id="id461" class="indexterm"></a>Application and see how to use SpinLock for synchronization, by going through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">SpinBasedLocking</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>After the <code class="literal">Program</code> class, but inside the <code class="literal">SpinBasedLocking</code> namespace, create a very simple definition for an <code class="literal">Account</code> class. This class only needs to have a single <code class="literal">public integer</code> field for the balance.</p><div class="informalexample"><pre class="programlisting">class Account
{
  public int Balance { get; set; }
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's start by creating the shared account object, a <code class="literal">SpinLock</code>, and a list to hold our tasks.</p><div class="informalexample"><pre class="programlisting">var account = new Account();
var spinLock = new SpinLock();
var taskList = new List&lt;Task&gt;();</pre></div></li><li><p>Next, let's add a <code class="literal">for</code> loop to the <code class="literal">Main</code> method that creates five tasks. Each task will loop several times updating the balance and using <code class="literal">SpinLock</code> to manage concurrent access. The <code class="literal">SpinLock</code> should be acquired in a <code class="literal">try</code> block and released in a <code class="literal">finally</code> block.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 5; i++)
{
  taskList.Add(Task.Factory.StartNew(() =&gt;
  {
    for (int x = 0; x &lt; 50; x++)
    {
      bool lockAquired = false;
      try
      {
        spinLock.Enter(ref lockAquired); 
        Thread.Sleep(50);
        account.Balance = account.Balance + 10;
        Console.WriteLine("Task {0} added 10 to the balance.", 
            Thread.CurrentThread.ManagedThreadId);     
      }
      finally
      {
        if(lockAquired) spinLock.Exit();
      }
    }
  }));
}</pre></div></li><li><p>Finish up the <a id="id462" class="indexterm"></a>
<code class="literal">Main</code> method by waiting for all of our tasks to complete and wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(taskList.ToArray());
Console.WriteLine("Expected account balance: 2500,  Actual account balance:      {0}", account.Balance);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output, similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec116"></a>How it worksâ€¦</h3></div></div></div><p>A SpinLock can be useful to avoid blocking in our applications, but if we expect a large amount of blocking, we <a id="id463" class="indexterm"></a>probably shouldn't use SpinLock, as excessive spinning could make the situation much worse. However, if the critical section performs a very minimal amount of work and the wait times for the lock are minimal, then spin locking could be a good choice.</p><p>The <code class="literal">enter</code> method of <code class="literal">SpinLock</code> takes a <code class="literal">Boolean</code> parameter that indicates if the lock was successfully taken. Even in the case of an <code class="literal">Exception</code>, we can examine the <code class="literal">Boolean</code> parameter to reliably determine if the lock was successfully taken.</p><div class="informalexample"><pre class="programlisting">bool lockAquired = false;
try
{
  spinLock.Enter(ref lockAquired); 
  //Critical section                               
}
finally
{
  if(lockAquired) spinLock.Exit();
}</pre></div><p>The <code class="literal">SpinLock</code> should be exited in a <code class="literal">finally</code> block to ensure that the locked is released. You should also use the <code class="literal">Boolean</code> parameter to check if the lock is actually held before exiting because calling <code class="literal">exit</code> on a lock that isn't held will produce an error.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec64"></a>Interlocked operations</h2></div></div><hr /></div><p>Locking is fairly safe in most of the cases but there are cases when locking may not be the safe solution. Some of these cases are incrementing or decrementing the value of a variable, adding to, or subtracting from a variable, and exchanging two variables with each other. These operations seem like atomic operations, but actually are not.</p><p>For example, increment and decrement <a id="id464" class="indexterm"></a>operations include three steps. The first is loading the value of from the variable to a register, the second is incrementing the value of variable, and the third is storing the incremented value back in the variable.</p><p>The problem is that a thread can be pre-empted after the first two steps and another thread can start execution before the incremented value of the variable is saved back in the variable from the register. In the meantime, a second thread can go ahead and execute all three steps. After that, the first thread executes the third step and overwrites the value of the counter variable. Now the operation that was executed by the second thread is lost.</p><p>So how do can we avoid this scenario? This is where interlocking comes in. The <code class="literal">Interlock</code> class provides members that can be used to increment/decrement values, and exchange data between two variables. The <code class="literal">Interlock</code> class provides atomic operations in variables that are shared among multiple concurrent threads.</p><p>In this recipe, we are going to create an application that has a bank account object that will be updated by<a id="id465" class="indexterm"></a> multiple tasks in parallel. Each of the tasks will have access to the shared account object, which has only a public field for the balance. The tasks will use <code class="literal">Interlocked.Add</code> to update the account balance as an atomic operation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec117"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at the following steps on how to use interlocked in a Console Application:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">InterlockedExample</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">InterlockedExample</code> namespace:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>After the <code class="literal">Program</code> class, but inside the <code class="literal">InterlockedExample</code> namespace, create a very simple definition for an <code class="literal">Account</code> class. This class only needs to have a single <code class="literal">public integer</code> field for the balance.</p><div class="informalexample"><pre class="programlisting">class Account
{
  public int Balance = 0;
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's start by creating the shared account object and a list of <code class="literal">Task</code> to hold our tasks.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  var account = new Account();            
  var taskList = new List&lt;Task&gt;();  
}</pre></div></li><li><p>Next, let's add a <code class="literal">for</code> loop to the <code class="literal">Main</code> method that creates five tasks. Each task will loop several times and use <code class="literal">Interlocked.Add</code> to increase the balance of the <code class="literal">Account</code> object as an atomic operation.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 5; i++)
{
  taskList.Add(Task.Factory.StartNew(() =&gt;
  {
    for (int x = 0; x &lt; 50; x++)
    {
      Thread.Sleep(50);
      Interlocked.Add(ref account.Balance, 10);
      Console.WriteLine("Task {0} added 10 to the balance.", 
        Thread.CurrentThread.ManagedThreadId);                       
    }
  }));
}</pre></div></li><li><p>Finish up the <code class="literal">Main</code> <a id="id466" class="indexterm"></a>method by waiting for all of our tasks to complete and wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(taskList.ToArray());
Console.WriteLine("Expected account balance: 2500,  
    Actual account balance: {0}", account.Balance);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see an output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_05.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec118"></a>How it worksâ€¦</h3></div></div></div><p>Interlocked can be used instead of a locking mechanism to provide simpler and fast operations on shared variables.</p><p>The usage of interlocked is<a id="id467" class="indexterm"></a> very simple. You just use its <code class="literal">static</code> method to automatically, add to, subtract from, increment, decrement, or exchange values in a variable.</p><div class="informalexample"><pre class="programlisting">Interlocked.Add(ref account.Balance, 10);</pre></div><p>These <code class="literal">static</code> methods change the math operations to be atomic. This means no other operations can be performed on the value during the call, and the operation won't be affected by context switching between threads.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec65"></a>Synchronizing multiple tasks with a Barrier</h2></div></div><hr /></div><p>When you need some tasks to perform a series of parallel phases, and each phase needs to start, after all other tasks <a id="id468" class="indexterm"></a>complete the previous phase, you can synchronize and coordinate this work using a barrier. In short, a barrier prevents individual tasks from continuing until all tasks reach the barrier.</p><p>Each task in the group is<a id="id469" class="indexterm"></a> referred to as a participant, and signals that it has reached the barrier in each phase and is waiting for all the other participants to signal their arrival at the barrier before continuing. Optionally, you can also specify a time out to avoid the deadlock that will occur if one task fails to reach the barrier.</p><p>In this recipe, we are going to create a Console Application that has four participant tasks that execute a method with a <code class="literal">for</code> loop. Each iteration of the loop is a phase controlled by the barrier. The tasks will signal when they have reached the barrier and wait for all of the other tasks before continuing.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec119"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a new Console Application and take a look at the following steps on how to synchronize tasks with Barrier:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">Barrier</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, in the <code class="literal">Program</code> class, let's use a <code class="literal">static</code> method called <code class="literal">OperationWithBarrier</code> that accepts a parameter of a <code class="literal">Barrier</code> object.</p><div class="informalexample"><pre class="programlisting">static void OperationWithBarrier(Barrier barrier)
{
  
}</pre></div></li><li><p>Now, in the body <a id="id470" class="indexterm"></a>of the <code class="literal">OperationWithBarrier</code> method, let's create a <code class="literal">for</code> loop that loops three times. In each loop, <a id="id471" class="indexterm"></a>get the <code class="literal">threadId</code> of the executing thread and then signal that the thread has reached the barrier.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 3; ++i)
{
  var threadId = Thread.CurrentThread.ManagedThreadId;
  Console.WriteLine("Thread {0} has reached wait.", threadId);
  barrier.SignalAndWait(100);
  Console.WriteLine("Thread {0} after wait wait.", threadId);
}</pre></div></li><li><p>Back in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's create a <code class="literal">Barrier</code> object that has four participants and a post-phase action that writes to the Console when each barrier phase is reached.</p><div class="informalexample"><pre class="programlisting">var barrier = new Barrier(4, (b) =&gt; 
  Console.WriteLine("Barrier phase {0} reached.", b.CurrentPhaseNumber));</pre></div></li><li><p>Now let's start four new tasks, each of which runs <code class="literal">OperationWithBarrier</code> passing in the <code class="literal">Barrier</code> object we just created at the parameter.</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt; OperationWithBarrier(barrier));
var task2 = Task.Factory.StartNew(() =&gt; OperationWithBarrier(barrier));
var task3 = Task.Factory.StartNew(() =&gt; OperationWithBarrier(barrier));
var task4 = Task.Factory.StartNew(() =&gt; OperationWithBarrier(barrier));</pre></div></li><li><p>Finally, let's wait for all of our tasks to complete and wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(task1, task2, task3, task4);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_01.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec120"></a>How it worksâ€¦</h3></div></div></div><p>When you create a <code class="literal">Barrier</code>, specify the number of participants; in our case four. The <code class="literal">Barrier</code> constructor also has<a id="id472" class="indexterm"></a> an overload that allows you to specify a post phase action of type <code class="literal">Action&lt;Barrier&gt;</code>. This action will fire after all<a id="id473" class="indexterm"></a> the four tasks signal have reached the barrier.</p><div class="informalexample"><pre class="programlisting">Barrier barrier = new Barrier(4, (b) =&gt; 
  Console.WriteLine("Barrier phase {0} reached.", b.CurrentPhaseNumber));</pre></div><p>Each of the four tasks signals reach the barrier and wait for the other tasks by calling the <code class="literal">Barrier.SignalAndWait</code> method.</p><div class="informalexample"><pre class="programlisting">barrier.SignalAndWait(100);</pre></div><p>A deadlock will occur if one participant's task fails to reach the barrier because the tasks that reach the barrier will wait indefinitely for the fourth call to <code class="literal">Barrier.SignalAndWait</code>. To avoid these deadlocks, we used one of the overloads of the <code class="literal">SignalAndWait</code> method<a id="id474" class="indexterm"></a> that specifies a time out. After the time out the remaining tasks are free to continue to the next phase.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec66"></a>Using ReaderWriterLockSlim</h2></div></div><hr /></div><p>The <code class="literal">ReaderWriterLockSlim</code> class is used to protect a resource that is read by multiple threads and written to by one thread at a <a id="id475" class="indexterm"></a>time.</p><p>
<code class="literal">ReaderWriterLockSlim</code> allows a thread to enter one of the following three modes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Read mode</strong></span>: Allows multiple threads to enter the lock as long as there is no thread currently holding a write lock <a id="id476" class="indexterm"></a>or waiting to acquire a write lock. If there are any threads that are holding or waiting for a write lock, the threads waiting to enter in read mode are blocked.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Upgradeable mode</strong></span>: Intended for <a id="id477" class="indexterm"></a>cases where a thread usually performs reads and might also occasionally perform writes.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Write mode</strong></span>: Only one<a id="id478" class="indexterm"></a> thread can be in write mode at a time. A thread waiting to enter the lock in write mode will block if there is a thread currently holding a lock in write mode or waiting to enter write mode. If there are threads in read mode, the thread that is upgrading to write mode will block.</p></li></ul></div><p>In this recipe, we are going to build a Console Application that creates a writer task to write numeric values to an array. The application will also start up three reader tasks that read the values that were written to the array and append the values to a string using <code class="literal">StringBuilder</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec121"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how to use <code class="literal">ReaderWriterLockSlim</code> by having a look at the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ReaderWriter</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class which our writer task will call to write values to an array. The <code class="literal">write</code> method will ask to enter the lock in write mode and will loop a few times writing the square of the loop <a id="id479" class="indexterm"></a>index to the array.</p><div class="informalexample"><pre class="programlisting">static void Write()
{
  int id = Thread.CurrentThread.ManagedThreadId;
  for (int i = 0; i &lt; MaxNumberValues; ++i)
  {
    _lock.EnterWriteLock();
    Console.WriteLine("Entered WriteLock on thread {0}", id);
    _array[i] = i*i;
    Console.WriteLine("Added {0} to array on thread {1}", 
        _array[i], id);

    Console.WriteLine("Exiting WriteLock on the thread {0}", 
        id);
    _lock.ExitWriteLock();
    Thread.Sleep(1000);
  }
}</pre></div></li><li><p>Now let's create another <code class="literal">static</code> method<a id="id480" class="indexterm"></a> on the <code class="literal">Program</code> class called <code class="literal">Read</code> that our reader tasks will use to read the values from the array and append the values to a string using <code class="literal">StringBuilder</code>. The <code class="literal">Write</code> method will request a reader lock and loop through the values of the array, writing the values to the output string.</p><div class="informalexample"><pre class="programlisting">static void Read()
{
  int idNumber = Thread.CurrentThread.ManagedThreadId;
  for (int i = 0; i &lt; MaxNumberValues; ++i)
  {
    _lock.EnterReadLock();
    Console.WriteLine("Entered ReadLock on the thread {0}", 
              idNumber);
    StringBuilder sbObj = new StringBuilder();
    for (int j = 0; j &lt; i; j++)
    {
      if (sbObj.Length &gt; 0) sbObj.Append(", ");
      sbObj.Append(_array[j]);
    }
    Console.WriteLine("Array: {0} on the thread {1}", sbObj, 
              idNumber);
    Console.WriteLine("Exiting the ReadLock on thread {0}", 
              idNumber);
    _lock.ExitReadLock();
    Thread.Sleep(2000);
  }
}</pre></div></li><li><p>Next, at the top of the <code class="literal">Program</code> class, let's create a constant for the maximum number of values and a couple of static fields for the array and the lock.</p><div class="informalexample"><pre class="programlisting">const int MaxNumberValues = 5;
static int[] _array = new int[MaxNumberValues];
static ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();</pre></div></li><li><p>Now we need<a id="id481" class="indexterm"></a> to create the <code class="literal">Main</code> method of our <code class="literal">program</code> class. The <code class="literal">Main</code> method will have a list of tasks that we can use to wait. We will need to create a single writer task that calls the <code class="literal">write</code> method and will do a loop to create three reader tasks which will call the <code class="literal">reader</code> method. Finish up by waiting for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  var taskList = new List&lt;Task&gt;();
  taskList.Add(Task.Factory.StartNew(() =&gt; Write()));
  Thread.Sleep(1000);
  for (int i = 0; i &lt; 3; i++)
  {
    taskList.Add(Task.Factory.StartNew(()=&gt;Read()));
  }
  Task.WaitAll(taskList.ToArray());
  Console.WriteLine("Finished. Press &lt;Enter&gt; to exit.");
  Console.ReadKey();
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Notice the ordered results in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec122"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">ReaderWriterLockSlim</code> allows multiple threads to be in read mode; allows one thread to be in write mode with an exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode.</p><p>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode. In our Console <a id="id482" class="indexterm"></a>Application, the <code class="literal">Write</code> method requests to enter the lock in write mode by calling the <code class="literal">EnterWriteLock</code> method and the <code class="literal">Read</code> method enters the read mode by calling the <code class="literal">EnterReadLock</code> method<a id="id483" class="indexterm"></a>.</p><p>Only one thread can be in write mode at any time. When a thread is in write mode, no other thread can enter the lock in any mode. So, any of our reader tasks will block if a writer lock is currently held. Once our writer task releases the write lock by calling the <code class="literal">ExitWriteLock</code> method, multiple reader tasks will be able to obtain a read lock and enter the critical section.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec67"></a>Using WaitHandles with Mutex</h2></div></div><hr /></div><p>A <span class="strong"><strong>Mutex</strong></span>
<a id="id484" class="indexterm"></a> is like a lock, but it can work across multiple processes. A Mutex is a synchronization primitive<a id="id485" class="indexterm"></a> that can also be used for inter-process synchronization. When two or more threads need to access a shared resource at the <a id="id486" class="indexterm"></a>same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. Mutex is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a Mutex, the second thread that wants to acquire that Mutex is suspended until the first thread releases the Mutex.</p><p>In this recipe, we are going to return to our bank account example and build a Console Application that <a id="id487" class="indexterm"></a>creates several tasks to update the balance on a shared bank account object. The tasks<a id="id488" class="indexterm"></a> will use a Mutex to provide <a id="id489" class="indexterm"></a>access to the balance for a single task at a time.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec123"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a new Console Application and see how to use Mutex by having a look at the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">MutexExample</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>After the <code class="literal">Program</code> class, but inside the <code class="literal">MutexExample</code> namespace, create a very simple definition for an <code class="literal">Account</code> class. This class only needs to have a single <code class="literal">public integer</code> field for the balance.</p><div class="informalexample"><pre class="programlisting">class Account
{
  public int Balance { get; set; }
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's start by creating the shared account object, a <code class="literal">Mutex</code>, and a list of <code class="literal">Task</code> to hold our tasks.</p><div class="informalexample"><pre class="programlisting">var account = new Account();
var mutex = new Mutex();
var taskList = new List&lt;Task&gt;();</pre></div></li><li><p>Next, let's add a <code class="literal">for</code> loop to the <code class="literal">Main</code> method that creates five tasks. Each task will loop several times updating the balance and using <code class="literal">Mutex</code> to manage concurrent access. The <code class="literal">Mutex</code> should be acquired in a <code class="literal">try</code> block and released in a <code class="literal">finally</code> block.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 5; i++)
{
  taskList.Add(Task.Factory.StartNew(() =&gt;
  {
    for (int x = 0; x &lt; 50; x++)
    {
      bool lockAquired = false;
      try
      {
        lockAquired = mutex.WaitOne();
        Thread.Sleep(50);
        account.Balance = account.Balance + 10;
        Console.WriteLine("Task {0} added 10 to the balance.", 
          Thread.CurrentThread.ManagedThreadId);
      }
      finally
      {
        if (lockAquired) mutex.ReleaseMutex();
      }
    }
  }));
}</pre></div></li><li><p>Finish up the <code class="literal">Main</code> method<a id="id490" class="indexterm"></a> by waiting for all <a id="id491" class="indexterm"></a>of our tasks to complete and wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.WaitAll(taskList.ToArray());
Console.WriteLine("Expected account balance: 2500,  
      Actual account balance: {0}", account.Balance);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec124"></a>How it worksâ€¦</h3></div></div></div><p>Basically, a Mutex is a mechanism that acts as a flag to prevent two threads from performing one or<a id="id492" class="indexterm"></a> more actions simultaneously.</p><p>With a <code class="literal">Mutex</code> class, <a id="id493" class="indexterm"></a> you call the <code class="literal">WaitHandle.WaitOne</code> method to lock. The <code class="literal">WaitOne</code> method<a id="id494" class="indexterm"></a> takes a <code class="literal">Boolean</code> parameter that indicates if the lock was successfully taken. Even in the case of an <code class="literal">Exception</code>, you can examine the<a id="id495" class="indexterm"></a> <code class="literal">Boolean</code> parameter to reliably determine if the lock was successfully taken.</p><div class="informalexample"><pre class="programlisting">bool lockAquired = false;
try
{
  lockAquired = mutex.WaitOne(); 
  //Critical section                               
}
finally
{
  if(lockAquired) mutex.ReleaseMutex();
}</pre></div><p>Closing or disposing a <code class="literal">Mutex</code> automatically releases it. Just as with the lock statement, a Mutex can be released only from the same thread that obtained it. The <code class="literal">Mutex</code> should be released in a <code class="literal">finally</code> block to ensure that the locked is released. You should also use the <code class="literal">Boolean</code> parameter to check if the <code class="literal">Mutex</code> is actually held before exiting because calling <code class="literal">ReleaseMutex</code> on a <code class="literal">Mutex</code> that isn't held will produce an error.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec68"></a>Waiting for multiple threads with CountdownEvent</h2></div></div><hr /></div><p>A common asynchronous pattern is the pattern known as fork/join parallelism. This typically manifests by starting a number of pieces of work and later joining with that work.</p><p>A <code class="literal">CountdownEvent</code> is<a id="id496" class="indexterm"></a> initialized with a count. Threads can block waiting on the event until the count reaches <code class="literal">0</code>, at which point the <code class="literal">CountdownEvent</code> will be set and the threads can proceed.</p><p>In this recipe, we will create a Console Application that performs some simulated work in a loop. We will initialize a <code class="literal">CountdownEvent</code> to a small number of tasks, and then start simulating the work with the specified number of tasks. Each task will decrement the <code class="literal">CountDownEvent</code>. When the <code class="literal">CountDownEvent</code> reaches <code class="literal">0</code> and is signaled, we will reset the <code class="literal">CountDownEvent</code> with a higher count and start over until we reach the maximum number of tasks.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec125"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at using <code class="literal">CoundownEven</code>t to wait for multiple threads. Have a look at the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ForkAndJoin</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>At the beginning of your <code class="literal">Program</code> class, start by creating a static variable for the <code class="literal">CountdownEvent</code> and a couple of constants for the number of tasks we want to start with and the number of tasks we want to finish with.</p><div class="informalexample"><pre class="programlisting">private static CountdownEvent _countdownEvent;
private const int BEGIN_TASKS = 2;
private const int END_TASKS = 6;</pre></div></li><li><p>At the bottom of the <code class="literal">Program</code> class, after the <code class="literal">Main</code> method, create a new <code class="literal">static</code> method called <code class="literal">SimulateWork</code>. This method will take an <code class="literal">integer</code> parameter which represents the number of tasks to create. The method will then loop to create the number of tasks specified. The tasks will just sleep for a bit and write a message to the Console. When the tasks are finished executing, <a id="id497" class="indexterm"></a>to call the <code class="literal">Signal</code> method of the <code class="literal">CountdownEvent</code> to decrement the count.</p><div class="informalexample"><pre class="programlisting">private static void SimulateTasks(int taskCount)
{
  for (int i = 0; i &lt; taskCount; i++)
  {
    Task.Factory.StartNew((num) =&gt;
      {
        try
        {
          var taskNumber = (int)num;
          Thread.Sleep(2500);
          Console.WriteLine("Task {0} simultated.", 
              taskNumber);
        }
        finally
        {
          _countdownEvent.Signal();
        }
      },i);
  }
}</pre></div></li><li><p>In the <code class="literal">Main</code> method of your <code class="literal">Program</code> class, start with instantiating the <code class="literal">CountdownEvent</code> object. Pass in the <code class="literal">Begin_Tasks</code> constant to the <code class="literal">CountdownEvent</code> constructor so that the event will be signaled after two tasks.</p><div class="informalexample"><pre class="programlisting">_countdownEvent = new CountdownEvent(BEGIN_TASKS);</pre></div></li><li><p>Next, in the <code class="literal">Main</code> method, create a task that executes a <code class="literal">for</code> loop. Each iteration of the loop should reset the <code class="literal">CountdownEvent</code> to the number of tasks we want to wait for. Then the task will call the <code class="literal">SimulateWork</code> method and wait for the tasks to finish by calling the <code class="literal">Wait</code> method of <code class="literal">CountdownEvent</code>.</p><div class="informalexample"><pre class="programlisting">var task1 = Task.Factory.StartNew(() =&gt;
{
  for (int i = BEGIN_TASKS; i &lt;= END_TASKS; i++)
  {
    Console.WriteLine("**** Start simulating {0} tasks.", i);
    _countdownEvent.Reset(i);
    SimulateTasks(i);
    _countdownEvent.Wait();
    Console.WriteLine("**** End simulating {0} tasks.", i);
  }
});</pre></div></li><li><p>Finish up the <code class="literal">Main</code> method by waiting for the previous task to complete in a <code class="literal">try</code> block and disposing of the <code class="literal">CountdownEvent</code> in a <code class="literal">finally</code> block. Wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">try
{
  task1.Wait();
  Console.WriteLine("Finished. Press &lt;Enter&gt; to exit.");
}
finally
{
  _countdownEvent.Dispose();
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio <a id="id498" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec126"></a>How it worksâ€¦</h3></div></div></div><p>The main feature of <code class="literal">CoutndownEvent</code>, as you have already seen, is that it can be used to signal when several tasks have been completed.</p><p>The constructor for <code class="literal">CountDownEvent</code> accepts an <code class="literal">integer</code> parameter to specify the initial count of signals that we want to wait for before triggering the event. In our case, we passed in a constant value that is equal to two.</p><div class="informalexample"><pre class="programlisting">_countdownEvent = new CountdownEvent(BEGIN_TASKS);</pre></div><p>The number of <a id="id499" class="indexterm"></a>events we are waiting for can be reset by calling the <code class="literal">Reset</code> method as we have done in our <code class="literal">for</code> loop. Each iteration of the <code class="literal">for</code> loop increases the number of events we are waiting for, up to the maximum number which we specified in another constant.</p><div class="informalexample"><pre class="programlisting">for (int i = BEGIN_TASKS; i &lt;= END_TASKS; i++)
{
  Console.WriteLine("**** Start simulating {0} tasks.", i);
<span class="strong"><strong>  _countdownEvent.Reset(i);</strong></span>
  SimulateTasks(i);
<span class="strong"><strong>  _countdownEvent.Wait();</strong></span>
  Console.WriteLine("**** End simulating {0} tasks.", i);
}</pre></div><p>After calling the <code class="literal">SimulateWork</code> method with the desired number of tasks to spin up, we wait for the tasks to complete by calling the <code class="literal">WaitMethod</code> on the <code class="literal">CountdownEvent</code>.</p><p>Finally, in the <code class="literal">SimulateWork</code> method<a id="id500" class="indexterm"></a>, each task indicates that it has completed and decrements the count of the signals we are waiting for by calling the <code class="literal">Signal</code> method of <code class="literal">CountDownEvent</code>.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew((num) =&gt;
{
  try
  {
    var taskNumber = (int)num;
    Thread.Sleep(2500);
    Console.WriteLine("Task {0} simultated.", taskNumber);
  }
  finally
  {
<span class="strong"><strong>    _countdownEvent.Signal();</strong></span>
  }
},i);</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec69"></a>Using ManualResetEventSlim to spin and wait</h2></div></div><hr /></div><p>
<code class="literal">ManualResetEventSlim</code>, a light-weight synchronization <a id="id501" class="indexterm"></a>primitive that was introduced in .NET Framework 4.0, allows threads to communicate with each other by signaling.</p><p>When a task begins an activity that it must complete before other tasks proceed, it calls <code class="literal">Reset</code> to put <code class="literal">ManualResetEventSlim</code> in the non-signaled state. This thread can be thought of as controlling the reset event. Tasks that call the <code class="literal">Wait</code> method of <code class="literal">ManualResetEventSlim</code> will block, awaiting the signal. When the controlling thread completes the activity, <a id="id502" class="indexterm"></a>it calls <code class="literal">Set</code> to signal that the waiting threads can proceed. All waiting threads are then released.</p><p>In this recipe, the main application thread will create a <code class="literal">ManualResetEventSlim</code> to coordinate five tasks that it spins up. The tasks will call the <code class="literal">Wait</code> method of the reset event and wait for the event to be signaled. After sleeping for a bit, the main thread will wake up and call the <code class="literal">Set</code> method of the reset event to release all of the other tasks to proceed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec127"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's take a look at how to use <code class="literal">ManualResetEventSlim</code> by going through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">SpinAndWait</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's create a <code class="literal">static</code> method on the <code class="literal">Program</code> class that will use a <code class="literal">for</code> loop to create and start five tasks. Each task will sleep for two seconds, write a message to the Console, and wait for the main thread to set the <code class="literal">ManualResetEventSlim</code>.</p><div class="informalexample"><pre class="programlisting">private static void StartTasks()   
{   
  for (int i = 0; i &lt; 5; i++)   
  {
    Task.Factory.StartNew(()=&gt;
    {   
      Thread.Sleep(2000);   
      Console.WriteLine("Task {0} waiting for event...", 
        Thread.CurrentThread.ManagedThreadId);   
      resetEvent.Wait();   
      Console.WriteLine("Task {0} event signalled", 
        Thread.CurrentThread.ManagedThreadId);   
    } );   
  }               
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method, create a <code class="literal">ManualResetEventSlim</code> object, and call the <code class="literal">StartTasks</code> method.</p><div class="informalexample"><pre class="programlisting">resetEvent = new ManualResetEventSlim(false); 
StartTasks();</pre></div></li><li><p>Now, put the main thread to sleep for a second and then call the <code class="literal">Set</code> method of the reset event object to the tasks that are waiting.</p><div class="informalexample"><pre class="programlisting">Thread.Sleep(1000);
Console.WriteLine("Main thread setting event");
resetEvent.Set();</pre></div></li><li><p>Next, sleep<a id="id503" class="indexterm"></a> the main thread for <code class="literal">500</code> ms and then call the <code class="literal">Reset</code> method of the reset event object to stop any more tasks from continuing.</p><div class="informalexample"><pre class="programlisting">Thread.Sleep(500);
Console.WriteLine("Main thread re-setting event");
resetEvent.Reset();</pre></div></li><li><p>Finally, sleep the main thread for another second, the call the <code class="literal">Set</code> method of the reset event to release the waiting tasks. Wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">Thread.Sleep(1000);
Console.WriteLine("Main thread setting event again");
resetEvent.Set();

Console.WriteLine("Finished. Press &lt;Enter&gt; to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_10.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec128"></a>How it worksâ€¦</h3></div></div></div><p>
<code class="literal">ManualResetEventSlim</code> functions like a gate. When you call the <code class="literal">Set</code> method, you open the up the gate, allowing <a id="id504" class="indexterm"></a>any tasks that have called the <code class="literal">Wait</code> method to start running. Calling <code class="literal">Reset</code> closes the gate and any task that calls <code class="literal">Wait</code> will block, waiting for the event to be set. When the gate is next opened, they will all be released again at once.</p><p>The code is pretty simple. We create five tasks and each of the tasks call the <code class="literal">Wait</code> method of the reset event object and block, waiting for the event to be set.</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(()=&gt;
{   
  ...   
  resetEvent.Wait();   
  ...   
} );</pre></div><p>The main thread then goes to sleep for a second, releasing the currently blocking tasks to run. Then we sleep for a bit more, reset, and set the event again, releasing the remaining tasks.</p><p>
<code class="literal">ManualResetEventSlim</code> is optimized for short waiting times and has the ability to opt into spinning for a set number of iterations. It also has a more efficiently managed implementation and allows a <code class="literal">Wait</code> to be cancelled via a <code class="literal">CancellationToken</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec70"></a>Using SemaphoreSlim to limit access</h2></div></div><hr /></div><p>A semaphore works by keeping a counter. Each time a thread obtains the semaphore, the counter is reduced and each time the thread returns the semaphore, it is increased.</p><p>
<code class="literal">SemaphoreSlim</code> is a lightweight semophore that limits the number of threads that can access a resource or resources <a id="id505" class="indexterm"></a>concurrently. A task that calls the <code class="literal">Wait</code> method of a <code class="literal">SemaphoreSlim</code> object will block until the semaphore counter is below the number of requests the semaphore can grant, which is specified in the constructor.</p><p>In this recipe, the main application thread will use a <code class="literal">for</code> loop to create five tasks. Each of the tasks call a method that waits in a <code class="literal">SemaphoreSlim</code> object before allowing access to a simulated shared resource.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec129"></a>How to do itâ€¦</h3></div></div></div><p>Let's finish up the chapter by seeing how to use <code class="literal">SemaphoreSlim</code> to limit access to a shared resource. Have a look at the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">SemaphoreSlimExample</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following code snippet using directives to the top of your program class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>First, let's create a <code class="literal">static</code> method on the <code class="literal">Program</code> class that each of our threads will call in order to access a simulated shared resource. This method will call the <code class="literal">Wait</code> method<a id="id506" class="indexterm"></a> of a <code class="literal">SemaphoreSlim</code> object, which will only grant access to three tasks at a time.</p><div class="informalexample"><pre class="programlisting">static void Enter(object id)
{
  Console.WriteLine("Task {0} is trying to enter.",id);
  _semaphoreSlim.Wait();
  Console.WriteLine("Task {0} has entered.", id);   
  Thread.Sleep(2000); //Shared resource           
  Console.WriteLine("Task {0} is leaving.", id); 
  _semaphoreSlim.Release();
}</pre></div></li><li><p>Now, previously to the <code class="literal">Main</code> method, create a static <code class="literal">SemaphoreSlim</code> object field on the <code class="literal">Program</code> class that will grant three access requests.</p><div class="informalexample"><pre class="programlisting">static SemaphoreSlim _semaphoreSlim = new SemaphoreSlim(3);</pre></div></li><li><p>The <code class="literal">Main</code> method <a id="id507" class="indexterm"></a>just needs to create and start five tasks in a <code class="literal">for</code> loop. The tasks only need to call the <code class="literal">Enter</code> method. Now, wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">for (int i = 1; i &lt;= 5; i++)
{
  Task.Factory.StartNew((num) =&gt;
    {
      Enter(num);
    }, i);
}
Console.ReadLine();</pre></div></li><li><p>In Visual Studio <a id="id508" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_06_10.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec130"></a>How it worksâ€¦</h3></div></div></div><p>A semaphore is an enforcement of access limitation to a shared resource. Once it's full, no more tasks can enter the semaphore until one or more tasks complete and get terminated. A queue builds up outside for other tasks. Then, for each task that leaves the semaphore, another enters from the queue.</p><p>Using <code class="literal">SemaphoreSlim</code> is an easy two-step process. First you need to create a <code class="literal">SemaphoreSlim</code> object that all of your threads have visibility to. Use the constructor to specify the number of requests the semaphore can grant concurrently.</p><div class="informalexample"><pre class="programlisting">static SemaphoreSlim _semaphoreSlim = new SemaphoreSlim(3);</pre></div><p>Before accessing a shared <a id="id509" class="indexterm"></a>resource, call the <code class="literal">Wait</code> method <a id="id510" class="indexterm"></a>on the semaphore method. Execution will continue into the shared resource for the specified number of tasks. All other tasks will block until one of the current tasks exits. Exiting tasks release the semaphore and decrement the request count by calling the<a id="id511" class="indexterm"></a> <code class="literal">Release</code> method.</p><div class="informalexample"><pre class="programlisting">static void Enter(object id)
{
	 _semaphoreSlim.Wait();
	//Shared resource   
	_semaphoreSlim.Release();
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch07"></a>ChapterÂ 7.Â Profiling and Debugging</h2></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using the Threads and Call Stack windows</p></li><li style="list-style-type: disc"><p>Using the Parallel Stacks window</p></li><li style="list-style-type: disc"><p>Watching values in a thread with Parallel Watch window</p></li><li style="list-style-type: disc"><p>Detecting deadlocks with the parallel tasks window</p></li><li style="list-style-type: disc"><p>Measuring CPU utilization with Concurrency Visualizer</p></li><li style="list-style-type: disc"><p>Using Concurrency Visualizer Threads view</p></li><li style="list-style-type: disc"><p>Using Concurrency Visualizer Cores view </p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec71"></a>Introduction</h2></div></div><hr /></div><p>Parallel programming can create complex problems. Maybe you didn't get the performance gain you expected from parallelizing your application. It could even be running slower that a sequential version of the same algorithm. Maybe you are getting consistently or occasionally incorrect results.</p><p>The problems that can occur in a parallel program are numerous and can be hard to detect. Perhaps oversubscription is causing poor performance because of the high number of context switches. Maybe you have inadvertently created a lock convoy, which is a condition that occurs when multiple threads of equal priority contend repeatedly for the same lock, and can lead to significant lock contention and serialization of the program even though multiple threads are in use.</p><p>In this chapter, we are going to take a look at the Visual Studio 2012 debugging features for multi-threaded applications, and how to use those features to solve concurrency related issues.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec72"></a>Using the Threads and Call Stack windows</h2></div></div><hr /></div><p>When we want a thread-centric view of our application, the Threads window is the place to start. We can use the <a id="id512" class="indexterm"></a>Threads window to see the location of all of our threads, see the thread call stack, and more. We can use the Call Stack window to view<a id="id513" class="indexterm"></a> the stack frames of our application, or the function, or procedure calls that are currently on the stack.</p><p>In this recipe, we are going to see how to use the Threads and Call Stack windows in Visual Studio 2012 to view the call stack information for the threads in our application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec131"></a>Getting readyâ€¦</h3></div></div></div><p>Before we<a id="id514" class="indexterm"></a> start looking at the debugging features of Visual Studio 2012, we need an application to debug. Let's create a <code class="literal">Console</code> application that spins up a few tasks so we <a id="id515" class="indexterm"></a>can take a look at their call stack information.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">LockExample</code> as the <span class="strong"><strong>Solution name.</strong></span>
</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start by creating a few <code class="literal">static</code> methods on the <code class="literal">Program</code> class. Add a method named <code class="literal">Method1</code> that loops three times, creating tasks. The tasks just need to call <code class="literal">Method2</code> with an <code class="literal">integer</code> parameter.</p><div class="informalexample"><pre class="programlisting">static void Method1()
{
  Console.WriteLine("In Method1.");
  for (int i = 0; i &lt; 3; i++)
  {
    Task.Factory.StartNew(index =&gt; Method2((int)index), i);               
  }
}</pre></div></li><li><p>Now create a method named <code class="literal">Method2</code>. <code class="literal">Method2</code> just adds a random number to the parameter, writes the parameter to <code class="literal">Console</code>, and calls <code class="literal">Method4</code>.</p><div class="informalexample"><pre class="programlisting">static void Method2(int number)
{
  Random rnd = new Random();
  var sum = number + rnd.Next(1,10);
  Console.WriteLine("In Method2. Value:{0}", sum);
  Method4(sum);            
}</pre></div></li><li><p>Next create <code class="literal">Method3</code>, which just starts a third task that calls <code class="literal">Method2</code>.</p><div class="informalexample"><pre class="programlisting">static void Method3()
{
  Console.WriteLine("In Method3.");
  for (int i = 0; i &lt; 3; i++)
  {
    Task.Factory.StartNew(() =&gt;
    {
      Task.Factory.StartNew(index =&gt; Method2((int)index), i);
    });
    Thread.Sleep(10);
  }
  
}</pre></div></li><li><p>Lastly, <a id="id516" class="indexterm"></a>create <code class="literal">Method4</code> which contains our breakpoint.</p><div class="informalexample"><pre class="programlisting">static void Method4(int number)
{
  Console.WriteLine("In Method4.", number);
  Debugger.Break();
}</pre></div></li><li><p>In the <code class="literal">Main</code> method,<a id="id517" class="indexterm"></a> create a task that calls <code class="literal">Method1</code> and <code class="literal">Task</code> that calls <code class="literal">Method3</code>. Wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">static void Main()
{
  var task1 = Task.Factory.StartNew(() =&gt; Method1());
  var task2 = Task.Factory.StartNew(() =&gt; Method3());
  Console.ReadLine();
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec132"></a>How to do itâ€¦</h3></div></div></div><p>Let's start a debugging<a id="id518" class="indexterm"></a> session and take a look at the window.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</p></li><li><p>When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu of Visual Studio 2012, and click on <span class="strong"><strong>Windows</strong></span>, and click on <span class="strong"><strong>Call Stack</strong></span> to view the <span class="strong"><strong>Threads</strong></span> window.</p></li><li><p>The active thread is the thread that is currently selected in the <span class="strong"><strong>Threads</strong></span> window, indicated by the arrow icon. By default, the active thread is the one that hits the <a id="id519" class="indexterm"></a>breakpoint. Switch the active thread via the <span class="strong"><strong>Threads</strong></span> window by double-clicking on a different thread in the view.</p><div class="mediaobject"><img src="graphics/0225OT_07_07.jpg" /></div></li><li><p>Go back to the <span class="strong"><strong>Debug</strong></span> menu, click on <span class="strong"><strong>Windows,</strong></span> and click on <span class="strong"><strong>Threads</strong></span> to show the <span class="strong"><strong>Call</strong></span> <span class="strong"><strong>Stack</strong></span> window.</p></li><li><p>The <span class="strong"><strong>Call Stack</strong></span> window indicates the top of stack of the active thread with a arrow icon. This is known as the active stack frame. When switching threads, the active stack frame changes. When execution resumes, the execution continues from the active stack frame onwards.</p><div class="mediaobject"><img src="graphics/0225OT_07_08.jpg" /></div></li><li><p>The current stack frame is the stack frame that drives the rest of the debugger tools and windows. Change the current stack frame by double-clicking on a different entry in the <span class="strong"><strong>Call Stack</strong></span> window. When changing the current stack frame to be something other than the active stack frame, it shows a tapered arrow.</p><div class="mediaobject"><img src="graphics/0225OT_07_09.jpg" /></div></li><li><p>You can <a id="id520" class="indexterm"></a>navigate to the source code for any entry in stack frame. In the <span class="strong"><strong>Call Stack</strong></span> window, right-click on the function whose source code you want to see and click on <span class="strong"><strong>Go To Source Code</strong></span> from the shortcut menu.</p><div class="mediaobject"><img src="graphics/0225OT_07_10.jpg" /></div></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec73"></a>Using the Parallel Stacks window</h2></div></div><hr /></div><p>As the degree of parallelism in our applications continues to grow, we need the ability to view and navigate multiple threads<a id="id521" class="indexterm"></a> call stacks from a single view. A developer debugging a multi-threaded application needs the ability to view call stacks of multiple threads at the same time, in order to see an overall picture of the application's status.</p><p>In this recipe, we will see how to use the Parallel Stacks window in Visual Studio 2012 to get a graphical view of the call stacks of all tasks in our application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec133"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's go back to Visual Studio 2012 and take a look at the Parallel Stacks window.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In Visual Studio<a id="id522" class="indexterm"></a> 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</p></li><li><p>When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu, click on <span class="strong"><strong>Windows</strong></span>, and click on <span class="strong"><strong>Parallel Stacks</strong></span> to display the <span class="strong"><strong>Parallel Stacks</strong></span> window.</p><div class="mediaobject"><img src="graphics/0225OT_07_01.jpg" /></div></li><li><p>Your <span class="strong"><strong>Parallel Stacks</strong></span> view may differ slightly from the image, but you can see the call stacks of all of our tasks in a single graph view. The Parallel Stacks window in the preceding screenshot shows that we have one thread that went from an anonymous method in <code class="literal">Main</code> to <code class="literal">Method3</code>, as was called out to <span class="strong"><strong>External Code</strong></span>. One thread is in <code class="literal">Main</code>, and had gone out to the <span class="strong"><strong>External Code</strong></span>. Two other threads started, have gone through an anonymous method in <code class="literal">Method1</code>, through <code class="literal">Method2</code>, to <code class="literal">Method4</code>. This is also the active stack frame and this is the current thread, as indicated by the flag on the active thread. Visual Studio 2012 groups threads that have the same call stack information together into the same box.</p></li><li><p>Hover your mouse over the boxes and notice the tool tips that show the stack frame information, including method name and parameter values for each thread grouped into the box.</p><div class="mediaobject"><img src="graphics/0225OT_07_02.jpg" /></div></li><li><p>You can <a id="id523" class="indexterm"></a>double-click on any item in the stack frame of the thread to navigate to the code.</p><div class="mediaobject"><img src="graphics/0225OT_07_03.jpg" /></div></li><li><p>To switch to another thread, right-click on the stack frame of the desired thread and click on <span class="strong"><strong>Switch To Frame</strong></span>. Notice that highlight has changed to the selected stack frame, and there is a green arrow in the box indicating that this is the current stack frame that the debugger is focusing on, as opposed to the active stack frame which is indicated by an arrow.</p><div class="mediaobject"><img src="graphics/0225OT_07_04.jpg" /></div></li><li><p>You can switch back<a id="id524" class="indexterm"></a> to the active stack frame by double-clicking on it in the <span class="strong"><strong>Parallel Stacks</strong></span> windows. Notice that it has a thread icon rather than an arrow while the different stack frame has the focus of the debugger. Once you double-click on it, the arrow returns, indicating that this is the active and current thread.</p><div class="mediaobject"><img src="graphics/0225OT_07_05.jpg" /></div></li><li><p> You can see the <span class="strong"><strong>Threads</strong></span> that have called a method by clicking on the current stack frame, and then click on the <span class="strong"><strong>Method View</strong></span> button on the <span class="strong"><strong>Parallel Stacks</strong></span> window menu. After clicking on the button, the view will change to show which<a id="id525" class="indexterm"></a> methods the threads are calling.</p><div class="mediaobject"><img src="graphics/0225OT_07_06.jpg" /></div></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec74"></a>Watching values in a thread with Parallel Watch window</h2></div></div><hr /></div><p>Traditionally, debuggers have been designed to work in the context of a single thread at a time. In order to work with<a id="id526" class="indexterm"></a> a different thread, you needed to first switch the thread context. Visual Studio 2012 has a feature known as Parallel Watch window that allows you to display the values of a variable or expression on multiple threads.</p><p>In this recipe, we are going to see how to view the value of a variable across multiple threads using the Parallel Watch window.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec134"></a>How to do itâ€¦</h3></div></div></div><p>Let's see how the Parallel <a id="id527" class="indexterm"></a>Watch window can help us view variable values across multiple threads.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</p></li><li><p>When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu of Visual Studio 2012, and click on <span class="strong"><strong>Windows</strong></span>. Then click on <span class="strong"><strong>Parallel Watch</strong></span> and <span class="strong"><strong>Parallel Watch 1</strong></span> to view the window.</p></li><li><p>By default, the <span class="strong"><strong>Parallel Watch</strong></span> window brings up all the threads currently executing in the process.<a id="id528" class="indexterm"></a> In order to add new watches, we need to click on <span class="strong"><strong>&lt;Add Watch&gt;</strong></span> column which allows us to enter an expression. Click on <span class="strong"><strong>&lt;Add Watch&gt;</strong></span> and enter numbers as the expression to watch. As soon as the watch is added we can now see the expression evaluated across all the different threads in the <span class="strong"><strong>Watch</strong></span> window.</p><div class="mediaobject"><img src="graphics/0225OT_07_11.jpg" /></div></li><li><p>Enter a Boolean expression in the <span class="strong"><strong>Filter by Boolean Expression</strong></span> box<a id="id529" class="indexterm"></a>. The debugger evaluates the expression for each thread context. Only rows where the value is true are displayed.</p><div class="mediaobject"><img src="graphics/0225OT_07_12.jpg" /></div></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec75"></a>Detecting deadlocks with the Parallel Tasks window</h2></div></div><hr /></div><p>A very useful feature of the<a id="id530" class="indexterm"></a> Visual Studio 2012 debugger is the ability to detect deadlocks in your tasks. A deadlock occurs when two or more tasks permanently block each other by each task having a lock on a resource which the other tasks are trying to lock, or by waiting for each other to finish.</p><p>The easiest way<a id="id531" class="indexterm"></a> to find a deadlock in your application is to use the Parallel Tasks window of Visual Studio 2012. The Parallel Tasks window is very similar to the Threads window, except that it shows information about each <code class="literal">Task</code> or <code class="literal">task_handle</code> object instead of each thread, along with the status of the task.</p><p>In this recipe, we are going to create a <code class="literal">Console</code> application that will create several tasks in a loop. The tasks will deadlock because each task will be waiting for the next task to finish.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec135"></a>Getting readyâ€¦</h3></div></div></div><p>Before we use the Parallel Task window to see the deadlocks in our code, we need to create an application that has some deadlocks for us to see.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">DetectDeadlock</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, let's start by creating a variable for the number of tasks to create <code class="literal">CountDownEvent</code>, and an array of <code class="literal">tasks</code>.</p><div class="informalexample"><pre class="programlisting">static void Main()
{
  int taskCount = 5;
  var countdownEvent = new CountdownEvent(taskCount);
  var tasks = new Task[taskCount];
}</pre></div></li><li><p>Now, just below the previous code, let's create the blocked <code class="literal">tasks</code> in a <code class="literal">for</code> loop. Each task should wait for the next task to finish.</p><div class="informalexample"><pre class="programlisting">for(int i = 0; i &lt; taskCount; i++)
{
   tasks[i] = Task.Factory.StartNew((state) =&gt;
     {
       countdownEvent.Signal();
       tasks[(((int)state)+1)taskCount].Wait();
     },i);
}</pre></div></li><li><p>Next, let's create and start a couple of tasks that won't block.</p><div class="informalexample"><pre class="programlisting">var task1 = new Task(() =&gt;
{
  Thread.Sleep(500);                
});

var task2 = new Task(() =&gt;
{
  Thread.Sleep(500);
});

task1.Start();
task2.Start();</pre></div></li><li><p>Finish up the <code class="literal">Main</code> method by waiting for <code class="literal">CountDownEvent</code>
<a id="id532" class="indexterm"></a> and setting a breakpoint for <code class="literal">Debugger</code>.</p><div class="informalexample"><pre class="programlisting">countdownEvent.Wait();
Debugger.Break();</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec136"></a>How to do itâ€¦</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In Visual<a id="id533" class="indexterm"></a> Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project.</p></li><li><p>When the debugger hits the <code class="literal">Debug.Break</code> statement, go to the <span class="strong"><strong>Debug</strong></span> menu of Visual Studio 2012 and click on <span class="strong"><strong>Windows</strong></span>. Then click on <span class="strong"><strong>Parallel Tasks</strong></span> to view the window.</p><div class="mediaobject"><img src="graphics/0225OT_07_13.jpg" /></div></li><li><p>In the <span class="strong"><strong>Parallel Tasks</strong></span> window<a id="id534" class="indexterm"></a> you can see all of the tasks that have been identified to be deadlocked. Hover your mouse over any of the blocked tasks to see what the task is waiting for.</p><div class="mediaobject"><img src="graphics/0225OT_07_14.jpg" /></div></li><li><p>For<a id="id535" class="indexterm"></a> applications with a lot of tasks, it can be useful to group the tasks by their status. Right-click anywhere in the <span class="strong"><strong>Parallel Tasks</strong></span> window, click on <span class="strong"><strong>Group By</strong></span> and then click on <span class="strong"><strong>Status</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_07_15.jpg" /></div></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec76"></a>Measure CPU utilization with Concurrency Visualizer</h2></div></div><hr /></div><p>Parallel applications are not only prone to common sources of inefficiency that are found in sequential applications,<a id="id536" class="indexterm"></a> but they can <a id="id537" class="indexterm"></a>also suffer from uniquely parallel performance issues such as load imbalance, excessive synchronization overhead, or thread migration.</p><p>Understanding such performance issues can be a difficult and time-consuming process. However, Visual Studio 2012 includes a profiling tool, the Concurrency Visualizer, which can significantly reduce the burden of parallel performance analysis.</p><p>In this recipe we will be looking at the CPU Utilization view of the Concurrency Visualizer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec137"></a>Getting readyâ€¦</h3></div></div></div><p>Before we look <a id="id538" class="indexterm"></a>at the Concurrency Visualizer, we need to create a <code class="literal">Console</code> application that is going to exercise the <a id="id539" class="indexterm"></a>processor on your development machine a bit. This <code class="literal">Console</code> application will be a slight variation of the <code class="literal">MultipleProducerConsumer</code> application we created in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Concurrent Collections</em></span>. The application will use a <code class="literal">for</code> loop to create some producer <code class="literal">tasks</code> that the producers use to perform a mathematic operation on some numbers, and add the results to <code class="literal">BlockingCollection</code>. <code class="literal">BlockingCollection</code>, which is a class that provides blocking and bounding capabilities for thread safe collections that implement <code class="literal">IProducerConsumerCollection&lt;T&gt;</code>. There will also be four consumer <code class="literal">tasks</code> that retrieve the results from <code class="literal">BlockingCollection</code> and write them to <code class="literal">Console</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">MultipleProducerConsumer</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;</pre></div></li><li><p>Let's add a <code class="literal">static</code> method to the <code class="literal">Program</code> class which the producer tasks will call to perform the calculation.</p><div class="informalexample"><pre class="programlisting">private static double CalcSumRoot(int root)
{
  double result = 0;
  for (int i = 1; i &lt; 10000000; i++)
  {
    result += Math.Exp(Math.Log(i) / root);
  }
  return result;
}</pre></div></li><li><p>Now, just below the previous method, let's create another <code class="literal">static</code> method that consumer <code class="literal">tasks</code> will use to write the results to <code class="literal">Console</code>.</p><div class="informalexample"><pre class="programlisting">private static void DisplayResults(BlockingCollection&lt;double&gt; results)
{
  foreach (var item in results.GetConsumingEnumerable())
  {
    Console.Write("\nConsuming item: {0}", item);
  }
}</pre></div></li><li><p>In the <code class="literal">Main</code> method, let's start by creating <code class="literal">BlockingCollection</code>, to be the buffer between<a id="id540" class="indexterm"></a> the producers and consumers, list of tasks, and the definition for four consumer <code class="literal">tasks</code>.</p><div class="informalexample"><pre class="programlisting">var results = new BlockingCollection&lt;double&gt;();
var tasks = new List&lt;Task&gt;();
var consume1 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume2 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume3 = Task.Factory.StartNew(() =&gt; DisplayResults(results));
var consume4 = Task.Factory.StartNew(() =&gt; DisplayResults(results));</pre></div></li><li><p>Now let's<a id="id541" class="indexterm"></a> create a <code class="literal">for</code> loop that spins up some producer <code class="literal">tasks</code>, performs the calculations, and adds the results to <code class="literal">BlockingCollection</code>.</p><div class="informalexample"><pre class="programlisting">for (int item = 1; item &lt; 100; item++)
{
  var value = item;
  var compute = Task.Factory.StartNew(() =&gt;
  {
    var calcResult = CalcSumRoot(value);
    Console.Write("\nProducing item: {0}", calcResult);
    results.TryAdd(calcResult);
  });
  tasks.Add(compute);
}</pre></div></li><li><p>Finally, let's create a continuation that calls <code class="literal">CompleteAdding</code> on <code class="literal">BlockingCollection</code> when all producer <code class="literal">tasks</code> finish. Wait for the user input before exiting.</p><div class="informalexample"><pre class="programlisting">Task.Factory.ContinueWhenAll(tasks.ToArray(), result =&gt;
{
 results.CompleteAdding();
 Console.Write("\nCompleted adding.");
});

Console.ReadLine();</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec138"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how we<a id="id542" class="indexterm"></a> can use Concurrency<a id="id543" class="indexterm"></a> Visualizer to report on the performance and efficiency of parallel code.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>On Visual Studio 2012 menu, click on <span class="strong"><strong>Analyze</strong></span>, and then click on <span class="strong"><strong>Concurrency Visualizer</strong></span>, and <span class="strong"><strong>Start with Current Project</strong></span>. You will see the application running while Visual Studio 2012 collects data and builds a report in the background.</p></li><li><p>When the application finishes running, close the application. Visual Studio 2012 will then finalize and open the performance report.</p><div class="mediaobject"><img src="graphics/0225OT_07_16.jpg" /></div></li><li><p>Once the report is completed and loaded, you will see the <span class="strong"><strong>Utilization</strong></span> view of the Concurrency Visualizer. The X axis shows the <span class="strong"><strong>Elapsed Time</strong></span> since the trace started. The Y axis shows the number of logical processor cores in your system. The green area shows the <span class="strong"><strong>Number of Logical Cores</strong></span> that the application is using at any given point in the analysis run. The rest of the cores are either idle, or are being used by <span class="strong"><strong>Other Processes</strong></span> which are shown by the gray lines coming from the top of the graph. There is a <span class="strong"><strong>Zoom</strong></span> slider<a id="id544" class="indexterm"></a> at the top which can be used to narrow the time scale of the graph.</p><div class="mediaobject"><img src="graphics/0225OT_07_17.jpg" /></div></li><li><p>When tuning your parallel application, this view allows you to confirm the degree of parallelism. You can get hints of common parallel performance problems<a id="id545" class="indexterm"></a> by reviewing the graph. Load imbalances among the processor's cores appear as stair-step <a id="id546" class="indexterm"></a>patterns in the graph. Contention for synchronization objects appear on the graph, such as serial execution when parallel is expected.</p></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec77"></a>Using Concurrency Visualizer Threads view</h2></div></div><hr /></div><p>Threads view is probably<a id="id547" class="indexterm"></a> the most useful and<a id="id548" class="indexterm"></a> frequently used view in the Concurrency Visualizer. By using this view, you can identify whether the threads are executing or blocking because of synchronization or some other reason. Threads view assigns a category to each context switch when a thread has stopped executing.</p><p>In this recipe, we are going to use the Concurrency Visualizer to show all of the context switch events for each application thread.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec139"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe, we <a id="id549" class="indexterm"></a>will use the same sample application as in the previous recipe. If you have closed the <code class="literal">MultipleProducerConsumer</code> solution, please reopen it, and go to the Concurrency Visualizer through the Visual Studio 2012 menu, and click on <span class="strong"><strong>Analyze</strong></span>. Then, click on <span class="strong"><strong>Concurrency Visualizer</strong></span>, and <span class="strong"><strong>Open Trace. </strong></span>Alternately, you can rerun the Concurrency Visualizers as in the previous recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec140"></a>How to do itâ€¦</h3></div></div></div><p>Let's take a look at what<a id="id550" class="indexterm"></a> we can do with the Concurrency Visualizer Threads view.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <span class="strong"><strong>Concurrency Visualizer</strong></span> for the <span class="strong"><strong>MultipleProducerConsumer</strong></span> solution and click on the <span class="strong"><strong>Threads</strong></span> view.</p><div class="mediaobject"><img src="graphics/0225OT_07_18.jpg" /></div></li><li><p>When the <span class="strong"><strong>Threads</strong></span> view opens, you will notice that the X axis is again a <span class="strong"><strong>Timeline</strong></span>. However, the Y axis is divided into horizontal channels. If the physical disks on your machine have any activity during the running of the application (which in this case they don't), the top channels will depict your physical disks. In our case, the channels are all threads in our application. You will see the <code class="literal">Main</code> thread, a debugger helper thread, and all of your worker threads. Below the list of <span class="strong"><strong>Threads</strong></span>, you will see the <span class="strong"><strong>Execution Categories</strong></span> that are assigned by Concurrency Visualizer. In the following screenshot, you can see that the application spent <span class="strong"><strong>16%</strong></span> of the <span class="strong"><strong>Timeline</strong></span> in <span class="strong"><strong>Execution</strong></span> and <span class="strong"><strong>71%</strong></span> of the <span class="strong"><strong>Timeline</strong></span> in <span class="strong"><strong>Synchronization</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_07_19.jpg" /></div></li><li><p>Click on one of the CLR worker threads in the top channel. The <span class="strong"><strong>Timeline</strong></span> next to the channel <a id="id551" class="indexterm"></a>for the <span class="strong"><strong>CLR Worker Thread</strong></span> will be divided into the <span class="strong"><strong>Time slices</strong></span> for the thread. Click on the <span class="strong"><strong>Current</strong></span> tab in the <span class="strong"><strong>Profile Report</strong></span> tab. You will see the call stack for the thread at the time of the context switch, the reason for the context switch, and <span class="strong"><strong>Category</strong></span> assigned by the report. You can see on the <span class="strong"><strong>Current</strong></span> tab that this thread was context switched because it arrived at a <span class="strong"><strong>Monitor.Wait</strong></span> call.</p><div class="mediaobject"><img src="graphics/0225OT_07_20.jpg" /></div></li><li><p>One of the most valuable features of the <span class="strong"><strong>Threads</strong></span> view is the ability to determine thread<a id="id552" class="indexterm"></a> dependencies. Select a synchronization segment for a worker thread (a pink segment). On the <span class="strong"><strong>Current</strong></span> tab you will see the thread that unblocked the current thread. Click on the <span class="strong"><strong>Unblocking Stack</strong></span> tab<a id="id553" class="indexterm"></a> and you will see the call stack of the thread that unblocked the current thread.</p><div class="mediaobject"><img src="graphics/0225OT_07_21.jpg" /></div></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec78"></a>Using Concurrency Visualizer Cores view </h2></div></div><hr /></div><p>Frequent context switching can seriously degrade application performance, especially when threads migrate across cores when they resume execution. The reason for this performance impact is that running threads load instructions and data they need into the cache hierarchy, and when<a id="id554" class="indexterm"></a> a thread resumes execution on a different core, there can be latency while working data is reloaded from memory or other caches.</p><p>The Cores view<a id="id555" class="indexterm"></a> of the Concurrency Visualizer is a tool that aids in identifying excessive context switches. In this recipe, we will return to the <code class="literal">MultipleProducerConsumer</code> solution to see how we can examine the context switching that occurs in the application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec141"></a>Getting readyâ€¦</h3></div></div></div><p>For this recipe, we will<a id="id556" class="indexterm"></a> use the same sample application as in the previous recipe. If you have closed the <code class="literal">MultipleProducerConsumer</code> solution, please reopen it and go to the Concurrency Visualizer through the Visual Studio 2012 menu. Click on <span class="strong"><strong>Analyze</strong></span>, and then click on <span class="strong"><strong>Concurrency Visualizer</strong></span>, and <span class="strong"><strong>Open Trace</strong></span>. Alternately, you can rerun the Concurrency Visualizers as in the previous recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec142"></a>How to do itâ€¦</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the Concurrency Visualizer for the <code class="literal">MultipleProducerConsumer</code> solution and click on the <span class="strong"><strong>Cores</strong></span> view.</p><div class="mediaobject"><img src="graphics/0225OT_07_22.jpg" /></div></li><li><p>Like the other views, the <span class="strong"><strong>Cores</strong></span> view<a id="id557" class="indexterm"></a> displays the timeline on the X axis. The logical cores of the system are shown on the Y axis. Each thread in the application is shown in a different color, and thread execution segments are displayed on the core channels.</p><div class="mediaobject"><img src="graphics/0225OT_07_23.jpg" /></div></li><li><p>The statistics shown in the <span class="strong"><strong>Cores</strong></span> view help the developer to identify <span class="strong"><strong>Threads</strong></span> that have excessive context switches and incur core migrations. The list of threads<a id="id558" class="indexterm"></a> at the bottom of the <span class="strong"><strong>Cores</strong></span> view is sorted by the number of <span class="strong"><strong>Cross-Core Context Switches</strong></span>. Click on the thread with the highest number of core switches (the top thread in the list). Notice how the thread execution is spread across the available <span class="strong"><strong>Cores</strong></span> in your system.</p><div class="mediaobject"><img src="graphics/0225OT_07_24.jpg" /></div></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch08"></a>ChapterÂ 8.Â Async</h2></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating an <code class="literal">async</code> method</p></li><li style="list-style-type: disc"><p>Handling <code class="literal">Exceptions</code> in asynchronous code</p></li><li style="list-style-type: disc"><p>Cancelling an asynchronous operation</p></li><li style="list-style-type: disc"><p>Cancelling <code class="literal">async</code> operation after timeout period</p></li><li style="list-style-type: disc"><p>Processing multiple <code class="literal">async</code> tasks as they complete</p></li><li style="list-style-type: disc"><p>Improving performance of <code class="literal">async</code> solution with <code class="literal">Task.WhenAll</code>
</p></li><li style="list-style-type: disc"><p>Using <code class="literal">async</code> for file access</p></li><li style="list-style-type: disc"><p>Checking the progress of an asynchronous task</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec79"></a>Introduction</h2></div></div><hr /></div><p>We've all seen client applications that do not respond to mouse events or update the display for noticeable periods of time. This delay is likely the result of code holding on to the single UI thread for far too long. Maybe it is waiting for network I/O or maybe it is performing an intensive computation. Meanwhile, the user is left sitting there waiting, as our application grinds to a halt. The answer to this problem is asynchrony.</p><p>How is the concept of asynchrony different from parallelism? <a id="id559" class="indexterm"></a>Parallelism, with which you are quite familiar by this point in the book, is mainly about application performance. Parallelism enables developers to perform CPU intensive work on multiple threads at once, taking advantage of modern multi-core computer architectures. Asynchrony on the other hand, is a superset of concurrency. It includes concurrency as well as other asynchronous calls which are more I/O bound than CPU bound. Let's say you are saving a large file to your hard drive or you want to download some data from the server. These kinds of I/O bound tasks are ideal for asynchrony. Asynchrony is a pattern which yields control instantly, and waits for a callback or other notification to occur before continuing.</p><p>So, just do things using an asynchronous pattern and your UI responsiveness problems are solved, right? Well, yes, but there is one small problem. Asynchronous code is difficult, at least historically speaking. However, asynchrony is taking a huge leap forward in terms of usability. Microsoft has delivered this by building on the <code class="literal">Task</code> functionality in .NET 4.5, as well as the addition of two new keywords to the .NET Framework: <code class="literal">async</code> and <code class="literal">await</code>.</p><p>In this chapter, we will walk through several recipes that show how to maintain a responsive UI or scalable services by using the new <span class="strong"><strong>Task-based Asynchronous Pattern</strong></span>
<a id="id560" class="indexterm"></a> (<span class="strong"><strong>TAP</strong></span>) of the .NET Framework 4.5.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec80"></a>Creating an async method</h2></div></div><hr /></div><p>The TAP is a new pattern for <a id="id561" class="indexterm"></a>asynchronous programming in .NET Framework 4.5. It is based on a task, but in this case a task doesn't represent work which will be performed on another thread. In this case, a task is used to represent arbitrary asynchronous operations.</p><p>Let's start learning how <code class="literal">async</code> and <code class="literal">await</code> work by creating a <span class="strong"><strong>Windows Presentation</strong></span>
<a id="id562" class="indexterm"></a>
<span class="strong"><strong> Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>) application that accesses the web using <code class="literal">HttpClient</code>. This kind of network access is ideal for seeing TAP in action. The application will get the contents of a classic book from the web, and will provide a count of the number of words in the book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec143"></a>How to do itâ€¦</h3></div></div></div><p>Let's go to Visual Studio<a id="id563" class="indexterm"></a> 2012 and see how to use the <code class="literal">async</code> and <code class="literal">await</code> keywords to maintain a responsive UI by doing the web communications asynchronously.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">WordCountAsync</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create a simple user interface containing <code class="literal">Button</code> and <code class="literal">TextBlock</code>:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="WordCountAsync.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WordCountAsync" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
    Content="Start" 
    HorizontalAlignment="Left" 
    Margin="219,195,0,0" 
    VerticalAlignment="Top" 
    Width="75" 
    RenderTransformOrigin="-0.2,0.45" 
    Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResults" 
      HorizontalAlignment="Left" 
      Margin="60,28,0,0" 
      TextWrapping="Wrap" 
      VerticalAlignment="Top" 
      Height="139" 
      Width="411"/&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div><div class="mediaobject"><img src="graphics/0225OT_08_01.jpg" /></div></li><li><p>Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to<a id="id564" class="indexterm"></a> the <span class="strong"><strong>Project</strong></span> and add a reference to <code class="literal">System.Net.Http</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>At the top<a id="id565" class="indexterm"></a> of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre></div></li><li><p>Add a button click event for the <code class="literal">StartButton</code> and add the <code class="literal">async</code> modifier to the method signature to indicate that this will be a <code class="literal">async</code> method. Please note that <code class="literal">async</code> methods that return <code class="literal">void</code> are normally only used for event handlers, and should be avoided.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  
}</pre></div></li><li><p>Next, let's create a <code class="literal">async</code> method called <code class="literal">GetWordCountAsync</code> that returns <code class="literal">Task&lt;int&gt;</code>. This method will create <code class="literal">HttpClient</code> and call its <code class="literal">GetStringAsync</code> method to download the book contents as a string. It will then use the <code class="literal">Split</code> method to split the string into a <code class="literal">wordArray</code>. We can return the count of the <code class="literal">wordArray</code> as our <code class="literal">return</code> value.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync()
{
  TextResults.Text += "Getting the word count for Origin of Species...\n";
  var client = new HttpClient();
  var bookContents = await client.GetStringAsync(@"http://www.gutenberg.org/files/2009/2009.txt");
  var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return wordArray.Count();           
}</pre></div></li><li><p>Finally, let's complete the implementation of our button click event. The <code class="literal">Click</code> event handler will just call <code class="literal">GetWordCountAsync</code> with the <code class="literal">await</code> keyword and display the results to <code class="literal">TextBlock</code>.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  var result = await GetWordCountAsync();
  TextResults.Text += String.Format("Origin of Species word count: {0}",result);
}</pre></div></li><li><p>In Visual Studio <a id="id566" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button, and your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec144"></a>How it worksâ€¦</h3></div></div></div><p>In the TAP, asynchronous methods are marked with an <code class="literal">async</code> modifier. The <code class="literal">async</code> modifier on a method does<a id="id567" class="indexterm"></a> not mean that the method will be scheduled to run asynchronously on a worker thread. It means that the method contains control flow that involves waiting for the result of an asynchronous operation, and will be rewritten by the compiler to ensure that the asynchronous operation can resume this method at the right spot.</p><p>Let me try to put this a little more simply. When you add the <code class="literal">async</code> modifier to a method, it indicates that the method will wait on an asynchronous code to complete. This is done with the <code class="literal">await</code> keyword. The compiler actually takes the code that follows the <code class="literal">await</code> keyword in an <code class="literal">async</code> method and turns it into a continuation that will run after the result of the <code class="literal">async</code> operation is available. In the meantime, the method is suspended, and control returns to the method's caller.</p><p>If you add the <code class="literal">async</code> modifier to a method, and then don't <code class="literal">await</code> anything, it won't cause an error. The method will simply run synchronously.</p><p>An <code class="literal">async</code> method can <a id="id568" class="indexterm"></a>have one of the three return types: <code class="literal">void</code>, <code class="literal">Task</code>, or <code class="literal">Task&lt;TResult&gt;</code>. As mentioned before, a task in this context doesn't mean that this is something that will execute on a separate thread. In this case, task is just a container for the asynchronous work, and in the case of <code class="literal">Task&lt;TResult&gt;</code>, it is a promise that a result value of type <code class="literal">TResult</code> will show up after the asynchronous operation completes.</p><p>In our application, we use the <code class="literal">async</code> keyword to mark the button click event handler as asynchronous, and then we wait for the <code class="literal">GetWordCountAsync</code> method<a id="id569" class="indexterm"></a> to complete by using the <code class="literal">wait</code> keyword.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  StartButton.Enabled = false;
  var result = await GetWordCountAsync();
  TextResults.Text += String.Format("Origin of Species word count: {0}",
..................  result);
  StartButton.Enabled = true;
}</pre></div><p>The code that follows the a<code class="literal">wait</code> keyword, in this case, the same line of code that updates <code class="literal">TextBlock</code>, is turned by the compiler into a continuation that will run after the <code class="literal">integer</code> result is available.</p><p>If the <code class="literal">Click</code> event is fired again while this asynchronous task is in progress, another asynchronous task is created and awaited. To prevent this, it is a common practice to disable the button that is clicked.</p><p>It is a convention to name an asynchronous method with an <code class="literal">Async</code> postfix, as we have done with <code class="literal">GetWordCountAsync</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec81"></a>Handling Exceptions in asynchronous code</h2></div></div><hr /></div><p>So how would you add <code class="literal">Exception</code> handling to code that is executed asynchronously? In previous asynchronous<a id="id570" class="indexterm"></a> patterns, this was very difficult to achieve. In C# 5.0 it is much more straightforward because you just have to wrap the asynchronous function call with a standard <code class="literal">try</code>/<code class="literal">catch</code> block.</p><p>On the surface <a id="id571" class="indexterm"></a>this sounds easy, and it is, but there is more going on behind the scene that will be explained right after we build our next example application.</p><p>For this recipe, we will return to our classic books word count scenario, and we will be handling an <code class="literal">Exception</code> thrown by <code class="literal">HttpClient</code> when it tries to get the book contents using an incorrect URL.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec145"></a>How to do itâ€¦</h3></div></div></div><p>Let's build another WPF<a id="id572" class="indexterm"></a> application and take a look at<a id="id573" class="indexterm"></a> how to handle <code class="literal">Exceptions</code> when something goes wrong in one of our asynchronous methods.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncExceptions</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create a simple user interface containing <code class="literal">Button</code> and a <code class="literal">TextBlock</code>:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="WordCountAsync.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WordCountAsync" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
    Content="Start" 
    HorizontalAlignment="Left" 
    Margin="219,195,0,0" 
    VerticalAlignment="Top" 
    Width="75" 
    RenderTransformOrigin="-0.2,0.45" 
    Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResults" 
      HorizontalAlignment="Left" 
      Margin="60,28,0,0" 
      TextWrapping="Wrap" 
      VerticalAlignment="Top" 
      Height="139" 
      Width="411"/&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div></li><li><p>Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Framework</strong></span> from the menu on the left side of the <span class="strong"><strong>Reference Manager</strong></span>, and then add a reference to <code class="literal">System.Net.Http</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>At the top<a id="id574" class="indexterm"></a> of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of <a id="id575" class="indexterm"></a>the book into a word array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre></div></li><li><p>Now let's create our <code class="literal">GetWordCountAsync</code> method. This method will be very similar to the last recipe, but it will be trying to access the book on an incorrect URL. The asynchronous code will be wrapped in a <code class="literal">try</code>/<code class="literal">catch</code> block to handle <code class="literal">Exception</code>. We will also use a <code class="literal">finally</code> block to dispose of <code class="literal">HttpClient</code>.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync()
{
  ResultsTextBlock.Text += "Getting the word count for Origin of Species...\n";
  var client = new HttpClient();            
  try
  {
    var bookContents = await client.GetStringAsync(@"http://www.gutenberg.org/files/2009/No_Book_Here.txt");
    var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  catch (Exception ex)
  {
    ResultsTextBlock.Text += String.Format("An error has occurred: {0} \n", ex.Message);
    return 0;
  }
  finally
  {
    client.Dispose();
  }
  
}</pre></div></li><li><p>Finally, let create the <code class="literal">Click</code> event handler for our <code class="literal">StartButton</code>. This is pretty much the same as the last recipe, just wrapped in a <code class="literal">try</code>/<code class="literal">catch</code> block. Don't forget to add the <code class="literal">async</code> modifier to the method signature.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{            
  try
  {
    var result = await GetWordCountAsync();
    ResultsTextBlock.Text += String.Format("Origin of Species word count: {0}", 
        result);
  }
  catch(Exception ex)
  {
    ResultsTextBlock.Text += String.Format("An error has occurred: {0} \n", 
            ex.Message);
  } 
}</pre></div></li><li><p>Now, in Visual<a id="id576" class="indexterm"></a> Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button. Your application should appear as<a id="id577" class="indexterm"></a> shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_03.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec146"></a>How it worksâ€¦</h3></div></div></div><p>Wrapping your asynchronous code in a <code class="literal">try</code>/<code class="literal">catch</code> block is pretty easy. In fact, it hides some of the complex work Visual Studio 2012 to doing for us.</p><p>To understand this, you need to think about the context in which your code is running.</p><p>When the TAP is used in Windows Forms or WPF applications, there's already a context that the code is running in, such as the message loop UI thread. When <code class="literal">async</code> calls are made in those applications, the awaited code goes off to do its work asynchronously and the <code class="literal">async</code> method<a id="id578" class="indexterm"></a> exits back to its caller. In other words, the program execution returns to the message loop UI thread.</p><p>The <code class="literal">Console</code> applications <a id="id579" class="indexterm"></a>don't have the concept of a context. When the code hits an awaited call inside the <code class="literal">try</code> block, it will exit back to its caller, which in this case is <code class="literal">Main</code>. If there is no more code after the awaited call, the application ends without the <code class="literal">async</code> method ever finishing.</p><p>To alleviate this issue, Microsoft included <code class="literal">async</code> compatible context with the TAP that is used for <code class="literal">Console</code> apps or unit test apps to prevent this inconsistent behavior. This new context is called <code class="literal">GeneralThreadAffineContext</code>.</p><p>Do you really need to understand these context issues to handle async <code class="literal">Exceptions</code>? No, not really. That's part of the beauty of the Task-based Asynchronous Pattern.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec82"></a>Cancelling an asynchronous operation</h2></div></div><hr /></div><p>In .NET 4.5,<a id="id580" class="indexterm"></a> asynchronous operations can be cancelled in the same way that parallel tasks can be cancelled, by passing in <code class="literal">CancellationToken</code> and calling the <code class="literal">Cancel</code> method on <code class="literal">CancellationTokenSource</code>.</p><p>In this recipe, we are going to create a WPF application that gets the contents of a classic book over the web and performs a word count. This time though we are going to set up a <span class="strong"><strong>Cancel</strong></span> button that we can use to cancel the <code class="literal">async</code> operation if we don't want to wait for it to finish.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec147"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a WPF application to show how we can add cancellation to our asynchronous methods.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncCancellation</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our<a id="id581" class="indexterm"></a> user interface. In this case, the UI contains <code class="literal">TextBlock</code>, <code class="literal">StartButton</code>, and <code class="literal">CancelButton</code>.</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncCancellation.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="AsyncCancellation" Height="400" Width="599"&gt;
    &lt;Grid Width="600" Height="400"&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start" 
        HorizontalAlignment="Left" 
        Margin="142,183,0,0" 
        VerticalAlignment="Top" 
        Width="75" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;Button x:Name="CancelButton" 
        Content="Cancel" 
        HorizontalAlignment="Left" 
        Margin="379,185,0,0" 
        VerticalAlignment="Top" 
        Width="75" 
        Click="CancelButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
        HorizontalAlignment="Left" 
        Margin="27,24,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Height="135" 
        Width="540"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div></li><li><p>Next, open up <code class="literal">MainWindow.xaml.cs</code>, click on the <span class="strong"><strong>Project Explorer</strong></span>, and add a reference to <code class="literal">System.Net.Http</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre></div></li><li><p>Next, let's create the <code class="literal">GetWordCountAsync</code> method<a id="id582" class="indexterm"></a>. This method is very similar to the method explained before. It needs to be marked as asynchronous with the <code class="literal">async</code> modifier and it returns <code class="literal">Task&lt;int&gt;</code>. This time however, the <a id="id583" class="indexterm"></a>method takes a <code class="literal">CancellationToken</code> parameter. We also need to use the <code class="literal">GetAsync</code> method of <code class="literal">HttpClient</code> instead of the <code class="literal">GetStringAsync</code> method, because the former supports cancellation, whereas the latter does not. We will add a small delay in the method so we have time to cancel the operation before the download completes.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  TextResult.Text += "Getting the word count for Origin of Species...\n";            
  var client = new HttpClient();
  await Task.Delay(500);
  try
  {
    HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
    var words = await response.Content.ReadAsStringAsync();
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  finally
  {
    client.Dispose();
  }
}</pre></div></li><li><p>Now, let's create the <code class="literal">Click</code> event handler for our <code class="literal">CancelButton</code>. This method just needs to check if <code class="literal">CancellationTokenSource</code> is <code class="literal">null</code>, and if not, it calls the <code class="literal">Cancel</code> method.</p><div class="informalexample"><pre class="programlisting">private void CancelButton_Click(object sender, RoutedEventArgs e)
{
  if (cts != null)
  {
    cts.Cancel();
  }
}</pre></div></li><li><p>Ok, let's finish up by adding a <code class="literal">Click</code> event handler for <code class="literal">StartButton</code>. This method is the same as explained before, except we also have a <code class="literal">catch</code> block that specifically handles <code class="literal">OperationCancelledException</code>. Don't forget to mark the method<a id="id584" class="indexterm"></a> with the <code class="literal">async</code> modifier.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  TextResult.Text += "Getting the word count for Origin of Species...\n";            
  var client = new HttpClient();
  await Task.Delay(500);
  try
  {
    HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
    var words = await response.Content.ReadAsStringAsync();
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  finally
  {
    client.Dispose();
  }
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project Click on the <span class="strong"><strong>Start</strong></span> button, then the <span class="strong"><strong>Cancel</strong></span> button. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec148"></a>How it worksâ€¦</h3></div></div></div><p>Cancellation is an aspect of user interaction that you need to consider to build a professional <code class="literal">async</code>
<a id="id585" class="indexterm"></a> application. In this example, we implemented cancellation by using a <span class="strong"><strong>Cancel</strong></span> button, which is one of the most common ways to surface cancellation functionality in a GUI application.</p><p>In this recipe, cancellation follows a very common flow.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The caller (start button click event handler) creates a <code class="literal">CancellationTokenSource</code> object.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  cts = new CancellationTokenSource();            
  ...
}</pre></div></li><li><p>The caller calls a cancelable method, and passes <code class="literal">CancellationToken</code> from <code class="literal">CancellationTokenSource</code> (<code class="literal">CancellationTokenSource.Token</code>).</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(<span class="strong"><strong>CancellationToken ct</strong></span>)
{
  ...
  HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", <span class="strong"><strong>ct</strong></span>);
  ...
}</pre></div></li><li><p>The cancel button click event handler requests cancellation using the <code class="literal">CancellationTokenSource</code> object (<code class="literal">CancellationTokenSource.Cancel()</code>).</p><div class="informalexample"><pre class="programlisting">private void CancelButton_Click(object sender, RoutedEventArgs e)
{
  if (cts != null)
  {
    cts.Cancel();
  }
}</pre></div></li><li><p>The task <a id="id586" class="indexterm"></a>acknowledges the cancellation by throwing <code class="literal">OperationCancelledException</code>, which we handle in a <code class="literal">catch</code> block in the start button click event handler.</p></li></ol></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec83"></a>Cancelling async operation after timeout period</h2></div></div><hr /></div><p>Another common scenario for cancelling asynchronous tasks is to set a timeout period by using the <code class="literal">CancellationTokenSource.CancelAfter</code> method. This method schedules the cancellation of any<a id="id587" class="indexterm"></a> associated tasks that aren't complete within the period of time that's designated by the <code class="literal">CancelAfter</code> expression.</p><p>In this recipe, we are going to create a WPF application that gets the contents of a classic book over the web and performs a word count. This time though, we are going to set a timeout period after which the task gets cancelled.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec149"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how we can create an asynchronous task that cancels after a specified timeout period.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">CancelAfterTimeout</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and add the following XAML to create our user interface:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="CancelAfterTimeout.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,264,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
        HorizontalAlignment="Left" 
        Margin="48,10,0,0" TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Height="213" 
        Width="420"/&gt;
        &lt;Label Content="Timeout (in ms):" 
         HorizontalAlignment="Left" 
         Margin="163,227,0,0" 
         VerticalAlignment="Top"/&gt;
        &lt;TextBox x:Name="TextTimeout" 
        HorizontalAlignment="Left" 
        Height="23" 
        Margin="277,231,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Width="50"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div><div class="mediaobject"><img src="graphics/0225OT_08_05.jpg" /></div></li><li><p>Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span> and add a reference to <code class="literal">System.Net.Http</code>.</p></li><li><p>Add the following <code class="literal">using</code>
<a id="id588" class="indexterm"></a> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre></div></li><li><p>Next, let's create the <code class="literal">GetWordCountAsync</code> method. This method is exactly the same as the last recipe. It needs to be marked as asynchronous with the <code class="literal">async</code> modifier and it returns <code class="literal">Task&lt;int&gt;</code>. The method takes a <code class="literal">CancellationToken</code> parameter. We will add a small delay in the method so we have time to cancel<a id="id589" class="indexterm"></a> the operation before the download completes.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  TextResult.Text += "Getting the word count for Origin of Species...\n";            
  var client = new HttpClient();
  await Task.Delay(500);
  try
  {
    HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
    var words = await response.Content.ReadAsStringAsync();
    var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
    return wordArray.Count();
  }
  finally
  {
    client.Dispose();
  }
}</pre></div></li><li><p>Ok, let's finish up by adding a <code class="literal">Click</code> event handler for <code class="literal">StartButton</code>. This method is similar to the last recipe, except we call the <code class="literal">CancellationTokenSource.CancelAfter</code> method<a id="id590" class="indexterm"></a>, passing it the value of our <code class="literal">timeout</code> textbox. Don't forget to mark the method with the <code class="literal">async</code> modifier.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  StartButton.IsEnabled = false;
  try
  {
    tokenSource = new CancellationTokenSource();
    var timeoutPeriod = int.Parse(TextTimeout.Text);
    tokenSource.CancelAfter(timeoutPeriod);                
    await GetWordCount(tokenSource.Token);                                
  }
  catch (OperationCanceledException)
  {
    TextResult.Text += "The operation was cancelled. \n";
  }
  catch (Exception)
  {
    TextResult.Text += "The operation failed to complete due to an exception. \n";
  }
  finally
  {
    StartButton.IsEnabled = true;
  }
}</pre></div></li><li><p>In Visual Studio<a id="id591" class="indexterm"></a> 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Set the <code class="literal">timeout</code> value to <code class="literal">100</code>. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec150"></a>How it worksâ€¦</h3></div></div></div><p>The application is very similar to the application we created in the last recipe, except this time the <code class="literal">Cancel</code> button isn't used. The actual cancellation follows a similar flow however.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The caller (start button click event handler) creates a <code class="literal">CancellationTokenSource</code> object, and then calls the <code class="literal">CancelAfter</code> method to pass in the <code class="literal">timeout</code> value.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  StartButton.IsEnabled = false;
  try
  {
    tokenSource = new CancellationTokenSource();
    var timeoutPeriod = int.Parse(TextTimeout.Text);
    tokenSource.CancelAfter(timeoutPeriod);                
    ...                                
  }
  ...
}</pre></div></li><li><p>The caller calls<a id="id592" class="indexterm"></a> a cancelable method, and passes <code class="literal">CancellationToken</code> from <code class="literal">CancellationTokenSource</code> (<code class="literal">CancellationTokenSource.Token</code>).</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync(CancellationToken ct)
{
  ...
  HttpResponseMessage response = await client.GetAsync(@"http://www.gutenberg.org/files/2009/2009.txt", ct);
  ...
}</pre></div></li><li><p>After the timeout period expires, <code class="literal">CancellationTokenSource</code> triggers a cancellation same as if we had made a call to <code class="literal">CancellationTokenSource.Cancel</code>.</p><div class="informalexample"><pre class="programlisting">private void CancelButton_Click(object sender, RoutedEventArgs e)
{
  if (cts != null)
  {
    cts.Cancel();
  }
}</pre></div></li></ol></div><p>The task acknowledges the cancellation by throwing <code class="literal">OperationCancelledException</code>, which we handle in a <code class="literal">catch</code> block in the start button click event handler.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec84"></a>Processing multiple async tasks as they complete</h2></div></div><hr /></div><p>Many of the methods of the <code class="literal">Task</code> class that we learned about in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Task Parallel Library</em></span>, are as useful when writing an asynchronous code as they are when writing a<a id="id593" class="indexterm"></a> parallel code. In this recipe, we are going to download the contents of multiple books and use <code class="literal">Task.WhenAny</code> to process them as they finish.</p><p>This application will use a <code class="literal">while</code> loop to create a collection of tasks. Each task downloads the contents of a specified book. In each iteration of a loop, an awaited call to <code class="literal">WhenAny</code> returns the task in the collection of tasks that finishes first. That task is removed from the collection and processed. The loop repeats until the collection contains no more tasks.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec151"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's create a WPF application that creates multiple asynchronous tasks and processes them as they complete.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncMultipleRequest</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our user interface:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncMultipleRequest.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,264,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
           HorizontalAlignment="Left" 
           Margin="48,10,0,0" 
           TextWrapping="Wrap" 
           VerticalAlignment="Top" 
           Height="213" Width="420"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div></li><li><p>Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span>, and add a reference to <code class="literal">System.Net.Http</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Documents;
using System.Net.Http;</pre></div></li><li><p>At the top of <a id="id594" class="indexterm"></a>the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre></div></li><li><p>Let's start by creating a helper function that builds a list of <code class="literal">KeyValuePair&lt;string,string&gt;</code> which represents our book titles and URLs.</p><div class="informalexample"><pre class="programlisting">private List&lt;KeyValuePair&lt;string, string&gt;&gt; GetBookUrls()
{
  var urlList = new List&lt;KeyValuePair&lt;string, string&gt;&gt;
  {
    new KeyValuePair&lt;string,string&gt;("Origin of Species",
          "http://www.gutenberg.org/files/2009/2009.txt"),
    new KeyValuePair&lt;string,string&gt;("Beowulf",
          "http://www.gutenberg.org/files/16328/16328-8.txt"),
    new KeyValuePair&lt;string,string&gt;("Ulysses",
          "http://www.gutenberg.org/files/4300/4300.txt")
  };
  return urlList;
}</pre></div></li><li><p>Now let's create an <code class="literal">async</code> method that does the book download and returns <code class="literal">KeyValuePair&lt;string, int&gt;</code> that represents our book titles and word count. This method will need to accept a <code class="literal">KeyValuePair&lt;string, string&gt;</code> parameter representing the book title and URL. The method also needs an <code class="literal">HttpClient</code> parameter.</p><div class="informalexample"><pre class="programlisting">async Task&lt;KeyValuePair&lt;string,int&gt;&gt; ProcessBook(KeyValuePair&lt;string,string&gt; book, HttpClient client)
{
  var bookContents = await client.GetStringAsync(book.Value);
  var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return new KeyValuePair&lt;string,int&gt;(book.Key,wordArray.Count());
}</pre></div></li><li><p>Now we need to create another <code class="literal">async</code> method called <code class="literal">GetMultipleWordCount</code>. This method executes a query on our list of books. Each query calls the <code class="literal">ProcessBook</code> method to actually do the download and obtain the word count. After the query, we set up a <code class="literal">while</code> loop that loops while our list of book processing tasks is greater than zero. Each iteration of the loop awaits a call to <code class="literal">Task.WhenAny</code>. When a task is completed, the <a id="id595" class="indexterm"></a>results are written out and <code class="literal">Task</code> is removed from the <code class="literal">Task</code> list. This method takes no parameters and returns <code class="literal">Task</code>.</p><div class="informalexample"><pre class="programlisting">public async Task GetMultipleWordCount()
{
  var client = new HttpClient();
  var results = new List&lt;KeyValuePair&lt;string, int&gt;&gt;();
  var urlList = GetBookUrls();
  IEnumerable&lt;Task&lt;KeyValuePair&lt;string,int&gt;&gt;&gt; bookQuery =
    from book in urlList select ProcessBook(book, client);
  List&lt;Task&lt;KeyValuePair&lt;string,int&gt;&gt;&gt; bookTasks = bookQuery.ToList();
  while (bookTasks.Count &gt; 0)
  {
    Task&lt;KeyValuePair&lt;string, int&gt;&gt; firstFinished = await Task.WhenAny(bookTasks);
    bookTasks.Remove(firstFinished);
    var thisBook = await firstFinished;
    TextResult.Text += String.Format("Finished downloading {0}. Word count: {1}\n", 
      thisBook.Key, 
      thisBook.Value);
  }
}</pre></div></li><li><p>Finally, let's create our start button click event handler. The handler only needs to call the <code class="literal">GetMultipleWordCount</code> method<a id="id596" class="indexterm"></a>.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  TextResult.Text += "Started downloading books...\n";
  await GetMultipleWordCount();
  TextResult.Text += "Finished downloading books...\n";
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec152"></a>How it worksâ€¦</h3></div></div></div><p>We have already seen in the previous recipes that the <code class="literal">WhenAny</code> method of the <code class="literal">Task</code> class can be used on a list <a id="id597" class="indexterm"></a>of parallel tasks to continue processing when any of the tasks in the array is complete.</p><p>Even though a task in the <code class="literal">async</code> context doesn't mean that our list of <code class="literal">async</code> tasks are running in parallel on separate worker threads, we can still use the <code class="literal">WhenAny</code> method<a id="id598" class="indexterm"></a> to handle <code class="literal">async</code> requests as they complete.</p><p>In this recipe, we downloaded the text of multiple books and displayed the word count of each of the books as the download finished. The start button's click event handler doesn't do much other than add some text to <code class="literal">TextBlock</code> and <code class="literal">await</code> a call to the <code class="literal">GetMultipleWordCount</code> method. After creating <code class="literal">HttpClient</code>, the <code class="literal">GetMultipleWordCount</code> method makes a call to the <code class="literal">GetBookUrls</code> helper method that we created, which just returns a list of three books and their URLs.</p><p>After getting the list of <a id="id599" class="indexterm"></a>books and their URLs, the <code class="literal">GetMultipleWordCount</code> method creates <code class="literal">IEnumerable&lt;Task&lt;TResult&gt;&gt;</code> by executing a LINQ query that calls the <code class="literal">ProcessBook</code> method on each <code class="literal">book</code> in the list.</p><div class="informalexample"><pre class="programlisting">var bookQuery = from book in urlList select ProcessBook(book, client);
var bookTasks = bookQuery.ToList();</pre></div><p>Next, we set up a <code class="literal">while</code> loop on the condition that <code class="literal">bookTasks.Count</code> is greater than zero. In the body of the <code class="literal">while</code> loop, we <code class="literal">await</code> a call to the <code class="literal">Task.WhenAny</code> method, which will return when the first list of tasks is complete. We then remove this <code class="literal">Task</code> from <code class="literal">bookTasks</code> so the count is decremented. Below that, we await the <code class="literal">firstFinished</code> task variable. This has the effect of the compiler creating a continuation for us at this point that will run, as soon as the <code class="literal">task</code> variable <code class="literal">firstFinished</code> is completed, the compiler-created continuation will contain the code to update the <code class="literal">TextBlock</code> with the word count for the book.</p><div class="informalexample"><pre class="programlisting">var firstFinished = await Task.WhenAny(bookTasks);
bookTasks.Remove(firstFinished);
var thisBook = await firstFinished;

// The compiler will create a continuation at this point that will run
//  when the task referenced by the firstFinished variable completes.
TextResult.Text += String.Format("Finished downloading {0}. Word count: {1}\n", 
  thisBook.Key, 
  thisBook.Value);</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec85"></a>Improving performance of async solution with Task.WhenAll </h2></div></div><hr /></div><p>We have already seen how we can use the <code class="literal">Task.WhenAny</code> method to handle asynchronous <a id="id600" class="indexterm"></a>tasks as they complete. You will also find the <code class="literal">Task.WhenAll</code> method very useful in the asynchronous context.<a id="id601" class="indexterm"></a> In some applications that create multiple asynchronous requests, it can improve application performance by using <code class="literal">Task.WhenAll</code> to hold off on processing results until all the asynchronous tasks have completed.</p><p>In this recipe, we are going to create a WPF application that downloads the contents of multiple books asynchronously, but holds off on processing the results until all the tasks have completed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec153"></a>How to do itâ€¦</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncMultipleRequest</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by <a id="id602" class="indexterm"></a>opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our user interface:<a id="id603" class="indexterm"></a>
</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncMultipleRequest.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,264,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
           HorizontalAlignment="Left" 
           Margin="48,10,0,0" 
           TextWrapping="Wrap" 
           VerticalAlignment="Top" 
           Height="213" Width="420"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div></li><li><p>Next, open up <code class="literal">MainWindow.xaml.cs</code>. Go to the <span class="strong"><strong>Project Explorer</strong></span>, and add a reference to <code class="literal">System.Net.Http</code>.</p></li><li><p>Add the following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Documents;
using System.Net.Http;</pre></div></li><li><p>At the top <a id="id604" class="indexterm"></a>of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split<a id="id605" class="indexterm"></a> the contents of the book into a word array.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };</pre></div></li><li><p>Let's start by creating a helper function that builds a list of <code class="literal">KeyValuePair&lt;string,string&gt;</code>, which represents our book titles and URLs.</p><div class="informalexample"><pre class="programlisting">private List&lt;KeyValuePair&lt;string, string&gt;&gt; GetBookUrls()
{
  var urlList = new List&lt;KeyValuePair&lt;string, string&gt;&gt;
  {
    new KeyValuePair&lt;string,string&gt;("Origin of Species",
          "http://www.gutenberg.org/files/2009/2009.txt"),
    new KeyValuePair&lt;string,string&gt;("Beowulf",
          "http://www.gutenberg.org/files/16328/16328-8.txt"),
    new KeyValuePair&lt;string,string&gt;("Ulysses",
          "http://www.gutenberg.org/files/4300/4300.txt")
  };
  return urlList;
}</pre></div></li><li><p>Now let's create a <code class="literal">async</code> method that performs the book download and returns <code class="literal">KeyValuePair&lt;string, int&gt;</code> that represents our book titles and word count. This method will need to accept a <code class="literal">KeyValuePair&lt;string, string&gt;</code> parameter representing the book title and URL. The method also needs a <code class="literal">HttpClient</code> parameter.</p><div class="informalexample"><pre class="programlisting">async Task&lt;KeyValuePair&lt;string,int&gt;&gt; ProcessBook(KeyValuePair&lt;string,string&gt; book, HttpClient client)
{
  var bookContents = await client.GetStringAsync(book.Value);
  var wordArray = bookContents.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return new KeyValuePair&lt;string,int&gt;(book.Key,wordArray.Count());
}</pre></div></li><li><p>Next, we need to create the <code class="literal">GetWordCount</code> method. This method will execute a LINQ query to call the <code class="literal">ProcessBook</code> method on each <code class="literal">book</code> in the list of books.<a id="id606" class="indexterm"></a> It then calls <code class="literal">Task.WhenAll</code> to <code class="literal">await</code> the tasks completed of all of the tasks. When<a id="id607" class="indexterm"></a> all tasks have finished, it needs to write the results to the <code class="literal">TextBlock</code> in a <code class="literal">for</code> loop.</p><div class="informalexample"><pre class="programlisting">public async Task GetWordCount()
{            
  var urlList = GetBookUrls();
  var wordCountQuery = from book in urlList select ProcessBook(book);
  Task&lt;KeyValuePair&lt;string,int&gt;&gt;[] wordCountTasks = wordCountQuery.ToArray();
  KeyValuePair&lt;string, int&gt;[] wordCounts = await Task.WhenAll(wordCountTasks);
  foreach (var book in wordCounts)
  {
    TextResult.Text += String.Format("Finished processing {0} : Word count {1} \n", 
      book.Key, book.Value);
  }
}</pre></div></li><li><p>Lastly, the start button click event handler just needs to call the <code class="literal">GetWordCount</code> method and <code class="literal">await</code> the task.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  
  TextResult.Text = "Started downloading books...\n";
  Task countTask = GetWordCount();
  await countTask;            
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should have results as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec154"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, the <code class="literal">GetWordCount</code> method<a id="id608" class="indexterm"></a> calls the <code class="literal">ProcessBook</code> method for each book in the list by executing<a id="id609" class="indexterm"></a> a LINQ <a id="id610" class="indexterm"></a>query. This returns an <code class="literal">IEnumerable&lt;Task&lt;TResult&gt;&gt;</code>, when we turn in to an array of tasks by calling the <code class="literal">ToArray</code> method.</p><div class="informalexample"><pre class="programlisting">var urlList = GetBookUrls();
var wordCountQuery = from book in urlList select ProcessBook(book);
var wordCountTasks = wordCountQuery.ToArray();</pre></div><p>Next, we just <code class="literal">await</code> a call to the <code class="literal">Task.WhenAll</code> method which will return when all of the asynchronous tasks complete. Finally, we just use a <code class="literal">for</code> loop to update the <code class="literal">TextBlock</code>.</p><div class="informalexample"><pre class="programlisting">var wordCounts = await Task.WhenAll(wordCountTasks);
foreach (var book in wordCounts)
{
  TextResult.Text += String.Format("Finished processing {0} : Word count {1} \n", book.Key, book.Value);
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec86"></a>Using async for file access</h2></div></div><hr /></div><p>Until now, we have created applications that use <code class="literal">async</code> for web access, using <code class="literal">HttpClient</code>. Another<a id="id611" class="indexterm"></a> common use for <code class="literal">async</code> is performing asynchronous file I/O without blocking the main thread.</p><p>In this recipe, we are going to create a WPF application that can write to and read from a file asynchronously. The application will have two text boxes, one containing the text to write to a file, and the other containing text to read from a file.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec155"></a>How to do itâ€¦</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncFileAccess</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and adding the following XAML to create our user interface:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncFileAccess.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;Label Content="Text to Write" 
        HorizontalAlignment="Left" 
        Margin="49,24,0,0" 
        VerticalAlignment="Top" 
        Width="87"/&gt;
        &lt;Button x:Name="WriteButton" 
        Content="Write to File" 
        HorizontalAlignment="Left" 
        Margin="212,139,0,0" 
        VerticalAlignment="Top" 
        Width="75" 
        Click="WriteButton_Click"/&gt;
        &lt;TextBox x:Name="TextWrite" 
        HorizontalAlignment="Left" 
        Height="66" Margin="54,55,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" Width="420"/&gt;
        &lt;TextBox x:Name="TextRead" 
        HorizontalAlignment="Left" 
        Height="66" 
        Margin="54,200,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Width="420"/&gt;
        &lt;Label Content="Text from File" 
        HorizontalAlignment="Left" 
        Margin="51,167,0,0" 
        VerticalAlignment="Top" 
        Width="87"/&gt;
        &lt;Button x:Name="ReadButton" 
        Content="Read from File" 
        HorizontalAlignment="Left" 
        Margin="205,277,0,0" 
        VerticalAlignment="Top" 
        Width="94" 
        Click="ReadButton_Click"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;.</pre></div><div class="mediaobject"><img src="graphics/0225OT_08_09.jpg" /></div></li><li><p>Add the<a id="id612" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">path</code> constant for the path of the text file you will be writing. This can be any path you like.</p><div class="informalexample"><pre class="programlisting">string path = @"C:\temp\temp.txt";</pre></div></li><li><p>Next, let's create a <code class="literal">async</code> method called <code class="literal">WriteToFileAsync</code> that returns <code class="literal">Task</code>. This method gets a <code class="literal">Unicode</code> encoded <code class="literal">byte</code> array of the text in our <code class="literal">TextBox</code>, creates a file stream, and writes the text to the file.</p><div class="informalexample"><pre class="programlisting">private async Task WriteToFileAsync(string path, string content)
{
  byte[] encodedContent = Encoding.Unicode.GetBytes(content);
  using(FileStream stream = new FileStream(path,FileMode.Append,
       FileAccess.Write,
       FileShare.None,
       bufferSize: 4096,
       useAsync:true))
       {
         await stream.WriteAsync(encodedContent,
                    0,
                    encodedContent.Length);
       };
}</pre></div></li><li><p>Now create an asynchronous <code class="literal">Click</code> event handler for the <code class="literal">Write</code> button. Here, we just need to <code class="literal">await</code> a call to <code class="literal">WriteFileAsync</code>, passing it the input string.</p><div class="informalexample"><pre class="programlisting">private async void WriteButton_Click(object sender, RoutedEventArgs e)
{
  WriteButton.IsEnabled = false;
  string content = TextWrite.Text;
  await WriteToFileAsync(path, content);
  WriteButton.IsEnabled = true;
}</pre></div></li><li><p>Now,<a id="id613" class="indexterm"></a> let's create an asynchronous method called <code class="literal">ReadFromFileAsync</code> that returns <code class="literal">Task&lt;string&gt;</code>. This method creates <code class="literal">FileStream</code> and reads the contents of the file into <code class="literal">string</code>.</p><div class="informalexample"><pre class="programlisting">private async Task&lt;string&gt; ReadFromFileAsync(string path)
{
  using (FileStream stream = new FileStream(path, 
                  FileMode.Open,
                  FileAccess.Read, 
                  FileShare.Read, 
                  bufferSize: 4096, 
                  useAsync: true))
  {
    var sb = new StringBuilder();
    byte[] buffer = new byte[0x1000];
    int bytesRead;
    while((bytesRead = await stream.ReadAsync(buffer, 
                      	  0, 
                      	  buffer.Length))!=0)
    {
      string content = Encoding.Unicode.GetString(buffer,
                            0,
                            bytesRead);
      sb.Append(content);
    }
    return sb.ToString();
  }
}</pre></div></li><li><p>Finally, let's create the read button click handler. This <code class="literal">async</code> method just needs to<a id="id614" class="indexterm"></a> check for the existence of the file, and <code class="literal">await</code> a call to <code class="literal">ReadFromFileAsync</code>. Set the results of the method call to the proper <code class="literal">TextBox</code>.</p><div class="informalexample"><pre class="programlisting">private async void ReadButton_Click(object sender, RoutedEventArgs e)
{
  if (File.Exists(path) == false)
  {
    TextRead.Text = "There was an error reading the file.";
  }
  else
  {
    try
    {
      string content = await ReadFromFileAsync(path);
      TextRead.Text = content;
    }
    catch(Exception ex)
    {
      TextRead.Text = ex.Message;
    }                
  }
}</pre></div></li><li><p>In Visual <a id="id615" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_010.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec156"></a>How it worksâ€¦</h3></div></div></div><p>The <code class="literal">Click</code> event handler is pretty straightforward. It is marked with the <code class="literal">async</code> keyword because it awaits a call to <code class="literal">WriteToFileAsync</code>. You must have noticed that we disabled the <code class="literal">Write</code> button at the start of the method and enabled it again at the end. This is a good practice to control reentrancy with <code class="literal">async</code> methods. The UI is free to respond to clicks and will fire the <code class="literal">Click</code> event handler again, if it receives a click.</p><div class="informalexample"><pre class="programlisting">private async void WriteButton_Click(object sender, RoutedEventArgs e)
{
  WriteButton.IsEnabled = false;
  string content = TextWrite.Text;
  await WriteToFileAsync(path, content);
  WriteButton.IsEnabled = true;
}</pre></div><p>The <code class="literal">WriteToFileAsync</code> method<a id="id616" class="indexterm"></a> gets a <code class="literal">Unicode</code> encoded <code class="literal">byte</code> array of the input string then creates <code class="literal">FileStream</code> with <code class="literal">Write</code> access in the <code class="literal">Append</code> mode. Once <code class="literal">stream</code> is open, we <code class="literal">await</code> a call to the <code class="literal">WriteAsync</code> method of <code class="literal">FileStream</code>, passing it our <code class="literal">byte</code> array.</p><div class="informalexample"><pre class="programlisting">byte[] encodedContent = Encoding.Unicode.GetBytes(content);
using(FileStream stream = new FileStream(path,FileMode.Append,
     FileAccess.Write,FileShare.None,bufferSize: 4096,useAsync:true))
     {
       await stream.WriteAsync(encodedContent,0,encodedContent.Length);
     };</pre></div><p>The <code class="literal">ReadFromFileAsync</code> method<a id="id617" class="indexterm"></a> just creates <code class="literal">FileStream</code> in open mode with read access. Once the <code class="literal">stream</code> is <a id="id618" class="indexterm"></a>open, we <code class="literal">await</code> a call to the <code class="literal">ReadAsync</code> method of <code class="literal">FileStream</code> in a <code class="literal">while</code> loop, and read its contents.</p><div class="informalexample"><pre class="programlisting">var sb = new StringBuilder();
byte[] buffer = new byte[0x1000];
int bytesRead;
while((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length))!=0)
{
  string content = Encoding.Unicode.GetString(buffer,0,bytesRead);
  sb.Append(content);
}
return sb.ToString();</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec87"></a>Checking the progress of an asynchronous task</h2></div></div><hr /></div><p>If an asynchronous functionality in your application involves a noticeable delay while the user waits for the result, you might want to inform users that there will be a wait and provide a sense of <a id="id619" class="indexterm"></a>how long the wait might be. The progress and cancellation features of the <code class="literal">async</code> programming model enable you to deliver on these needs.</p><p>In this recipe, we are going to create a WPF application that uses the progress events of <code class="literal">WebClient</code> to display the status of a <code class="literal">Download</code> task with a <code class="literal">ProgressBar</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec157"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a WPF application and see how we can add progress reporting to our asynchronous operations.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>WPF Application</strong></span> project template and assign <code class="literal">AsyncProgress</code> as <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Begin by opening <code class="literal">MainWindow.xaml</code> and add the following XAML to create our user interface:</p><div class="informalexample"><pre class="programlisting">&lt;Window x:Class="AsyncProgress.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="AsyncProgress" Height="400" Width="525" ResizeMode="NoResize"&gt;
    &lt;Grid&gt;
        &lt;Button x:Name="StartButton" 
        Content="Start Download" 
        HorizontalAlignment="Left" 
        Margin="194,288,0,0" 
        VerticalAlignment="Top" 
        Width="125" 
        RenderTransformOrigin="-0.2,0.45" 
        Click="StartButton_Click"/&gt;
        &lt;TextBlock x:Name="TextResult" 
        HorizontalAlignment="Left" 
        Margin="48,10,0,0" 
        TextWrapping="Wrap" 
        VerticalAlignment="Top" 
        Height="213" 
        Width="420"/&gt;
        &lt;ProgressBar x:Name="DownloadProgress" 
        HorizontalAlignment="Left" 
        Height="20" 
        Margin="48,249,0,0" 
        VerticalAlignment="Top" 
        Width="420"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</pre></div><div class="mediaobject"><img src="graphics/0225OT_08_011.jpg" /></div></li><li><p>Add the<a id="id620" class="indexterm"></a> following <code class="literal">using</code> directives to the top of your <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.ComponentModel;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using System.Windows;</pre></div></li><li><p>At the top of the <code class="literal">MainWindow</code> class, add a <code class="literal">character</code> array constant that will be used to split the contents of the book into a word array. Also add a <code class="literal">string</code> constant for the user agent header for a <code class="literal">WebClient</code>.</p><div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";</pre></div></li><li><p>Now let's add a method called <code class="literal">client_DownloadFileCompleted</code> that will be the event handler for the <code class="literal">DownloadFileCompleted</code> event of a <code class="literal">WebClient</code>. This method just needs to add some text to <code class="literal">TextBlock</code> to indicate that the download has finished.</p><div class="informalexample"><pre class="programlisting">void client_DownloadFileCompleted(object sender, AsyncCompletedEventArgs e)
{
  TextResult.Text += " Download completed. \n";
}</pre></div></li><li><p>Next,<a id="id621" class="indexterm"></a> create a method called <code class="literal">client_DownloadProgressChanged</code>
<a id="id622" class="indexterm"></a>. This method will be the event handler for the WebClient's <code class="literal">DownloadProgressChanged</code> event, and needs to calculate the bytes received, the total bytes, the percentage complete, and update the progress bar.</p><div class="informalexample"><pre class="programlisting">void client_DownloadProgressChanged(object sender, DownloadProgressChangedEventArgs e)
{
  double bytesIn = double.Parse(e.BytesReceived.ToString());
  double totalBytes = double.Parse(e.TotalBytesToReceive.ToString());
  double percentage = bytesIn / totalBytes * 100;
  DownloadProgress.Value = int.Parse(Math.Truncate(percentage).ToString());
}</pre></div></li><li><p>Now we need to create our asynchronous <code class="literal">GetWordCountAsync</code> method<a id="id623" class="indexterm"></a>. This method returns <code class="literal">Task&lt;int&gt;</code>, and after creating <code class="literal">WebClient</code>, and wiring up the <code class="literal">DownloadFileCompletedEvent</code> and <code class="literal">DownloadProgressChanged</code> events, it awaits a call to the <code class="literal">DownloadStringTaskAsync</code> method of <code class="literal">WebClient</code> to download the contents of the book and split the words into an array of strings.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCount()
{
  TextResult.Text += " Getting the word count for Origin of Species...\n";
  var client = new WebClient();
  client.Headers.Add("user-agent", headerText);
  client.DownloadProgressChanged += new 
      DownloadProgressChangedEventHandler(client_DownloadProgressChanged);
  client.DownloadFileCompleted += 
      new AsyncCompletedEventHandler(client_DownloadFileCompleted);
  Task&lt;string&gt; wordsTask = 
    client.DownloadStringTaskAsync(new Uri("http://www.gutenberg.org/files/2009/2009.txt"));
  var words = await wordsTask;
  var wordArray = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);
  return wordArray.Count();
}</pre></div></li><li><p>Finally,<a id="id624" class="indexterm"></a> let's create an asynchronous <code class="literal">Click</code> event handler for <code class="literal">StartButton</code>. This button just writes some text to <code class="literal">TextBlock</code> and awaits a call to <code class="literal">GetWordCountAsync</code>.</p><div class="informalexample"><pre class="programlisting">private async void StartButton_Click(object sender, RoutedEventArgs e)
{
  TextResult.Text += "Started downloading Origin of Species...\n";
  Task&lt;int&gt; countTask = GetWordCountAsync();
  int result = await countTask;
  TextResult.Text += String.Format("Finished downloading. Word count: {0}\n", result);
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should display the results as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_08_012.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec158"></a>How it worksâ€¦</h3></div></div></div><p>This application was able to show the progress of its download by wiring up two events of the <code class="literal">WebClient</code> class: <code class="literal">DownloadProgressChanged</code> and <code class="literal">DownloadFileCompleted</code>. It then calls the<a id="id625" class="indexterm"></a> <code class="literal">DownloadStringTaskAsync</code> method<a id="id626" class="indexterm"></a> of <code class="literal">WebClient</code>, which triggers the events as the download progresses.</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; GetWordCountAsync()
{
  ...
  client.DownloadProgressChanged += 
      new DownloadProgressChangedEventHandler(client_DownloadProgressChanged);
  client.DownloadFileCompleted += 
      new AsyncCompletedEventHandler(client_DownloadFileCompleted);
  Task&lt;string&gt; wordsTask = 
      client.DownloadStringTaskAsync(new Uri("http://www.gutenberg.org/files/2009/2009.txt"));
  ...
}</pre></div><p>The event handler for <code class="literal">DownloadFileCompleted</code> is pretty self-explanatory. The event handler for <code class="literal">DownloadProgressChanged</code> is where the calculation of the progress actually happens. Each time the event fires, we get the number of bytes the <code class="literal">WebClient</code> has received, the total number of bytes to receive, and we calculate the percentage completed of the download. Finally, we set the<a id="id627" class="indexterm"></a> <code class="literal">Value</code> property of <code class="literal">ProgressBar</code> with the results of the <code class="literal">percentage</code> calculation.</p><div class="informalexample"><pre class="programlisting">void client_DownloadProgressChanged(object sender, DownloadProgressChangedEventArgs e)
{
  double bytesIn = double.Parse(e.BytesReceived.ToString());
  double totalBytes = double.Parse(e.TotalBytesToReceive.ToString());
  double percentage = bytesIn / totalBytes * 100;
  DownloadProgress.Value = int.Parse(Math.Truncate(percentage).ToString());
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>ChapterÂ 9.Â Dataflow Library</h2></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Reading from and writing to a dataflow block synchronously</p></li><li style="list-style-type: disc"><p>Reading from and writing to a dataflow block asynchronously</p></li><li style="list-style-type: disc"><p>Implementing a producer-consumer dataflow pattern</p></li><li style="list-style-type: disc"><p>Creating a dataflow pipeline</p></li><li style="list-style-type: disc"><p>Cancelling a dataflow block</p></li><li style="list-style-type: disc"><p>Specifying the degree of parallelism</p></li><li style="list-style-type: disc"><p>Unlink dataflow blocks</p></li><li style="list-style-type: disc"><p>Using <code class="literal">JoinBlock</code> to read from multiple data sources</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec88"></a>Introduction</h2></div></div><hr /></div><p>The Task Parallel Library's dataflow is a new library that is designed to increase the robustness of highly concurrent applications. TPL dataflow uses asynchronous message passing and pipelining to obtain more control and better performance than manual threading.</p><p>A dataflow<a id="id628" class="indexterm"></a> consists of a series of blocks. Each block can be a source or target for data. Data typically enters into a dataflow by being posted to a propagation block, which is a block that implements <code class="literal">ISourceBlock&lt;T&gt;</code> and <code class="literal">ITargetBlock&lt;T&gt;</code>. The source block can be linked to other target or propagation blocks. The data flows from one block to the next block in the chain asynchronously. The data is buffered at the source or target block until it is needed.</p><p>The predefined blocks fall into three categories. There are <a id="id629" class="indexterm"></a>buffering blocks which hold data for use by data consumers, there are execution blocks <a id="id630" class="indexterm"></a>that call a user-provided delegate for each piece of received data, and there are grouping blocks which combine data from one or more sources and under various constraints.</p><p>The TPL dataflow library provides three types of buffering blocks. There is the <code class="literal">System.Threading.Tasks.Dataflow.BufferBlock&lt;T&gt;</code> class, the <code class="literal">System.Threading.Tasks.Dataflow.BroadcastBlock&lt;T&gt;</code> class, and the <code class="literal">System.Threading.Tasks.Dataflow.WriteOnceBlock&lt;T&gt;</code> class. The <code class="literal">BufferBlock&lt;T&gt;</code> class is a general-purpose asynchronous messaging class. <code class="literal">BufferBlock&lt;T&gt;</code> stores a <span class="strong"><strong>First-In- First-Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>)<a id="id631" class="indexterm"></a> queue of messages that can be written to by multiple sources or read from by multiple targets.</p><p>The <code class="literal">BroadcastBlock&lt;T&gt;</code> class<a id="id632" class="indexterm"></a> is useful when you pass multiple messages to another component, or a message to multiple components.</p><p>The <code class="literal">WriteOnceBlock&lt;T&gt;</code> class<a id="id633" class="indexterm"></a> is similar the <code class="literal">BroadcastBlock&lt;T&gt;</code> class, except that a <code class="literal">WriteOnceBlock&lt;T&gt;</code> object can be written one time only.</p><p>The TPL dataflow library provides three types of execution blocks. There is the <code class="literal">ActionBlock&lt;TInput&gt;</code> class, the <code class="literal">System.Threading.Tasks.Dataflow.TransformBlock&lt;TInput, TOutput&gt;</code> class, and the <code class="literal">System.Threading.Tasks.Dataflow.TransformManyBlock&lt;TInput, TOutput&gt;</code> class.</p><p>The <code class="literal">ActionBlock&lt;TInput&gt;</code> class<a id="id634" class="indexterm"></a> is a target block that calls a delegate when it receives data. You can think of a <code class="literal">ActionBlock&lt;TInput&gt;</code> object as a delegate that runs asynchronously when data becomes available.</p><p>The <code class="literal">TransformBlock&lt;TInput, TOutput&gt;</code> class<a id="id635" class="indexterm"></a> resembles the <code class="literal">ActionBlock&lt;TInput&gt;</code> class, except that it acts both as a source and as a target.</p><p>The <code class="literal">TransformManyBlock&lt;TInput, TOutput&gt; </code>class<a id="id636" class="indexterm"></a> resembles the <code class="literal">TransformBlock&lt;TInput,</code> <code class="literal">TOutput&gt;</code> class<a id="id637" class="indexterm"></a>, except that <code class="literal">TransformManyBlock&lt;TInput, TOutput&gt;</code> produces zero or more output values for each input value, instead of only one output value for each input value.</p><p>The TPL dataflow library also provides three types of join blocks. There is the <code class="literal">BatchBlock&lt;T&gt;</code> class, the <code class="literal">JoinBlock&lt;T1, T2&gt;</code> class, and the <code class="literal">BatchedJoinBlock&lt;T1, T2&gt;</code> class.<a id="id638" class="indexterm"></a>
</p><p>The <code class="literal">BatchBlock&lt;T&gt;</code> class <a id="id639" class="indexterm"></a>combines sets of input data, which are known as batches, into arrays of output data.</p><p>The <code class="literal">JoinBlock&lt;T1, T2&gt;</code> and <code class="literal">JoinBlock&lt;T1, T2, T3&gt;</code> classes collect input elements and propagate out <code class="literal">System.Tuple&lt;T1, T2&gt;</code> or <code class="literal">System.Tuple&lt;T1, T2, T3&gt;</code> objects that contain those elements.</p><p>The <code class="literal">BatchedJoinBlock&lt;T1, T2&gt;</code> and <code class="literal">BatchedJoinBlock&lt;T1, T2, T3&gt;</code> classes collect batches of input elements and propagate out the <code class="literal">System.Tuple(IList(T1), IList(T2))</code> or <code class="literal">System.Tuple(IList(T1), IList(T2), IList(T3))</code> objects that contain those elements.</p><p>The Dataflow library's infrastructure is built on .NET 4.5's Task Parallel Library. These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec89"></a>Reading from and writing to a dataflow block synchronously</h2></div></div><hr /></div><p>Writing a message synchronously to a dataflow block is done by calling the <code class="literal">Post&lt;TInput&gt;</code> method of a block. Let's use the <code class="literal">Receive</code> method of the block to receive data.</p><p>In this recipe, we are <a id="id640" class="indexterm"></a>going to create a <code class="literal">Console</code> application that uses a <code class="literal">for</code> loop to synchronously write some numbers to <code class="literal">BufferBlock</code> using<a id="id641" class="indexterm"></a> the <code class="literal">Post</code> method. The application then reads the data back from <code class="literal">BufferBlock</code> using the <code class="literal">Receive</code> method and writes the data to <code class="literal">Console</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec159"></a>Getting readyâ€¦</h3></div></div></div><p>The TPL dataflow library doesn't ship with the rest of the TPL. To use the TPL dataflow library in your solutions, you need to use NuGet Package Manager to set your reference.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>After creating your new project in Visual Studio 2012, go to the <span class="strong"><strong>Solution</strong></span> <span class="strong"><strong>Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, and click on <span class="strong"><strong>Manage</strong></span> <span class="strong"><strong>NuGet</strong></span> <span class="strong"><strong>Package</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_09_01.jpg" /></div></li><li><p>In the NuGet<a id="id642" class="indexterm"></a> Package Manager<a id="id643" class="indexterm"></a> window, click on <span class="strong"><strong>Online</strong></span> from the menu on the left and search for <span class="strong"><strong>TPL Dataflow</strong></span>.</p><div class="mediaobject"><img src="graphics/0225OT_09_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec160"></a>How to do itâ€¦</h3></div></div></div><p>Let's create a new <code class="literal">Console</code>
<a id="id644" class="indexterm"></a> application so we can<a id="id645" class="indexterm"></a> see how to create a dataflow block and write to it synchronously.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">Dataflow ReadingWriting</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGetPackages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks.Dataflow;</pre></div></li><li><p>In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, create a <code class="literal">BufferBlock&lt;int&gt;</code> object.</p><div class="informalexample"><pre class="programlisting">var bufferingBlock = new BufferBlock&lt;int&gt;();</pre></div></li><li><p>Now let's create a <code class="literal">for</code> loop that loops from zero to ten and writes the square of the loop index to the buffer block using the <code class="literal">Post</code> method.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 10; i++)
{
  bufferingBlock.Post(i*i);
}</pre></div></li><li><p>Now, let's create another <code class="literal">for</code> loop that loops from zero to ten that calls the <code class="literal">Receive</code> method on the buffer block for each iteration, and writes the results to <code class="literal">Console</code>.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 10; i++)
{
  Console.WriteLine(bufferingBlock.Receive.ToString());
}</pre></div></li><li><p>Finish up by<a id="id646" class="indexterm"></a> writing a<a id="id647" class="indexterm"></a> message to the <code class="literal">Console</code> application and waiting for user input before exiting.</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Finished. Press any key to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button, and your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_03.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec161"></a>How it worksâ€¦</h3></div></div></div><p>This simple example shows how to read from and write to a message block directly. More often, you will <a id="id648" class="indexterm"></a>be connecting dataflow blocks to form pipelines, or linear sequences of blocks.</p><p>Writing to a block<a id="id649" class="indexterm"></a> directly is a pretty easy matter; you just need to call the <code class="literal">Post&lt;TInput&gt;</code> method.</p><div class="informalexample"><pre class="programlisting">bufferingBlock.Post(i*i);</pre></div><p>The <code class="literal">Post</code> method acts synchronously, and returns once the target block has decided to accept or reject the item.</p><p>Conversely, data can be directly received from <code class="literal">bufferingBlock</code> by calling the <code class="literal">Receive</code> method.</p><div class="informalexample"><pre class="programlisting">bufferingBlock.Receive()</pre></div><p>The <code class="literal">Receive</code> method has a few convenient overloads that can accept a time out period, <code class="literal">CancellationToken</code> or both.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec90"></a>Reading from and writing to a dataflow block asynchronously</h2></div></div><hr /></div><p>Writing a message <a id="id650" class="indexterm"></a>asynchronously to a dataflow block is done by calling the <code class="literal">SendAsync&lt;TInput&gt;</code> method of a block. <a id="id651" class="indexterm"></a>You use the <code class="literal">ReceiveAsync</code> method of the block to receive data.</p><p>In this recipe, we are going to create a <code class="literal">Console</code> application that uses a <code class="literal">for</code> loop to asynchronously write some numbers to <code class="literal">BufferBlock</code> using the <code class="literal">SendAsync</code> method. The application then reads the data back from <code class="literal">BufferBlock</code> using the <code class="literal">ReceiveAsync</code> method and writes the data to <code class="literal">Console</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec162"></a>How to do itâ€¦</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">Dataflow ReadWriteAsync</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to <span class="strong"><strong>Solution</strong></span> <span class="strong"><strong>Explorer</strong></span>, right-click on <span class="strong"><strong>references</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span> and add a reference to the TPL Dataflow library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks.Dataflow;
using System.Threading.Tasks;</pre></div></li><li><p>Now let's create a <code class="literal">static async</code> method that returns <code class="literal">Task</code> called <code class="literal">WriteDataAsync</code>. The method takes a <code class="literal">BufferBlock&lt;int&gt;</code> parameter, and uses a <code class="literal">for</code> loop to iterate<a id="id652" class="indexterm"></a> from zero to ten. In each iteration of the loop, we need to use the <code class="literal">SendAsync</code> method<a id="id653" class="indexterm"></a> to write the square of the loop indexer to <code class="literal">bufferingBlock</code>.</p><div class="informalexample"><pre class="programlisting">private static async Task WriteDataAsync(BufferBlock&lt;int&gt; bufferingBlock)
{
  // Post some messages to the block. 
  for (int i = 0; i &lt; 10; i++)
  {
    await bufferingBlock.SendAsync(i * i);
  }
}</pre></div></li><li><p>Next, let's create a <code class="literal">static async</code> method<a id="id654" class="indexterm"></a> that returns <code class="literal">Task</code> called <code class="literal">ReadDataAsync</code>. The method takes a <code class="literal">BufferBlock&lt;int&gt;</code> parameter, and uses a <code class="literal">for</code> loop to read the data from <code class="literal">BufferBlock</code> and display it to <code class="literal">Console</code>.</p><div class="informalexample"><pre class="programlisting">private static async Task ReadDataAsync(BufferBlock&lt;int&gt; bufferingBlock)
{
  // Receive the messages back . 
  for (int i = 0; i &lt; 10; i++)
  {
    Console.WriteLine(await bufferingBlock.ReceiveAsync());
  }
}</pre></div></li><li><p>Finally, let's create the implementation of the <code class="literal">Main</code> method. Here we just need to wait on calls to <code class="literal">WriteDataAsync</code> and <code class="literal">ReadDataAsync</code>. We also need to wait on user input before exiting.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  // Create a BufferBlock object. 
  var bufferingBlock = new BufferBlock&lt;int&gt;();
  WriteDataAsync(bufferingBlock).Wait();
  ReadDataAsync(bufferingBlock).Wait();

  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre></div></li><li><p>Now, in Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec163"></a>How it worksâ€¦</h3></div></div></div><p>This application uses the <code class="literal">SendAsync</code> method<a id="id655" class="indexterm"></a> to asynchronously write to a <code class="literal">BufferBlock&lt;int&gt;</code> object and the <code class="literal">ReceiveAsync</code> method to read from the<a id="id656" class="indexterm"></a> same object. We also use the <code class="literal">async</code> and <code class="literal">await</code> operators to send data to and read data from the target block.</p><p>Notice that both the <a id="id657" class="indexterm"></a>
<code class="literal">ReadDataAsync</code> and <code class="literal">WriteDataAsync</code> methods<a id="id658" class="indexterm"></a> are marked as <code class="literal">async</code>, with a return type of <code class="literal">Task</code>. We use the <code class="literal">await</code> keyword to asynchronously make the call to <code class="literal">SendAsync</code> and <code class="literal">ReceiveAsync</code>.</p><div class="informalexample"><pre class="programlisting">private static async Task ReadDataAsync(BufferBlock&lt;int&gt; bufferingBlock)
{            
  for (int i = 0; i &lt; 10; i++)
  {
    Console.WriteLine(await bufferingBlock.ReceiveAsync());
  }
}</pre></div><p>The <code class="literal">ReceiveAsync</code> method <a id="id659" class="indexterm"></a>is especially useful when you want to act on data as the data becomes available.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec91"></a>Implementing a producer-consumer dataflow pattern</h2></div></div><hr /></div><p>TPL dataflow blocks can also be used in a producer-consumer pattern, where a producer sends messages to a block, and the consumer reads messages from a block.</p><p>In this recipe, we are going<a id="id660" class="indexterm"></a> to create a <code class="literal">Console</code> application to demonstrate a basic producer-consumer pattern that uses dataflow. The producer will use a <code class="literal">for</code> loop to create some random numbers and add them to <code class="literal">BufferBlock&lt;int&gt;</code>. The consumer task will asynchronously receive the data from <code class="literal">BufferBlock</code> as it becomes available, and returns a sum of all the numbers.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec164"></a>How to do itâ€¦</h3></div></div></div><p>Let's create another <code class="literal">Console</code>
<a id="id661" class="indexterm"></a> application and see how we can use dataflow blocks to implement a producer-consumer pattern.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">Dataflow ProducerConsumer</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks.Dataflow;
using System.Threading.Tasks;</pre></div></li><li><p>Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class called <code class="literal">Produce</code>. This method returns <code class="literal">void</code>, and takes a parameter of type <code class="literal">ITargetBlock&lt;int&gt;</code>. This method will use a <code class="literal">for</code> loop to generate random numbers, and then use the <code class="literal">Post</code> method to send them to the block. When the <code class="literal">Produce</code> method is finished adding, it calls the <code class="literal">Complete</code> method on the block.</p><div class="informalexample"><pre class="programlisting">static void Produce(ITargetBlock&lt;int&gt; target)
{
  // Create a Random object.
  Random rand = new Random();

  // fill a buffer with random data  
  for (int i = 0; i &lt; 100; i++)
  {
    // get the next random number 
    int number = rand.Next();

    // Post the result .
    target.Post(number);
  }

  // Set the target to the completed state
  target.Complete();
}</pre></div></li><li><p>Next, let's create a method called <code class="literal">ConsumeAsync</code>. As you probably guessed from the method<a id="id662" class="indexterm"></a> name, this is an <code class="literal">async</code> method that returns <code class="literal">Task&lt;int&gt;</code>.The <code class="literal">ConsumeAsync</code> method<a id="id663" class="indexterm"></a> needs a parameter type of <code class="literal">ISourceBlock&lt;int&gt;</code>. This method used a <code class="literal">while</code> loop to get data from the block as it becomes available, and produces a sum of the numbers.</p><div class="informalexample"><pre class="programlisting">static async Task&lt;int&gt; ConsumeAsync(ISourceBlock&lt;int&gt; source)
{
  // Initialize a counter to track the sum. 
  int sumOfProcessed = 0;

  // Read from the source buffer until empty
  while (await source.OutputAvailableAsync())
  {
    int data = source.Receive();

    // calculate the sum.
    sumOfProcessed += data;
  }

  return sumOfProcessed;
}</pre></div></li><li><p>Ok, let's finish up by implementing the <code class="literal">Main</code> method<a id="id664" class="indexterm"></a> of the <code class="literal">Program</code> class. This method just needs to start <code class="literal">producer</code> and <code class="literal">consumer</code>, and display the results when finished.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{  
  var buffer = new BufferBlock&lt;int&gt;();

  // Start the consumer.   
  var consumer = ConsumeAsync(buffer);

  // Post source data.
  Produce(buffer);

  // Wait for the consumer to process data.
  consumer.Wait();

  // Print the count of bytes processed to the console.
  Console.WriteLine("Sum of processed numbers: {0}.", consumer.Result);
  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre></div></li><li><p>In Visual Studio <a id="id665" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_05.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec165"></a>How it worksâ€¦</h3></div></div></div><p>The <code class="literal">Produce</code> method is very straightforward. We declared a parameter of the interface type <code class="literal">ITargetBlock&lt;TInput&gt;</code>. <code class="literal">ITargetBlock</code> is an interface implemented by <code class="literal">BufferBlock</code> that represents a dataflow block that is a target for data.</p><p>The <code class="literal">Produce</code> method just uses a <code class="literal">for</code> loop to send data to the target block using the <code class="literal">Post</code> method. After it is finished adding the data, it calls the complete method to signal that it is finished.</p><div class="informalexample"><pre class="programlisting">static void Produce(ITargetBlock&lt;int&gt; target)
{
  ... 
  for (int i = 0; i &lt; 100; i++)
  {
    ...
    target.Post(number);
  }.
  target.Complete();
}</pre></div><p>
<code class="literal">ConsumeAsync</code> accepts a parameter of the interface type <code class="literal">ISourceBlock</code>, which represents a dataflow<a id="id666" class="indexterm"></a> block that is a source of data. To act asynchronously, the <code class="literal">ConsumeAsync</code> method calls the <code class="literal">OutputAvailiableAsync</code> method<a id="id667" class="indexterm"></a> to receive a notification when the source block has data available when the source block is finished, and will never have additional data. Other than that, it just uses the <code class="literal">Receive</code> method to receive the data and sums up the results.</p><div class="informalexample"><pre class="programlisting">static async Task&lt;int&gt; ConsumeAsync(ISourceBlock&lt;int&gt; source)
{
  ...
  while (await source.OutputAvailableAsync())
  {
    int data = source.Receive();
      sumOfProcessed += data;
  }
  return sumOfProcessed;
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec92"></a>Creating a dataflow pipeline</h2></div></div><hr /></div><p>As we have seen so far, you can use <code class="literal">Post</code>, <code class="literal">Receive</code>, and <code class="literal">RecieveAsync</code> to send and receive messages from source blocks. You can also connect message blocks to form a dataflow pipeline. A dataflow<a id="id668" class="indexterm"></a> pipeline is a chain of dataflow blocks, each of which performs a specific task and contributes to a larger goal. Each block in the pipeline performs its work when it receives a message from another dataflow block.</p><p>In this recipe, we are to return to our WordCount example one final time. We are going to create a <code class="literal">Console</code> application that forms a dataflow pipeline for downloading the contents of a classic book, filters out the small words from the book contents, and returns a count of the words.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec166"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how<a id="id669" class="indexterm"></a> we can chain dataflow blocks together to form a pipeline.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">DataflowPipeline</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading.Tasks.Dataflow;
using System.Net;</pre></div></li><li><p>The first step is to create the dataflow blocks that participate in the pipeline. In the <code class="literal">Main</code> method, create <code class="literal">TransformBlock&lt;string,string&gt;</code> that takes the string input parameter and uses <code class="literal">WebClient</code> to download the book contents as a string.</p><div class="informalexample"><pre class="programlisting">// Download a book as a string
var downloadBook = new TransformBlock&lt;string, string&gt;(url =&gt;
{
  Console.WriteLine("Downloading the book...");

  return new WebClient().DownloadString(url);
});</pre></div></li><li><p>Next, let's add <code class="literal">TransformBlock&lt;string, string[]&gt;</code> which receives the output from the previous block, removes the spaces, and splits the words into a string array.</p><div class="informalexample"><pre class="programlisting">// splits text into an array of strings. 
var createWordList = new TransformBlock&lt;string, string[]&gt;(text =&gt;
{
  Console.WriteLine("Creating list of words...");

  // Remove punctuation  
  char[] tokens = text.ToArray();
  for (int i = 0; i &lt; tokens.Length; i++)
  {
    if (!char.IsLetter(tokens[i]))
      tokens[i] = ' ';
  }
  text = new string(tokens);

  return text.Split(new char[] { ' ' },
     StringSplitOptions.RemoveEmptyEntries);
});</pre></div></li><li><p>Ok, let's create <code class="literal">TransformBlock&lt;string[],int&gt;</code> that filters out words less than three <a id="id670" class="indexterm"></a>characters and returns a count of the words.</p><div class="informalexample"><pre class="programlisting">// Remove short words and return the count 
var filterWordList = new TransformBlock&lt;string[], int&gt;(words =&gt;
{
  Console.WriteLine("Counting words...");

  var wordList = words.Where(word =&gt; word.Length &gt; 3).OrderBy(word =&gt; word)
     .Distinct().ToArray();
  return wordList.Count();
});</pre></div></li><li><p>Finally, let's create <code class="literal">ActionBlock&lt;int&gt;</code> to display the word count to <code class="literal">Console</code>.</p><div class="informalexample"><pre class="programlisting">var printWordCount = new ActionBlock&lt;int&gt;(wordcount =&gt;
{
  Console.WriteLine("Found {0} words",
     wordcount);
});</pre></div></li><li><p>Now, let's use the <code class="literal">LinkTo</code> method to connect the source blocks and target blocks to form the pipeline.</p><div class="informalexample"><pre class="programlisting">downloadBook.LinkTo(createWordList);
createWordList.LinkTo(filterWordList);
filterWordList.LinkTo(printWordCount);</pre></div></li><li><p>Next, we need to add some completion tasks to enable each dataflow block to perform a final action after processing all data elements.</p><div class="informalexample"><pre class="programlisting">downloadBook.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)createWordList).Fault(t.Exception);
  else createWordList.Complete();
});
createWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)filterWordList).Fault(t.Exception);
  else filterWordList.Complete();
});
filterWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)printWordCount).Fault(t.Exception);
  else printWordCount.Complete();
});</pre></div></li><li><p>Finally, let's add some code to <code class="literal">Main</code> to post the data to the pipeline, complete the pipeline<a id="id671" class="indexterm"></a> activity, wait for the pipeline to finish, and wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">// Download Origin of Species
downloadBook.Post("http://www.gutenberg.org/files/2009/2009.txt");

// Mark the head of the pipeline as complete. 
downloadBook.Complete();

printWordCount.Completion.Wait();

Console.WriteLine("Finished. Press any key to exit.");
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should display the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec167"></a>How it worksâ€¦</h3></div></div></div><p>In this application we used <code class="literal">TransformBlock&lt;TInput, TOutput&gt;</code> to enable each member of the pipeline to perform an operation on its input data and send the results to the next step in the<a id="id672" class="indexterm"></a> pipeline. For example, <code class="literal">downloadBook TransformBlock</code> takes a string input and returns a string output to the next step.</p><div class="informalexample"><pre class="programlisting">var downloadBook = new TransformBlock&lt;string, string&gt;(uri =&gt;
{
  ...
  return new WebClient().DownloadString(uri);
});</pre></div><p>The only exception is the tail of the pipeline is <code class="literal">ActionBlock&lt;TInput&gt;</code> because it performs an action on its input and does not produce a result.</p><p>The next step is to connect each block in the pipeline to the next. The <code class="literal">LinkTo</code> method of <code class="literal">DataflowBlock</code> is used to connect <code class="literal">ISourceBlock&lt;TOutput&gt;</code> to <code class="literal">TargetBlock&lt;TInput&gt;</code>. When you call the <code class="literal">LinkTo</code> method to connect a source to a target, the source will propagate data to the target as it becomes available.</p><div class="informalexample"><pre class="programlisting">downloadBook.LinkTo(createWordList);
createWordList.LinkTo(filterWordList);
filterWordList.LinkTo(printWordCount);</pre></div><p>We also added some completion tasks to propagate completion through the pipeline. Each completion task sets the next dataflow block to the completed state.</p><div class="informalexample"><pre class="programlisting">downloadBook.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)createWordList).Fault(t.Exception);
  else createWordList.Complete();
});</pre></div><p>Finally, we used <code class="literal">DataflowBlock.Post&lt;TInput&gt;</code> to synchronously send data to the head of the pipeline. The following is the URL string of the book we are downloading:</p><div class="informalexample"><pre class="programlisting">downloadBook.Post("http://www.gutenberg.org/files/2009/2009.txt");</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec93"></a>Cancelling a dataflow block</h2></div></div><hr /></div><p>Since dataflow blocks are <a id="id673" class="indexterm"></a>built on the <code class="literal">Task</code> infrastructure of the TPL, cancellation is supported by obtaining <code class="literal">CancellationToken</code> from <code class="literal">CancellationTokenSource</code>.</p><p>In this recipe, we will create a dataflow pipeline to download the contents of a classic book and perform a word count, except this time, we will enable the blocks that form the pipeline to be cancelled.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec168"></a>How to do itâ€¦</h3></div></div></div><p>Let's see how we <a id="id674" class="indexterm"></a>can add cancellation to our dataflow blocks.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">CancelDataflow</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading.Tasks.Dataflow;
using System.Net;
using System.Threading;</pre></div></li><li><p>In the <code class="literal">Main</code> method, create a new <code class="literal">CancellationTokenSource</code> object.</p><div class="informalexample"><pre class="programlisting">var cancellationSource = new CancellationTokenSource();</pre></div></li><li><p>Next, let's create the blocks that form the pipeline. The blocks are exactly as before, except, this time they are created with a new <code class="literal">ExecutionDataflowBlockOptions</code> parameter<a id="id675" class="indexterm"></a> that sets <code class="literal">CancellationToken</code>.</p><div class="informalexample"><pre class="programlisting">// Download a book as a string
var downloadBook = new TransformBlock&lt;string, string&gt;(uri =&gt;
{
  Console.WriteLine("Downloading the book...");

  return new WebClient().DownloadString(uri);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});



// splits text into an array of strings. 
var createWordList = new TransformBlock&lt;string, string[]&gt;(text =&gt;
{
  Console.WriteLine("Creating list of words...");

  // Remove punctuation  
  char[] tokens = text.ToArray();
  for (int i = 0; i &lt; tokens.Length; i++)
  {
    if (!char.IsLetter(tokens[i]))
      tokens[i] = ' ';
  }
  text = new string(tokens);
  return text.Split(new char[] { ' ' },
     StringSplitOptions.RemoveEmptyEntries);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});

// Remove short words and return the count 
var filterWordList = new TransformBlock&lt;string[], int&gt;(words =&gt;
{
  Console.WriteLine("Counting words...");

  var wordList = words.Where(word =&gt; word.Length &gt; 3).OrderBy(word =&gt; word)
     .Distinct().ToArray();
  return wordList.Count();
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});

var printWordCount = new ActionBlock&lt;int&gt;(wordcount =&gt;
{
  Console.WriteLine("Found {0} words",
     wordcount);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});</pre></div></li><li><p>Now, let's use the <code class="literal">LinkTo</code> method to connect the source blocks and target blocks to form the pipeline.</p><div class="informalexample"><pre class="programlisting">downloadBook.LinkTo(createWordList);
createWordList.LinkTo(filterWordList);
filterWordList.LinkTo(printWordCount);</pre></div></li><li><p>Next, we<a id="id676" class="indexterm"></a> need to add some completion tasks to enable each dataflow block to perform a final action after processing all data elements.</p><div class="informalexample"><pre class="programlisting">downloadBook.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)createWordList).Fault(t.Exception);
  else createWordList.Complete();
});
createWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)filterWordList).Fault(t.Exception);
  else filterWordList.Complete();
});
filterWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)printWordCount).Fault(t.Exception);
  else printWordCount.Complete();
});</pre></div></li><li><p>Now, add a <code class="literal">try</code> block to post the data to the head of the pipeline, complete the pipeline activity, and cancel the token.</p><div class="informalexample"><pre class="programlisting">try
{
  Console.WriteLine("Starting...");                
  
  // Download Origin of Species
  downloadBook.Post("http://www.gutenberg.org/files/2009/2009.txt");

  // Mark the head of the pipeline as complete. 
  downloadBook.Complete();

  // Cancel the operation
  cancellationSource.Cancel();

  printWordCount.Completion.Wait();

}</pre></div></li><li><p>Finally, add a <code class="literal">catch</code> block that handles <code class="literal">AggregateException</code> and a <code class="literal">finally</code> block to wait for user input before exiting.</p><div class="informalexample"><pre class="programlisting">catch (AggregateException ae)
{
  foreach (Exception ex in ae.InnerExceptions)
  {
    Console.WriteLine(ex.Message);
  }
}
finally
{
  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre></div></li><li><p>In Visual Studio <a id="id677" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_07.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec169"></a>How it worksâ€¦</h3></div></div></div><p>This application forms a dataflow pipeline to process the contents of a book and return a word count as in<a id="id678" class="indexterm"></a> the previous recipe. The difference is that we set up cancellation by creating a <code class="literal">CancellationTokenSource</code> object, and then setting the <code class="literal">CancellationToken</code> property of the <code class="literal">ExecutionDataflowBlockOptions</code> object associated with the blocks in our pipeline.</p><div class="informalexample"><pre class="programlisting">CancellationTokenSource cancellationSource = new CancellationTokenSource();            

var downloadBook = new TransformBlock&lt;string, string&gt;(uri =&gt;
{
  ...

  return new WebClient().DownloadString(uri);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});</pre></div><p>We set the <code class="literal">CancellationToken</code> property<a id="id679" class="indexterm"></a> of the <code class="literal">ExecutionDataflowBlockOptions</code> object to <code class="literal">CancellationToken</code> obtained from the <code class="literal">CancellationTokenSource</code> object.</p><p>As with all other cancellations in the TPL, we need to handle the <code class="literal">OperationCancelled</code> exception, which will be wrapped in a <code class="literal">AggregateException</code> object.</p><div class="informalexample"><pre class="programlisting">catch (AggregateException ae)
{
  foreach (Exception ex in ae.InnerExceptions)
  {
    Console.WriteLine(ex.Message);
  }
}</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec94"></a>Specifying the degree of parallelism</h2></div></div><hr /></div><p>In the previous recipe, we saw how to use the <code class="literal">CancellationToken</code> property of the <code class="literal">ExecutionDataflowBlockOptions</code> object to enable cancellation of a pipeline. In this recipe, we will see how<a id="id680" class="indexterm"></a> to use the <code class="literal">MaxDegreeOfParallelism</code> property to enable dataflow blocks to process more than one message at a time.</p><p>We are going to create a <code class="literal">Console</code> application that performs two dataflow calculations, and prints the elapsed time of each calculation. The first calculation sets the maximum degree of parallelism to one. The second operation is the same as the first, but sets the maximum degree of parallelism to the number of available processors on your machine.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec170"></a>How to do itâ€¦</h3></div></div></div><p>Now, let's see how to add cancellation to our dataflow blocks.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">DegreeOfParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open<a id="id681" class="indexterm"></a> up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks.Dataflow;</pre></div></li><li><p>Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class called <code class="literal">ComputeTime</code>. The method needs to accept an <a id="id682" class="indexterm"></a>
<code class="literal">integer</code> parameter for <code class="literal">maxDegreeOfParallelism</code> and an <code class="literal">integer</code> parameter for <code class="literal">messageCount</code>.</p><div class="informalexample"><pre class="programlisting">static TimeSpan ComputeTime(int maxDegreeOfParallelism, int messageCount)
{
  
}</pre></div></li><li><p>In the <code class="literal">ComputeTime</code> method<a id="id683" class="indexterm"></a>, create <code class="literal">ActionBlock&lt;int&gt;</code> that just sleeps for the time period of the <code class="literal">integer</code> parameter. <code class="literal">ActionBlock</code> also needs to use a <code class="literal">ExecutionDataflowBlockOptions</code> parameter and set the <code class="literal">MaxDegreeOfParallelism</code> property to the value of the method parameter.</p><div class="informalexample"><pre class="programlisting">var actionBlock = new ActionBlock&lt;int&gt;(
  millisecondsTimeout =&gt; Thread.Sleep(millisecondsTimeout),
  new ExecutionDataflowBlockOptions
  {
     MaxDegreeOfParallelism = maxDegreeOfParallelism
  });</pre></div></li><li><p>Let's finish up the <code class="literal">ComputeTime</code> method by creating a <code class="literal">Stopwatch</code> object, using a <code class="literal">for</code> loop to post data to the action block, complete the action block, and return the elapsed time.</p><div class="informalexample"><pre class="programlisting">Stopwatch sw = new Stopwatch();
sw.Start();

for (int i = 0; i &lt; messageCount; i++)
{
	actionBlock.Post(1000);
}
actionBlock.Complete();
actionBlock.Completion.Wait();
sw.Stop();

return sw.Elapsed;</pre></div></li><li><p>Next, we need to implement the <code class="literal">Main</code> method. Let's start by getting the processor count of your machine; call the <code class="literal">ComputeTime</code> method twice (once with the <code class="literal">maxDegreeOfParallelism</code> parameter set to one, and once with the <code class="literal">maxDegreeOfParallelism</code> parameter set to your processor count), and display the<a id="id684" class="indexterm"></a> results.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  int processorCount = Environment.ProcessorCount;
  int messageCount = processorCount;
  TimeSpan elapsedTime;
  elapsedTime = ComputeTime(1, messageCount);
  Console.WriteLine("Degree of parallelism = {0}; message count = {1}; " +
     "elapsed time = {2}ms.", 1, messageCount, (int)elapsedTime.TotalMilliseconds);

  elapsedTime = ComputeTime(processorCount, messageCount);
  Console.WriteLine("Degree of parallelism = {0}; message count = {1}; " +
     "elapsed time = {2}ms.", processorCount, messageCount, (int)elapsedTime.TotalMilliseconds);

  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should have results as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec171"></a>How it worksâ€¦</h3></div></div></div><p>In this recipe, we just<a id="id685" class="indexterm"></a> use the <code class="literal">ComputeTime</code> method to set the maximum degree of parallelism of <code class="literal">ActionBlock&lt;int&gt;</code> to the value of the <code class="literal">maxDegreeOfParallelism</code> method parameter.</p><div class="informalexample"><pre class="programlisting">static TimeSpan ComputeTime(int maxDegreeOfParallelism, int messageCount)
{
  var actionBlock = new ActionBlock&lt;int&gt;(
     millisecondsTimeout =&gt; Thread.Sleep(millisecondsTimeout),
     new ExecutionDataflowBlockOptions
     {
       MaxDegreeOfParallelism = maxDegreeOfParallelism
     });
   ...
     
}</pre></div><p>We call this method twice, once with the <code class="literal">maxDegreeOfParallelism</code> parameter set to one, and once with the <code class="literal">maxDegreeOfParallelism</code> parameter<a id="id686" class="indexterm"></a> set to the processor count of your machine.</p><p>A maximum degree of parallelism of one causes the dataflow block to process messages serially, and a degree of parallelism of greater than one enables the dataflow block to process messages in parallel.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec95"></a>Unlink dataflow blocks</h2></div></div><hr /></div><p>We have previously seen how to link dataflow blocks together to form a pipeline. This recipe is going to show how to unlink a dataflow block from its source.</p><p>We are going to show<a id="id687" class="indexterm"></a> how to unlink a dataflow block by creating a <code class="literal">Console</code> application that creates three transform blocks, each of which calls a method to perform a calculation. The transform block objects will each be linked to a <code class="literal">WriteOnceBlock&lt;T&gt;</code> object, with the <code class="literal">MaxMessages</code> property<a id="id688" class="indexterm"></a> set to one. This will instruct the source blocks to unlink after the first message is received at the target.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec172"></a>How to do itâ€¦</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">DegreeOfParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks.Dataflow;</pre></div></li><li><p>First, let's create a <code class="literal">static</code> method called <code class="literal">DoCalculation</code>. This method accepts <code class="literal">integer</code> and <code class="literal">CancellationToken</code> as parameters, and returns <code class="literal">integer</code>. This method is going to simulate a lengthy calculation that takes a few seconds to complete, then returns a somewhat arbitrary value.</p><div class="informalexample"><pre class="programlisting">static int DoCalculation(int n, CancellationTokenSource tokenSource)
{  
  // simulate a workload and return result
  SpinWait.SpinUntil(() =&gt; tokenSource.IsCancellationRequested,
    new Random().Next(2000));
  return n + 5;
}</pre></div></li><li><p>Next, let's create another <code class="literal">static</code> method called <code class="literal">ReceiveFromAny&lt;T&gt;</code>. This method will take a parameter array of <code class="literal">ISourceBlock&lt;T&gt;</code> and return <code class="literal">T</code>. This method will receive a value from the first source in the <code class="literal">source</code> array that returns a value. It will create new <code class="literal">WriteOnceBlock&lt;T&gt;</code> and link it to each source block, with a <code class="literal">DataFlowLinkOptions</code> parameter and the <code class="literal">MaxMessages</code> property set to one. Finally, it will receive the value produced by <code class="literal">WriteOnceBlock</code>.</p><div class="informalexample"><pre class="programlisting">public static T ReceiveFromAny&lt;T&gt;(params ISourceBlock&lt;T&gt;[] sources)
{
  var writeOnceBlock = new WriteOnceBlock&lt;T&gt;(e =&gt; e);
  foreach (var source in sources)
  {
    source.LinkTo(writeOnceBlock, new DataflowLinkOptions { MaxMessages = 1 });
  }            
  return writeOnceBlock.Receive();
}</pre></div></li><li><p>Finally, let's<a id="id689" class="indexterm"></a> implement the <code class="literal">Main</code> method. <code class="literal">Main</code> needs to create a new <code class="literal">CancellationToken</code> object, create three <code class="literal">System.Threading.Tasks.Dataflow.TransformBlock</code> objects that each call the <code class="literal">DoCalculation</code> method, posts data to each of <code class="literal">TransformBlocks</code>, and receives the result.</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{

  try
  {
    var tokenSource = new CancellationTokenSource();

    Func&lt;int, int&gt; action = n =&gt; DoCalculation(n, tokenSource);
    var calculation1 = new TransformBlock&lt;int, int&gt;(action);
    var calculation2 = new TransformBlock&lt;int, int&gt;(action);
    var calculation3 = new TransformBlock&lt;int, int&gt;(action);

    calculation1.Post(11);
    calculation2.Post(21);
    calculation3.Post(31);

    int result = ReceiveFromAny(calculation1, calculation2, calculation3);

    // Cancel all calls to TrySolution that are still active.
    tokenSource.Cancel();

    // Print the result to the console.
    Console.WriteLine("The solution is {0}.", result);
  }
  catch (AggregateException) { }
  finally { Console.ReadLine(); }

}</pre></div></li><li><p>In Visual Studio 2012, <a id="id690" class="indexterm"></a>press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec173"></a>How it worksâ€¦</h3></div></div></div><p>The <code class="literal">Main</code> method of this application is responsible for creating our <code class="literal">TransformBlock</code> objects, creating <code class="literal">Func</code> to call the <code class="literal">DoCalculation</code> method, posting some data to <code class="literal">TransformBlocks</code>, and calling <code class="literal">RecieveFromAny</code> with <code class="literal">TransformBlocks</code> as parameter.</p><div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();

Func&lt;int, int&gt; action = n =&gt; DoCalculation(n, tokenSource);
var calculation1 = new TransformBlock&lt;int, int&gt;(action);
var calculation2 = new TransformBlock&lt;int, int&gt;(action);
var calculation3 = new TransformBlock&lt;int, int&gt;(action);

calculation1.Post(11);
calculation2.Post(21);
calculation3.Post(31);

int result = ReceiveFromAny(calculation1, calculation2, calculation3);</pre></div><p>The <code class="literal">RecieveFromAny</code> method<a id="id691" class="indexterm"></a> creates <a id="id692" class="indexterm"></a>a new <code class="literal">WriteOnceBlock&lt;T&gt;</code> object, uses a <code class="literal">for</code> loop to link the <code class="literal">WriteOnceBlocks</code> to the source <code class="literal">TransformBlocks</code>, and receives the first data the <code class="literal">WriteOnceBlock</code> produces.</p><div class="informalexample"><pre class="programlisting">public static T ReceiveFromAny&lt;T&gt;(params ISourceBlock&lt;T&gt;[] sources)
{
  var writeOnceBlock = new WriteOnceBlock&lt;T&gt;(e =&gt; e);
  foreach (var source in sources)
  {
    source.LinkTo(writeOnceBlock, new DataflowLinkOptions { MaxMessages = 1 });
  }            
  return writeOnceBlock.Receive();
}</pre></div><p>The link to the source blocks is created using the <code class="literal">LinkTo</code> method<a id="id693" class="indexterm"></a> as before, but this time a new <code class="literal">DataflowLinkOptions</code> object is used as a parameter, with the <code class="literal">MaxMessages</code> property set to one.</p><p>The <code class="literal">MaxMessages</code> property<a id="id694" class="indexterm"></a> is used to set the maximum number of messages that may be consumed across a link.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec96"></a>Using JoinBlock to read from multiple data sources</h2></div></div><hr /></div><p>This recipe is going to <a id="id695" class="indexterm"></a>show how to use <code class="literal">JoinBlock</code> to perform an operation when data is available from multiple sources.</p><p>We are going to create a <code class="literal">Console</code> application that defines two types of resources: <code class="literal">NetworkResource</code> and <code class="literal">MemoryResource</code>. We will use the <code class="literal">NetworkResource</code> and <code class="literal">MemoryResource</code> pair to perform an operation. To enable the operation to occur when both required resources are available, we will use <code class="literal">JoinBlock&lt;T1, T2&gt;</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec174"></a>How to do itâ€¦</h3></div></div></div><p>Let's see how to use <code class="literal">JoinBlock</code> to perform an operation based on data from multiple sources.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">JoinBlock</code> as the <span class="strong"><strong>Solution name</strong></span>.</p></li><li><p>Next, go to <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</p></li><li><p>Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks.Dataflow;</pre></div></li><li><p>Inside the <code class="literal">Program</code> class <a id="id696" class="indexterm"></a>above the <code class="literal">Main</code> method, create an <code class="literal">abstract</code> class definition for resource, and a concrete <code class="literal">class</code> definition for <code class="literal">MemoryResource</code> and <code class="literal">NetworkResource</code>.</p><div class="informalexample"><pre class="programlisting">abstract class Resource
{
}

class MemoryResource : Resource
{
}

class NetworkResource : Resource
{
}</pre></div></li><li><p>Now, in the <code class="literal">Main</code> method, create a <code class="literal">BufferBlock&lt;MemoryResource&gt;</code> and a <code class="literal">BufferBlock&lt;NetworkResource&gt;</code> object.</p><div class="informalexample"><pre class="programlisting">var networkResources = new BufferBlock&lt;NetworkResource&gt;();
var memoryResources = new BufferBlock&lt;MemoryResource&gt;();</pre></div></li><li><p>Next, create a <code class="literal">JoinBlock&lt;NetworkResource, MemoryResource&gt;</code>. Create a <code class="literal">GroupingDataflowBlockOptions</code> object parameter and set the <code class="literal">Greedy</code> property to false.</p><div class="informalexample"><pre class="programlisting">var joinResources =
   new JoinBlock&lt;NetworkResource, MemoryResource&gt;(
    new GroupingDataflowBlockOptions
    {
      Greedy = false
    });</pre></div></li><li><p>Now we need to create a <code class="literal">ActionBlock&lt;Tuple&lt;NetworkResource, MemoryResource&gt;&gt;</code> object to simulate <code class="literal">NetworkResource</code> doing a lengthy network access operation.</p><div class="informalexample"><pre class="programlisting">var networkMemoryAction =
   new ActionBlock&lt;Tuple&lt;NetworkResource, MemoryResource&gt;&gt;(
    data =&gt;
    {
      Console.WriteLine("Network worker: using resources.");
      Thread.Sleep(new Random().Next(500, 2000));
      Console.WriteLine("Network worker: finished using resources.");
      networkResources.Post(data.Item1);
      memoryResources.Post(data.Item2);
    });</pre></div></li><li><p>Finally, let's finish<a id="id697" class="indexterm"></a> up the <code class="literal">Main</code> method by linking the resource objects, linking <code class="literal">JoinBlock</code> to <code class="literal">ActionBlock</code>, and posting data to the resource blocks.</p><div class="informalexample"><pre class="programlisting">networkResources.LinkTo(joinResources.Target1);
memoryResources.LinkTo(joinResources.Target2);

joinResources.LinkTo(networkMemoryAction);

networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());

memoryResources.Post(new MemoryResource());

Thread.Sleep(10000);
Console.ReadLine();</pre></div></li><li><p>In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should display results as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0225OT_09_10.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec175"></a>How it worksâ€¦</h3></div></div></div><p>This application starts<a id="id698" class="indexterm"></a> by creating two <code class="literal">BufferBlock&lt;T&gt;</code> objects; one holds network resources and one holds memory resources.</p><div class="informalexample"><pre class="programlisting">var networkResources = new BufferBlock&lt;NetworkResource&gt;();
var memoryResources = new BufferBlock&lt;MemoryResource&gt;();</pre></div><p>Then we created a non-greedy <code class="literal">JoinBlock</code> to join the network resources to the memory resources by setting the <code class="literal">Greedy</code> property<a id="id699" class="indexterm"></a> to <code class="literal">false</code>. In the default greedy mode, the join block will greedily take the data from the source, but it still won't produce a result tuple until all necessary data is available. This is primarily important when sources are connected to multiple join blocks. If all of the joins take data greedily from the sources, you can end up in situations where data would be available to satisfy one of the joins, but end up being taken greedily and split across multiple joins such that none of them could be satisfied, and thus, none will produce results until more data comes along.</p><div class="informalexample"><pre class="programlisting">var joinResources =
   new JoinBlock&lt;NetworkResource, MemoryResource&gt;(
    new GroupingDataflowBlockOptions
    {
      Greedy = false
   });</pre></div><p>The next step is to create <code class="literal">ActionBlock</code> that operates network and memory resources. The action just simulates a lengthy operation on a network resource and then releases the resources back to their pools.</p><div class="informalexample"><pre class="programlisting">var networkMemoryAction =
   new ActionBlock&lt;Tuple&lt;NetworkResource, MemoryResource&gt;&gt;(
    data =&gt;
    {
      ...
      Thread.Sleep(new Random().Next(500, 2000));
      ...
      networkResources.Post(data.Item1);
      memoryResources.Post(data.Item2);
    });</pre></div><p>Finally, we link ou<a id="id700" class="indexterm"></a>r resources together, populate our resource pools and allow data to flow through for a few seconds.</p><div class="informalexample"><pre class="programlisting">networkResources.LinkTo(joinResources.Target1);
memoryResources.LinkTo(joinResources.Target2);
joinResources.LinkTo(networkMemoryAction);

networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());

memoryResources.Post(new MemoryResource());

Thread.Sleep(10000);</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">

    <div id="backindex">
      <h1 class="title">Index</h1>
      <h2>A</h2>
      <ul>
        <li>accumulator function / </li>
        <li>ActionBlock&lt;TInput&gt; class / </li>
        <li>AggregateException.Handle<ul><li>used, for task exception handling / </li></ul></li>
        <li>AsParallel extension method / </li>
        <li>AsParallel method / </li>
        <li>AsUnordered method / </li>
        <li>async<ul><li>using, for file access / </li></ul></li>
        <li>asynchronous code<ul><li>exceptions, handling / </li></ul></li>
        <li>asynchronous operation<ul><li>about / </li><li>creating / </li><li>working / </li><li>cancelling, after timeout period / </li></ul></li>
        <li>asynchronous task progress<ul><li>checking / </li></ul></li>
        <li>async method<ul><li>about / </li><li>creating / </li><li>working / </li></ul></li>
        <li>async solution performance<ul><li>improving, Task.WhenAll used / </li></ul></li>
      </ul>
      <h2>B</h2>
      <ul>
        <li>barrier<ul><li>used, for multiple task synchronization / </li></ul></li>
        <li>basic parallel foreach loop<ul><li>about / </li><li>creating / </li><li>working / </li></ul></li>
        <li>basic parallel for loop<ul><li>about / </li><li>creating / </li><li>working / </li></ul></li>
        <li>basic parallel query<ul><li>about / </li><li>creating / </li></ul></li>
        <li>BatchBlock&lt;T&gt; class / </li>
        <li>BatchedJoinBlock&lt;T1, T2&gt; class / </li>
        <li>blocking/ bounding functionality<ul><li>adding , with IProducerConsumerCollection / </li></ul></li>
        <li>BlockingCollection<ul><li>items, adding / </li><li>items, removing / </li><li>iterating, GetConsumingEnumerable used / </li></ul></li>
        <li>BlockingCollection parameter / </li>
        <li>Boolean parameter / </li>
        <li>BroadcastBlock&lt;T&gt; class / </li>
      </ul>
      <h2>C</h2>
      <ul>
        <li>CalcSumRoot method / </li>
        <li>Call Stack windows<ul><li>about / </li><li>using / </li></ul></li>
        <li>CancellationToken property / <a href="#ch09lvl1sec93" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
        <li>CancellationTokenSource.CancelAfter method / </li>
        <li>CancellationTokenSource.Cancel method / </li>
        <li>child task<ul><li>creating / </li></ul></li>
        <li>client_DownloadProgressChanged method / </li>
        <li>CompleteAdding method / </li>
        <li>ComputeTime method / <a href="#ch09lvl1sec94" title="How to do itâ€¦" class="link">How to do itâ€¦</a></li>
        <li>Concurrency Visualizer<ul><li>used, for CPU utilization measurement / </li><li>Threads view, using / </li><li>Cores view, using / </li></ul></li>
        <li>Concurrency Visualizer Cores view<ul><li>using / </li></ul></li>
        <li>Concurrency Visualizer Threads view<ul><li>about / </li><li>using / </li></ul></li>
        <li>concurrent collection<ul><li>operation, cancelling / </li></ul></li>
        <li>ConcurrentDictionary<ul><li>about / </li><li>using / </li><li>working / </li></ul></li>
        <li>ConcurrentStack<ul><li>used, for performing LIFO operations  / </li><li>used, for object pool creation / </li></ul></li>
        <li>Console application  / </li>
        <li>ConsoleWriter class / </li>
        <li>ConsumeAsync method / <a href="#ch09lvl1sec91" title="How to do itâ€¦" class="link">How to do itâ€¦</a></li>
        <li>consumers<ul><li>working with / </li></ul></li>
        <li>continuation<ul><li>task results, passing / </li><li>running, specifying / </li><li>NotOnRanToCompletion / </li><li>NotOnFaulted / </li><li>NotOnCancelled / </li><li>OnlyOnRanToCompletion / </li><li>OnlyOnFaulted / </li><li>OnlyOnCancelled / </li><li>used, for exception handling / </li><li>cancelling / </li><li>used, for multiple tasks chaining / </li><li>used, for UI updation / </li></ul></li>
        <li>continuations / </li>
        <li>CopyTo method / </li>
        <li>Cores view / </li>
        <li>CountDownEvent / </li>
        <li>CountdownEvent<ul><li>used, for multiple threads waiting / </li></ul></li>
        <li>CPU utilization<ul><li>measuring, with Concurrency Visualizer / </li></ul></li>
        <li>custom partitioner<ul><li>creating / </li><li>about / </li></ul></li>
        <li>CustomPartitioner class / </li>
        <li>CustomPartitioning method / </li>
      </ul>
      <h2>D</h2>
      <ul>
        <li>data<ul><li>passing, to task / </li></ul></li>
        <li>dataflow / </li>
        <li>dataflow block<ul><li>message, writing synchronously / </li><li>message, writinga synchronously / </li><li>message, writing asynchronously / </li><li>about / <a href="#ch09lvl1sec93" title="Cancelling a dataflow block" class="link">Cancelling a dataflow block</a></li><li>cancelling / <a href="#ch09lvl1sec93" title="How to do itâ€¦" class="link">How to do itâ€¦</a>, <a href="#ch09lvl1sec93" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li></ul></li>
        <li>dataflow blocks<ul><li>unlinking / <a href="#ch09lvl1sec95" title="Unlink dataflow blocks" class="link">Unlink dataflow blocks</a>, <a href="#ch09lvl1sec95" title="How to do itâ€¦" class="link">How to do itâ€¦</a>, <a href="#ch09lvl1sec95" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li></ul></li>
        <li>dataflow pipeline<ul><li>about / <a href="#ch09lvl1sec92" title="Creating a dataflow pipeline" class="link">Creating a dataflow pipeline</a></li><li>creating / <a href="#ch09lvl1sec92" title="How to do itâ€¦" class="link">How to do itâ€¦</a>, <a href="#ch09lvl1sec92" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li></ul></li>
        <li>DefaultPartitioning method / </li>
        <li>DenyChildAttach option / </li>
        <li>DownloadStringTaskAsync method / </li>
      </ul>
      <h2>E</h2>
      <ul>
        <li>EnterReadLock method / </li>
        <li>exception handling<ul><li>continuation, using / </li></ul></li>
        <li>exceptions<ul><li>handling, in parallel loop / </li><li>handling, in asynchronous code / </li></ul></li>
        <li>ExecutionDataflowBlockOptions parameter / <a href="#ch09lvl1sec93" title="How to do itâ€¦" class="link">How to do itâ€¦</a></li>
      </ul>
      <h2>F</h2>
      <ul>
        <li>Filter by Boolean Expression box / </li>
        <li>First-In- First-Out (FIFO) / </li>
        <li>First-In-First-Out (FIFO) / </li>
        <li>ForAll method / </li>
        <li>ForEach loop / </li>
      </ul>
      <h2>G</h2>
      <ul>
        <li>GetConsumingEnumerable<ul><li>used, for BlockingCollection iterating / </li></ul></li>
        <li>GetConsumingEnumerable method / </li>
        <li>GetDynamicPartitions method / </li>
        <li>GetItems method / </li>
        <li>GetMultipleWordCount method / </li>
        <li>GetObject method / </li>
        <li>GetPartitions method / </li>
        <li>GetWordCountAsync method / </li>
        <li>GetWordCount method / </li>
        <li>Greedy property / <a href="#ch09lvl1sec96" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
      </ul>
      <h2>I</h2>
      <ul>
        <li>integer parameter / <a href="#ch09lvl1sec94" title="How to do itâ€¦" class="link">How to do itâ€¦</a></li>
        <li>Interlocked.Add method / </li>
        <li>interlocked operations<ul><li>about / </li></ul></li>
        <li>Invoke/BeginInvoke methods / </li>
        <li>IProducerConsumerCollection<ul><li>bounding functionality, adding / </li><li>blocking functionality, adding / </li></ul></li>
        <li>IProducerConsumerCollection.TryAdd method  / </li>
        <li>IsCancellationRequested property / </li>
        <li>items<ul><li>adding, BlockingCollection used / </li><li>removing, BlockingCollection used / </li></ul></li>
      </ul>
      <h2>J</h2>
      <ul>
        <li>JoinBlock<ul><li>using, for reading from multiple data sources / <a href="#ch09lvl1sec96" title="Using JoinBlock to read from multiple data sources" class="link">Using JoinBlock to read from multiple data sources</a>, <a href="#ch09lvl1sec96" title="How to do itâ€¦" class="link">How to do itâ€¦</a>, <a href="#ch09lvl1sec96" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li></ul></li>
      </ul>
      <h2>L</h2>
      <ul>
        <li>lazy tasks<ul><li>executing / </li></ul></li>
        <li>LIFO operations<ul><li>performing, ConcurrentStack used / </li></ul></li>
        <li>LinkTo method / <a href="#ch09lvl1sec95" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
        <li>LINQ / </li>
        <li>lock keyword / </li>
        <li>loop<ul><li>parallelism degree, controlling / </li></ul></li>
      </ul>
      <h2>M</h2>
      <ul>
        <li>Main method / <a href="#ch09lvl1sec91" title="How to do itâ€¦" class="link">How to do itâ€¦</a></li>
        <li>ManualResetEventSlim<ul><li>used, for spin / </li></ul></li>
        <li>Math.Sqrt() method / </li>
        <li>maxDegreeOfParallelism parameter / <a href="#ch09lvl1sec94" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
        <li>MaxDegreeOfParallelism property / </li>
        <li>MaxMessages property / <a href="#ch09lvl1sec95" title="Unlink dataflow blocks" class="link">Unlink dataflow blocks</a>, <a href="#ch09lvl1sec95" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
        <li>merge options<ul><li>specifying / </li><li>Not Buffered / </li><li>Auto Buffered / </li><li>Fully Buffered / </li></ul></li>
        <li>message<ul><li>writing, synchronously to dataflow block / </li><li>writing,asynchronously to dataflow block / </li><li>writing, asynchronously to dataflow block / </li></ul></li>
        <li>monitor<ul><li>about / </li><li>using / </li></ul></li>
        <li>multiple async tasks<ul><li>procession, on completion / </li></ul></li>
        <li>multiple concurrent collections<ul><li>used, for creating pipeline / </li></ul></li>
        <li>multiple producers<ul><li>working with / </li></ul></li>
        <li>multiple tasks<ul><li>cancelling / </li><li>chaining, continuation used / </li><li>synchronizing, barrier used / </li></ul></li>
        <li>Mutex<ul><li>about / </li><li>WaitHandles, using / </li></ul></li>
        <li>mutual exclusion lock<ul><li>about / </li><li>using / </li></ul></li>
      </ul>
      <h2>N</h2>
      <ul>
        <li>.NET 4.5 Parallel Extensions / </li>
        <li>.NET framework 4.5<ul><li>offerings / </li></ul></li>
        <li>NoPartitioning method / </li>
      </ul>
      <h2>O</h2>
      <ul>
        <li>object pool<ul><li>creating, ConcurrentStack used / </li></ul></li>
        <li>ObjectPool class / </li>
        <li>OnlyOnFaulted member / </li>
        <li>operation<ul><li>cancelling, in concurrent collection / </li></ul></li>
        <li>OrderedQuery method / </li>
        <li>OutputAvailiableAsync method / <a href="#ch09lvl1sec91" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
      </ul>
      <h2>P</h2>
      <ul>
        <li>Parallel.ForEach method / </li>
        <li>Parallel.Invoke() method / </li>
        <li>Parallel.Invoke method / </li>
        <li>ParallelEnumerable.ForAll method / </li>
        <li>ParallelEnumerable class / </li>
        <li>parallel execution<ul><li>forcing / </li></ul></li>
        <li>parallelism<ul><li>limiting, in query / </li></ul></li>
        <li>Parallelism / </li>
        <li>parallelism degree<ul><li>controlling, in loop / </li><li>specifying / <a href="#ch09lvl1sec94" title="Specifying the degree of parallelism" class="link">Specifying the degree of parallelism</a>, <a href="#ch09lvl1sec94" title="How to do itâ€¦" class="link">How to do itâ€¦</a>, <a href="#ch09lvl1sec94" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li></ul></li>
        <li>parallel LINQ<ul><li>order, preserving / </li><li>used, for range projection / </li><li>exceptions, handling / </li><li>cancelling / </li></ul></li>
        <li>parallel LINQ <ul><li>about / </li></ul></li>
        <li>parallel loop<ul><li>breaking / </li><li>working / </li><li>stopping / </li><li>cancelling / </li><li>exceptions, handling in / </li><li>data, partioning / </li></ul></li>
        <li>ParallelLoopState.IsStopped property / </li>
        <li>ParallelLoopState variable / </li>
        <li>Parallel Stacks window<ul><li>about / </li><li>using / </li></ul></li>
        <li>Parallel Tasks window<ul><li>about / </li><li>deadlocks, detecting / </li></ul> / </li>
        <li>Parallel Watch window<ul><li>about / </li><li>values in thread, viewing / </li></ul></li>
        <li>Partitioner.Create method / </li>
        <li>pipeline<ul><li>creating, multiple concurrent collections used / </li></ul></li>
        <li>predefined blocks<ul><li>buffering blocks / </li><li>execution blocks / </li></ul></li>
        <li>PriorityQueue class / </li>
        <li>producer-consumer dataflow pattern<ul><li>about / <a href="#ch09lvl1sec91" title="Implementing a producer-consumer dataflow pattern" class="link">Implementing a producer-consumer dataflow pattern</a></li><li>implementing / <a href="#ch09lvl1sec91" title="How to do itâ€¦" class="link">How to do itâ€¦</a>, <a href="#ch09lvl1sec91" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li></ul></li>
        <li>PutObject method / </li>
      </ul>
      <h2>Q</h2>
      <ul>
        <li>query<ul><li>parallelism, limiting / </li></ul></li>
        <li>query results<ul><li>processing / </li></ul></li>
      </ul>
      <h2>R</h2>
      <ul>
        <li>race condition / </li>
        <li>ReadDataAsync method / </li>
        <li>ReaderWriterLockSlim<ul><li>about / </li><li>Read mode / </li><li>Upgradeable mode / </li><li>Write mode / </li><li>using / </li></ul></li>
        <li>ReadFromFileAsync method / </li>
        <li>ReceiveAsync method / </li>
        <li>RecieveFromAny method / <a href="#ch09lvl1sec95" title="How it worksâ€¦" class="link">How it worksâ€¦</a></li>
        <li>reduction operations<ul><li>performing / </li></ul></li>
        <li>Register method / </li>
        <li>Release method / </li>
        <li>Result property / </li>
        <li>results<ul><li>returning, from task / </li></ul></li>
        <li>resultSelector parameter / </li>
      </ul>
      <h2>S</h2>
      <ul>
        <li>seedFactory function / </li>
        <li>SemaphoreSlim<ul><li>used, for limit accessing / </li></ul></li>
        <li>SequentialLoop method / </li>
        <li>SignalAndWait method / </li>
        <li>SimulateWork method / </li>
        <li>SpinLock<ul><li>about / </li><li>used, for synchronization / </li></ul></li>
        <li>Start method / </li>
        <li>static async method / </li>
        <li>static method / </li>
        <li>SupportsDynamicPartitions property / </li>
        <li>System.Collections.Concurrent / </li>
        <li>System.Collections namespace / </li>
        <li>System.Linq.ParallelEnumerable class / </li>
        <li>System.Threading.Task class / </li>
      </ul>
      <h2>T</h2>
      <ul>
        <li>TAP / </li>
        <li>task<ul><li>creating / </li><li>creating, Parallel.Invoke() method / </li><li>creating, Task.Factory.StartNew() method / </li><li>working / </li><li>completion, wait process / </li><li>results, returning from / </li><li>data, passing to / </li><li>child task, creating / </li><li>lazy task, executing / </li><li>exception handling, try/catch block used / </li><li>exception handling, AggregateException.Handle used / </li><li>cancelling / </li><li>multiple tasks, cancelling / </li><li>continuing / </li></ul></li>
        <li>Task.ContinueWith(Action&lt;Task&gt;) method / </li>
        <li>Task.Factory.StartNew() method / </li>
        <li>Task.Start() method / </li>
        <li>Task.Wait() method / </li>
        <li>Task.WaitAll(). method / </li>
        <li>Task.WhenAll<ul><li>used, for async solution performance increasing / </li></ul></li>
        <li>task results<ul><li>passing, to continuation / </li></ul></li>
        <li>Thread Local Storage<ul><li>about / </li><li>using / </li></ul></li>
        <li>thread safety data lookups<ul><li>ConcurrentDictionary, using / </li></ul></li>
        <li>Threads window<ul><li>about / </li><li>using / </li><li>debugging session / </li></ul></li>
        <li>ToArray method / </li>
        <li>TPL<ul><li>about / </li></ul></li>
        <li>TransformBlock&lt;TInput, TOutput&gt; class / </li>
        <li>TransformManyBlock&lt;TInput, TOutput&gt; class / </li>
        <li>try/catch block<ul><li>used, for task exception handling / </li></ul></li>
        <li>TryAdd method / </li>
        <li>TryTake method / </li>
      </ul>
      <h2>U</h2>
      <ul>
        <li>UI updating<ul><li>continuation, using / </li></ul></li>
        <li>Unblocking Stack tab / </li>
        <li>UnorderedQuery method / </li>
      </ul>
      <h2>V</h2>
      <ul>
        <li>Value property / </li>
      </ul>
      <h2>W</h2>
      <ul>
        <li>WaitHandles<ul><li>using, with Mutex / </li></ul></li>
        <li>Wait method / </li>
        <li>WaitOne method / </li>
        <li>WhenAll continuations<ul><li>using / </li></ul></li>
        <li>WhenAny continuations<ul><li>using / </li></ul></li>
        <li>WhenAny method / </li>
        <li>WithDegreeOfParallelism method / </li>
        <li>WithExecutionMode method / </li>
        <li>WithMergeOption method  / </li>
        <li>WithMergeOptions method / </li>
        <li>WPF / </li>
        <li>WriteDataAsync methods / </li>
        <li>WriteNumbersUnprotected method / </li>
        <li>WriteOnceBlock&lt;T&gt; class / </li>
        <li>WriteToFileAsync method / </li>
      </ul>
      <h2>Z</h2>
      <ul>
        <li>Zoom slider / </li>
      </ul>
    </div>
  </div></div></div>
</div></div></div></body></html>
