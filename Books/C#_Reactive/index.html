<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"> <!--320-->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

    <link rel="icon" href="../../mapt/images/favicon.ico">

    <link rel="stylesheet" href="../../mapt/css/font-awesome.css">
    <link rel="stylesheet" href="../../mapt/css/google-fonts.css">
    <link rel="stylesheet" href="../../mapt/css/devicon.css">

    <link rel="stylesheet" href="../../mapt/css/bootstrap.css">
    <link rel="stylesheet" href="../../mapt/css/bootstrap-xl.css">
    <link rel="stylesheet" href="../../mapt/css/magnific-popup.css">
    <link rel="stylesheet" href="../../mapt/css/prism.css">
    <link rel="stylesheet" href="../../mapt/css/hljs-github.css">

    <link rel="stylesheet" href="../../mapt/css/mapt.css">
    <link rel="stylesheet" href="../../mapt/css/custom.css">

    <script src="../../mapt/js/jquery.js"></script>
    <script src="../../mapt/js/bootstrap.js"></script>
    <script src="../../mapt/js/jquery.magnific-popup.js"></script>
    <script src="../../mapt/js/highlight.min.js"></script>

    <script src="../../mapt/js/custom.js"></script>
    
    <title>Reactive Programming for .NET Developers</title>
</head>

<body class="home-body">
    <div id="wrapper">
        <div id="sidebar-wrapper">    
            <ul class="sidebar-nav">
                <div class="list-group" id="sidebar-nav" role="tablist">
                    <li>
                        <a href="../../index.html" class="sidenav-menu-holder back-btn" id="back-link">
                            <span class="sidenav-menu">Book List</span>
                            <span class="pull-left mr5"><i class="fa fa-chevron-left"></i></span>
                        </a>
                    </li>
                    
                    <li class="book-info copyright">
                        <span class="info text-nowrap"><span class="copyleft">&copy;</span><span><strong>RuTracker</strong>.org</span></span>
                    </li>          
                    <li class="book-info copyright">
                        <span class="info text-nowrap">Pub date: <strong>29 Jul 2016</strong></span>
                    </li>         
                    <li class="book-info">
                        <span class="info text-nowrap">Price: €<strong>31.99</strong></span>
                        <span class="info text-nowrap">ISBN: <strong>9781785882883</strong></span>
                    </li>     
            
                    <li>
                        <a href="graphics/cover.jpg" class="sidenav-menu-holder cover-img">
                            <img src="graphics/cover.jpg" class="cover-image">
                        </a>
                    </li>        
            
                    <div class="book_navigation">
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse1">
                                <div class="section-name">1: First Steps Toward Reactive Programming</div>
                            </a>
                        </li>
                        <div id="collapse1" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="1" class="sub-nav">
                                <a href="#ch01">
                                    <div class="section-name">Chapter 1: First Steps Toward Reactive Programming</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec7" class="sub-nav">
                                <a href="#ch01lvl1sec7">                    
                                    <div class="section-name">Programming paradigms</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec8" class="sub-nav">
                                <a href="#ch01lvl1sec8">                    
                                    <div class="section-name">Dataflow programming</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec9" class="sub-nav">
                                <a href="#ch01lvl1sec9">                    
                                    <div class="section-name">Functional programming</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec10" class="sub-nav">
                                <a href="#ch01lvl1sec10">                    
                                    <div class="section-name">Reactive programming</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec11" class="sub-nav">
                                <a href="#ch01lvl1sec11">                    
                                    <div class="section-name">Further reading</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec12" class="sub-nav">
                                <a href="#ch01lvl1sec12">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse2">
                                <div class="section-name">2: Reactive Programming with C#</div>
                            </a>
                        </li>
                        <div id="collapse2" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="2" class="sub-nav">
                                <a href="#ch02">
                                    <div class="section-name">Chapter 2: Reactive Programming with C#</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec13" class="sub-nav">
                                <a href="#ch02lvl1sec13">                    
                                    <div class="section-name">IObserver interface</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec14" class="sub-nav">
                                <a href="#ch02lvl1sec14">                    
                                    <div class="section-name">IObservable interface</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec15" class="sub-nav">
                                <a href="#ch02lvl1sec15">                    
                                    <div class="section-name">Subscription life cycle</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec16" class="sub-nav">
                                <a href="#ch02lvl1sec16">                    
                                    <div class="section-name">Sourcing events</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec17" class="sub-nav">
                                <a href="#ch02lvl1sec17">                    
                                    <div class="section-name">Filtering events</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec18" class="sub-nav">
                                <a href="#ch02lvl1sec18">                    
                                    <div class="section-name">Correlating events</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec19" class="sub-nav">
                                <a href="#ch02lvl1sec19">                    
                                    <div class="section-name">Sourcing from CLR streams</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec20" class="sub-nav">
                                <a href="#ch02lvl1sec20">                    
                                    <div class="section-name">Sourcing from CLR enumerables</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec21" class="sub-nav">
                                <a href="#ch02lvl1sec21">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse3">
                                <div class="section-name">3: Reactive Extension Programming</div>
                            </a>
                        </li>
                        <div id="collapse3" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="3" class="sub-nav">
                                <a href="#ch03">
                                    <div class="section-name">Chapter 3: Reactive Extension Programming</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec22" class="sub-nav">
                                <a href="#ch03lvl1sec22">                    
                                    <div class="section-name">Setting up Rx.NET</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec23" class="sub-nav">
                                <a href="#ch03lvl1sec23">                    
                                    <div class="section-name">Marble diagrams</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec24" class="sub-nav">
                                <a href="#ch03lvl1sec24">                    
                                    <div class="section-name">Subjects</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec25" class="sub-nav">
                                <a href="#ch03lvl1sec25">                    
                                    <div class="section-name">Combining operators</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec26" class="sub-nav">
                                <a href="#ch03lvl1sec26">                    
                                    <div class="section-name">Filtering operators</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec27" class="sub-nav">
                                <a href="#ch03lvl1sec27">                    
                                    <div class="section-name">Mathematical operators</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec28" class="sub-nav">
                                <a href="#ch03lvl1sec28">                    
                                    <div class="section-name">Logic operators</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec29" class="sub-nav">
                                <a href="#ch03lvl1sec29">                    
                                    <div class="section-name">References</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec30" class="sub-nav">
                                <a href="#ch03lvl1sec30">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse4">
                                <div class="section-name">4: Observable Sequence Programming</div>
                            </a>
                        </li>
                        <div id="collapse4" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="4" class="sub-nav">
                                <a href="#ch04">
                                    <div class="section-name">Chapter 4: Observable Sequence Programming</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec31" class="sub-nav">
                                <a href="#ch04lvl1sec31">                    
                                    <div class="section-name">Sequence creation basics</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec32" class="sub-nav">
                                <a href="#ch04lvl1sec32">                    
                                    <div class="section-name">Time-based sequence creation</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec33" class="sub-nav">
                                <a href="#ch04lvl1sec33">                    
                                    <div class="section-name">Sequence manipulation and filtering</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec34" class="sub-nav">
                                <a href="#ch04lvl1sec34">                    
                                    <div class="section-name">Sequence partitioning</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec35" class="sub-nav">
                                <a href="#ch04lvl1sec35">                    
                                    <div class="section-name">Advanced operators</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec36" class="sub-nav">
                                <a href="#ch04lvl1sec36">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse5">
                                <div class="section-name">5: Debugging Reactive Extensions</div>
                            </a>
                        </li>
                        <div id="collapse5" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="5" class="sub-nav">
                                <a href="#ch05">
                                    <div class="section-name">Chapter 5: Debugging Reactive Extensions</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec37" class="sub-nav">
                                <a href="#ch05lvl1sec37">                    
                                    <div class="section-name">Tracing sequences</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec38" class="sub-nav">
                                <a href="#ch05lvl1sec38">                    
                                    <div class="section-name">Inspecting sequences</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec39" class="sub-nav">
                                <a href="#ch05lvl1sec39">                    
                                    <div class="section-name">Exception handling</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec40" class="sub-nav">
                                <a href="#ch05lvl1sec40">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse6">
                                <div class="section-name">6: CLR Integration and Scheduling</div>
                            </a>
                        </li>
                        <div id="collapse6" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="6" class="sub-nav">
                                <a href="#ch06">
                                    <div class="section-name">Chapter 6: CLR Integration and Scheduling</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec41" class="sub-nav">
                                <a href="#ch06lvl1sec41">                    
                                    <div class="section-name">Sourcing from CLR events</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec42" class="sub-nav">
                                <a href="#ch06lvl1sec42">                    
                                    <div class="section-name">Threading integration</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec43" class="sub-nav">
                                <a href="#ch06lvl1sec43">                    
                                    <div class="section-name">Scheduling</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec44" class="sub-nav">
                                <a href="#ch06lvl1sec44">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse7">
                                <div class="section-name">7: Advanced Techniques</div>
                            </a>
                        </li>
                        <div id="collapse7" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="7" class="sub-nav">
                                <a href="#ch07">
                                    <div class="section-name">Chapter 7: Advanced Techniques</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec45" class="sub-nav">
                                <a href="#ch07lvl1sec45">                    
                                    <div class="section-name">Designing a custom operator</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec46" class="sub-nav">
                                <a href="#ch07lvl1sec46">                    
                                    <div class="section-name">Designing a custom scheduler</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec47" class="sub-nav">
                                <a href="#ch07lvl1sec47">                    
                                    <div class="section-name">Creating Pattern&amp;lt;T&amp;gt;</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec48" class="sub-nav">
                                <a href="#ch07lvl1sec48">                    
                                    <div class="section-name">Implementing event sourcing with Rx</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec49" class="sub-nav">
                                <a href="#ch07lvl1sec49">                    
                                    <div class="section-name">Creating Interactive Extensions (Ix) operators</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec50" class="sub-nav">
                                <a href="#ch07lvl1sec50">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse8">
                                <div class="section-name">8: F# and Functional Reactive Programming</div>
                            </a>
                        </li>
                        <div id="collapse8" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="8" class="sub-nav">
                                <a href="#ch08">
                                    <div class="section-name">Chapter 8: F# and Functional Reactive Programming</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec51" class="sub-nav">
                                <a href="#ch08lvl1sec51">                    
                                    <div class="section-name">F# - first time</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec52" class="sub-nav">
                                <a href="#ch08lvl1sec52">                    
                                    <div class="section-name">F# how to use it</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl2sec103" class="sub-nav">
                                <a href="#ch08lvl2sec103">                    
                                    <div class="section-name">Discriminated Unions and the Record type</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl2sec104" class="sub-nav">
                                <a href="#ch08lvl2sec104">                    
                                    <div class="section-name">Active Patterns</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec53" class="sub-nav">
                                <a href="#ch08lvl1sec53">                    
                                    <div class="section-name">Asynchronous pattern in F#</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec54" class="sub-nav">
                                <a href="#ch08lvl1sec54">                    
                                    <div class="section-name">Functional Reactive Programming</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec55" class="sub-nav">
                                <a href="#ch08lvl1sec55">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse9">
                                <div class="section-name">9: Advanced FRP and Best Practices</div>
                            </a>
                        </li>
                        <div id="collapse9" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="9" class="sub-nav">
                                <a href="#ch09">
                                    <div class="section-name">Chapter 9: Advanced FRP and Best Practices</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec56" class="sub-nav">
                                <a href="#ch09lvl1sec56">                    
                                    <div class="section-name">Discrete and continuous components</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec57" class="sub-nav">
                                <a href="#ch09lvl1sec57">                    
                                    <div class="section-name">Time flow and dynamic change</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec58" class="sub-nav">
                                <a href="#ch09lvl1sec58">                    
                                    <div class="section-name">Even more on FRP and F#</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec59" class="sub-nav">
                                <a href="#ch09lvl1sec59">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                    </div>
                </div>
            </ul>
        </div>
        
        <div id="page-content-wrapper" class="book-page">
            <a href="#" id="menu-toggle" class="toggle-nav"><i class="fa fa-bars fa-2x mr5"></i></a>
            
            <a href="#" id="back_to_top" class="back-to-top"><img src="../../mapt/images/kopimi.svg"></a>
            
            <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10">
                <div class="btn-group pull-right mt15 mb30" role="group">
                    <a href="#home" class="btn btn-default">
                        <i class="fa fa-share fa-lg no-text-padding"></i>
                        <span class="hidden-xs ml5">Book Home</span>
                    </a>
                    <button class="btn btn-default" data-nid="26246" id="code-download">
                        <i class="fa fa-file fa-lg"></i>
                        <span class="hidden-xs ml5">Download Code Files</span>
                    </button>
                </div>
            </div>
            <div class="clearfix"></div>
            
            <div id="book-wrapper" class="container-fluid">
                <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10" id="home">
                    <h2 class="product-title">Reactive Programming for .NET Developers</h2>
                    <hr>
                    <div class="row">
                        <div class="col-sm-12">
                            <h5 class="mt10">By Antonio Esposito, Michael Ciceri</h5>
                            <div>
                                <p class="mb20"><b>Get up and running with reactive programming paradigms to build fast, concurrent, and powerful applications</b></p>
                                <a href="#ch01" class="btn btn-info btn-lg pull-right hidden-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <a href="#ch01" class="btn btn-info btn-lg btn-block mt20 mb20 visible-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <div class="clearfix"></div>
                                <div class="col-sm-12">
                                    <ul id="myTabs" class="nav nav-tabs nav-justified hidden-xs mt20" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab" data-toggle="tab">
                                                <h5>Info</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab" data-toggle="tab">
                                                <h5>Contents</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab" data-toggle="tab">
                                                <h5>Author</h5>
                                            </a>
                                        </li>
                                    </ul>
                
                                    <ul id="myTabsMobile" class="nav nav-pills text-center nav-stacked visible-xs mb60" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab-responsive" data-toggle="tab">
                                                Info
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab-responsive" data-toggle="tab">
                                                Contents
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab-responsive" data-toggle="tab">
                                                Author
                                            </a>
                                        </li>
                                    </ul>
                
                                    <div id="myTabContent" class="tab-content pt30">
                                    
                                        <div role="tabpanel" class="tab-pane active fade in" id="info">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Features</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Features</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li><span style="line-height: 20.4px; background-color: transparent;">Get to grips with the core design principles of reactive programming</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Learn about Reactive Extensions for .NET through real-world examples</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Improve your problem-solving ability by applying functional programming</span></li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Learning</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Learning</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li><span style="line-height: 20.4px; background-color: transparent;">Create, manipulate, and aggregate sequences in a functional-way</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Query observable data streams using standard LINQ query operators</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Program reactive observers and observable collections with C#</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Write concurrent programs with ease, scheduling actions on various workers</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Debug, analyze, and instrument Rx functions</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Integrate Rx with CLR events and custom scheduling</span></li>
                <li><span style="line-height: 20.4px; background-color: transparent;">Learn Functional Reactive Programming with F#</span></li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">About</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>About</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <p>Reactive programming is an innovative programming paradigm focused on time-based problem solving. It makes your programs better-performing, easier to scale, and more reliable.</p>
                <p>Want to create fast-running applications to handle complex logics and huge datasets for financial and big-data challenges? Then you have picked up the right book!</p>
                <p>Starting with the principles of reactive programming and unveiling the power of the pull-programming world, this book is your one-stop solution to get a deep practical understanding of reactive programming techniques. You will gradually learn all about reactive extensions, programming, testing, and debugging observable sequence, and integrating events from CLR data-at-rest or events. Finally, you will dive into advanced techniques such as manipulating time in data-flow, customizing operators and providers, and exploring functional reactive programming.</p>
                <p>By the end of the book, you'll know how to apply reactive programming to solve complex problems and build efficient programs with reactive user interfaces.</p>
                                            </div>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade in" id="content">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Contents</h5>
                                                <hr>
                                            </div>
                                            <ul>
                                                <div>
                                                    <li data-chapter="1">
                                                        <div class="section-name">1: First Steps Toward Reactive Programming</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="1" class="chapter-section">
                                                                    <a href="#ch01">        
                                                                        <div class="section-name">Chapter 1: First Steps Toward Reactive Programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec7" class="chapter-section">
                                                                    <a href="#ch01lvl1sec7">                    
                                                                        <div class="section-name">Programming paradigms</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec8" class="chapter-section">
                                                                    <a href="#ch01lvl1sec8">                    
                                                                        <div class="section-name">Dataflow programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec9" class="chapter-section">
                                                                    <a href="#ch01lvl1sec9">                    
                                                                        <div class="section-name">Functional programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec10" class="chapter-section">
                                                                    <a href="#ch01lvl1sec10">                    
                                                                        <div class="section-name">Reactive programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec11" class="chapter-section">
                                                                    <a href="#ch01lvl1sec11">                    
                                                                        <div class="section-name">Further reading</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec12" class="chapter-section">
                                                                    <a href="#ch01lvl1sec12">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="2">
                                                        <div class="section-name">2: Reactive Programming with C#</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="2" class="chapter-section">
                                                                    <a href="#ch02">        
                                                                        <div class="section-name">Chapter 2: Reactive Programming with C#</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec13" class="chapter-section">
                                                                    <a href="#ch02lvl1sec13">                    
                                                                        <div class="section-name">IObserver interface</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec14" class="chapter-section">
                                                                    <a href="#ch02lvl1sec14">                    
                                                                        <div class="section-name">IObservable interface</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec15" class="chapter-section">
                                                                    <a href="#ch02lvl1sec15">                    
                                                                        <div class="section-name">Subscription life cycle</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec16" class="chapter-section">
                                                                    <a href="#ch02lvl1sec16">                    
                                                                        <div class="section-name">Sourcing events</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec17" class="chapter-section">
                                                                    <a href="#ch02lvl1sec17">                    
                                                                        <div class="section-name">Filtering events</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec18" class="chapter-section">
                                                                    <a href="#ch02lvl1sec18">                    
                                                                        <div class="section-name">Correlating events</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec19" class="chapter-section">
                                                                    <a href="#ch02lvl1sec19">                    
                                                                        <div class="section-name">Sourcing from CLR streams</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec20" class="chapter-section">
                                                                    <a href="#ch02lvl1sec20">                    
                                                                        <div class="section-name">Sourcing from CLR enumerables</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec21" class="chapter-section">
                                                                    <a href="#ch02lvl1sec21">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="3">
                                                        <div class="section-name">3: Reactive Extension Programming</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="3" class="chapter-section">
                                                                    <a href="#ch03">        
                                                                        <div class="section-name">Chapter 3: Reactive Extension Programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec22" class="chapter-section">
                                                                    <a href="#ch03lvl1sec22">                    
                                                                        <div class="section-name">Setting up Rx.NET</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec23" class="chapter-section">
                                                                    <a href="#ch03lvl1sec23">                    
                                                                        <div class="section-name">Marble diagrams</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec24" class="chapter-section">
                                                                    <a href="#ch03lvl1sec24">                    
                                                                        <div class="section-name">Subjects</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec25" class="chapter-section">
                                                                    <a href="#ch03lvl1sec25">                    
                                                                        <div class="section-name">Combining operators</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec26" class="chapter-section">
                                                                    <a href="#ch03lvl1sec26">                    
                                                                        <div class="section-name">Filtering operators</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec27" class="chapter-section">
                                                                    <a href="#ch03lvl1sec27">                    
                                                                        <div class="section-name">Mathematical operators</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec28" class="chapter-section">
                                                                    <a href="#ch03lvl1sec28">                    
                                                                        <div class="section-name">Logic operators</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec29" class="chapter-section">
                                                                    <a href="#ch03lvl1sec29">                    
                                                                        <div class="section-name">References</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec30" class="chapter-section">
                                                                    <a href="#ch03lvl1sec30">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="4">
                                                        <div class="section-name">4: Observable Sequence Programming</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="4" class="chapter-section">
                                                                    <a href="#ch04">        
                                                                        <div class="section-name">Chapter 4: Observable Sequence Programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec31" class="chapter-section">
                                                                    <a href="#ch04lvl1sec31">                    
                                                                        <div class="section-name">Sequence creation basics</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec32" class="chapter-section">
                                                                    <a href="#ch04lvl1sec32">                    
                                                                        <div class="section-name">Time-based sequence creation</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec33" class="chapter-section">
                                                                    <a href="#ch04lvl1sec33">                    
                                                                        <div class="section-name">Sequence manipulation and filtering</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec34" class="chapter-section">
                                                                    <a href="#ch04lvl1sec34">                    
                                                                        <div class="section-name">Sequence partitioning</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec35" class="chapter-section">
                                                                    <a href="#ch04lvl1sec35">                    
                                                                        <div class="section-name">Advanced operators</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec36" class="chapter-section">
                                                                    <a href="#ch04lvl1sec36">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="5">
                                                        <div class="section-name">5: Debugging Reactive Extensions</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="5" class="chapter-section">
                                                                    <a href="#ch05">        
                                                                        <div class="section-name">Chapter 5: Debugging Reactive Extensions</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec37" class="chapter-section">
                                                                    <a href="#ch05lvl1sec37">                    
                                                                        <div class="section-name">Tracing sequences</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec38" class="chapter-section">
                                                                    <a href="#ch05lvl1sec38">                    
                                                                        <div class="section-name">Inspecting sequences</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec39" class="chapter-section">
                                                                    <a href="#ch05lvl1sec39">                    
                                                                        <div class="section-name">Exception handling</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec40" class="chapter-section">
                                                                    <a href="#ch05lvl1sec40">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="6">
                                                        <div class="section-name">6: CLR Integration and Scheduling</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="6" class="chapter-section">
                                                                    <a href="#ch06">        
                                                                        <div class="section-name">Chapter 6: CLR Integration and Scheduling</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec41" class="chapter-section">
                                                                    <a href="#ch06lvl1sec41">                    
                                                                        <div class="section-name">Sourcing from CLR events</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec42" class="chapter-section">
                                                                    <a href="#ch06lvl1sec42">                    
                                                                        <div class="section-name">Threading integration</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec43" class="chapter-section">
                                                                    <a href="#ch06lvl1sec43">                    
                                                                        <div class="section-name">Scheduling</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec44" class="chapter-section">
                                                                    <a href="#ch06lvl1sec44">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="7">
                                                        <div class="section-name">7: Advanced Techniques</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="7" class="chapter-section">
                                                                    <a href="#ch07">        
                                                                        <div class="section-name">Chapter 7: Advanced Techniques</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec45" class="chapter-section">
                                                                    <a href="#ch07lvl1sec45">                    
                                                                        <div class="section-name">Designing a custom operator</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec46" class="chapter-section">
                                                                    <a href="#ch07lvl1sec46">                    
                                                                        <div class="section-name">Designing a custom scheduler</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec47" class="chapter-section">
                                                                    <a href="#ch07lvl1sec47">                    
                                                                        <div class="section-name">Creating Pattern&amp;lt;T&amp;gt;</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec48" class="chapter-section">
                                                                    <a href="#ch07lvl1sec48">                    
                                                                        <div class="section-name">Implementing event sourcing with Rx</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec49" class="chapter-section">
                                                                    <a href="#ch07lvl1sec49">                    
                                                                        <div class="section-name">Creating Interactive Extensions (Ix) operators</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec50" class="chapter-section">
                                                                    <a href="#ch07lvl1sec50">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="8">
                                                        <div class="section-name">8: F# and Functional Reactive Programming</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="8" class="chapter-section">
                                                                    <a href="#ch08">        
                                                                        <div class="section-name">Chapter 8: F# and Functional Reactive Programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec51" class="chapter-section">
                                                                    <a href="#ch08lvl1sec51">                    
                                                                        <div class="section-name">F# - first time</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec52" class="chapter-section">
                                                                    <a href="#ch08lvl1sec52">                    
                                                                        <div class="section-name">F# how to use it</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl2sec103" class="chapter-section">
                                                                    <a href="#ch08lvl2sec103">                    
                                                                        <div class="section-name">Discriminated Unions and the Record type</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl2sec104" class="chapter-section">
                                                                    <a href="#ch08lvl2sec104">                    
                                                                        <div class="section-name">Active Patterns</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec53" class="chapter-section">
                                                                    <a href="#ch08lvl1sec53">                    
                                                                        <div class="section-name">Asynchronous pattern in F#</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec54" class="chapter-section">
                                                                    <a href="#ch08lvl1sec54">                    
                                                                        <div class="section-name">Functional Reactive Programming</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec55" class="chapter-section">
                                                                    <a href="#ch08lvl1sec55">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="9">
                                                        <div class="section-name">9: Advanced FRP and Best Practices</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="9" class="chapter-section">
                                                                    <a href="#ch09">        
                                                                        <div class="section-name">Chapter 9: Advanced FRP and Best Practices</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec56" class="chapter-section">
                                                                    <a href="#ch09lvl1sec56">                    
                                                                        <div class="section-name">Discrete and continuous components</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec57" class="chapter-section">
                                                                    <a href="#ch09lvl1sec57">                    
                                                                        <div class="section-name">Time flow and dynamic change</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec58" class="chapter-section">
                                                                    <a href="#ch09lvl1sec58">                    
                                                                        <div class="section-name">Even more on FRP and F#</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec59" class="chapter-section">
                                                                    <a href="#ch09lvl1sec59">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                            </ul>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade" id="author">
                                            <div class="visible-xs">
                                                <h4 class="mobile-title">About the Author</h4>
                                                <hr>
                                            </div>
                                            <p><strong>Antonio Esposito</strong></p>
                                            <div>
                                                <p>Antonio Esposito is a Microsoft Certified Trainer, software architect, father, son, and lover of cooking and eating. He has been addicted to computer programming from age 8, a developer since 2002, and a speaker from 2010. He has moved across Europe in the last fifteen years working as freelance consultant or speaker for companies such as UniCredit Bank, Ferrari F1 Racing Team, Microsoft Italy, IBM, and many others. He actively attends as a speaker at a lot of conferences, such as MCT Summit and WPC Italy. He is already an author for Packt with Learning .NET High Performance Programming in 2014.</p>
                                            </div>
                                            <p><strong>Michael Ciceri</strong></p>
                                            <div>
                                                <p>Michael Ciceri is a technology consultant in .NET Framework and Microsoft. He is a functional programming, mathematics, technology, psychology, and science enthusiast. He started as an autodidact and passionately became an analyst and software developer in several areas, such as image processing, banking ATM services security, intranet back end, app monetizing. Recently, he has been working on the analysis and development of functions in the core application to solve problems or improve capabilities.</p>
                                            </div>
                                        </div>
                                        
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="next-wrapper">
                        <div class="row ns">
                            <hr />
                            <span class="hidden-xs">
                                <h4 class="pull-left">
                                    <strong>Up Next: </strong><span class="section-title"></span>
                                </h4>
                                <a href="#" class="btn btn-primary pull-right btn-lg">
                                    Next Section
                                </a>
                            </span>
                            <span class="visible-xs">
                                <a href="#" class="btn btn-primary btn-block btn-lg">
                                    Next Section
                                </a>
                            </span>
                        </div>
                        <div class="row ns">
                            <hr>
                        </div>
                    </div>
                </div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch01"></a>Chapter 1. First Steps Toward Reactive Programming</h2></div></div></div><p>Thanks for buying this guide to <span class="strong"><strong>Reactive Programming</strong></span> and <span class="strong"><strong>Reactive Extensions</strong></span> for .NET.</p><p>This book will give you an expert overview about the magical world of programming, also known as programming live data or real-time data, instead of programming static data as happens with any other usual programming paradigm.</p><p>Do you know Microsoft Excel?</p><p>Excel is a software that lets you write raw numbers and functions in a proprietary mathematical form or through a simple scripting programming language (VBA).</p><p>The magic happens when you write an Excel function, such as <span class="emphasis"><em>=A1+A2</em></span>, which means that the current cell value will be the sum of the values contained in the <span class="emphasis"><em>A1</em></span> and <span class="emphasis"><em>A2</em></span> cells.</p><p>This simple function creates a subscription to the events of cells <span class="emphasis"><em>A1</em></span> and <span class="emphasis"><em>A2</em></span>. This means that any time you update the value of any of these two cells, the function will return a new value. This is the simplest example of functional and reactive programming available.</p><p>Now that we have an idea of what reactive is, it is easy to explain that this book will guide developers with any background knowledge about reactive programming toward the understanding of the reactive programming paradigm with a lot of examples of using <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>) for .NET.</p><p>This chapter will give an overview of what <span class="strong"><strong>Reactive Programming</strong></span> (<span class="strong"><strong>RP</strong></span>) is and how it works, starting with programming paradigms and later diving into the RP structure following the schema:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Programming paradigms</p></li><li style="list-style-type: disc"><p>Dataflow programming</p></li><li style="list-style-type: disc"><p>Functional programming</p></li><li style="list-style-type: disc"><p>Reactive programming</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec7"></a>Programming paradigms</h2></div></div><hr /></div><p>Once upon a time, programming languages where extremely different from the ones we have today.</p><p>The first-generation programming language was the <span class="emphasis"><em>machine-code</em></span> one. It was made against the hardware itself, and for most, programming in such way meant creating hardware solutions like moving jumpers or switches or adding/removing cables.</p><p>The second generation of programming languages was the <span class="emphasis"><em>assembly</em></span> language (such as Assembler). The name was related to the assembling stage of these languages into a machine level one that is able to run in the CPU execution pipelines. This language generation was the first made with text, although it was tightly coupled with hardware architectures.</p><p>The third generation of programming languages started the age of English-like languages that were able to run on top of hardware specifications with their own instruction set, no longer coupled with the lower hardware level. It started the reusability era.</p><p>These languages were not made in real CPU executable code. Programmers did their job in a <span class="emphasis"><em>high-level</em></span> programming language that, after the compilation stage, translated into a lower-level one that was able to run into the CPU execution pipeline. At the beginning of the high-level programming era, the most diffused languages where IBM ® Fortran and COBOL.</p><p>Modern languages, such as .NET, Java, and C/C++, are all of the same generation as their grandparents of the 1950s. Obviously, the current languages have improved features and abilities, because of the long evolution time.</p><p>The main differentiation between the previous programming languages and the current ones is the <span class="emphasis"><em>programming paradigm</em></span>—something like a programming approach of structured methodology that changes the way a programmer creates software.</p><p>The oldest one is the <span class="emphasis"><em>imperative  programming</em></span> paradigm. It is made of a direct sequence of steps, usually numbered from 1 to <span class="emphasis"><em>N</em></span>, that simply executes in a forward-only fashion. In these stages, the ability to jump forward or backward with commands, such as <code class="literal">GoTo</code>, was definitely a killing feature, while now, with modern programming paradigms, it is absolutely avoided. By programming with such an approach, a simple application made to sum two values was a simple sequence of steps, or instructions, that altogether achieved the desired goal. Here is an example in C#:</p><pre class="programlisting">Console.WriteLine("Step counter: RUNNING");

Console.WriteLine("Write the starting value");
var startingValue = int.Parse(Console.ReadLine());

//value entering starting point
REPEAT:
Console.WriteLine("Write the ending value");
var endingValue = int.Parse(Console.ReadLine());

if (endingValue &lt;= startingValue)
{
    Console.WriteLine("ending value must be greater than starting value");
    goto REPEAT;
}

//this counter represents the distance between startingValue and endingValue
var counter = 0;

//increments the counter until needed to reach the endingValue
COUNT:
if (endingValue &gt; ++counter + startingValue)
    goto COUNT;

Console.WriteLine("You need {0} steps to reach {1} from {2}", counter, endingValue, startingValue);
Console.WriteLine("END");
</pre><p>As you can see in the preceding example, the whole program is only a list of steps where the current actor is at once the computer asking for something on the console and the user writing some response on the console. The program is unable to do multiple things together. Either the computer places a question to the user, or the user enters a digit or something on the keyboard to give the computer a command or some data.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note4"></a>Note</h3><p>C# is a <span class="emphasis"><em>general purpose programming language</em></span> supporting imperative, procedural, declarative, object-oriented, component-oriented, service-oriented, and functional programming paradigms all together.</p></div><p>There are no interaction constructs (<code class="literal">for</code>, <code class="literal">for...each</code>) available in imperative programming, and there is no code factorization into subroutines able to abstract and make reusable single portions of code.</p><p>The check logic against the user value is available through a simple <code class="literal">GoTo</code> statement that is able to move the control's flow pointer (the actual execution row) to a newly desired position. Regarding this check logic, the execution flow simply goes back to some previous line executing and entering a destination value.</p><p>Similarly, when it is time to count the distance between the two given values, the logic again uses the <code class="literal">GoTo</code> statement, changing the current state of the <code class="literal">counter</code> variable to the updated value. It is the last time the variable will contain the required result.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note5"></a>Note</h3><p>It is interesting that throughout the imperative programming paradigm, C# is even faster than when programming in an object-oriented one, because of the higher usage of the stack memory, instead of the heap memory that is slower.</p><p>
If you are interested in code optimization and high performance programming, you may find it interesting to read my other book <span class="emphasis"><em>Learning .NET High Performance Programming</em></span>.</p></div><p>In imperative programming languages, such as Fortran, Pascal, or COBOL, there was a number for each row to give developers the ability to create interactive constructs, such as recurring jobs or any other interaction logic, by jumping between rows.</p><p>Obviously, this choice is not available in modern general-purpose languages, such as C#, which give the same feature with the use of a label (in the preceding example, we used <code class="literal">Repeat</code> and <code class="literal">Count</code>) instead of the row number. The result is the same.</p><p>To understand imperative programming, we must understand the meaning of the <span class="emphasis"><em>state</em></span>. An application's state is the sum of all the data usually available within the code through fields, properties, and variables. When we started the preceding code, the application state was empty (we will ignore the <span class="strong"><strong>Common Language Runtime</strong></span> (<span class="strong"><strong>CLR</strong></span>) stuff that is in the memory together with our data). During the execution, some variables (<code class="literal">startingValue</code> and <code class="literal">endingValue</code>) became available by asking data from the user.</p><p>Later, a <code class="literal">counter</code> variable will make the most of the work to find the distance between the two numbers. What is the heart of the imperative programming paradigm is the <span class="emphasis"><em>status change</em></span> that the code makes against available variables. As visible, the <code class="literal">counter</code> variable becomes incremented until the wanted value is found.</p><p>This status change still happens in other paradigms such as <span class="emphasis"><em>procedural-programming</em></span> or <span class="emphasis"><em>object-oriented programming</em></span>, although these paradigms bring to a higher level abstraction of data structures or a better code reusability.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec8"></a>Dataflow programming</h2></div></div><hr /></div><p>Changing the application state is not something wrong by itself, but there are different programming approaches that may produce better results and together give the developer a more pleasant working experience. A typical use case happens when we deal with <span class="emphasis"><em>in-move</em></span> data (or living data or data stream), where we may find that using interaction logic constructs that change state, such as <code class="literal">if</code>, <code class="literal">for</code>, and so on, is a poor performing choice together with a poor design. In-move data is any kind of data stream, such as a video stream, an application insights stream, and so on. Because of its statelessness, it is obvious that a stateless programming approach offers better results than a state-driven one.</p><p>We are used to dealing with static data, such as a variable, a database, or anything else such as some binary- or string-based data. All such data is <span class="emphasis"><em>data-at-rest</em></span>, static data, or simply data.</p><p>As an example if we execute a <code class="literal">select</code> statement against a relational database, we will always have a result set containing the exact value contained in the database table at the specific time we executed the query. A second later, the table could experience an <code class="literal">update</code> statement that could change any row's data without the first client (the one executing the <code class="literal">select</code> statement) receiving an update on such data changes. To address these kinds of data changes without having to face issues between different relational database clients, there are optimistic and pessimistic concurrency checks (a bit outside the scope of this book). Obviously, the less we need to synchronize code to access a concurrent resource, the better our code will perform.</p><p>In imperative programming, <span class="emphasis"><em>control-flow</em></span> is responsible for the good execution of the application. Such flow is usually made of multiple code rows that do something on input/output ports and somehow alter the application's state until the desired result is achieved, whereas in dataflow programming, data flows in and out of the different stages of a flowchart, as it behaves in a workflow.</p><p>Obviously, the different types of programming will greatly change the developers' experience and programming capability of the language. It is very difficult (and conceptually a bit wrong) to compute something by executing some interaction logic in data flow programming, because this kind of programming is simply outside the core design of the programming paradigm.</p><p>A practical example can be seen in data integrational , <span class="strong"><strong>Extract, Transform,</strong></span> and <span class="strong"><strong>Load</strong></span> (<span class="strong"><strong>ETL</strong></span>) workflows, such as those available in <span class="strong"><strong>SQL Server Integration Services</strong></span> (<span class="strong"><strong>SSIS</strong></span>), as shown in the following screenshot. An ETL workflow has the task of reading (extracting) data from a data source (relational or not) and mapping (transforming) such data by grouping or aggregating it with other data sources or by executing transforming functions. Then, data flows (loads) into a target data store (relational or not) for future simplified access. SSIS is the tool for designing these kinds of workflows within the SQL Server Business Intelligence suite.</p><p>
</p><div class="mediaobject"><img src="graphics/image_01_001.jpg" /><div class="caption"><p>A SSIS dataflow task doing some transformations on data from a relational database</p></div></div><p>
</p><p>Generally speaking, outside the SQL server-oriented implementation of SSIS, within data flow programming, instead of having a huge code base in a high-level code, we have something like a data workflow. A <span class="emphasis"><em>digraph</em></span> (directed graph)—an ordered version of a usual flowchart. Here is an example:</p><p>
</p><div class="mediaobject"><img src="graphics/4954_01_02.jpg" /><div class="caption"><p>A simple representation of a dataflow digraph made of three recurring stages</p></div></div><p>
</p><p>Within the Microsoft universe, the only data flow programming compliant language is the <span class="emphasis"><em>Microsoft Visual Programming Language</em></span> available for the Microsoft Robotics Developer Studio environment for robotics programming. Instead, SSIS simply uses data flows to handle data integrations between databases.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec6"></a>Statelessness</h3></div></div></div><p>The unavailability of the state, a key concept of data flow programming, is the opposite of what happens in all imperative or object-oriented programming-based applications. This behavior drastically changes the programming experience.</p><p>A stateless design never stores (temporary or persisted) application or user data with the need of changing it in time for computational needs.</p><p>We cannot use temporary variables to store changeable values, such as the total of an invoice. We cannot use an index to jump around a collection or an array, and we cannot iterate it. Obviously, if we need to write a function that needs a variable, we cannot use a variable anymore; in other words, we can't use variables that act as a business logic state persistence.</p><p>When we write a function, the data will simply have an origin, a target, and one or multiple transformations in multiple stages.</p><p>Thanks to this stateless design of the whole application, it is easy to see that each stage can run on a different thread together and each input or output endpoint can run on another thread and so on. The stateless design is the key that makes the design able to scale out quite perfectly according to <span class="emphasis"><em>Amdahl's Law</em></span>.</p><p>As well as performance results, a stateless design brings higher testability rates of the whole application (bear in mind ASP.NET WebForms versus ASP.NET MVC) together with a more modern approach in programming style that avoids the use of interactive loops such as <code class="literal">for</code>, <code class="literal">for...each</code>, and relatives.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec7"></a>The data-driven approach</h3></div></div></div><p>The last evolution of the imperative programming paradigm is object-oriented programming. Such paradigms request we model our business world into a high-level domain model. This means that, in our code, we will find an object representing any living entity of our business model; a invoice or a customer are examples of such objects. Such models drive business logic. They do not need to be persisted in a one-to-one representation from the model to the persistence store (usually, a relational database). This approach is called domain-driven design. The opposite of such an approach is the data-driven design that makes direct actions against data without a real discrimination between data and business.</p><p>Because of the intrinsic behavior of dataflow programming, a data-driven design is the natural choice when designing a solution based on such programing paradigms.</p><p>But in the modern .NET-based programming style, the use of business-related entities in the various stages of the dataflow execution is available and suggested too.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec8"></a>Data streams</h3></div></div></div><p>A data stream is the flow of some data in time, usually of a unique format, that is available to one or multiple readers.</p><p>Examples are television video streams, YouTube video streams, Twitter or RSS feeds, Azure EventHub, and so on. Those who are used to C# programming will remember the namespace <code class="literal">System.IO</code> that contains different classes made for stream programming, such as <code class="literal">BinaryReader</code>/<code class="literal">BinaryWriter</code> that makes available streaming any CLR low-level type or <code class="literal">StreamReader</code>/<code class="literal">StreamWriter</code> that makes available streaming any text supporting various encodings from ASCII to UTF32.</p><p>In other words, a data stream is some data in a specific time instance. Time is the key concept for understanding a data stream. It is all about running data or in-move data. Without the time component, data can never flow in a stream.</p><p>Depending on the stream, it may support <span class="emphasis"><em>seeking</em></span> operations, such as the ability to go forward and backward along the stream to start flowing data exactly at the desired time. Television video streams do not support such a feature. Microsoft Azure EventHub (a data stream) instead supports the feature in a configured time window of usually some hours.</p><p>The Azure EventHub is a paralleled stream service for streaming any data, usually used for <span class="strong"><strong>Internet of Things</strong></span> (<span class="strong"><strong>IoT</strong></span>) devices, telemetry values, or diagnostic purposes as an application insights collection. A similar choice within the Azure offering is the IoT Hub, another streamed service totally oriented to IoT devices that support more specific protocols.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec9"></a>Observer pattern</h3></div></div></div><p>The <code class="literal">Observer</code> pattern, is a published subscribe style pattern; it defines the ability to register for data change or event signaling. Although written words may be something new to read about, the observer pattern is something absolutely overused in the event-driven programming paradigm of the Microsoft oriented languages in the last 20 years.</p><p>When we handle the <code class="literal">Button</code> click event, either in Visual Basic (from version 1 to 6) or in modern .NET Windows Forms, WPF applications, or even ASP.NET applications, we are simply using an implementation of the observer pattern.</p><p>The pattern defines an event generator, also known as <span class="emphasis"><em>subject</em></span>, that fires the event and one or multiple event listeners or <span class="emphasis"><em>observers</em></span> (in .NET, also known as event handlers) that will do something in reaction to the data state change or event signaling.</p><p>When dealing with data flow programming, the observer pattern is the one responsible for the acknowledgment between stages of the new data available. Each stage informs the following stages of new data available with a signal. Stages do not know about the overall design of the digraph. They simple signal the new data availability event; all subsequent stages that are observing the previous one for new data will be then acknowledged. This design makes useless the need of an overall data state, thus the design is stateless. Each stage observes or is being observed. That is all. Such data flowing between stages are data streams.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec9"></a>Functional programming</h2></div></div><hr /></div><p>Functional programming is a programming paradigm that relies on the functional transformation of data between stages, not so different from the dataflow programming we just saw. The main addendum to the data flow paradigm is that, within the functional one, there is a specific functional transformation, while in the data flow paradigm such transformations occur in a specific idiom-based way that can be functional-based, script-based (imperative paradigm), component-based, or anything else.</p><p>In functional programming, data is always immutable and functions are responsible for data transformation. Anything in functional style is a data transformation. Although a decisional statement (<code class="literal">if</code>) cannot exist, a functional transformation from data containing predicate to data containing the Boolean result may occur:</p><pre class="programlisting">//procedural style
var sourceData = new { TotalAmount = 12345.67, PaidAmount = 12345.67 };
if (sourceData.PaidAmount == sourceData.TotalAmount)
{
    //do something
}

//functional style
//a simple enumerable
new[] { new { TotalAmount = 12345.67, PaidAmount = 12345.67 } }
//transformation block
.Select(x =&gt; new
{
    x.TotalAmount,
    x.PaidAmount,
    CanContinue = x.TotalAmount == x.PaidAmount,
})
//if
.Where(x =&gt; x.CanContinue)
//do something
.ToArray();
</pre><p>A widely known design pattern is the data mapper one. This design tries to decouple and translate objects of a layer (for historic purposes, the domain layer) into another one (for historic purposes, the data model one).</p><p>Here is a simple procedural (imperative with subroutines) programming style example in C#:</p><pre class="programlisting">
class Program
{
    static void Main(string[] args)
    {
        //retrieve invoices from DB
        var invoicesFromDB = GetInvoicesFromDB();

        //map those invoices to business model objects
        var invoicesForBusiness = ConvertInvoicesForBusiness(invoicesFromDB);
    }

    /// &lt;summary&gt;
    /// Reads invoices from a (fake) database
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    static InvoiceFromDB[] GetInvoicesFromDB()
    {
        var result = new InvoiceFromDB[3];

        result[0] = new InvoiceFromDB
            {
                CustomerName = "Mr. Black",
                Number = "100/2015/BBC",
                BaseAmount = 24560,
                VATMultiplier = 1.22,
            };

        result[1] = new InvoiceFromDB
            {
                CustomerName = "White Co Ltd",
                Number = "240/2015/BBC",
                BaseAmount = 422480,
                VATMultiplier = 1.22,
            };

        result[2] = new InvoiceFromDB
            {
                CustomerName = "Green Woods inc.",
                Number = "22/2015/BBC",
                BaseAmount = 8500,
                VATMultiplier = 1.22,
            };

        return result;
    }

    /// &lt;summary&gt;
    /// Converts invoices from database to invoices for business needs
    /// &lt;/summary&gt;
    static InvoiceBusiness[] ConvertInvoicesForBusiness(InvoiceFromDB[] source)
    {
        var result = new InvoiceBusiness[source.Length];

        for (int i = 0; i &lt; source.Length; i++)
            result[i] = new InvoiceBusiness
            {
                Number = source[i].Number,
                CustomerName = source[i].CustomerName,
                BaseAmount = source[i].BaseAmount,
                VATMultiplier = source[i].VATMultiplier,
            };

        return result;
    }
}

public class InvoiceFromDB
{
    public string CustomerName { get; set; }
    public string Number { get; set; }
    public double BaseAmount { get; set; }
    public double VATMultiplier { get; set; }
}

public class InvoiceBusiness
{
    public string CustomerName { get; set; }
    public string Number { get; set; }
    public double BaseAmount { get; set; }
    public double VATMultiplier { get; set; }
    public double Total
    {
        get { return BaseAmount * VATMultiplier; }
    }
}
</pre><p>In a functional style, the same program will benefit from the use of the enumerator pattern (for static data such as this one) or triggers that will notify for observed data changes.</p><p>Later, the transformation logic will take place within a function.</p><p>Here is the same preceding example in a functional style made with LINQ querying in C#:</p><pre class="programlisting">
class Program
{
    static void Main(string[] args)
    {
        var businessInvoices =
            //stage 1 - read db data
            GetInvoicesFromDB()
            //stage 2 - make transfomation
            .Select(dbinvoice =&gt; new InvoiceBusiness
            {
                Number = dbinvoice.Number,
                BaseAmount = dbinvoice.BaseAmount,
                CustomerName = dbinvoice.CustomerName,
                VATMultiplier = dbinvoice.VATMultiplier,
            })
            //force execution of the whole enumerator
            .ToArray();
    }

    static IEnumerable&lt;InvoiceFromDB&gt; GetInvoicesFromDB()
    {
        yield return new InvoiceFromDB
        {
            CustomerName = "Mr. Black",
            Number = "100/2015/BBC",
            BaseAmount = 24560,
            VATMultiplier = 1.22,
        };

        yield return new InvoiceFromDB
        {
            CustomerName = "White Co Ltd",
            Number = "240/2015/BBC",
            BaseAmount = 422480,
            VATMultiplier = 1.22,
        };

        yield return new InvoiceFromDB
        {
            CustomerName = "Green Woods inc.",
            Number = "22/2015/BBC",
            BaseAmount = 8500,
            VATMultiplier = 1.22,
        };
    }
}

public class InvoiceFromDB
{
    public string CustomerName { get; set; }
    public string Number { get; set; }
    public double BaseAmount { get; set; }
    public double VATMultiplier { get; set; }
}

public class InvoiceBusiness
{
    public string CustomerName { get; set; }
    public string Number { get; set; }
    public double BaseAmount { get; set; }
    public double VATMultiplier { get; set; }
    public double Total
    {
        get { return BaseAmount * VATMultiplier; }
    }
}
</pre><p>What makes the preceding example different from the previous one is that the <code class="literal">GetInvoicesFromDB</code> method returns an enumerable collection. Although an array is enumerable too, an array is a finite item collection. In the procedural example, all contained objects must already be in our memory before the method returns values creating a huge data state. Later, in the imperative example, such a state will be changed by the other method <code class="literal">ConvertInvoicesForBusiness</code> that is responsible for creating business objects containing business stuff (<code class="literal">Total</code> in the preceding example).</p><p>In the functional style example, instead of having an interactive statement that processes data in the memory, we will simply write a new function able to transform the data-oriented object into the business-oriented one. This transformation is declaratively defined with a function. The function simply states how the transformation must happen. Thus, to trigger the concrete computation and the storage (in memory) of the transformed data, we will use the <code class="literal">.ToArray()</code> LINQ extension method that will evaluate the functional result and store such results into a finite item collection, the array.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>We will delve more deeply into functional programming and functional reactive programming in <a class="link" href="#" linkend="ch08">
Chapter 8
</a>, <span class="emphasis"><em>F# and Functional Reactive Programming</em></span>, and <a class="link" href="#" linkend="ch09">
Chapter 9
</a>, <span class="emphasis"><em>Advanced FRP and Best Practices</em></span>, of this book.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Reactive programming</h2></div></div><hr /></div><p>At this point, the preceding functional programming examples should convince any reader that data-driven programming of in-move data in many programming scenarios may achieve a higher performance than imperative programming could ever do.</p><p>Reactive programming is the art of programming the propagation of changes. Think of an Excel function <span class="emphasis"><em>=A1+B2</em></span>. This function will always contain the sum of the two cells; it will never contain a raw (or static) value that represents the sum at a specific time. It will always contain the updated sum of the two cells' values. Anytime the related cells raise a value update event (<span class="emphasis"><em>A1</em></span> and <span class="emphasis"><em>A2</em></span>), the resulting cell will update the sum and show the new value. In C#, a similar behavior is available in a computed property, where the result is available only as a computation instead of a state value:</p><pre class="programlisting"> public double TotalAmount { get { return 10d * 10d; } }
</pre><p>Obviously, reactive programming is not simply a function or computed property. Specific designs and technologies are available and needed to develop using reactive programming. Let's start understanding such a new paradigm by reading its idea and its main characteristics and the available languages and idioms.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>Reactive manifesto</h3></div></div></div><p>The reactive programming experience starts with the reactive manifesto, the idea, the vision, the goal, and the overall design that should be behind any reactive application.</p><p>The manifesto is available here: <a class="ulink" href="http://www.reactivemanifesto.org/" target="_blank">
http://www.reactivemanifesto.org</a>.</p><p>The vision is actually simple: modern application needs are incompatible with widely used (and often legacy) designs and architectures. The goals are lovely; they are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A <span class="emphasis"><em>message-based</em></span> overall design with improved <span class="emphasis"><em>lose-coupling</em></span> (between application and external modules), improved horizontal scalability, high responsiveness, and <span class="emphasis"><em>graceful failure handling</em></span>.</p></li><li style="list-style-type: disc"><p>A high <span class="emphasis"><em>scalability</em></span> rate means the ability to scale out with a thin overhead in a sessionless design. This traduces in the ability to handle a huge amount of tasks all together by using multiple computational systems.</p></li><li style="list-style-type: disc"><p>Improved <span class="emphasis"><em>responsive</em></span> design because of the event-based design. The whole application will react to any request in a short time, letting the <code class="literal">Observer</code> module do its job without having the subject wait for completion time.</p></li><li style="list-style-type: disc"><p>Improved <span class="emphasis"><em>resiliency</em></span> design because of the ability to gracefully handle applications and user faults thanks to execution context isolation, software module and data replication, and other features.</p></li></ul></div><p>From this overview of the manifesto, you learned that reactive applications are all about the asynchronous programming of data and event messages flowing between multiple computational isolated stages.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>The programming experience</h3></div></div></div><p>Reactive programming means programming reactions to asynchronously streamed events. This means programming components that receive and produce messages. In between, we can add a transformation or a filter, or components that only produce or receive messages. Sometimes, in other programming paradigms, such message routing components are called message pump.</p><p>A time-based programming is drastically different from static data programming. For example, think of an invoice. Instead of programming its data (the total, the VAT amount, and other values), we will handle how the invoice changes in time.</p><p>Let's look at the difference, as follows:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Time stages</strong></span>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Imperative style</strong></span>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Reactive style</strong></span>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>T0</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>A new <code class="literal">Invoice</code> object is instantiated. Its total is <code class="literal">0.00</code>.</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>A new <code class="literal">Invoice</code> object is instantiated.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>T1</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>A product line is added to the invoice. The invoice's total changes to <code class="literal">450.00</code>.</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>A new <code class="literal">InvoiceAdditionItem</code> object is instantiated.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>T2</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>A product line is added to the invoice. The invoice's total changes to <code class="literal">1450.00</code>.</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>A new <code class="literal">InvoiceAdditionItem</code> object is instantiated.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; ">
<p>T3</p>
</td><td style="border-right: 0.5pt solid ; ">
<p>A product line is added to the invoice. The invoice's total changes to <code class="literal">2450.00</code>.</p>
</td><td style="">
<p>A new <code class="literal">InvoiceAdditionItem</code> object is instantiated.</p>
</td></tr></tbody></table></div><p>The main difference is that, in the reactive style, we have a time-based system, that is, we know exactly what the total invoice value at <span class="strong"><strong>T3</strong></span> or <span class="strong"><strong>T2 </strong></span>was, even years later.</p><p>In database programming, there is the ability to create time-based tables. In reactive programming, we do something similar, but at an improved level because in reactive programming, anything is time-based and asynchronous.</p><p>A typical explanation about persist the result or all the actors of a function is that, when we persist each message, we do something more real and more similar to how data originates. While we persist the result as a data state, we persist something easier to read later. This second choice is an easier way of programming and is often less disk consuming within a database server, although it may bring unwanted mistakes and further updates of data-state because of some events or needs.</p><p>A simple example is available in any Excel worksheet. If Excel was not reactive, at the <span class="emphasis"><em>A1</em></span> cell value update, the <span class="emphasis"><em>A2</em></span> cell formula pointing to <span class="emphasis"><em>A1</em></span> would not be updated, causing the developer to do more work later and exposing this work to a high error rate. Luckily, Excel is reactive; this means that any time we change any cell value, any formula will update its value.</p><p>This means that, in more cases, reactive programming behaves and performs better than state-driven programming, but this is not a universal solution. There are cases when state-driven programming is better than anything (typically, when dealing with other state-driven systems), and there are cases when we need to create a lightweight state to improve performances such as caching function results and so on.</p><p>When dealing with reactive programming, there are three kinds of message we can deal with. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A <span class="emphasis"><em>value</em></span> message containing a new valid value</p></li><li style="list-style-type: disc"><p>An <span class="emphasis"><em>error</em></span> message containing an error that will flow to any message consumer</p></li><li style="list-style-type: disc"><p>A <span class="emphasis"><em>completed</em></span> message that signals that the flow is ending</p></li></ul></div><p>The daily reactive programming receipt contains a lot of alterations to the flow of the subscribed streams, such as event filtering, event composition from multiple streams, event routing, event buffering (compacting multiple similar events occurring quite at the same time), event mapping (converting an event data to another one), and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Change propagation and cancellation</h3></div></div></div><p>Whenever a new message containing a value flows throughout a stream, a <span class="emphasis"><em>change propagation </em></span>occurs. It is not a simple binary message containing some values; this message actually informs of a data change. As we are dealing with a value of some types and are programming a time-based system, this flowing data assumes the name <span class="emphasis"><em>data-in-motion</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>Data-in-motion is data in real time, such as an application insight stream.
Analysis of such data happens on the same data stream, although some stages later. Data-in-motion messages may translate into other messages by morphing or mapping to other messages, but the original message can never change.</p></div><p>Data-in-motion starts flowing by itself in a push style. We do not need asking for a refreshed value (pull style) simply because, in a reactive application, data always flows from the subject (the data producer) to the subscribing observers, notifying always any new value with the change propagation. This means that any observer will always have the last value. Obviously, this design has a heavy constraint: we need to be always online with the data source.</p><p>However, in stateful systems, the change propagation may not occur. We simply ask for refreshed data, but in the meantime, we can work with <span class="emphasis"><em>disconnected</em></span> (offline) data.</p><p>There are multiple examples of pull-based systems working with data streams. For example, any CNC system gives updates (push way) on data changes in addition to the pull-based way of reading data.</p><p>Change propagation introduces another interesting feature: the ability of specifying a timeout value by which any elaboration must occur, otherwise it is cancelled. Similar is the ability to flow a specific cancellation message to request the premature end of executing elaborations against a data changed message.</p><p>These features are now available to any stateful system thanks to <span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>) that extends the low level thread API available in the CLR with specific task-oriented features, such as the task cancellation. However, not everything may execute within a <code class="literal">task</code> class, while in reactive programming, we may always have the ability to cancel a value-changed message elaboration.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>Linguistic characteristics</h3></div></div></div><p>Developing applications by using the reactive programming paradigm means applying to a specified paradigm and nothing else. There is not a specific language to use to comply with reactive programming tenets. Thus, it is possible to create a reactive application by using a specific reactive-oriented language to design the overall application's design and, later, write each computational node (a computational stage on the path of the data stream) in imperative, procedural, or object-oriented programming. This is usually called an <span class="emphasis"><em>implicit</em></span> reactive programming language. While languages that accept only their own constructs or components are <span class="emphasis"><em>explicit</em></span> reactive programming languages.</p><p>In the Microsoft universe, an implicit reactive programming style designer is available in the BizTalk Server SDK in the map (transformational graphical-based flowchart) designer. Here, specific transformational components, called <code class="literal">Functoids</code>, while there is the ability to use <code class="literal">plain</code> .NET languages or external .NET Assemblies (libraries). Effectively, the BizTalk Server has a lot of reactive programming although different.</p><p>A reactive-based programming language may be <span class="emphasis"><em>static</em></span> or <span class="emphasis"><em>dynamic</em></span>, exactly as it happens for nonreactive languages. In this context, a static language is the one that statically links multiple nodes between the others. While in a dynamic reactive programming language, these links become dynamic routes that may change because of a specific logic, giving a message of the direction of a node or another with the ability to change direction per message.</p><p>A mandatory feature of any reactive programming language is the ability to manipulate different streams with features, such as the ability to <span class="emphasis"><em>merge</em></span> multiple streams like a <code class="literal">join</code> statement makes against multiple relational tables or <span class="emphasis"><em>divide</em></span> a single stream into multiple ones.</p><p>Another must-have feature is the ability to configure a <span class="emphasis"><em>Quality of service</em></span> priority list of messages within the stream. This is because not all the messages have the same priority. A canonical example is about any real-time control console of hardware systems, where pressure on any key on the keyboard or any button on the board must give an immediate feedback to the user on the screen or with a light or a sound. Conversely, an informative message or notification from the system to the user does not need the same priority, because the use may simply be somewhere other than at the front of the console. This means that some millisecond of delay is valid.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>Programming languages and frameworks</h3></div></div></div><p>There are many reactive programming and compliant form programming languages available to any developer with any background.</p><p>For any Microsoft-oriented developer, the obvious choice is learning the Microsoft <span class="emphasis"><em>Reactive Extensions</em></span>—a library for adding all the needed features to .NET and other languages to comply with reactive programming. This is available for .NET as <span class="emphasis"><em>Rx.NET</em></span>, for JavaScript languages as <span class="emphasis"><em>RxJS</em></span>, and for Visual C++ developers such as <span class="emphasis"><em>RxCpp</em></span>.</p><p>For JavaScript developers, there are multiple libraries adding reactive features, such as <span class="emphasis"><em>Reactive.js</em></span>, <span class="emphasis"><em>React</em></span> (by Facebook), <span class="emphasis"><em>Node.js</em></span>, <span class="emphasis"><em>ProAct.js</em></span>, and others, available for client development in ASP.NET MVC or WebForms. Links to some of these libraries are listed here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Reactive Extensions: 
<a class="ulink" href="https://msdn.microsoft.com/en-us/data/gg577609.aspx" target="_blank">https://msdn.microsoft.com/en-us/data/gg577609.aspx</a>

</p></li><li style="list-style-type: disc"><p>Reactive.js: 
<a class="ulink" href="http://www.ractivejs.org/" target="_blank">http://www.ractivejs.org/</a>

</p></li><li style="list-style-type: disc"><p>React: 
<a class="ulink" href="https://facebook.github.io/react/" target="_blank">https://facebook.github.io/react/</a>

</p></li><li style="list-style-type: disc"><p>Elm: 
<a class="ulink" href="http://elm-lang.org/" target="_blank">http://elm-lang.org/</a>

</p></li><li style="list-style-type: disc"><p>Meteor: 
<a class="ulink" href="https://www.meteor.com/" target="_blank">https://www.meteor.com/</a>

</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>Reactive programming approaches</h3></div></div></div><p>When programming using the reactive programming paradigm in implicit style, we can mix different subparadigms into the computational stages that will handle stream processing. As already mentioned, implicit reactive programming languages give the ability to design an overall (or part of) reactive application and add nonreactive programming scripts or blocks into components, controls, or modules that will execute single stream logic, such as aggregation, filtering, mapping, and so on.</p><p>In these computational blocks (that represent data flow stages), we can use functional programming, object-oriented programming, and imperative or declarative programming. For most cases, such as the BizTalk Server mapping, a simple C# script (single or multiple lines) is available as a programmable component for a single stage. In the case of using such features extensively, the paradigm takes the name <span class="emphasis"><em>imperative reactive programming</em></span>.</p><p>When we use general-purpose programming languages, such as C#, we will obtain reactive programmability by adding libraries to the core base classes like <code class="literal">Rx.NET</code>.</p><p>The C# now available gives us the ability to use <span class="emphasis"><em>object-oriented reactive programming</em></span>. This means that we can use object-oriented programming in a single reactive stage or inverse the situation by using reactive programming in a single module or class or an object-oriented application. We can use both the alternatives together in the same application too, although this last choice will make the maintainability of the code difficult for the developer.</p><p>The more pure <span class="emphasis"><em>visual reactive programming</em></span> style instead gives the developer only visual components to do their job. This is what happens in the SSIS data flow diagram, although not a reactive programming language.</p><p>If, in the computational stage, we make use of functional programming or languages, such as F#, the overall paradigm will take the name <span class="emphasis"><em>functional reactive programming</em></span>.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Further reading</h2></div></div><hr /></div><p>Although this book is about reactive programming, the most transforming modules we will write will observe the object-oriented programming paradigm. This is a good thought. Simply consider the following assertion: the best programming style or language is the best only in a few conditions. Accordingly, try your programming style to the task you're facing.</p><p>Here are some suggestions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Patterns of Enterprise Application Architecture</em></span>, <span class="emphasis"><em>Martin Fowler</em></span>, <span class="emphasis"><em>Pearson Education, Inc</em></span>
</p></li><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em></span>, <span class="emphasis"><em>Eric Evans</em></span>, <span class="emphasis"><em>Pearson Education, Inc</em></span>
</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec12"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we had the opportunity to give an overall description of reactive programming frameworks and languages. Specific key concepts and designs are available for this programming paradigm.</p><p>In the next chapter, we will put into practice all such theoretic notions, writing examples in pure C#, and trying to understand all the key concepts and designs explained here.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch02"></a>Chapter 2. Reactive Programming with C#</h2></div></div></div><p>In the previous chapter, we gave an overall introduction to reactive programming and related languages and frameworks.</p><p>In this chapter, we will see a practical example of reactive programming with pure C# coding.</p><p>The following topics will be discussed here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">IObserver</code> interface</p></li><li style="list-style-type: disc"><p>
<code class="literal">IObservable</code> interface</p></li><li style="list-style-type: disc"><p>Subscription life cycle</p></li><li style="list-style-type: disc"><p>Sourcing events</p></li><li style="list-style-type: disc"><p>Filtering events</p></li><li style="list-style-type: disc"><p>Correlating events</p></li><li style="list-style-type: disc"><p>Sourcing from CLR streams</p></li><li style="list-style-type: disc"><p>Sourcing from CLR enumerables</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec13"></a>IObserver interface</h2></div></div><hr /></div><p>This core level interface is available within the <span class="strong"><strong>Base Class Library</strong></span> (<span class="strong"><strong>BCL</strong></span>) of .NET 4.0 and is available for the older 3.5 as an add-on.</p><p>The use is pretty simple and the goal is to provide a standard way of handling the most basic features of any reactive message consumer.</p><p>As already seen in the previous chapter, reactive messages flow by a producer and a consumer and subscribe for some messages. The <code class="literal">IObserver</code> C# interface is available to construct message receivers that comply with the reactive programming layout by implementing the three main message-oriented events: a <span class="emphasis"><em>message</em></span> received, an <span class="emphasis"><em>error</em></span> received, and a task <span class="emphasis"><em>completed</em></span> message.</p><p>The <code class="literal">IObserver</code> interface has the following sign and description:</p><pre class="programlisting">    // Summary:
    //     Provides a mechanism for receiving push-based notifications.
    //
    // Type parameters:
    //   T:
    //     The object that provides notification information.This type parameter is
    //     contravariant. That is, you can use either the type you specified or any
    //     type that is less derived. For more information about covariance and contravariance,
    //     see Covariance and Contravariance in Generics.
    public interface IObserver&lt;in T&gt;
    {
        // Summary:
        //     Notifies the observer that the provider has finished sending push-based notifications.
        void OnCompleted();
        //
        // Summary:
        //     Notifies the observer that the provider has experienced an error condition.
        //
        // Parameters:
        //   error:
        //     An object that provides additional information about the error.
        void OnError(Exception error);
        //
        // Summary:
        //     Provides the observer with new data.
        //
        // Parameters:
        //   value:
        //     The current notification information.
        void OnNext(T value);
    }
</pre><p>Any new message to flow to the receiver implementing such an interface will reach the <code class="literal">OnNext</code> method. Any error will reach the <code class="literal">OnError</code> method, while the task completed acknowledgement message will reach the <code class="literal">OnCompleted</code> method.</p><p>The use of an interface means that we cannot use generic premade objects from the BCL. We need to implement any receiver from scratch by using such an interface as a service contract. In <a class="link" href="#" linkend="ch03">
Chapter 3, <span class="emphasis"><em>Reactive Extension Programming</em></span>
</a>, we will be able to use subjects that will give us the chance not to implement such interfaces anytime, but for now, let's play this way.</p><p>Let's see an example, because talking about a code example is always simpler than talking about something theoretical. The following examples show how to read from a console application command from a user in a reactive way:</p><pre class="programlisting">
class Program
{
    static void Main(string[] args)
    {
        //creates a new console input consumer
        var consumer = new ConsoleTextConsumer();

        while (true)
        {
            Console.WriteLine("Write some text and press ENTER to send a
            message\r\Press ENTER to exit");
            //read console input
            var input = Console.ReadLine();

            //check for empty messate to exit
            if (string.IsNullOrEmpty(input))
            {
                //job completed
                consumer.OnCompleted();

                Console.WriteLine("Task completed. Any further message will
                generate an error");
            }
            else
            {
                //route the message to the consumer
                consumer.OnNext(input);
            }
        }
    }
}
public class ConsoleTextConsumer : IObserver&lt;string&gt;
{
    private bool finished = false;
    public void OnCompleted()
    {
        if (finished)
        {
            OnError(new Exception("This consumer already finished it's lifecycle"));
            return;
        }

        finished = true;
        Console.WriteLine("&lt;- END");
    }

    public void OnError(Exception error)
    {
        Console.WriteLine("&lt;- ERROR");
        Console.WriteLine("&lt;- {0}", error.Message);
    }

    public void OnNext(string value)
    {
        if (finished)
        {
            OnError(new Exception("This consumer finished its lifecycle"));
            return;
        }

        //shows the received message
        Console.WriteLine("-&gt; {0}", value);
        //do something

        //ack the caller
        Console.WriteLine("&lt;- OK");
    }
}
</pre><p>The preceding example shows the <code class="literal">IObserver</code> interface usage within the <code class="literal">ConsoleTextConsumer</code> class that simply asks a command console (DOS-like) for the user input text to do something. In this implementation, the class simply writes out the input text because we simply want to look at the reactive implementation.</p><p>The first important concept here is that a message consumer knows nothing about how messages are produced. The consumer simply reacts to one of the three events (not CLR events). Besides this, some kind of logic and cross-event ability is also available within the consumer itself. In the preceding example, we can see that the consumer simply showed any received message again on the console. However, if a <span class="emphasis"><em>complete</em></span> message puts the consumer in a finished state (by signaling the finished flag), any other message that comes on the <code class="literal">OnNext</code> method will be automatically routed to the error one. Likewise, any other complete message that reaches the consumer will produce another error once the consumer is already in the finished state.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec14"></a>IObservable interface</h2></div></div><hr /></div><p>The <code class="literal">IObservable</code> interface, the opposite of the <code class="literal">IObserver</code> interface, has the task of handling message production and the <code class="literal">observer</code> subscription. It routes right messages to the <code class="literal">OnNext</code> message handler and errors to the <code class="literal">OnError</code> message handler. As its life cycle ends, it acknowledges all the observers on the <code class="literal">OnComplete</code> message handler.</p><p>To create a valid reactive <code class="literal">observable</code> interface, we must write something that is not locking against user input or any other external system input data. The <code class="literal">observable</code> object acts as an infinite message generator, something like an infinite enumerable of messages; although in such cases, there is no enumeration.</p><p>Once a new message is available somehow, <code class="literal">observer</code> routes it to all the subscribers.</p><p>In the following example, we will try creating a console application to ask the user for an integer number and then route such a number to all the subscribers. Otherwise, if the given input is not a number, an error will be routed to all the subscribers.</p><p>This is <code class="literal">observer</code> similar to the one already seen in the previous example. Take a look at the following codes:</p><pre class="programlisting">
/// &lt;summary&gt;
/// Consumes numeric values that divides without rest by a given number
/// &lt;/summary&gt;
public class IntegerConsumer : IObserver&lt;int&gt;
{
    readonly int validDivider;
    //the costructor asks for a divider
    public IntegerConsumer(int validDivider)
    {
        this.validDivider = validDivider;
    }

    private bool finished = false;
    public void OnCompleted()
    {
        if (finished)
            OnError(new Exception("This consumer already finished it's lifecycle"));
        else
        {
            finished = true;
            Console.WriteLine("{0}: END", GetHashCode());
        }
    }

    public void OnError(Exception error)
    {
        Console.WriteLine("{0}: {1}", GetHashCode(), error.Message);
    }

    public void OnNext(int value)
    {
        if (finished)
            OnError(new Exception("This consumer finished its lifecycle"));

        //the simple business logic is made by checking divider result
        else if (value % validDivider == 0)
            Console.WriteLine("{0}: {1} divisible by {2}", GetHashCode(), value, validDivider);
    }
}
</pre><p>This <code class="literal">observer</code> consumes integer numeric messages, but it requires that the number is divisible by another one without producing any rest value. This logic, because of the encapsulation principle, is within the <code class="literal">observer</code> object. The <code class="literal">observable</code> interface, instead, only has the logic of the message sending of valid or error messages.</p><p>This filtering logic is made within the receiver itself. Although that is not something wrong, in more complex applications, specific filtering features are available in the publish-subscribe communication pipeline. In other words, another object will be available between <code class="literal">observable</code> (publisher) and <code class="literal">observer</code> (subscriber) that will act as a message filter.</p><p>Back to our numeric example, here we have the <code class="literal">observable</code> implementation made using an inner <code class="literal">Task</code> method that does the main job of parsing input text and sending messages. In addition, a cancellation token is available to handle the user <code class="literal">cancellation</code> request and an eventual <code class="literal">observable</code> dispose:</p><pre class="programlisting">//Observable able to parse strings from the Console
//and route numeric messages to all subscribers
public class ConsoleIntegerProducer : IObservable&lt;int&gt;, IDisposable
{
    //the subscriber list
    private readonly List&lt;IObserver&lt;int&gt;&gt; subscriberList = new List&lt;IObserver&lt;int&gt;&gt;();

    //the cancellation token source for starting stopping
    //inner observable working thread
    private readonly CancellationTokenSource cancellationSource;
    //the cancellation flag
    private readonly CancellationToken cancellationToken;
    //the running task that runs the inner running thread
    private readonly Task workerTask;
    public ConsoleIntegerProducer()
    {
        cancellationSource = new CancellationTokenSource();
        cancellationToken = cancellationSource.Token;
        workerTask = Task.Factory.StartNew(OnInnerWorker, cancellationToken);
    }

    //add another observer to the subscriber list
    public IDisposable Subscribe(IObserver&lt;int&gt; observer)
    {
        if (subscriberList.Contains(observer))
            throw new ArgumentException("The observer is already subscribed to this observable");

        Console.WriteLine("Subscribing for {0}", observer.GetHashCode());
        subscriberList.Add(observer);

        return null;
    }

    //this code executes the observable infinite loop
    //and routes messages to all observers on the valid
    //message handler
    private void OnInnerWorker()
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            var input = Console.ReadLine();
            int value;

            foreach (var observer in subscriberList)
                if (string.IsNullOrEmpty(input))
                    break;
                else if (input.Equals("EXIT"))
                {
                    cancellationSource.Cancel();
                    break;
                }
                else if (!int.TryParse(input, out value))
                    observer.OnError(new FormatException("Unable to parse given
                    value"));
                else
                    observer.OnNext(value);
        }
        cancellationToken.ThrowIfCancellationRequested();
    }


    //cancel main task and ack all observers
    //by sending the OnCompleted message
    public void Dispose()
    {
        if (!cancellationSource.IsCancellationRequested)
        {
            cancellationSource.Cancel();
            while (!workerTask.IsCanceled)
                Thread.Sleep(100);
        }

        cancellationSource.Dispose();
        workerTask.Dispose();

        foreach (var observer in subscriberList)
            observer.OnCompleted();
    }

    //wait until the main task completes or went cancelled
    public void Wait()
    {
        while (!(workerTask.IsCompleted || workerTask.IsCanceled))
            Thread.Sleep(100);
    }
}
</pre><p>To complete the example, here there is the program <code class="literal">Main</code>:</p><pre class="programlisting">
static void Main(string[] args)
{
    //this is the message observable responsible of producing messages
    using (var observer = new ConsoleIntegerProducer())
    //those are the message observer that consume messages
    using (var consumer1 = observer.Subscribe(new IntegerConsumer(2)))
    using (var consumer2 = observer.Subscribe(new IntegerConsumer(3)))
    using (var consumer3 = observer.Subscribe(new IntegerConsumer(5)))
        observer.Wait();

    Console.WriteLine("END");
    Console.ReadLine();
}
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip8"></a>Tip</h3><p>The <code class="literal">cancellationToken.ThrowIfCancellationRequested</code> may raise an exception in your Visual Studio when debugging. Simply go next by pressing <span class="emphasis"><em>
<span class="strong"><strong>F5</strong></span>
</em></span>, or test such a code example without the attached debugger by starting the test with <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>F5</strong></span>
</em></span> instead of <span class="emphasis"><em>
<span class="strong"><strong>F5</strong></span>
</em></span> alone.</p></div><p>The application simply creates an <code class="literal">observable</code> variable, which is able to parse user data. Then, register three observers specifying to each <code class="literal">observer</code> variable the required valid divider value.</p><p>Then, the <code class="literal">observable</code> variable will start reading user data from the console and valid or error messages will flow to all the observers. Each <code class="literal">observer</code> will apply its internal logic of showing the message when it divides for the related divider.</p><p>Here is the result of executing the application:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_001.jpg" /><div class="caption"><p>Observables and observers in action</p></div></div><p>
</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec15"></a>Subscription life cycle</h2></div></div><hr /></div><p>What will happen if we want to stop a single observer from receiving messages from the <code class="literal">observable</code> event source? If we change the program <code class="literal">Main</code> from the preceding example to the following one, we could experience a wrong <code class="literal">observer</code> life cycle design. Here's the code:</p><pre class="programlisting">
//this is the message observable responsible of producing messages
using (var observer = new ConsoleIntegerProducer())
//those are the message observer that consume messages
using (var consumer1 = observer.Subscribe(new IntegerConsumer(2)))
using (var consumer2 = observer.Subscribe(new IntegerConsumer(3)))
{
    using (var consumer3 = observer.Subscribe(new IntegerConsumer(5)))
    {
        //internal lifecycle
    }

    observer.Wait();
}

Console.WriteLine("END");
Console.ReadLine();
</pre><p>Here is the result in the output console:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_002.jpg" /><div class="caption"><p>The third observer unable to catch value messages</p></div></div><p>
</p><p>By using the <code class="literal">using</code>
<code class="literal">construct</code> method, we should stop the life cycle of the consumer object. However, we do not, because in the previous example, the <code class="literal">Subscribe</code> method of the <code class="literal">observable</code> simply returns a <code class="literal">NULL</code> object.</p><p>To create a valid observer, we must handle and design its life cycle management. This means that we must eventually handle the external disposing of the <code class="literal">Subscribe</code> method's result by signaling the right <code class="literal">observer</code> that his life cycle reached the end.</p><p>We have to create a <code class="literal">Subscription</code> class to handle an eventual object disposing in the right reactive way by sending the message for the <code class="literal">OnCompleted</code> event handler.</p><p>Here is a simple <code class="literal">Subscription</code> class implementation:</p><pre class="programlisting">
/// &lt;summary&gt;
/// Handle observer subscription lifecycle
/// &lt;/summary&gt;
public sealed class Subscription&lt;T&gt; : IDisposable
{
    private readonly IObserver&lt;T&gt; observer;
    public Subscription(IObserver&lt;T&gt; observer)
    {
        this.observer = observer;
    }

    //the event signalling that the observer has
    //completed its lifecycle
    public event EventHandler&lt;IObserver&lt;T&gt;&gt; OnCompleted;

    public void Dispose()
    {
        if (OnCompleted != null)
            OnCompleted(this, observer);

        observer.OnCompleted();
    }
}
</pre><p>The usage is within the <code class="literal">observable</code>
<code class="literal">Subscribe</code> method. Here's an example:</p><pre class="programlisting">//add another observer to the subscriber list
public IDisposable Subscribe(IObserver&lt;int&gt; observer)
{
    if (observerList.Contains(observer))
        throw new ArgumentException("The observer is already subscribed to this observable");

    Console.WriteLine("Subscribing for {0}", observer.GetHashCode());
    observerList.Add(observer);

    //creates a new subscription for the given observer
var subscription = new Subscription&lt;int&gt;(observer);
//handle to the subscription lifecycle end event
    subscription.OnCompleted += OnObserverLifecycleEnd;
    return subscription;
}

void OnObserverLifecycleEnd(object sender, IObserver&lt;int&gt; e)
{
    var subscription = sender as Subscription&lt;int&gt;;
    //remove the observer from the internal list within the observable
    observerList.Remove(e);
    //remove the handler from the subscription event
    //once already handled
    subscription.OnCompleted -= OnObserverLifecycleEnd;
}
</pre><p>As shown, the preceding example creates a new <code class="literal">Subscription&lt;T&gt;</code> object to handle this <code class="literal">observer</code> life cycle with the <code class="literal">IDisposable.Dispose</code> method.</p><p>Here is the result of such code edits against the full example available in the previous paragraph:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_003.jpg" /><div class="caption"><p>The observer will end their life as we dispose their life cycle tokens</p></div></div><p>
</p><p>This time, an <code class="literal">observer</code> ends its life cycle prematurely by disposing the <code class="literal">subscription</code> object. This is visible by the first <code class="literal">END</code> message. Later, only two observers remain available at the application ending; when the user asks for <code class="literal">EXIT</code>, only two such observers end their life cycle by themselves rather than by the <code class="literal">Subscription</code> disposing.</p><p>In real-world applications, observers often subscribe to observables and later unsubscribe by disposing the <code class="literal">Subscription</code> token. This happens because we do not always want a reactive module to handle all the messages. In this case, this means that we have to handle the <code class="literal">observer</code> life cycle by ourselves, as we already did in the previous examples, or we need to apply filters to choose which messages flow to which <code class="literal">subscriber</code>, as shown in the later section <span class="emphasis"><em>Filtering events</em></span>. Kindly consider that although filters make things easier, we will always have to handle the <code class="literal">observer</code> life cycle.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec16"></a>Sourcing events</h2></div></div><hr /></div><p>Sourcing events is the ability to obtain from a particular source where few useful events are usable in reactive programming.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip9"></a>Tip</h3><p>If you are searching for the <code class="literal">EventSourcing</code> pattern, take a look at <a class="link" href="#" linkend="ch07">
Chapter 7, <span class="emphasis"><em>Advanced Techniques</em></span>
</a>.</p></div><p>As already pointed out in the previous chapter, reactive programming is all about event message handling. Any event is a specific occurrence of some kind of handleable behavior of users or external systems. We can actually program event reactions in the most pleasant and productive way for reaching our software goals.</p><p>In the following example, we will see how to react to CLR events. In this specific case, we will handle filesystem events by using events from the <code class="literal">System.IO.FileSystemWatcher</code> class that gives us the ability to react to the filesystem's file changes without the need of making useless and resource-consuming polling queries against the file system status.</p><p>Here's the observer and observable implementation:</p><pre class="programlisting">
public sealed class NewFileSavedMessagePublisher : IObservable&lt;string&gt;, IDisposable
{
    private readonly FileSystemWatcher watcher;
    public NewFileSavedMessagePublisher(string path)
    {
        //creates a new file system event router
        this.watcher = new FileSystemWatcher(path);
        //register for handling File Created event
        this.watcher.Created += OnFileCreated;
        //enable event routing
        this.watcher.EnableRaisingEvents = true;
    }

    //signal all observers a new file arrived
    private void OnFileCreated(object sender, FileSystemEventArgs e)
    {
        foreach (var observer in subscriberList)
            observer.OnNext(e.FullPath);
    }

    //the subscriber list
    private readonly List&lt;IObserver&lt;string&gt;&gt; subscriberList = new List&lt;IObserver&lt;string&gt;&gt;();

    public IDisposable Subscribe(IObserver&lt;string&gt; observer)
    {
        //register the new observer
        subscriberList.Add(observer);

        return null;
    }

    public void Dispose()
    {
        //disable file system event routing
        this.watcher.EnableRaisingEvents = false;
        //deregister from watcher event handler
        this.watcher.Created -= OnFileCreated;
        //dispose the watcher
        this.watcher.Dispose();

        //signal all observers that job is done
        foreach (var observer in subscriberList)
            observer.OnCompleted();
    }
}

/// &lt;summary&gt;
/// A tremendously basic implementation
/// &lt;/summary&gt;
public sealed class NewFileSavedMessageSubscriber : IObserver&lt;string&gt;
{
    public void OnCompleted()
    {
        Console.WriteLine("-&gt; END");
    }

    public void OnError(Exception error)
    {
        Console.WriteLine("-&gt; {0}", error.Message);
    }

    public void OnNext(string value)
    {
        Console.WriteLine("-&gt; {0}", value);
    }
}
</pre><p>The <code class="literal">observer</code> interface simply gives us the ability to write text to the console. I think there is nothing to say about it.</p><p>On the other hand, the <code class="literal">observable</code> interface makes the most of the job in this implementation.</p><p>The <code class="literal">observable</code> interface creates the <code class="literal">watcher</code> object and registers the right event handler to catch the wanted reactive events. It handles the life cycle of itself and the internal <code class="literal">watcher</code> object. Then, it correctly sends the <code class="literal">OnComplete</code> message to all the observers.</p><p>Here's the program's initialization:</p><pre class="programlisting">static void Main(string[] args)
{
    Console.WriteLine("Watching for new files");
    using (var publisher = new NewFileSavedMessagePublisher(@"[WRITE A PATH
    HERE]"))
    using (var subscriber = publisher.Subscribe(new NewFileSavedMessageSubscriber()))
    {
        Console.WriteLine("Press RETURN to exit");
        //wait for user RETURN
        Console.ReadLine();
    }
}
</pre><p>Any new file that arises in the folder will let route full <code class="literal">FileName</code> to <code class="literal">observer</code>. This is the result of a copy and paste of the same file three times:</p><pre class="programlisting">-&gt; [YOUR PATH]\out - Copy.png
-&gt; [YOUR PATH]\out - Copy (2).png
-&gt; [YOUR PATH]\out - Copy (3).png
</pre><p>By using a single <code class="literal">observable</code> interface and a single <code class="literal">observer</code> interface, the power of reactive programming is not so evident. Let's begin with writing some intermediate object to change the message flow within the pipeline of our message pump made in a reactive way with filters, message correlator, and dividers.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Filtering events</h2></div></div><hr /></div><p>As said in the previous section, it is time to alter message flow.</p><p>The <code class="literal">observable</code> interface has the task of producing messages, while conversely <code class="literal">observer</code> consumes such messages. To create a message filter, we need to create an object that is both a publisher and a subscriber together.</p><p>The implementation must take into consideration the filtering need and the message routing to underlying observers that subscribe to the filter <code class="literal">observable</code> object instead of the main one.</p><p>Here's an implementation of the filter:</p><pre class="programlisting">
/// &lt;summary&gt;
/// The filtering observable/observer
/// &lt;/summary&gt;
public sealed class StringMessageFilter : IObservable&lt;string&gt;, IObserver&lt;string&gt;, IDisposable
{
    private readonly string filter;
    public StringMessageFilter(string filter)
    {
        this.filter = filter;
    }

    //the observer collection
    private readonly List&lt;IObserver&lt;string&gt;&gt; observerList = new List&lt;IObserver&lt;string&gt;&gt;();
    public IDisposable Subscribe(IObserver&lt;string&gt; observer)
    {
        this.observerList.Add(observer);
        return null;
    }

    //a simple implementation
    //that disables message routing once
    //the OnCompleted has been invoked
    private bool hasCompleted = false;
    public void OnCompleted()
    {
        hasCompleted = true;
        foreach (var observer in observerList)
            observer.OnCompleted();
    }

    //routes error messages until not completed
    public void OnError(Exception error)
    {
        if (!hasCompleted)
            foreach (var observer in observerList)
                observer.OnError(error);
    }

    //routes valid messages until not completed
    public void OnNext(string value)
    {
        Console.WriteLine("Filtering {0}", value);

        if (!hasCompleted &amp;&amp; value.ToLowerInvariant().Contains(filter.ToLowerInvariant()))
            foreach (var observer in observerList)
                observer.OnNext(value);
    }

    public void Dispose()
    {
        OnCompleted();
    }
}
</pre><p>This filter can be used together with the example from the previous section that routes the <code class="literal">FileSystemWatcher</code> events of created files. This is the new program initialization:</p><pre class="programlisting">static void Main(string[] args)
{
    Console.WriteLine("Watching for new files");
    using (var publisher = new NewFileSavedMessagePublisher(@"[WRITE A PATH HERE]"))
    using (var filter = new StringMessageFilter(".txt"))
    {
        //subscribe the filter to publisher messages
        publisher.Subscribe(filter);
        //subscribe the console subscriber to the filter
        //instead that directly to the publisher
        filter.Subscribe(new NewFileSavedMessageSubscriber());

        Console.WriteLine("Press RETURN to exit");
        Console.ReadLine();
    }
}
</pre><p>As we can see, this new implementation creates a new <code class="literal">filter</code> object that takes a parameter to verify valid filenames to flow to the underlying observers.</p><p>The <code class="literal">filter</code> subscribes to the main <code class="literal">observable</code> object, while the <code class="literal">observer</code> subscribes to the <code class="literal">filter</code> itself. It is like a chain where each chain link refers to the next one.</p><p>This is the output console of the running application:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_004.jpg" /><div class="caption"><p>The filtering observer in action</p></div></div><p>
</p><p>Although I made a copy of two files (a <code class="literal">.png</code> and a <code class="literal">.txt</code> file), we can see that only the text file reached the internal <code class="literal">observer</code> object, while the image file reached the <code class="literal">OnNext</code> of <code class="literal">filter</code> because the invalid against the <code class="literal">filter</code> argument never reached the internal <code class="literal">observer</code>.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Correlating events</h2></div></div><hr /></div><p>Sometimes, especially when dealing with integration scenarios, there is a need for correlating multiple events that don't always came together. This is the case of a header file that came together with multiple body files.</p><p>In reactive programming, correlating events means correlating multiple <code class="literal">observable</code> messages into a single message that is the result of two or more original messages. Such messages must be somehow correlated to a value (an <code class="literal">ID</code>, <code class="literal">serial</code>, or metadata) that defines that such initial messages belong to the same correlation set.</p><p>Useful features in real-world correlators are the ability to specify a timeout (that may be infinite too) in the correlation waiting logic and the ability to specify a correlation message count (infinite too).</p><p>Here's a <code class="literal">correlator</code> implementation made for the previous example based on the <code class="literal">FileSystemWatcher</code> class:</p><pre class="programlisting">
public sealed class FileNameMessageCorrelator : IObservable&lt;string&gt;, IObserver&lt;string&gt;, IDisposable
{
    private readonly Func&lt;string, string&gt; correlationKeyExtractor;
    public FileNameMessageCorrelator(Func&lt;string, string&gt; correlationKeyExtractor)
    {
        this.correlationKeyExtractor = correlationKeyExtractor;
    }

    //the observer collection
    private readonly List&lt;IObserver&lt;string&gt;&gt; observerList = new List&lt;IObserver&lt;string&gt;&gt;();
    public IDisposable Subscribe(IObserver&lt;string&gt; observer)
    {
        this.observerList.Add(observer);
        return null;
    }

    private bool hasCompleted = false;
    public void OnCompleted()
    {
        hasCompleted = true;
        foreach (var observer in observerList)
            observer.OnCompleted();
    }

    //routes error messages until not completed
    public void OnError(Exception error)
    {
        if (!hasCompleted)
            foreach (var observer in observerList)
                observer.OnError(error);
    }
</pre><p>Let's pause. Up to this row, we simply created the reactive structure of the <code class="literal">FileNameMessageCorrelator</code> class by implementing the two main interfaces. Here is the core implementation that correlates messages:</p><pre class="programlisting">//the container of correlations able to contain
//multiple strings per each key
private readonly NameValueCollection correlations = new NameValueCollection();

//routes valid messages until not completed
public void OnNext(string value)
{
    if (hasCompleted) return;

    //check if subscriber has completed
    Console.WriteLine("Parsing message: {0}", value);

    //try extracting the correlation ID
    var correlationID = correlationKeyExtractor(value);

    //check if the correlation is available
    if (correlationID == null) return;

    //append the new file name to the correlation state
    correlations.Add(correlationID, value);

    //in this example we will consider always
    //correlations of two items
    if (correlations.GetValues(correlationID).Count() == 2)
    {
        //once the correlation is complete
        //read the two files and push the
        //two contents altogether to the
        //observers

        var fileData = correlations.GetValues(correlationID)
            //route messages to the ReadAllText method
            .Select(File.ReadAllText)
            //materialize the query
            .ToArray();

        var newValue = string.Join("|", fileData);

        foreach (var observer in observerList)
            observer.OnNext(newValue);

        correlations.Remove(correlationID);
    }
}
</pre><p>This <code class="literal">correlator</code> class accepts a <code class="literal">correlation</code> function as a constructor parameter. This function is later used to evaluate <code class="literal">correlationID</code> when a new <code class="literal">filename</code> variable flows within the <code class="literal">OnNext</code> method.</p><p>Once the function returns valid <code class="literal">correlationID</code>, such IDs will be used as key for <code class="literal">NameValueCollection</code>, a specialized string collection to store multiple values per key. When there are two values for the same key, <code class="literal">correlation</code> is ready to flow out to the underlying observers by reading file data and joining such data into a single string message.</p><p>Here's the application's initialization:</p><pre class="programlisting">static void Main(string[] args)
{
    using (var publisher = new NewFileSavedMessagePublisher(@"[WRITE A PATH HERE]"))
    //creates a new correlator by specifying the correlation key
    //extraction function made with a Regular expression that
    //extract a file ID similar to FILEID0001
    using (var correlator = new FileNameMessageCorrelator(ExtractCorrelationKey))
    {
        //subscribe the correlator to publisher messages
        publisher.Subscribe(correlator);

        //subscribe the console subscriber to the correlator
        //instead that directly to the publisher
        correlator.Subscribe(new NewFileSavedMessageSubscriber());

        //wait for user RETURN
        Console.ReadLine();
    }
}

private static string ExtractCorrelationKey(string arg)
{
    var match = Regex.Match(arg, "(FILEID\\d{4})");
    if (match.Success)
        return match.Captures[0].Value;
    else
        return null;
}
</pre><p>The initialization is almost the same as the filtering example seen in the previous section. The biggest difference is that the <code class="literal">correlator</code> object, instead of a string <code class="literal">filter</code> variable, accepts a function that analyses the incoming filename and produces the eventually available <code class="literal">correlationID</code> variable.</p><p>I prepared two files with the same ID in the <code class="literal">filename</code> variable. Here's the console output of the running example:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_005.jpg" /><div class="caption"><p>Two files correlated by their name</p></div></div><p>
</p><p>As can be seen, <code class="literal">correlator</code> fulfilled its job by joining the two file's data into a single message regardless of the order in which the two files were stored in the filesystem.</p><p>These examples regarding the filtering and correlation of messages should show you that we can do anything with received messages: we can put a message in standby until a correlated message comes, we can join multiple messages into one, we can produce multiple times the same message, and so on.</p><p>This programming style opens the programmer's mind to a lot of new application designs and possibilities.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Sourcing from CLR streams</h2></div></div><hr /></div><p>Any class that extends <code class="literal">System.IO.Stream</code> is some kind of cursor-based flow of data. The same happens when we want to see a video stream, a sort of locally not persisted data that flows only in the network with the ability to go forward and backward, stop, pause, resume, play, and so on. The same behavior is available while streaming any kind of data, thus, the <code class="literal">Stream</code> class is the base class that exposes such behavior for any need.</p><p>There are specialized classes that extend <code class="literal">Stream</code>, helping work with the streams of text data (<code class="literal">StreamWriter</code> and <code class="literal">StreamReader</code>), binary serialized data (<code class="literal">BinaryReader</code> and <code class="literal">BinaryWriter</code>), memory-based temporary byte containers (<code class="literal">MemoryStream</code>), network-based streams (<code class="literal">NetworkStream</code>), and many others.</p><p>Regarding reactive programming, we are dealing with the ability to source events from any stream regardless of its type (network, file, memory, and so on).</p><p>Real-world applications that use reactive programming based on streams are cheats, remote binary listeners (socket programming), and any other unpredictable event-oriented application. On the other hand, it is useless to read a huge file in a reactive way, because there is simply nothing reactive in such cases.</p><p>It is time to look at an example. Here's a complete example of a reactive application made for listening to a TPC port and routing string messages (CR + LF divides multiple messages) to all the available observers. The program <code class="literal">Main</code> and the usual <code class="literal">ConsoleObserver</code> methods are omitted for better readability:</p><pre class="programlisting">
    public sealed class TcpListenerStringObservable : IObservable&lt;string&gt;, IDisposable
    {
        private readonly TcpListener listener;
        public TcpListenerStringObservable(int port, int backlogSize = 64)
        {
            //creates a new tcp listener on given port
            //with given backlog size
            listener = new TcpListener(IPAddress.Any, port);
            listener.Start(backlogSize);

            //start listening asynchronously
            listener.AcceptTcpClientAsync().ContinueWith(OnTcpClientConnected);
        }

        private void OnTcpClientConnected(Task&lt;TcpClient&gt; clientTask)
        {
            //if the task has not encountered errors
            if (clientTask.IsCompleted)
                //we will handle a single client connection per time
                //to handle multiple connections, simply put following
                //code into a Task
                using (var tcpClient = clientTask.Result)
                using (var stream = tcpClient.GetStream())
                using (var reader = new StreamReader(stream))
                    while (tcpClient.Connected)
                    {
                        //read the message
                        var line = reader.ReadLine();

                        //stop listening if nothing available
                        if (string.IsNullOrEmpty(line))
                            break;
                        else
                        {
                            //construct observer message adding client's remote
                            endpoint address and port
                            var msg = string.Format("{0}: {1}",
                             tcpClient.Client.RemoteEndPoint, line);

                            //route messages
                            foreach (var observer in observerList)
                                observer.OnNext(msg);
                        }
                    }

            //starts another client listener
            listener.AcceptTcpClientAsync().ContinueWith(OnTcpClientConnected);
        }

        private readonly List&lt;IObserver&lt;string&gt;&gt; observerList = new
        List&lt;IObserver&lt;string&gt;&gt;();
        public IDisposable Subscribe(IObserver&lt;string&gt; observer)
        {
            observerList.Add(observer);

            //subscription lifecycle missing
            //for readability purpose
            return null;
        }

        public void Dispose()
        {
            //stop listener
            listener.Stop();
        }
    }
</pre><p>The preceding example shows how to create a reactive TCP listener that acts as an <code class="literal">observable</code> of string messages.</p><p>The <code class="literal">observable</code> method uses an internal <code class="literal">TcpListener</code> class that provides mid-level network services across an underlying <code class="literal">Socket</code> object. The example asks the listener to start listening and starts waiting for a client into another thread with the use of a <code class="literal">Task</code> object. When a remote client becomes available, its communication with the internals of <code class="literal">observable</code> is guaranteed by the <code class="literal">OnTcpClientConneted</code> method that verifies the normal execution of <code class="literal">Task</code>. Then, it catches <code class="literal">TcpClient</code> from <code class="literal">Task</code>, reads the network stream, and appends <code class="literal">StreamReader</code> to such a network stream to start a reading feature.</p><p>Once the message reading feature is complete, another <code class="literal">Task</code> starts repeating the procedure. Although, this design handles a backlog of pending connections, it makes available only a single client per time. To change such designs to handle multiple connections altogether, simply encapsulate the <code class="literal">OnTcpClientConnected</code> logic. Here's an example:</p><pre class="programlisting">
private void OnTcpClientConnected(Task&lt;TcpClient&gt; clientTask)
{
    //if the task has not encountered errors
    if (clientTask.IsCompleted)
        Task.Factory.StartNew(() =&gt;
            {
                using (var tcpClient = clientTask.Result)
                using (var stream = tcpClient.GetStream())
                using (var reader = new StreamReader(stream))
                    while (tcpClient.Connected)
                    {
                        //read the message
                        var line = reader.ReadLine();

                        //stop listening if nothing available
                        if (string.IsNullOrEmpty(line))
                            break;
                        else
                        {
                            //construct observer message adding client's remote
                              endpoint address and port
                            var msg = string.Format("{0}: {1}",
                            tcpClient.Client.RemoteEndPoint, line);

                            //route messages
                            foreach (var observer in observerList)
                                observer.OnNext(msg);
                        }
                    }
            }, TaskCreationOptions.PreferFairness);

    //starts another client listener
    listener.AcceptTcpClientAsync().ContinueWith(OnTcpClientConnected);
}
</pre><p>This is the output of the reactive application when it receives two different connections by using <code class="literal">telnet</code> as a client (<code class="literal">C:\&gt;telnetlocalhost8081</code>). The program <code class="literal">Main</code> and the usual <code class="literal">ConsoleObserver</code> methods are omitted for better readability:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_006.jpg" /><div class="caption"><p>The observable routing events from the telnet client</p></div></div><p>
</p><p>As you can see, each client starts connecting to the listener by using a different remote port. This gives us the ability to differentiate multiple remote connections although they connect altogether.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Sourcing from CLR enumerables</h2></div></div><hr /></div><p>Sourcing from a finite collection is quite useless with regard to reactive programming. However, specific enumerable collections are perfect for reactive uses. These collections are the changeable collections that support collection change notifications by implementing the <code class="literal">INotifyCollectionChanged</code>(<code class="literal">System.Collections.Specialized</code>) interface like the <code class="literal">ObservableCollection</code>(<code class="literal">System.Collections.ObjectModel</code>) class and any infinite collection that supports the enumerator pattern with the use of the <code class="literal">yield</code> keyword.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Changeable collections</h3></div></div></div><p>The <code class="literal">ObservableCollection&lt;T&gt;</code> class gives us the ability to understand, in an event-based way, any change that occurs against the collection content. Kindly consider that changes regarding collection child properties are outside of the collection scope. This means that we are notified only for collection changes like the one produced from the <code class="literal">Add</code> or <code class="literal">Remove</code> methods. Changes within a single item do not produce an alteration of the collection size, thus, they are not notified at all.</p><p>Here's a generic (non reactive) example:</p><pre class="programlisting">
static void Main(string[] args)
{
    //the observable collection
    var collection = new ObservableCollection&lt;string&gt;();
    //register a handler to catch collection changes
    collection.CollectionChanged += OnCollectionChanged;

    collection.Add("ciao");
    collection.Add("hahahah");

    collection.Insert(0, "new first line");
    collection.RemoveAt(0);

    Console.WriteLine("Press RETURN to EXIT");
    Console.ReadLine();
}

private static void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
{
    var collection = sender as ObservableCollection&lt;string&gt;;

    if (e.NewStartingIndex &gt;= 0) //adding new items
        Console.WriteLine("-&gt; {0} {1}", e.Action, collection[e.NewStartingIndex]);
    else //removing items
        Console.WriteLine("-&gt; {0} at {1}", e.Action, e.OldStartingIndex);
}
</pre><p>As shown, <code class="literal">collection</code> notifies all the adding operations, giving the ability to catch the new message. The <code class="literal">Insert</code> method signals an <code class="literal">Add</code> operation; although with the <code class="literal">Insert</code> method, we can specify the index and the value will be available within <code class="literal">collection</code>. Obviously, the parameter containing the index value (<code class="literal">e.NewStartingIndex</code>) contains the new index according to the right operation. However, the <code class="literal">Remove</code> operation, although notifying the removed element index, cannot give us the ability to read the original message before the removal, because the event triggers after the remove operation has already occurred.</p><p>In a real-world reactive application, the most interesting operation against <code class="literal">ObservableCollection</code> is the <code class="literal">Add</code> operation. Here's an example (console observer omitted for better readability):</p><pre class="programlisting">
class Program
{
    static void Main(string[] args)
    {
        //the observable collection
        var collection = new ObservableCollection&lt;string&gt;();

        using (var observable = new NotifiableCollectionObservable(collection))
        using (var observer = observable.Subscribe(new ConsoleStringObserver()))
        {
            collection.Add("ciao");
            collection.Add("hahahah");

            collection.Insert(0, "new first line");
            collection.RemoveAt(0);

            Console.WriteLine("Press RETURN to EXIT");
            Console.ReadLine();
        }
    }

public sealed class NotifiableCollectionObservable : IObservable&lt;string&gt;, IDisposable
{
    private readonly ObservableCollection&lt;string&gt; collection;
    public NotifiableCollectionObservable(ObservableCollection&lt;string&gt; collection)
    {
        this.collection = collection;
        this.collection.CollectionChanged += collection_CollectionChanged;
    }

    private readonly List&lt;IObserver&lt;string&gt;&gt; observerList = new List&lt;IObserver&lt;string&gt;&gt;();
    public IDisposable Subscribe(IObserver&lt;string&gt; observer)
    {
        observerList.Add(observer);

        //subscription lifecycle missing
        //for readability purpose
        return null;
    }

    public void Dispose()
    {
        this.collection.CollectionChanged -= collection_CollectionChanged;

        foreach (var observer in observerList)
            observer.OnCompleted();
    }
}
}
</pre><p>The result is the same as the previous example of <code class="literal">ObservableCollection</code> without the reactive objects. The only difference is that <code class="literal">observable</code> only routes messages when the <code class="literal">Action</code> values add.</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_007.jpg" /><div class="caption"><p>The ObservableCollection signaling its content changes</p></div></div><p>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Infinite collections</h3></div></div></div><p>Our last example is regarding sourcing events from an infinite <code class="literal">collection</code> method.</p><p>In C#, it is possible to implement the enumerator pattern by signaling each object to enumerate per time, thanks to the <code class="literal">yield</code> keyword. Here's an example:</p><pre class="programlisting">
static void Main(string[] args)
{
    foreach (var value in EnumerateValuesFromSomewhere())
        Console.WriteLine(value);
}

static IEnumerable&lt;string&gt; EnumerateValuesFromSomewhere()
{
    var random = new Random(DateTime.Now.GetHashCode());
    while (true) //forever
    {
        //returns a random integer number as string
        yield return random.Next().ToString();
        //some throttling time
        Thread.Sleep(100);
    }
}
</pre><p>This implementation is powerful because it doesn't materialize all the values into the memory. It simply signals that a new object is available to the enumerator that the <code class="literal">foreach</code> structure internally uses itself. The result is forever writing numbers onto the output console.</p><p>Somehow, this behavior is useful for reactive use, because it doesn't create a useless state like a temporary array, list, or generic collection. It simply signals new items available to the enumerable.</p><p>Here's an example:</p><pre class="programlisting">
    public sealed class EnumerableObservable : IObservable&lt;string&gt;, IDisposable
    {
        private readonly IEnumerable&lt;string&gt; enumerable;
        public EnumerableObservable(IEnumerable&lt;string&gt; enumerable)
        {
            this.enumerable = enumerable;
            this.cancellationSource = new CancellationTokenSource();
            this.cancellationToken = cancellationSource.Token;
            this.workerTask = Task.Factory.StartNew(() =&gt;
                {
                    foreach (var value in this.enumerable)
                    {
                        //if task cancellation triggers, raise the proper exception
                        //to stop task execution
                        cancellationToken.ThrowIfCancellationRequested();

                        foreach (var observer in observerList)
                            observer.OnNext(value);
                    }
                }, this.cancellationToken);
        }

        //the cancellation token source for starting stopping
        //inner observable working thread
        private readonly CancellationTokenSource cancellationSource;
        //the cancellation flag
        private readonly CancellationToken cancellationToken;
        //the running task that runs the inner running thread
        private readonly Task workerTask;
        //the observer list
        private readonly List&lt;IObserver&lt;string&gt;&gt; observerList = new List&lt;IObserver&lt;string&gt;&gt;();
        public IDisposable Subscribe(IObserver&lt;string&gt; observer)
        {
            observerList.Add(observer);

            //subscription lifecycle missing
            //for readability purpose
            return null;
        }

        public void Dispose()
        {
            //trigger task cancellation
            //and wait for acknoledge
            if (!cancellationSource.IsCancellationRequested)
            {
                cancellationSource.Cancel();
                while (!workerTask.IsCanceled)
                    Thread.Sleep(100);
            }

            cancellationSource.Dispose();
            workerTask.Dispose();

            foreach (var observer in observerList)
                observer.OnCompleted();
        }
    }
</pre><p>This is the code of the program startup with the infinite enumerable generation:</p><pre class="programlisting">    class Program
    {
        static void Main(string[] args)
        {
            //we create a variable containing the enumerable
            //this does not trigger item retrieval
            //so the enumerator does not begin flowing datas
            var enumerable = EnumerateValuesFromSomewhere();

            using (var observable = new EnumerableObservable(enumerable))
            using (var observer = observable.Subscribe(new ConsoleStringObserver()))
            {
                //wait for 2 seconds than exit
                Thread.Sleep(2000);
            }

            Console.WriteLine("Press RETURN to EXIT");
            Console.ReadLine();
        }

        static IEnumerable&lt;string&gt; EnumerateValuesFromSomewhere()
        {
            var random = new Random(DateTime.Now.GetHashCode());
            while (true) //forever
            {
                //returns a random integer number as string
                yield return random.Next().ToString();
                //some throttling time
                Thread.Sleep(100);
            }
        }
    }
</pre><p>As against the last examples, here we have the use of the <code class="literal">Task</code> class. The <code class="literal">observable</code> uses the enumerable within the asynchronous <code class="literal">Task</code> method to give the programmer the ability to stop the execution of the whole operation by simply exiting the <span class="emphasis"><em>using</em></span> scope or by manually invoking the <code class="literal">Dispose</code> method.</p><p>This example shows a tremendously powerful feature: the ability to yield values without having to source them from a concrete (finite) array or collection by simply implementing the enumerator pattern. Although few are used, the <code class="literal">yield</code> operator gives the ability to create complex applications simply by pushing messages between methods. The more methods we create that cross send messages to each other, the more complex business logics the application can handle.</p><p>Consider the ability to catch all such messages with observables, and you have a little idea about how powerful reactive programming can be for a developer.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we had the opportunity to test the main features that any reactive application must implement: message sending, error sending, and completing acknowledgement. We focused on plain C# programming to give the first overview of how reactive classic designs can be applied to all main application needs, such as sourcing from streams, from user input, from changeable and infinite collections.</p><p>In the following chapters, we will divert Reactive Extensions for .NET features that will give us the ability to test more complex solutions to comply with more complex reactive needs.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch03"></a>Chapter 3. Reactive Extension Programming</h2></div></div></div><p>This chapter will lead readers through the first steps in <span class="strong"><strong>Reactive Extension</strong></span> (<span class="strong"><strong>Rx</strong></span>) programming. We will give an overview of the Rx architecture with information on how to configure our application to use the framework and how to use its main components.</p><p>We will cover the following arguments:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Setting up <code class="literal">Rx.NET</code>
</p></li><li style="list-style-type: disc"><p>Marble diagrams</p></li><li style="list-style-type: disc"><p>Subjects</p></li><li style="list-style-type: disc"><p>Transforming operators</p></li><li style="list-style-type: disc"><p>Combining operators</p></li><li style="list-style-type: disc"><p>Filtering operators</p></li><li style="list-style-type: disc"><p>Mathematical operators</p></li><li style="list-style-type: disc"><p>Logic operators</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Tip</h3><p>The NuGet package names have been changed. The Rx-* and Ix-* packages have been renamed to match their library names, keeping inline with the rest of .NET Core.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Use <code class="literal">System.Reactive</code> instead of <code class="literal">Rx-Main</code></p></li><li style="list-style-type: disc"><p>Use <code class="literal">System.Interactive</code> instead of <code class="literal">Ix-Main</code></p></li><li style="list-style-type: disc"><p>Use <code class="literal">System.Interactive.Async</code> instead of <code class="literal">Ix-Async</code></p></li></ul></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec22"></a>Setting up Rx.NET</h2></div></div><hr /></div><p>To configure our .NET-based application to use the <code class="literal">Rx.NET</code> classes, we can simply ask <span class="strong"><strong>NuGet</strong></span> to download the <code class="literal">Rx-Main</code> (<span class="strong"><strong>Reactive Extensions -  Main Library</strong></span>) package.</p><p>This action will register all .NET assemblies in our application, including other NuGet packages, such as <code class="literal">Rx-Core</code>, <code class="literal">Rx-Interfaces</code>, <code class="literal">Rx-PlatformServices</code>, and <code class="literal">Rx-Linq</code>, all from Microsoft Corp.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" /><div class="caption"><p>NuGet Rx-Main package</p></div></div><p>
</p><p>Other packages are available using NuGet. This book will cover only the mainline of such package distributions.</p><p>At the time of writing this book, Rx was available in version 2.2.5 that was released in July 2014. Although in May 2015 a version 2.3.0 beta was available throughout NuGet, a stable 2.3.x release is still not available.</p><p>A stable version 2.x was available in August 2012, supporting .NET 4.0, 4.5, 4.5 for Store Apps, Windows Phone 7.5, and Silverlight 5.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec23"></a>Marble diagrams</h2></div></div><hr /></div><p>A marble diagram exposes graphically a sequence of <code class="literal">observable</code> items in a time fashion.</p><p>This simple diagram is the standard de facto of exposing observable sequences when composed with observable operators, such as <code class="literal">merge</code>, <code class="literal">delay</code>, <code class="literal">scan</code>, and so on.</p><p>The most practical example is available on 
<a class="ulink" href="http://rxmarbles.com" target="_blank">http://rxmarbles.com</a>
.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" /><div class="caption"><p>A marble diagram showing a merge operation</p></div></div><p>
</p><p>In the preceding screenshot, we can see two time-based sequences of observable numeric values in the first two lines. The balls are the values. The little vertical lines are the <code class="literal">OnCompleted</code> messages that define when a sequence ends its life cycle.</p><p>The third line shows the merged observable sequence containing all the values from the first two sequences.</p><p>The website offers a great selection of examples regarding the most used reactive operators by using marble diagrams. This is useful to understand the operator job before diving into coding.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec24"></a>Subjects</h2></div></div><hr /></div><p>A <code class="literal">subject</code> class is an observable sequence that is an observer too. A subject may produce and consume values; in other words, it is a value publisher and a value subscriber.</p><p>In real-world reactive applications, there are various (some times hundreds) subjects interacting with each other.</p><p>In the previous section, when we saw the <code class="literal">merge</code> operation in the marble diagram, we pressed two sequences into another one to give us the ability to subscribe an <code class="literal">Observer</code> to the new merged sequence. This merged sequence is a subject because it receives values from the nonmerged sequences and then produces values to the related observer.</p><p>This is only an example of the infinite subjects available in any application.</p><p>A <code class="literal">subject</code> class gives us the ability to create sequences or observers without having to always create a specific class and implement the relative interface, as seen in the previous examples with pure C# coding. Here is an example:</p><pre class="programlisting">//a new sequence
var s = new Subject&lt;string&gt;();
//subscribe such new observer OnNext implementation
s.Subscribe(Console.WriteLine);

//some push value
s.OnNext("value1");
s.OnNext("value2");
Console.ReadLine();
</pre><p>The ability to create sequences with minimal effort is one of the killing features of a <code class="literal">subject</code>.</p><p>As shown in the previous example, we do not need to implement any interface or create any custom class to achieve the desired result. The only required task is providing the <code class="literal">OnNext</code> method implementation by executing the <code class="literal">Subscribe</code> method. This method asks for <code class="literal">Action&lt;T&gt;</code>. We can pass such a parameter by writing a lambda or by passing the method itself (as seen in the example).</p><p>The <code class="literal">Subject</code> class itself implements the <code class="literal">OnCompleted</code> method and the <code class="literal">OnError</code> method by routing the proper message to all the subscribers and then disposing all the subscriber tokens.</p><p>When using Rx, we have lot of extension methods available to access the huge amount of operations available against <code class="literal">subjects</code>. Later, in this chapter, we will give an overview of the most widely used ones.</p><p>
<code class="literal">Subject</code> is only the head of the dragon. A lot of other classes extends <code class="literal">Subject</code> by adding other features.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec18"></a>ReplaySubject</h3></div></div></div><p>
<code class="literal">ReplaySubject&lt;T&gt;</code> gives a time buffer feature.</p><p>Normally, when we use <code class="literal">Subject</code> by pushing values into the subject, only already subscribed <code class="literal">observers</code> will receive the new value from the first subject, as seen in the example:</p><pre class="programlisting">var simpleSubject = new Subject&lt;string&gt;();
simpleSubject.OnNext("value1");
simpleSubject.OnNext("value2");
simpleSubject.Subscribe(Console.WriteLine);
simpleSubject.OnNext("value3");
simpleSubject.OnNext("value4");
</pre><p>Instead, by using <code class="literal">ReplaySubject</code>, the subject will route all the pushed messages to its subscribers like a normal subject does, adding the ability to store all such messages, making them available to later subscribers.</p><p>In this case, words are a bit more confusing than code:</p><pre class="programlisting">var replaySubject = new ReplaySubject&lt;string&gt;();
replaySubject.OnNext("value1");
replaySubject.OnNext("value2");
replaySubject.Subscribe(Console.WriteLine);
replaySubject.OnNext("value3");
replaySubject.OnNext("value4");
</pre><p>The difference between those two identical examples is that, in the <code class="literal">simpleSubject</code> example at the beginning of the <span class="emphasis"><em>Subjects</em></span> section, only <code class="literal">value3</code> and <code class="literal">value4</code> will be outputted to the console. In the example of the <span class="emphasis"><em>ReplaySubject</em></span> section, all the values will reach the console output.</p><p>
<code class="literal">ReplaySubject</code> will buffer all the received messages in its memory and will later produce all such messages to the new subscriber.</p><p>Obviously, because the memory is finite, we have the ability to specify in the constructor a numeric buffer amount or a time-based amount with <code class="literal">TimeSpan</code>:</p><pre class="programlisting">var a = new ReplaySubject&lt;string&gt;(10);
var b = new ReplaySubject&lt;string&gt;(TimeSpan.FromSeconds(10));
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec19"></a>BehaviorSubject</h3></div></div></div><p>This alternative extension of the <code class="literal">Subject</code> class is similar to <code class="literal">ReplaySubject</code> with the difference that <code class="literal">BehaviorSubject</code> always stores the latest available value (or the initial value if we're at the beginning of its life). This means that a default value must be provided through its constructor. Here is an example:</p><pre class="programlisting">var behaviorSubject = new BehaviorSubject&lt;DateTime&gt;(new DateTime(2001, 1, 1));
Thread.Sleep(1000);
//the default value will flow to the new subscriber
behaviorSubject.Subscribe(x =&gt; Console.WriteLine(x));
Thread.Sleep(1000);
//a new value will flow to the subscriber
behaviorSubject.OnNext(DateTime.Now);
Thread.Sleep(1000);
//this new subscriber will receive the last available message
//regardless is was not subscribing at the time the message arise
behaviorSubject.Subscribe(x =&gt; Console.WriteLine(x));
Thread.Sleep(1000);
</pre><p>In any case, if <code class="literal">observer</code> subscribes to <code class="literal">subject</code>, it receives the last available value. However, when a subscriber already subscribes <code class="literal">subject</code> when a new value is available, this value will normally flow to the subscriber.</p><p>This behavior is very specific in reactive programming because it allows us to ensure that a value will always flow to any subscriber regardless of the availability of new values.</p><p>In the real world, this subject is used in cases where we want to have the opportunity to subscribe, take some updated value, unsubscribe, and then be able to subscribe again in the future, thus repeating the behavior. This is a bit unreactive, but there are cases when this is useful.</p><p>Consider the case when you interface to a <span class="strong"><strong>Programmable Logic Controller</strong></span> (<span class="strong"><strong>PLC</strong></span>) to read analogic data. You may want the ability to stop collecting data and the ability to connect our subscribers again to the PLC reactive interface by receiving immediately the last value of all the wanted variables/analogic ports without having to wait until each PLC variable produces a new value to flow to our subscribers.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec20"></a>AsyncSubject</h3></div></div></div><p>
<code class="literal">AsyncSubject</code> is another single message <code class="literal">subject</code>. Although similar to <code class="literal">BehaviorSubject</code>, it routes only the last message it receives, waiting for the <code class="literal">OnComplete</code> message before routing its single <code class="literal">OnNext</code> message:</p><pre class="programlisting">var asyncSubject = new AsyncSubject&lt;string&gt;();
asyncSubject.OnNext("value1"); //this will be missed
asyncSubject.Subscribe(Console.WriteLine);
asyncSubject.OnNext("value2"); //this will be missed
asyncSubject.OnNext("value3"); //this will be routed once OnCompleted raised
Console.ReadLine();
asyncSubject.OnCompleted();
</pre><p>
<code class="literal">AsyncSubject</code> is very useful for cases when we need to work in a message-based way with the need of a message flow logic. The most used case is in combination to other sequences that produce a rolling average or a rolling total from a sequence of values. This subject gives us the ability to catch only the end result from the rolling one.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec21"></a>Custom subjects</h3></div></div></div><p>If out-of-the box subjects cannot satisfy our needs, we can create our custom <code class="literal">subject</code> class by implementing the <code class="literal">ISubject</code> interface. This interface offers the ability to create <code class="literal">subjects</code> with the same type argument in receiving and sending messages, like in all the <code class="literal">subject</code> classes seen in the previous examples. An interesting feature is the ability to create <code class="literal">subjects</code> with different in/out type arguments. Here's an example:</p><pre class="programlisting">public sealed class MapperSubject&lt;Tin, Tout&gt; : ISubject&lt;Tin, Tout&gt;
{
    readonly Func&lt;Tin, Tout&gt; mapper;
    public MapperSubject(Func&lt;Tin, Tout&gt; mapper)
    {
        this.mapper = mapper;
    }

    public void OnCompleted()
    {
        foreach (var o in observers.ToArray())
        {
            o.OnCompleted();
            observers.Remove(o);
        }
    }

    public void OnError(Exception error)
    {
        foreach (var o in observers.ToArray())
        {
            o.OnError(error);
            observers.Remove(o);
        }
    }

    public void OnNext(Tin value)
    {
        Tout newValue = default(Tout);
        try
        {
            //mapping statement
            newValue = mapper(value);
        }
        catch (Exception ex)
        {
            //if mapping crashed
            OnError(ex);
            return;
        }

        //if mapping succeded
        foreach (var o in observers)
            o.OnNext(newValue);
    }

    //all registered observers
    private readonly List&lt;IObserver&lt;Tout&gt;&gt; observers = new
    List&lt;IObserver&lt;Tout&gt;&gt;();
    public IDisposable Subscribe(IObserver&lt;Tout&gt; observer)
    {
        observers.Add(observer);
        return new ObserverHandler&lt;Tout&gt;(observer, OnObserverLifecycleEnd);
    }

    private void OnObserverLifecycleEnd(IObserver&lt;Tout&gt; o)
    {
        o.OnCompleted();
        observers.Remove(o);
    }

    //this class simply informs the subject that a dispose
    //has been invoked against the observer causing its removal
    //from the observer collection of the subject
    private class ObserverHandler&lt;T&gt; : IDisposable
    {
        private IObserver&lt;T&gt; observer;
        Action&lt;IObserver&lt;T&gt;&gt; onObserverLifecycleEnd;
        public ObserverHandler(IObserver&lt;T&gt; observer, Action&lt;IObserver&lt;T&gt;&gt;
        onObserverLifecycleEnd)
        {
            this.observer = observer;
            this.onObserverLifecycleEnd = onObserverLifecycleEnd;
        }

        public void Dispose()
        {
            onObserverLifecycleEnd(observer);
        }
    }
}
</pre><p>Here's the usage:</p><pre class="programlisting">var mapper = new MapperSubject&lt;string, double&gt;(x =&gt; double.Parse(x));
mapper.Subscribe(x =&gt; Console.WriteLine("{0:N4}", x));
mapper.OnNext("4.123");
mapper.OnNext("5.456");
mapper.OnNext("7.90'?");
mapper.OnNext("9.432");
</pre><p>This example shows how to create a mapping subject that translates messages into another type before routing all the data to the waiting observers.</p><p>The <code class="literal">subject</code> class uses an <code class="literal">ObserverHandler</code> class that handles the <code class="literal">observer</code> life cycle by signaling the subject an eventual <code class="literal">observerDispose</code> invoke by removing it from the <code class="literal">observer</code> list.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>Subject from IObservable/IObserver</h3></div></div></div><p>An interesting feature available as the factory method from the <code class="literal">Subject</code> class is the ability to create a new <code class="literal">Subject</code> class using the given <code class="literal">IObservable</code> and <code class="literal">IObserver</code> couple. This gives us the ability to create mixed subjects from the external <code class="literal">observable</code>/<code class="literal">observer</code> objects or by reusing the <code class="literal">IObservable</code> or the <code class="literal">IObserver</code> part of other subject objects into a new <code class="literal">subject</code> class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>Kindly bear in mind that the <code class="literal">IObserver</code> implementation of <code class="literal">subject</code> is simply the message routing to its underlying observers. Here is an example:</p></div><pre class="programlisting">var receiverSubject = new Subject&lt;string&gt;();
//the final observer implementation
receiverSubject.Subscribe(x =&gt; Console.WriteLine("s1=&gt;{0}", x));

//the source of all messages
var senderSubject = new Subject&lt;string&gt;();
//no observers here

//the router made with the Observer part of
//the receiverSubject and the Observable part
//of the senderSubject
var routerSubject = Subject.Create(receiverSubject, senderSubject);
//another observer for testing purposes
routerSubject.Subscribe(x =&gt; Console.WriteLine("s3=&gt;{0}", x));

senderSubject.OnNext("value1");
senderSubject.OnNext("value2");

</pre><p>This example shows us how to use the <code class="literal">Subject.Create</code> factory method.</p><p>When creating a new subject by using <code class="literal">Subject.Create</code>, the first parameter is <code class="literal">IObserver</code> that will receive messages, and the second parameter is the <code class="literal">IObservable</code> that will produce messages.</p><p>Although this example uses two subjects for creating <code class="literal">routerSubject</code> (<code class="literal">receiverSubject</code> and <code class="literal">senderSubject</code>), any <code class="literal">IObservable</code> and any <code class="literal">IObserver</code> are valid in their place.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>All the operators are usually available as extension methods by including the <code class="literal">System.Reactive.Linq</code> namespace in all the <code class="literal">IObservables</code> classes.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Transforming operators</h3></div></div></div><p>Transforming operators transform a message into another type or transform the sequence message order or flow.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec0"></a>Delay</h4></div></div></div><p>A <code class="literal">delay</code> operation adds some time delay to each message flowing within a sequence.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" /><div class="caption"><p>A marble diagram showing a delay operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s3 = new Subject&lt;string&gt;();
var delay = s3.Delay(TimeSpan.FromSeconds(10));
delay.Subscribe(Console.WriteLine);

s3.OnNext("value1");
s3.OnNext("value2");
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec1"></a>Map</h4></div></div></div><p>The <code class="literal">map</code> operator creates a new sequence that will flow messages from the sourcing sequence translated into another type. The translation may change the intrinsic value (as a mathematic operation similar to the example shown in the following screenshot) or may be a type transformation:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_004.jpg" /><div class="caption"><p>A marble diagram showing a map operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s4 = new Subject&lt;string&gt;();
//a numeric sequence
var map = s4.Select(x =&gt; double.Parse(x));
map.Subscribe(x =&gt; Console.WriteLine("{0:N4}", x));
s4.OnNext("10.40");
s4.OnNext("12.55");
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec2"></a>Scan</h4></div></div></div><p>A <code class="literal">scan</code> operation works by applying a transformation to each message within a sequence with the ability to interact with the last transformed value. The following example shows how to create a running total, as the one available within Microsoft Excel, to have a real-time invoice total amount.</p><p>During the first execution, the transformation <code class="literal">Func</code> is not executed.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_005.jpg" /><div class="caption"><p>A marble diagram showing a scan operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var invoiceSummarySubject = new Subject&lt;double&gt;();
var invoiceSummaryScanSubject = invoiceSummarySubject.Scan((last, x) =&gt; x + last);
//register an observer for printing total amount
invoiceSummaryScanSubject.Subscribe(new Action&lt;double&gt;(x =&gt; Console.WriteLine("Total amount: {0:C}", x)));
//register some invoice item total
invoiceSummarySubject.OnNext(1250.50); //add a notebook
invoiceSummarySubject.OnNext(-50.0); //discount
invoiceSummarySubject.OnNext(44.98); //a notebook bag
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip13"></a>Tip</h3><p>
<code class="literal">Scan</code> produces a sequence containing a running total; alternative if the ending total is your only interest, you can use the <code class="literal">Aggregate</code> extension method.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec3"></a>Debounce</h4></div></div></div><p>A <code class="literal">Debounce</code> operator avoids messages from flowing in at a higher rate by setting a time-based throttling between messages. This means that messages cannot flow at a rate higher than the set one. In Rx, the operator name is Throttle, because it slows down the message flow when too many messages flow altogether in a short period.</p><p>Real world uses are the need to slow down useless high rate notifications that have to reach a UX, where anything other than 30 fps is only a resource waste, or when we make an analog-to-digital parsing that we don't want to exceed a parsing rate per second.</p><p>When we use the <code class="literal">Throttle</code> extension method, we must specify the minimum time from the last message so that the new sequence will wait to ensure the last message has flown out.</p><p>The <code class="literal">Debounce</code> operator adds a time delay and regulates the flow of messages when the source observable is still producing a lot of messages:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_006.jpg" /><div class="caption"><p>A marble diagram showing a debounce operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s5 = new Subject&lt;DateTime&gt;();
var throttle = s5.Throttle(TimeSpan.FromMilliseconds(500));
throttle.Subscribe(x =&gt; Console.WriteLine("{0:T}", x));

//produce 100 messages
for (int i = 0; i &lt; 100; i++)
    s5.OnNext(DateTime.Now);
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec4"></a>Amb</h4></div></div></div><p>The <code class="literal">Amb</code> operator will produce a new sequence that will flow messages from the fastest to produce the first message between the sourcing sequences. This means that the first sequence that flows a message into the <code class="literal">Amb</code> operator's sequence will became the only sourcing sequence of the <code class="literal">Amb</code> operator regardless of whether this sequence later completes prematurely while other initial sourcing sequences are still alive. This kind of operator is great when we need the <span class="emphasis"><em>Speculative Execution</em></span> logic with reactive sequences. With this logic design, we can start or simply wait until multiple functions doing the same task with different parameters (think of a web search with the user's raw search criteria, or similar words from an anagram dictionary) execute, usually taking the result only from the fastest to results.</p><p>It is a routing sequence that accepts multiple source sequences (of the same message type), as other routing sequences, the <code class="literal">Amb</code> simply routes messages without applying any transformation. It simply chooses a single sourcing sequence between all those available by selecting the fastest one to produce any message:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_007.jpg" /><div class="caption"><p>A marble diagram showing an amb operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s20 = new Subject&lt;string&gt;();
var s21 = new Subject&lt;string&gt;();
var amb = s20.Amb(s21);
amb.Subscribe(Console.WriteLine);

//the first message will let amb operator
//choose the definite source sequence

s21.OnNext("value1");
//messages from the other sequences are ignored
s20.OnNext("value2");
</pre></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Combining operators</h2></div></div><hr /></div><p>Combining operators combine multiple sequences into a new sequence, eventually with a specific design to reduce message flow.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Combine latest</h3></div></div></div><p>The <code class="literal">CombineLatest</code> operator produces a new sequence that combines multiple sourcing sequences by joining such messages to produce a new composite message. Kindly consider that anytime each of the source enumerable flows a new message, regardless of being the first or the second sequence, a new composite message will flow throughout the combined latest sequence.</p><p>The new sequence will start flowing messages when all the sourcing sequences produce their first message.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_008.jpg" /><div class="caption"><p>A marble diagram showing a combine latest operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s6 = new Subject&lt;string&gt;();
var s7 = new Subject&lt;int&gt;();
var clatest = s6.CombineLatest(s7, (x, y) =&gt; new { text = x, value = y, });
clatest.Subscribe(x =&gt; Console.WriteLine("{0}: {1}", x.text, x.value));

//some message
s6.OnNext("Mr. Brown");
s7.OnNext(10);
s7.OnNext(20);
s6.OnNext("Mr. Green");
s6.OnNext("Mr. White");
s7.OnNext(30);
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Concat</h3></div></div></div><p>The <code class="literal">Concat</code> operator creates a new sequence that contains the concatenation of multiple sourcing sequences, as they are registered as sourcing sequence.</p><p>In other words, as shown in the following screenshot, the <code class="literal">Concat</code> sequence will start flowing messages from the first sourcing sequence and will then start flowing messages from the second sourcing sequence and so on. An important aspect is that this operator will start flowing messages from a new sequence only after the previous sequence completes (by flowing the <code class="literal">OnComplete</code> message) correctly. In other words, this operator sequentially flows messages from multiple sequences. For the parallel version, take a look at the <code class="literal">Merge</code> operator in the following section.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_009.jpg" /><div class="caption"><p>A marble diagram showing a Concat operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s8 = new Subject&lt;string&gt;();
var s9 = new Subject&lt;string&gt;();
var concat = s8.Concat(s9);
concat.Subscribe(Console.WriteLine);

//some message
s8.OnNext("value1");
s8.OnNext("value2");
s9.OnNext("value3"); //missed
s9.OnNext("value4"); //missed
s8.OnNext("value5");
//close first sequence
s8.OnCompleted();
//only now messages from second sequence will start flowing
s9.OnNext("value6");
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>Merge</h3></div></div></div><p>The <code class="literal">Merge</code> operation flattens messages of the same type between multiple sequences into a single output sequence. In other words, it combines values from a multiple sequence in a parallel way.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_010.jpg" /><div class="caption"><p>A marble diagram showing a merge operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s1 = new Subject&lt;string&gt;();
var s2 = new Subject&lt;string&gt;();
var merge = s1.Merge(s2);
merge.Subscribe(Console.WriteLine);

s1.OnNext("value1"); //first subject
s2.OnNext("value2"); //second subject
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Sample</h3></div></div></div><p>A <code class="literal">Sample</code> sequence lets the values flow from another sequence only when a value flows from another sequence that works like a metronome when playing music. The second sequence simply defines the time when a message can flow. The first sequence, however is the source of all the messages that will flow within the sampling. This is something like a polling-based design.</p><p>Consider the case when we read data from a PLC analogic port. The PLC usually works in a reactive way by itself (PLC's SDK may support multiple data paradigm outputs); this means that it flows out new analogic port values only when these change the value changes. Rather, if we need sampling data at a fixed time, as happens in digital audio, we may use the Sample operator by reading raw data from the PLC sourcing sequence, and a clock message from another sequence. With this design, we will be able to sample at a fixed time from a source that flows values as they're available with few efforts in a full reactive design.</p><p>In Rx, the <code class="literal">Sample</code> extension method has two overloads. One overload accepts a  <code class="literal">DateTime</code> parameter useful to sample at a fixed time. Another overload accepts another sequence to sample when sampling messages flow. Although an overload accepting a fixed time parameter is available with the <code class="literal">Scan</code> operator, the canonical one is the overload with two sequence parameter overloads.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_011.jpg" /><div class="caption"><p>A marble diagram showing a sample operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var samplingValueSequence = new Subject&lt;int&gt;();
var samplingTimeSequence = new Subject&lt;object&gt;();
var samplingSequence = samplingValueSequence.Sample(samplingTimeSequence);
//register an observer
samplingSequence.Subscribe(new Action&lt;int&gt;(x =&gt; Console.WriteLine(x)));

//some value
samplingValueSequence.OnNext(10); //ignored
samplingValueSequence.OnNext(20);
//raise a message into the sampling time sequence
samplingTimeSequence.OnNext(null); //last value will be outputted now
samplingValueSequence.OnNext(30); //ignored
samplingValueSequence.OnNext(40);
//raise a message into the sampling time sequence
samplingTimeSequence.OnNext(null); //last value will be outputted now
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>StartWith</h3></div></div></div><p>The <code class="literal">StartWith</code> operator is similar to the <code class="literal">Concat</code> operator because they concatenate values of sequences with the difference that <code class="literal">StartWith</code> inserts a specific value at the beginning of its sourcing sequence. The other difference is that <code class="literal">StartWith</code> does not work on multiple sequences. It simply uses a defined group of values, such as an array or any <code class="literal">IEnumerable</code>.</p><p>
<code class="literal">Startwith</code> is very useful when combined with the <code class="literal">Scan</code> operator because it gives the <code class="literal">Scan</code> operator a value to start the running total (or any other running operation).</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_012.jpg" /><div class="caption"><p>A marble diagram showing a startwith operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s10 = new Subject&lt;string&gt;();
var swith = s10.StartWith("value0");
swith.Subscribe(Console.WriteLine);
s10.OnNext("value1");
s10.OnNext("value2");
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"></a>Zip</h3></div></div></div><p>The <code class="literal">Zip</code> operator is similar to the combine latest operator, producing values from two other sequences only when each source sequence has a new value. The difference is that the combine latest operator produces messages wherever any source sequence produces a new message, eventually reusing the same value from the other sequence. Instead, the <code class="literal">Zip</code> operator synchronizes the two sequences using the message index number as a correlation ID to flow messages always together, eventually waiting for the two sequences to have the new couple of messages to produce the new one.</p><p>As the combine latest operator, the <code class="literal">Zip</code> operator translates the two source messages into a new message by executing a transformation operation.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_013.jpg" /><div class="caption"><p>A marble diagram showing a zip operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s11 = new Subject&lt;string&gt;();
var s12 = new Subject&lt;double&gt;();
var zip = s11.Zip(s12, (x, y) =&gt; new { text = x, value = y });
zip.Subscribe(x =&gt; Console.WriteLine("{0}: {1}", x.text, x.value));
//same example of combine latest
s11.OnNext("Mr. Brown");
s12.OnNext(10);
s12.OnNext(20);
s11.OnNext("Mr. Green");
s11.OnNext("Mr. White");
s12.OnNext(30);
//this time the output is synchronized
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec26"></a>Filtering operators</h2></div></div><hr /></div><p>Filtering operators act as the <code class="literal">where</code> operators of any <code class="literal">LINQ</code> query. They reduce, take, or peek a value (or multiple values) from a sequence when messages comply with a given filtering function.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec30"></a>Filter</h3></div></div></div><p>The easiest filtering operator, filter, simply applies a filtering condition that allows or prevents messages from flowing throughout the newly created sequence. In Rx, the filter operator in made by using the <code class="literal">Where</code> extension method like in any other <code class="literal">LINQ</code> query.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_014.jpg" /><div class="caption"><p>A marble diagram showing a filter operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s12 = new Subject&lt;string&gt;();
var filtered = s12.Where(x =&gt; x.Contains("e"));
filtered.Subscribe(Console.WriteLine);
s12.OnNext("Mr. Brown");
s12.OnNext("Mr. White");
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec31"></a>Distinct</h3></div></div></div><p>The <code class="literal">distinct</code> operator, similar to what happens in any SQL statement, creates a new sequence that prevents duplicated values from flowing out from the source sequence.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_015.jpg" /><div class="caption"><p>A marble diagram showing a distinct operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s13 = new Subject&lt;string&gt;();
var distinct = s13.Distinct();
distinct.Subscribe(Console.WriteLine);
s13.OnNext("value1");
s13.OnNext("value2");
s13.OnNext("value1");
s13.OnNext("value2");
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec32"></a>DistinctUntilChanged</h3></div></div></div><p>Different from the simple distinct operator, the <code class="literal">DistinctUntilChanged</code> operator avoids duplicated values flowing into a new sequence only when those duplicated values are contiguous.</p><p>This is a powerful operator for any raw value sampling, such as when dealing with analog or digital sensors from IoT applications, preventing high rate sampling from creating multiple duplicated values because the sampling rate is higher than the value change rate.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_016.jpg" /><div class="caption"><p>A marble diagram showing a DistinctUntilChanged operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s24 = new Subject&lt;string&gt;();
var distinct = s24.DistinctUntilChanged();
distinct.Subscribe(Console.WriteLine);
s24.OnNext("value1"); //ok
s24.OnNext("value2"); //ok
s24.OnNext("value2"); //ignored
s24.OnNext("value3"); //ok
s24.OnNext("value4"); //ok
s24.OnNext("value1"); //ok
s24.OnNext("value2"); //ok
s24.OnNext("value2"); //ignored
s24.OnNext("value3"); //ok
s24.OnNext("value4"); //ok
</pre><p>Bear in mind that the operator avoids duplicated values when these flow sequentially, otherwise duplicates may exist. Thus, in the preceding example, we saw that we can flow out messages from <code class="literal">1</code> to <code class="literal">4</code> two times. Only the two duplicates are ignored.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec33"></a>ElementAt</h3></div></div></div><p>The <code class="literal">ElementAt</code> operator makes available accessing a new sequence that will flow a single message when its index in the source sequence equals the requested index.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_017.jpg" /><div class="caption"><p>A marble diagram showing a ElementAt operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s13 = new Subject&lt;string&gt;();
var indexed = s13.ElementAt(2);

indexed.Subscribe(Console.WriteLine);
s13.OnNext("value1"); //ignored
s13.OnNext("value2"); //ignored
s13.OnNext("value3"); //OK
s13.OnNext("value4"); //ignored
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec34"></a>Skip</h3></div></div></div><p>The <code class="literal">Skip</code> operator creates a new sequence that will skip some messages from the source sequence before it starts flowing messages.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_018.jpg" /><div class="caption"><p>A marble diagram showing a skip operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s14 = new Subject&lt;string&gt;();
var skip = s14.Skip(2);
skip.Subscribe(Console.WriteLine);
s14.OnNext("value1"); //ignored
s14.OnNext("value2"); //ignored
s14.OnNext("value3"); //ok
s14.OnNext("value4"); //ok
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec35"></a>Take</h3></div></div></div><p>The <code class="literal">Take</code> operator, as the opposite of the skip operator, creates a new sequence that will flow only an initial amount of messages from the source sequence.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_019.jpg" /><div class="caption"><p>A marble diagram showing a take operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s15 = new Subject&lt;string&gt;();
var take = s15.Take(2);
take.Subscribe(Console.WriteLine);
s15.OnNext("value1"); //ok
s15.OnNext("value2"); //ok
s15.OnNext("value3"); //ignored
s15.OnNext("value4"); //ignored
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Mathematical operators</h2></div></div><hr /></div><p>Mathematical operators are all the operators that deal with mathematics aggregations. All such operators work on aggregated values.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec36"></a>Min/Max/Avg/Sum/Count</h3></div></div></div><p>All these operators create a new sequence that will flow a single message containing the minimum, maximum, averaged, sum, or count value ever entered in the operator from the source sequence. The new sequence will flow out its message only when the source sequence is complete.</p><p>Here is an example:</p><pre class="programlisting">var s16 = new Subject&lt;double&gt;();
var min = s16.Min(); //register for finding the min
var max = s16.Max(); //register for finding the max
var avg = s16.Average(); //register for finding the average
var sum = s16.Sum(); //register for finding the count
var count = s16.Count(); //register for finding the sum

min.Subscribe(x =&gt; Console.WriteLine("min: {0}", x));
max.Subscribe(x =&gt; Console.WriteLine("max: {0}", x));
avg.Subscribe(x =&gt; Console.WriteLine("avg: {0}", x));
sum.Subscribe(x =&gt; Console.WriteLine("sum: {0}", x));
count.Subscribe(x =&gt; Console.WriteLine("count: {0}", x));

//some value
var r = new Random(DateTime.Now.GetHashCode());
for (int i = 0; i &lt; 10; i++)
    s16.OnNext(r.NextDouble() * 100d);

//now aggregation operators will flow their message
s16.OnCompleted();
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec28"></a>Logic operators</h2></div></div><hr /></div><p>Logic operators deal with Boolean results, giving the programmer the ability to take decisions on sequence values in a reactive way by producing other sequences. They are the respective of <code class="literal">LINQAny</code>, <code class="literal">All</code>, and similar operators.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec37"></a>Every/Some/Includes</h3></div></div></div><p>All these operators produce a new sequence containing a single message that will contain a result of a Boolean question.</p><p>The <code class="literal">Every</code> operator is the reactive version of the LINQ All operator, returning if all the elements of a sequence comply with a specified statement.</p><p>The <code class="literal">Some</code> operator is the reactive version of the LINQ <code class="literal">Any</code> operator, returning if any element in a sequence complies with a specified statement.</p><p>The <code class="literal">Includes</code> operator is the reactive version of the LINQ <code class="literal">Contains</code> operator, returning if any element in the sequence is the one specified.</p><p>Boolean operators, similar to mathematical ones, need the source sequence complete before flowing their response messages.</p><p>Here's an example:</p><pre class="programlisting">var s17 = new Subject&lt;double&gt;();
var every = s17.All(x =&gt; x &gt; 0);
var some = s17.Any(x =&gt; x % 2 == 0);
var includes = s17.Contains(4d);

every.Subscribe(x =&gt; Console.WriteLine("every: {0}", x));
some.Subscribe(x =&gt; Console.WriteLine("some: {0}", x));
includes.Subscribe(x =&gt; Console.WriteLine("includes: {0}", x));

//some value
var r = new Random(DateTime.Now.GetHashCode());
for (int i = 0; i &lt; 10; i++)
    s17.OnNext(r.NextDouble() * 100d);

//now operators will flow their message
s17.OnCompleted();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec38"></a>SequenceEqual</h3></div></div></div><p>The <code class="literal">SequenceEqual</code> operator, similar to mathematical and Boolean operators, creates a new sequence that will flow a single message containing the result if multiple source sequences have the same message values respecting the original order, eventually ignoring time-based differences. This means that the two sequences are not synchronized in their message flow timings. The only interest is in the message order and values.</p><p>The new sequence will flow its result message only when all the source sequences are complete.</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_020.jpg" /><div class="caption"><p>A marble diagram showing a SequenceEqual operation</p></div></div><p>
</p><p>Here's an example:</p><pre class="programlisting">var s18 = new Subject&lt;int&gt;();
var s19 = new Subject&lt;int&gt;();
var equals = s18.SequenceEqual(s19);
equals.Subscribe(x =&gt; Console.WriteLine("sequenceEqual: {0}", x));
s18.OnNext(10);
s18.OnNext(20);
s19.OnNext(10);
s19.OnNext(20);
s18.OnNext(30);
s19.OnNext(30);

//completes to flow out the sequenceEqual result message
s18.OnCompleted();
s19.OnCompleted();
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>References</h2></div></div><hr /></div><p>Interesting reading on observer patterns can be found at the following link:</p><p>
<a class="ulink" href="http://reactivex.io/" target="_blank">
http://reactivex.io/
</a>.</p><p>An operator list and detailed explanation is provided at the following link:</p><p>
<a class="ulink" href="http://reactivex.io/documentation/operators.html" target="_blank">
http://reactivex.io/documentation/operators.html
</a>.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we took a first look at Reactive Extensions for .NET-based languages.</p><p>We took some steps toward programming with subjects and with the huge operator library available as Extension Methods.</p><p>In the next chapter, we will continue our Rx programming tour by looking at creational factories and other sequence manipulation operators.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch04"></a>Chapter 4. Observable Sequence Programming</h2></div></div></div><p>This chapter will give the reader a specific idea of sequence creation and manipulation. We will see the Reactive Extension framework's abilities to interact with sequences with the huge operator's availability through a lot of extension methods available to any observable sequence.</p><p>During this chapter, we will focus on the following arguments:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Sequence creation basics</p></li><li style="list-style-type: disc"><p>Time-based sequence creation</p></li><li style="list-style-type: disc"><p>Sequence manipulation and filtering</p></li><li style="list-style-type: disc"><p>Sequence partitioning</p></li><li style="list-style-type: disc"><p>Advanced operators</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Sequence creation basics</h2></div></div><hr /></div><p>In the previous chapter, we saw how to create sequences other than simply implementing the <code class="literal">IObservable</code> interface by creating our custom <code class="literal">observables</code> using the <code class="literal">Subject</code> class that gives us an initial implementation which is useful in a lot of cases, thus reducing the bootstrap time when programming in a reactive way.</p><p>We can create a new <code class="literal">observable</code> subject simply with the <code class="literal">new</code> keyword of the C# programming language. The same happens in regard to customized observable sequences (by implementing the <code class="literal">IObservable</code> interface). Other than this, we can create generic observable sequences with the factory methods available within the <code class="literal">observable</code> helper class that give us the ability to create sequences from the scratch without having to create custom classes, or by other values or other CLR objects, such as events and so on. These sequences are only observable sequences; they are not subjects and they are not observers.</p><p>A lot of the following factory methods will simply translate state-based (variables) data into flowing data by returning the same value wrapped into a sequence. Although this may seem like a change of minimal importance, the truth is that by changing the layout of data, we are also changing the kind of application design.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec39"></a>Empty/Never</h3></div></div></div><p>The simplest sequence is the empty sequence. This kind of sequence may be useful to start/end some kind of operations or may be useful to comply with some operator method signs.</p><p>Each of the two operators are available as factory methods from the <code class="literal">Observable</code> helper. Each of these two operators (<code class="literal">Empty</code> and <code class="literal">Never</code>) produces a virtually empty sequence. The difference is that the <code class="literal">Empty</code> factory method produces a sequence without values that inform of its emptiness by flowing a completed message. On the other hand, the <code class="literal">Never</code> method produces a sequence that will either never end (infinite sequence) or never send any message:</p><pre class="programlisting">//an empty sequence ended with a completed message
IObservable&lt;string&gt; s2ended = Observable.Empty&lt;string&gt;();
//an infinite sequence
IObservable&lt;string&gt; s2infinite = Observable.Never&lt;string&gt;();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec40"></a>Return</h3></div></div></div><p>When we need a sequence from an already available value, to bring such a value into the reactive world, we can simply use the <span class="strong"><strong>
<code class="literal">Return</code>
</strong></span> factory method. This factory gives us the ability to go from the state-based application design to the reactive one:</p><pre class="programlisting">//a sequence from a value
IObservable&lt;double&gt; s3 = Observable.Return(40d);
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec41"></a>Throw</h3></div></div></div><p>Identical to the <code class="literal">Return</code> factory, <code class="literal">Throw</code> lets the error message flow to the underlying observers. It produces a new sequence with a single error message that originates from <code class="literal">Exception</code>:</p><pre class="programlisting">//a faulty sequence
IObservable&lt;DateTime&gt; s4 = Observable.Throw&lt;DateTime&gt;(new Exception("Now"));
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec42"></a>Create</h3></div></div></div><p>The <code class="literal">Create</code> factory method is the most complex of the group. It does not simply change the type of the resulting object. It actually is a factory method that returns a factory for creating arbitrary sequences, such as message sources, to interact with observers.</p><p>We are not creating a self-messaging sequence. Instead, we will actually write a code that will produce messages per each observer ever attached to such a sequence. This is extremely different to any other sequence we have already seen (and even others in the next chapters), because all the sequences produce the same message that routes to all the observers, while the sequence born with the <code class="literal">Create</code> factory method produces different messages based on any logic.</p><p>The <code class="literal">Create</code> operator gives us the ability to specify a <code class="literal">Func&lt;IObserver&lt;T&gt;, IDisposable&gt;</code> delegate that will contain the message sourcing logic. This delegated implementation will definitely produce messages (that is, by materializing a database query) that each subscriber will consume, only when the subscription occurs, in a lazy fashion. Bear in mind that each subscription will cause the execution of the delegate that will start flowing messages. The ability to have different implementations per subscriber makes this operator unique. Thus, only with the <code class="literal">Create</code> operator, we have the ability to interact with the observer itself from within the sequence operator chain itself.</p><p>Before trying to understand such sequences in detail, let's take a look at an example:</p><pre class="programlisting">
var s5 = Observable.Create&lt;DateTime&gt;(observer =&gt;
    {
        Console.WriteLine("Registering subscriber {0} of type {1}",
        observer.GetHashCode(), observer);
        //here you can handle by hand your observer interaction logic
        Task.Factory.StartNew(() =&gt;
            {
                //some (time based) message
                for(int i=0;i&lt;10;i++)
                {
                    observer.OnNext(DateTime.Now);
                    Thread.Sleep(1000);
                }
                //end of observer life
                observer.OnCompleted();
            });
        return () =&gt; Console.WriteLine("OnCompleted {0} of type {1}",
        observer.GetHashCode(), observer);
    });

//subscribe an anonymous observer
s5.Subscribe(d =&gt;
    {
        Console.WriteLine("OnNext : {0}", d);
    });
</pre><p>The preceding example creates a sequence that accepts <code class="literal">Action</code> that contains the executing code that represents the observable sequence logic for a given observer. Based on such a logic, different observers may even receive different messages.</p><p>In the example, we created <code class="literal">Task</code> that will produce messages containing current <code class="literal">DateTime</code>. At the end, a completed message reached the observer, killing it.</p><p>Instead of returning a simple <code class="literal">Action</code> method representing the handler of the completed message that will reach the observer, we can produce a <code class="literal">Disposable</code> object that is actually an end-of-life token. Once disposed, such tokens will kill the observer subscription even prematurely. The result is identical to the solution with the <code class="literal">Action</code> already seen in the preceding code.</p><p>It is interesting see the ability to use the <code class="literal">Disposable</code> helper module that gives us the opportunity to have empty disposable objects or disposable objects that execute some specific code once the disposing happens by specifying <code class="literal">Action</code>. The previous example routes the written <code class="literal">Action</code> method into the <code class="literal">Disposable.Create</code> helper method, thus producing the same result of the following code with the difference being that, in the following example, we can stop prematurely the observer's life cycle:</p><pre class="programlisting">
var s5 = Observable.Create&lt;DateTime&gt;(observer =&gt;
    {
        Console.WriteLine("Registering subscriber {0} of type {1}",
        observer.GetHashCode(), observer);
        //here you can handle by hand your observer interaction logic
        Task.Factory.StartNew(() =&gt;
            {
                //some (time based) message
                for (int i = 0; i &lt; 10; i++)
                {
                    observer.OnNext(DateTime.Now);
                    Thread.Sleep(1000);
                }
                //end of observer life
                observer.OnCompleted();
            });
        return Disposable.Create(() =&gt; Console.WriteLine("Disposing..."));
    });

//subscribe an anonymous observer
var disposableObserver = s5.Subscribe(d =&gt;
    {
        Console.WriteLine("OnNext : {0}", d);
    });

//wait some time and press RETURN
//to dispose the observer
Console.ReadLine();

disposableObserver.Dispose();

Console.ReadLine();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec43"></a>Range</h3></div></div></div><p>The <code class="literal">Range</code> factory method creates a sequence that will produce messages from a specific value range using the <code class="literal">Int32</code> message type. This is something like creating a range of values by executing the <code class="literal">Enumerable.Range()</code> method that is later flowed in an observable sequence. Here's an example:</p><pre class="programlisting">
//a ranged sequence
var range = Observable.Range(0, 1000);
//an observer will get values
//anytime it will subscribe
range.Subscribe(value =&gt;
    {
        Console.WriteLine("range -&gt; {0}", value);
    });
</pre><p>The <code class="literal">Range</code> operator creates something like a sourcing message pattern. This means that each subscribing observer will benefit by the same result. In other words, if we specify a range of <code class="literal">1000</code> items, each subscriber will receive <code class="literal">1000</code> messages. This also means that if there are no existing subscribers, nothing will happen and no message will flow to the consuming resources.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec44"></a>Generate</h3></div></div></div><p>The <code class="literal">Generate</code> factory method is some kind of aberration within the reactive world. We should deal with functions; instead, it is a <code class="literal">For</code> statement made reactive.</p><p>In other words, we have an index value (<code class="literal">i=0</code>), an evaluation statement (<code class="literal">i&lt;10</code>), an index iteration addition function, and a body function, exactly the same as any <code class="literal">For</code> statement. Here's an example:</p><pre class="programlisting">
//a reactive For statement
//similar to for(int i=0;i&lt;10;i++)
var generated = Observable.Generate&lt;int, DateTime&gt;(0, i =&gt; i &lt; 10, i =&gt; i + 1, i =&gt; new DateTime(2016, 1, 1).AddDays(i));

generated.Subscribe(value =&gt;
    {
        Console.WriteLine("generated -&gt; {0}", value);
    });
</pre><p>Although it is strange to see an iterative statement in the reactive world, sometimes, it may be useful.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec32"></a>Time-based sequence creation</h2></div></div><hr /></div><p>In the previous sections, we had the opportunity to create simple sequences from known values or by executing some specific code.</p><p>Although these opportunities give us the chance to create useful message sequences, in the real world, reactive programming deals with some kind of time-based messages.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec45"></a>Interval</h3></div></div></div><p>The easiest form of time-based interaction is the polling design. This design, typical of nonreactive programming, happens anytime we ask for a value or a state at a fixed time interval. Similarly, within the reactive programming, we may produce messages at a fixed time interval running in a push design to use the value itself or to trigger other logics available in the following sequence chain.</p><p>The <code class="literal">Interval</code> operator produces a similar design by specifying the wanted time interval, receiving a counter of the current tick as the <code class="literal">Int64</code> value.</p><p>Here's an example:</p><pre class="programlisting">
static void Main(string[] args)
{
    //this sequence produces a message per second
    var sequence = Observable.Interval(TimeSpan.FromSeconds(1));
    sequence.Subscribe(ObserverOnNext);

    Console.ReadLine();
}

private static void ObserverOnNext(long obj)
{
    Console.WriteLine("{0} -&gt; {1}", obj, DateTime.Now);
}
</pre><p>The greatest benefit here is the asynchronous implementation of the sequence that came from the <code class="literal">Observable.Interval</code> helper method at actually no cost for the developer.</p><p>Instead of creating threads or tasks, we simply asked for a sequence to produce messages at a timely basis and that is what we have.</p><p>The sequence always produces the <code class="literal">Int64</code> values starting from zero. This is a message counter. Useful for some hardcoded, antireactive solution/design, the suggestion is to ignore such values.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec46"></a>Timer</h3></div></div></div><p>The <code class="literal">Timer</code> factory method adds another feature to the <code class="literal">Interval</code> one. Like <code class="literal">Interval</code>, <code class="literal">Timer</code> may give us the ability to produce messages at a fixed time interval, but the real use of the <code class="literal">Timer</code> method is the ability to defer the execution at a given time or mix two features together. Here's an example:</p><pre class="programlisting">
//a timer used for defer the message sending
var defer = Observable.Timer(TimeSpan.FromSeconds(5));
defer.Subscribe(value =&gt;
    {
        Console.WriteLine("defer -&gt; {0}", value);
    });

//a polling timer that will produce
//messages at fixed time interval
var loop = Observable.Timer(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(0.5));
loop.Subscribe(value =&gt;
{
    Console.WriteLine("loop -&gt; {0}", value);
});

Console.ReadLine();
</pre><p>Similar to the <code class="literal">Interval</code> factory method, the <code class="literal">Timer</code> produces a sequence to work in an asynchronous way without having the developer doing the hard job of creating threads or tasks.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>Timeout</h3></div></div></div><p>The <code class="literal">Timeout</code> factory method creates a new sequence to throw <code class="literal">TimeoutException</code> if the system time exceeds a specific time (absolute timeout) or if a message flows by a time that exceeds a given time by the previous message (relative timeout).</p><p>This powerful sequence can help in addressing a lot of network-related needs or multiple message correlations based on specific synchronization times.</p><p>Here's a complete example of the two working modes:</p><pre class="programlisting">
class Program
{
    static void Main(string[] args)
    {
        //this sequence must complete by 5 seconds from now
        var absoluteTimeoutSequence = Observable.Interval(TimeSpan.FromSeconds(1))
            .Select(id =&gt; DateTime.UtcNow)
            .Timeout(DateTimeOffset.Now.AddSeconds(5));

        absoluteTimeoutSequence.Subscribe(new ConsoleObserver());

        Console.WriteLine("Press RETURN to start the following example");
        Console.ReadLine();

        //this sequence's messages must flow
        //by 2 seconds
        var relativeTimeoutSequence = Observable.Create&lt;DateTime&gt;(newObserver =&gt;
            {
                Console.WriteLine("Registering observer...");
                Console.WriteLine("Starting message flow...");

                //handle the new subscriber message flow
                Task.Factory.StartNew(() =&gt;
                {
                    //the message flow will slow down until timeout
                    int i = 100;
                    while (true)
                    {
                        newObserver.OnNext(DateTime.UtcNow);
                        //the delay will increase each iteration
                        Thread.Sleep(i += 100);
                    }
                }, TaskCreationOptions.PreferFairness);

                return new Action(() =&gt;
                {
                    Console.WriteLine("Completed");
                });
            })
            .Timeout(TimeSpan.FromSeconds(2));

        relativeTimeoutSequence.Subscribe(new ConsoleObserver());

        Console.ReadLine();
    }
}

public class ConsoleObserver : IObserver&lt;DateTime&gt;
{
    public void OnCompleted()
    {
        Console.WriteLine("Observer completed!");
    }

    public void OnError(Exception error)
    {
        Console.WriteLine("Observer error: {0}", error);
    }

    public void OnNext(DateTime value)
    {
        Console.WriteLine("{0}", value);
    }
}
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>TimeInterval/Timestamp</h3></div></div></div><p>The <code class="literal">TimeInterval</code> factory method is a very useful factory method that creates a sequence to record the time interval that exists between messages flowing from a sourcing sequence. It is absolutely useful for diagnostic purposes.</p><p>Similarly useful is the <code class="literal">Timestamp</code> factory method that creates a sequence that flows out messages with a timestamp (<code class="literal">DateTimeOffset</code>) which is useful for tracing/logging message flows.</p><p>Here's a complete example of a fixed time interval sourcing sequence:</p><pre class="programlisting">
class Program
{
    static void Main(string[] args)
    {
        //a sourcing sequence
        var sourcingSequence =
         Observable.Interval(TimeSpan.FromSeconds(1)).Select(id =&gt;
         DateTime.UtcNow);
         sourcingSequence.Subscribe(value =&gt;
            {
                Console.WriteLine("{0}", value);
            });

        //a sequence recording the time interval of the sourcing sequence
        var diagnosticSequence = sourcingSequence.TimeInterval();
        diagnosticSequence.Subscribe(interval =&gt;
            {
                Debug.WriteLine(string.Format("Message flowing in {0:N0}ms",
                interval.Interval.TotalMilliseconds));
            });

        var diagnosticSequence2 = sourcingSequence.Timestamp();
        diagnosticSequence2.Subscribe(new MessageTimeStampLogger());

        Console.ReadLine();
    }
}

public class MessageTimeStampLogger : IObserver&lt;Timestamped&lt;DateTime&gt;&gt;
{
    public void OnCompleted()
    {
        Console.WriteLine("Observer completed!");
    }

    public void OnError(Exception error)
    {
        Console.WriteLine("Observer error: {0}", error);
    }

    public void OnNext(Timestamped&lt;DateTime&gt; value)
    {
        Debug.WriteLine(string.Format("{0} -&gt; Now flowing: {1}", value.Timestamp, value.Value));
    }
}
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec33"></a>Sequence manipulation and filtering</h2></div></div><hr /></div><p>Manipulation and filtering of sequence messages helps in the development of complex messaging designs. The most immediate and widely used operator is <code class="literal">Where</code>, which creates a routing sequence of messages already filtered based on its filtering predicate. We have already seen some of the manipulating or filtering factory methods in the previous chapter, such as the <code class="literal">Take</code>, <code class="literal">Skip</code>, <code class="literal">Distinct</code>, and <code class="literal">DistinctUntilChanged</code> methods.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec49"></a>Where</h3></div></div></div><p>The <code class="literal">Where</code> factory method creates a new sequence that flows messages from another sequence only when a specific <code class="literal">Where</code> predicate succeeds. Here's an example:</p><pre class="programlisting">
//fixed-time interval sequence
var fixedTimeBasedSequence = Observable.Interval(TimeSpan.FromSeconds(1));

//convert the message
//into time value
var dateTimeSequence = fixedTimeBasedSequence
    .Select(v=&gt; DateTime.UtcNow );

//filtered sequence of times with even second value
var filteredSequence = dateTimeSequence.Where(dt =&gt; dt.Second % 2 == 0);

//outputs the value
filteredSequence.Subscribe(dt =&gt;
    {
        Console.WriteLine("{0:d} {0:T}", dt);
    });

Console.ReadLine();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec50"></a>Join</h3></div></div></div><p>The <code class="literal">Observable.Join</code> factory method (available as the <code class="literal">Extension</code> method) creates a single sequence of messages from multiple sequences. To synchronize messages from the sourcing sequences, we must give such messages time to synchronize to others. This time the window makes it evident as to how much reactive programming is time-based. This is different from state-driven paradigms in which an eventual <code class="literal">Join</code> clause would use a specific value to synchronize to another value, as what happens within the SQL language.</p><p>Before I try to explain further, let's take a look at an example:</p><pre class="programlisting">
//two sourcing sequences of time-based values
var sourceSequence1 = Observable.Interval(TimeSpan.FromSeconds(2)).Select(nr =&gt; DateTime.UtcNow);
var sourceSequence2 = Observable.Interval(TimeSpan.FromSeconds(3)).Select(nr =&gt; DateTime.UtcNow);

//a joined sequence of messages
var joinedSequence = sourceSequence1.Join(sourceSequence2,
    v =&gt; Observable.Return(v).Delay(TimeSpan.FromMilliseconds(100)),
    v =&gt; Observable.Return(v).Delay(TimeSpan.FromMilliseconds(100)),
    (v1, v2) =&gt; new { fromSequence1 = v1, fromSequence2 = v2 });

joinedSequence.Subscribe(x =&gt;
    {
        Console.WriteLine("{0} / {1}", x.fromSequence1, x.fromSequence2);
    });
</pre><p>The preceding example shows the usage of the <code class="literal">Join</code> clause. There are two sourcing sequences of values, one emitting messages <code class="literal">2</code> seconds each and another emitting messages <code class="literal">3</code> seconds each. To make things easier, the two sequences produce the <code class="literal">DateTime</code> values.</p><p>The <code class="literal">Join</code> method needs the sourcing sequences, two time window function generators and a function that creates the new object from the two sourcing ones.</p><p>The most interesting things here are the two time window generator functions. These functions create other sequences of messages with little delay in the message flow. This delay is in the time window that the joined sequence uses to match messages from the two sourcing sequences.</p><p>In the preceding example, we take values from two sourcing sequences. To match values based on the time (messages must arise from the sourcing sequences in the same moment), we need to create something like a time buffer to let messages from the two sequences match the other. To make this happen, we will create (with two identical lambda functions) two new sequences with a time delay from the value of the sourcing sequence. These sequences produce a message that is like a time to leave for the sourcing message itself. In other words, it is a matching timeout of the sourcing messages. When the two sourcing sequences flow messages that overlap the timeout of the message from the other source, the two messages match the Join operator filter and flow out with the resulting sequence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec51"></a>If</h3></div></div></div><p>The <code class="literal">If</code> factory method of the <code class="literal">Observable</code> helper module returns a sequence that chooses which sourcing sequence to return to each subscriber based on a conditional function. This is similar to the usual <code class="literal">If</code> statement of C# with a difference that such reactive versions will execute the conditional function to evaluate which sourcing sequence to return each time a new subscriber asks for registering. Here's a complete example:</p><pre class="programlisting">
//two sourcing sequences of time values

var sourcingSequence1 = Observable.Interval(TimeSpan.FromSeconds(2))
    .Select(id =&gt; DateTime.UtcNow);

var sourcingSequence2 = Observable.Interval(TimeSpan.FromSeconds(3))
    .Select(id =&gt; DateTime.UtcNow);


//a selection function to choose
//which sourcing sequence to use
var mustUseTheFirstSequenceSelector = new Func&lt;bool&gt;(() =&gt;
    {
        var isFirst = DateTime.UtcNow.Second % 2 == 0;
        Console.WriteLine("IsFirst: {0}", isFirst);
        return isFirst;
    });

//a conditional sequence of values from
// the first or the second sourcing sequence
var conditionalSequence = Observable.If(mustUseTheFirstSequenceSelector, sourcingSequence1, sourcingSequence2);

for (int i = 0; i &lt; 3; i++)
{
    Console.WriteLine("Subscribing new observer...");
    conditionalSequence.Subscribe(x =&gt;
        {
            Console.WriteLine("{0}", x);
        });
    Thread.Sleep(1000);
}

Console.ReadLine();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec52"></a>TakeUntil/TakeWhile/SkipUntil/SkipWhile</h3></div></div></div><p>These factory methods are available as the <code class="literal">Extension</code> methods to any observable sequence and manipulate the message's availability as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">TakeUntil</code> operator sources values until a timeout occurs</p></li><li style="list-style-type: disc"><p>The <code class="literal">TakeWhile</code> operator sources values while a condition remains true</p></li><li style="list-style-type: disc"><p>The <code class="literal">SkipUntil</code> operator will avoid flowing messages until a timeout occurs</p></li><li style="list-style-type: disc"><p>The <code class="literal">SkipWhile</code> operator will avoid flowing messages while a condition remains <code class="literal">true</code>
</p></li></ul></div><p>Here's a group example:</p><pre class="programlisting">
//a sourcing sequence
var sourcingSequence = Observable.Interval(TimeSpan.FromSeconds(1)).Select(id =&gt; DateTime.UtcNow);

//will flow messages for next 5 seconds
var takeUntil = sourcingSequence.TakeUntil(DateTimeOffset.Now.AddSeconds(5));
takeUntil.Subscribe(value =&gt;
    {
        Console.WriteLine("Until5Seconds: {0}", value);
    });

var begin=DateTime.UtcNow;
//will flow messages while in the
//same minute of the begin
var takeWhile = sourcingSequence.TakeWhile(x =&gt; begin.Minute == x.Minute);
takeWhile.Subscribe(value =&gt;
    {
        Console.WriteLine("WhileSameMinute: {0}", value);
    });

//skip messages for 5 seconds
var skipUntil = sourcingSequence.SkipUntil(DateTimeOffset.Now.AddSeconds(5));
skipUntil.Subscribe(value =&gt;
    {
        Console.WriteLine("SkipFor5Seconds: {0}", value);
    });

//skip messages of the same minute
var skipWhile = sourcingSequence.SkipWhile(x =&gt; begin.Minute == x.Minute);
skipWhile.Subscribe(value =&gt;
    {
        Console.WriteLine("SkipSameMinute: {0}", value);
    });

Console.ReadLine();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec53"></a>TakeLast/SkipLast</h3></div></div></div><p>These two factory methods give us the ability to create sequences that deal with the last messages of a sourcing sequence. The difference between these two implementations is that, with the <code class="literal">TakeLast</code>, we will obtain a new sequence that will produce only a small numeric amount of messages (given a specific count or time window) just before the sourcing sequence completes its life. On the other hand, <code class="literal">SkipLast</code> will flow all the messages, except the last amount of messages (given a specific count or time window).</p><p>Here's a group example:</p><pre class="programlisting">
Console.WriteLine("Starting: {0}", DateTime.Now);
//a sourcing sequence for a time-window of 5 seconds
var sourcingSequence = Observable.Interval(TimeSpan.FromSeconds(1)).Select(id =&gt; DateTime.UtcNow)
    .TakeUntil(DateTimeOffset.Now.AddSeconds(5));

//skip last messages within a time-window of 3 seconds
var skipLast = sourcingSequence.SkipLast(TimeSpan.FromSeconds(3));
skipLast.Subscribe(value =&gt;
    {
        Console.WriteLine("SkipLast: {0}", value);
    });

//take last messages within a time-window of 3 seconds
var takeLast = sourcingSequence.TakeLast(TimeSpan.FromSeconds(3));
takeLast.Subscribe(value =&gt;
{
    Console.WriteLine("TakeLast: {0}", value);
});

Console.ReadLine();
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec34"></a>Sequence partitioning</h2></div></div><hr /></div><p>Partitioning is the ability to split data into multiple strips.</p><p>When dealing with reactive sequences, partitioning means splitting a sourcing sequence into multiple subsequences. The goal may be to maintain message flow consistency when dealing with multiple parallel sequences. In this case, although we may prefer working with data from all the sourcing sequences in a single sequence chain for simplicity and maintainability, at a time, we will need to split the messages from their original flow by grouping them by one (or more) properties.</p><p>In reactive programming, we never partition for performance needs (such as parallelizing processing) because this is achieved by default using the reactive framework itself if we use the proper overall design (refer to <a class="link" href="#" linkend="ch06">
Chapter 6,</a>
<span class="emphasis"><em>CLR Integration and Scheduling</em></span>, for a more in-depth the argument).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec54"></a>GroupBy</h3></div></div></div><p>The king of the partitioning functions is the <code class="literal">GroupBy</code> one. This is the same within Rx, thus we have the <code class="literal">GroupBy</code> extension method that will produce a grouping observable sequence (<code class="literal">IGroupedObservable&lt;T&gt;</code>) of small sequences to deal with a single group item per time.</p><p>These sequences will flow out the grouping sequence in a lazy way. Once a new message, requiring a new subsequence, flows out the sourcing sequence, the grouping sequence will flow out a new grouping sequence. This is why we need a two-level subscribing method, because at the first level, we register the new subsequence, and at the second one we register the message observer as usual for nongrouped sequences.</p><p>Here's an example:</p><pre class="programlisting">
//a sourcing sequence
var sourcingSequence = Observable.Interval(TimeSpan.FromSeconds(1)).Select(id =&gt; DateTime.UtcNow);

//sequence partitioning by seconds
var partitions = sourcingSequence.GroupBy(x =&gt; Math.Floor(x.Second / 10d));

//register the partition per group key
partitions.Subscribe(partition =&gt;
    {
        Console.WriteLine("Registering observer for: {0}", partition.Key);

        //register the observer per partition
        partition.Subscribe(value =&gt;
            {
                Console.WriteLine("partition {0}: {1}", partition.Key, value);
            });
    });

Console.ReadLine();
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Tip</h3><p>Nested subscriptions, although useful for demonstration purposes, are something we should avoid in the real world because they may cause difficulties in maintainability and debugging, and (most importantly) because they reduce our control on the overall flow because of the nested delegates we need to write to handle nested sequences. Although we will see other nested sequences here, the suggestion when dealing with real-world coding is to write something like the following example of the <code class="literal">GroupBy</code> operator. The only difference is that, to avoid nesting, we need to flatten the multiple stripes into a single sequence of new messages containing the original value and the group key. Although we're still logically grouping, we don't actually need multiple real subsequences:
<code class="literal">//register the partition per group key </code>
<code class="literal">//without nested sequences partitions </code>
<code class="literal">//transform inner groups into new objects </code>
<code class="literal">//containing the key and the value altogether </code>
<code class="literal">.SelectMany(group =&gt; group.Select(x =&gt; new { key = group.Key, value = x })) </code>
<code class="literal">.Subscribe(msg =&gt; Console.WriteLine("partition {0}: {1}", msg.key, msg.value)); </code>
</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec55"></a>Aggregate</h3></div></div></div><p>The <code class="literal">Aggregate</code> factory method creates a new sequence that will interact with each source message, returning a single output message that will produce any operation we want. In the following example, there is an accumulator function that simply adds each message value to the next:</p><pre class="programlisting">
//a sourcing sequence of random doubles
var sourcingSequence = Observable.Create&lt;double&gt;(observer =&gt;
    {
        var r = new Random(DateTime.Now.GetHashCode());

        for (int i = 0; i &lt; 5; i++)
        {
            observer.OnNext((r.NextDouble() - 0.5d) * 10d);
            Thread.Sleep(1000);
        }

        observer.OnCompleted();

        return () =&gt;
        {
            Console.WriteLine("Completed");
        };
    });

//aggregate values to compute a single ending value
var aggregationSequence = sourcingSequence.Aggregate(0d, (rolling, value) =&gt;
{
    Console.WriteLine("Aggregating: {0} + {1}", rolling, value);
    return rolling + value;
});
aggregationSequence.Subscribe(value =&gt; Console.WriteLine("Aggregated value: {0}", value));

Console.ReadLine();
</pre><p>In the <code class="literal">Aggregate</code> factory method, the first parameter is the starting accumulation function value. Then, we simply need to write the accumulation function in the preceding example, which will show the input value on the console for better understanding of the operation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec56"></a>MaxBy/MinBy</h3></div></div></div><p>When dealing with aggregations, there are premade sequences. The <code class="literal">MaxBy</code> and <code class="literal">MinBy</code> factory methods create sequences that group by the sourcing value for the given key and then return only messages where the key is equal to the min or max value found in the sourcing sequence.</p><p>Each of these sequences will produce a single message that contains multiple sourcing messages. The sequence will produce no messages until the sourcing sequence fires its completed message. Here's a group example:</p><pre class="programlisting">
//a sourcing sequence of 2 messages per second
var sourcingSequence = Observable.Interval(TimeSpan.FromSeconds(0.5))
    //a transformation into DateTime
    //skipping milliseconds/nanoseconds
    .Select(id =&gt; new DateTime(DateTime.UtcNow.Year, DateTime.UtcNow.Month, DateTime.UtcNow.Day, DateTime.UtcNow.Hour, DateTime.UtcNow.Minute, DateTime.UtcNow.Second))
    //we take messages only for 5 seconds
    .TakeUntil(DateTimeOffset.Now.AddSeconds(5));

//the maxby sequence
var maxBySequence = sourcingSequence.MaxBy(d =&gt; d.Ticks);
maxBySequence.Subscribe(ordered =&gt;
{
    foreach (var value in ordered)
        Console.WriteLine("MaxBy: {0}", value);
});

//the minby sequence
var minBySequence = sourcingSequence.MinBy(d =&gt; d.Ticks);
minBySequence.Subscribe(ordered =&gt;
{
    foreach (var value in ordered)
        Console.WriteLine("MinBy: {0}", value);
});

Console.ReadLine();
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip15"></a>Tip</h3><p>Usually, primitive types already implement the <code class="literal">IComparable</code> interface. To make our types comparable, we may implement the same interface. To compare types that don't implement the <code class="literal">IComparable</code> interface by themselves, we can create an external comparer by implementing the <code class="literal">IComparer&lt;T&gt;</code> interface. Once we have the comparer, another overload of the <code class="literal">MaxBy</code>/<code class="literal">MinBy</code> operator will accept the value selector and the comparer as the second parameter to let us use the operator with our custom comparer.</p></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>Advanced operators</h2></div></div><hr /></div><p>Sometimes, we need functions to create message repetitions or to manipulate or reuse a subscription with multiple observers. This is the time when advanced operators come into play.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec57"></a>IgnoreElements</h3></div></div></div><p>The <code class="literal">IgnoreElements</code> factory method creates a new sequence that will ignore any value message. Instead, errors and completion messages will normally flow out from the sourcing sequence.</p><p>This method is particularly useful to create multiple acknowledgements or simply to append some completion code to a sourcing sequence. Here's an example:</p><pre class="programlisting">
//the sourcing sequence of errors or completed messages
var sourcingSequence = Observable.Throw&lt;object&gt;(new Exception("Test"));

//a sequence able to handle only errors or completed messages
var ignoredElements = sourcingSequence.IgnoreElements();
ignoredElements.Subscribe(new ConsoleObserver());
</pre><p>The <code class="literal">ConsoleObserver</code> class is the same as that of the previous examples. See the <span class="emphasis"><em>Interval</em></span> or <span class="emphasis"><em>Create</em></span> sections in this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec58"></a>Repeat</h3></div></div></div><p>The <code class="literal">Repeat</code> factory method creates a sequence that will flow out sourcing sequence messages multiple (or infinite) times. Here's an example:</p><pre class="programlisting">
//a sourcing sequence of 5 elements
var sourcingSequence = Observable.Range(1, 5);

//the repeating sequence
var repeatFor2Times = sourcingSequence.Repeat(2);
repeatFor2Times.Subscribe(value =&gt; Console.WriteLine("Value: {0}", value));
</pre><p>Although the <code class="literal">Repeat</code> factory method is pretty simple to use, it is perfect to show the reader a possible unintended behavior. Anytime we subscribe a sequence, most of the premade factory methods restart their implementation. When dealing with simple integers, it is difficult to notice such behavior, but when dealing with the <code class="literal">DateTime</code> values, this is immediate. Here's an example:</p><pre class="programlisting">
//a sourcing sequence of 5 elements
var sourcingSequence = Observable.Range(1, 5)
    //slow down
    .Select(i =&gt; { Thread.Sleep(1000); return i; })
    //take the actual time
    .Select(i =&gt; DateTime.Now);

//the repeating sequence
var repeatFor2Times = sourcingSequence.Repeat(2);
repeatFor2Times.Subscribe(value =&gt; Console.WriteLine("Value: {0}", value));
</pre><p>In this example, we cannot use the <code class="literal">Interval</code> factory method, because this one lacks the completion message that is required for the <code class="literal">Repeat</code> method.</p><p>By using a <code class="literal">DateTime</code> value, you will immediately see that the <code class="literal">Repeat</code> sequence will subscribe two times the sourcing sequence that came from a <code class="literal">Range</code> factory method. This means that the integer values are valued two times in the <code class="literal">Select</code> transformation providing new <code class="literal">DateTime</code> values, instead of repeating the original ones. If this is an unintended behavior, we can use the <code class="literal">Publish</code> factory method just before.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec59"></a>Publish/Connect</h3></div></div></div><p>The <code class="literal">Publish</code> method produces a single subscription sequence available to any other following subscriber. As it has already been said before, any subscription may cause the sourcing sequence to produce different values. Here's an example based on a random value:</p><pre class="programlisting">
var r = new Random(DateTime.Now.GetHashCode());
//a randomic value sequence
var sourcingSequence = Observable.Range(1, 5)
    //slow down
    .Select(i =&gt; { Thread.Sleep(500); return i; })
    //take the actual time
    .Select(i =&gt; r.Next());

//multiple subscriptions causing different
//values being printed onto the console
sourcingSequence.Subscribe(value =&gt; Console.WriteLine("Observer#1: {0}", value));
sourcingSequence.Subscribe(value =&gt; Console.WriteLine("Observer#2: {0}", value));
sourcingSequence.Subscribe(value =&gt; Console.WriteLine("Observer#3: {0}", value));
</pre><p>The preceding example will print to the console as follows:</p><pre class="programlisting">Observer#1: 1387437772
Observer#1: 1673597686
Observer#1: 407780858
Observer#1: 630401573
Observer#1: 336086919
Observer#2: 1071679403
Observer#2: 302043112
Observer#2: 1359704606
Observer#2: 413086291
Observer#2: 1357199039
Observer#3: 1918565397
Observer#3: 1660389991
Observer#3: 1852413164
Observer#3: 1520275706
Observer#3: 1750871851
</pre><p>As we can see, each subscription will start with a new ranged source sequence. Instead, the <code class="literal">Publish</code> method will create a single subscription sequence that will be available to multiple subscribers, routing the messages to all the observers. To start publishing messages, we need to turn on (and eventually off) the flowing by invoking the <code class="literal">Connect</code> method of the publishing sequence. Once we complete our task, we will dispose such connection flags. Here's another example:</p><pre class="programlisting">
//the sourcing sequence
var publishedSequence = Observable.Interval(TimeSpan.FromSeconds(0.5))
    .Select(i =&gt; DateTime.Now)
    .Publish();

//attach subscribers before connecting the publisher
publishedSequence.Subscribe(value =&gt; Console.WriteLine("Observer#1: {0}", value));
publishedSequence.Subscribe(value =&gt; Console.WriteLine("Observer#2: {0}", value));
publishedSequence.Subscribe(value =&gt; Console.WriteLine("Observer#3: {0}", value));

while (true)
{
    Console.WriteLine("Press RETURN to connect the published sequence");
    Console.ReadLine();
    using (var connected = publishedSequence.Connect())
    {
        Console.WriteLine("Press RETURN to quit the connection");
        Console.ReadLine();
    }
    //now we disconnected from the published sequence
}
</pre><p>Now, we have the same value flowing to all the subscribers, thus such subscribers receive their value, value by value, instead of having each subscriber wait for the previous subscriber to read the whole sequence as it happened in the previous example.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec60"></a>RefCount</h3></div></div></div><p>Similar to the <code class="literal">Publish</code>/<code class="literal">Connect</code> operator pattern, <code class="literal">RefCount</code> returns a sequence of the published messages to its subscribers by subscribing only once to the sourcing sequence.</p><p>The difference is that <code class="literal">RefCount</code> automatically connects and disconnects from the published sequence while there is at least one subscriber. Once the last subscriber unsubscribes, the <code class="literal">RefCount</code> operator will automatically disconnect from the sourcing sequence. This is a powerful operator because it avoids the implementation of the <code class="literal">Publish</code>/<code class="literal">Connect</code> pattern by ourselves, and because this implementation avoids the occurrence of a race condition between the <code class="literal">Publish</code> and the <code class="literal">Subscribe</code> operators that in some cases may happen.</p><p>Here's an example:</p><pre class="programlisting">
//the sourcing sequence
var publishedSequence = Observable.Interval(TimeSpan.FromSeconds(0.5))
    .Select(i =&gt; DateTime.Now)
    .Publish()
    .RefCount();

while (true)
{
    Console.WriteLine("Press return to subscribe");
    Console.ReadLine();
    using (var subscription = publishedSequence.Subscribe(value =&gt;
    Console.WriteLine("Observer: {0}", value)))
    {
        Console.WriteLine("Press return to unsubscribe");
        Console.ReadLine();
    }
   //now we disconnected from the published sequence
}
</pre><p>Another significant difference between the <code class="literal">Publish</code>/<code class="literal">Connect</code> pattern and the <code class="literal">RefCount</code> operator is that <code class="literal">RefCount</code> subscribers will start receiving messages as soon as they subscribe, while the <code class="literal">Publish</code>/<code class="literal">Connect</code> subscribers must wait for the <code class="literal">Connect</code> method to start receiving messages.</p><p>However, having a sequence without subscribers often is a performance improvement because the sequence consumes fewer resources.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec61"></a>PublishLast</h3></div></div></div><p>If you want to simply publish the last value instead of the whole sequence, the choice is to use the <code class="literal">PublishLast</code> factory method:</p><pre class="programlisting">
//the sourcing sequence
var publishedSequence = Observable.Interval(TimeSpan.FromSeconds(0.5))
    .Select(i =&gt; DateTime.Now)
    .Take(5)
    .PublishLast();

publishedSequence.Subscribe(value =&gt; Console.WriteLine("Last: {0}", value));
publishedSequence.Connect();
</pre><p>Keep in mind that the difference between such implementations and a classical <code class="literal">Last</code> one is that, with <code class="literal">PublishLast</code>, we make a single subscription to the sourcing sequence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec62"></a>Replay</h3></div></div></div><p>The <code class="literal">Replay</code> factory method creates a single subscription sequence that will buffer messages of the sourcing sequence for the given buffer size. The replayed sequence will be identical to the sourcing sequence for message values and timings. This means that buffered messages will not flow altogether to the first subscriber. Instead, they will flow out as if they were just produced from the sourcing sequence. Here's an example:</p><pre class="programlisting">
//the sourcing sequence will fire
//for 5 seconds
var publishedSequence = Observable.Interval(TimeSpan.FromSeconds(1))
    .Select(i =&gt; DateTime.Now)
    .Take(5)
    .Replay(10);

//we wait for 2 seconds
Thread.Sleep(2000);

//now we connect the subscriber that will
//recover all messages thanks to the replay behaviour
publishedSequence.Subscribe(value =&gt; Console.WriteLine("Value: {0}", value));
publishedSequence.Connect();

Console.ReadLine();
</pre><p>In the preceding example, we are taking only <code class="literal">5</code> messages from the sourcing sequence by setting a replay buffer of <code class="literal">10</code> items, which is obviously to contain the whole sourcing sequence. In real-world applications, this buffer acts as a cache, allowing lazy subscribers to catch all the messages they want to reduce losses.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec63"></a>Multicast</h3></div></div></div><p>The <code class="literal">Multicast</code> factory method is the father of all the previously seen methods that produces a single subscription against the sourcing sequence. All the other methods are built on the <code class="literal">Multicast</code> one, returning <code class="literal">Subject</code> or another to produce the right implementation.</p><p>This explains the internals of all the seen single subscription methods. They use <code class="literal">Subject</code> to read and produce messages from the sourcing sequence to the target subscribers.</p><p>We can use such factory methods to create our own implementations. Here's an example:</p><pre class="programlisting">
//the sourcing sequence
var sourcingSequence = Observable.Interval(TimeSpan.FromSeconds(1))
    .Select(i =&gt; DateTime.Now);

//the subject that will route messages
var multicastingSubject = new Subject&lt;DateTime&gt;();

//the publisher sequence
var multicastSequence = sourcingSequence.Multicast(multicastingSubject);

//subscribers
multicastSequence.Subscribe(value =&gt; Console.WriteLine("Observer#1: {0}", value));
multicastSequence.Subscribe(value =&gt; Console.WriteLine("Observer#2: {0}", value));

//connect the publisher sequence
multicastSequence.Connect();

Console.ReadLine();
</pre><p>This example shows an implementation similar to the classic <code class="literal">Publish</code> factory method. The difference here is that this implementation gives the developer the chance of using a personally extended version of the subject, creating new publishing sequence implementations.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec36"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we had the opportunity to deal with sequence creation and manipulation. The knowledge of a wide amount of factory methods gives the reactive programming developer the ability to write reactive functions that can deal with all the real-world demands. Together, this knowledge is mandatory before reading the next chapters that will bring the reader into deeper Rx and reactive programming understanding.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch05"></a>Chapter 5.     Debugging Reactive Extensions    </h2></div></div></div><p>Debugging Reactive Extensions (Rx) for .NET means something more than simply using the visual studio debugger. This chapter focuses on how to trace the executing operations against all the sequences that behave within our application and how to use diagnostic-oriented sequences that strongly improve developer debugging times. Here's a short list of arguments we're going to cover in this chapter:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Tracing sequences</p></li><li style="list-style-type: disc"><p>Inspecting sequences</p></li><li style="list-style-type: disc"><p>Exception handling</p></li><li style="list-style-type: disc"><p>Playing with sequences</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Tracing sequences</h2></div></div><hr /></div><p>The most widely used diagnostic solution is application tracing; in a few words, it is the art of logging the application execution flow with emphasis on the event type and its description.</p><p>This is the same in reactive programming, thus, we have the ability to use specific sequences that mark messages with additional metadata or log out messages to analyze (or dump for further usages) the sequence flow in addition to the usual tracing tools available within the .NET world.</p><p>More than a simple reactive way of tracing, we can design specific diagnostic sequence flows with related filtering or manipulation, and the ability to use any other reactive operator to help us isolate interesting diagnostic information.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec64"></a>Materialize</h3></div></div></div><p>The <code class="literal">Materialize</code> extension method produces a new sequence for diagnostic purposes that flows messages containing additional metadata information about the messages flowing in the sourcing sequence.</p><p>The great advantage of materializing a sequence is the ability to know the message's type (<code class="literal">OnNext</code>, <code class="literal">OnComplete</code>, or <code class="literal">OnError</code>), inspecting its sourcing data or exceptions without having to fit within the original sequence chain. This is  actually, a powerful feature. However, this has a cost in resource needs. This is why we cannot materialize every sequence just to have access to related metadata until we definitely need it.</p><p>In other words, <code class="literal">Materialize</code> is something similar to what <code class="literal">Reflection</code> is for normal types, giving us the ability to write a code to read the object's property by simply looping across all those available because we don't need to write code in a static way. In fact, with reflection, there is huge additional resource cost, and with reflection, we definitely need it often.</p><p>You have just another use case to look at before you dive into code: think about the ability to handle any reactive message at a single point by simply analyzing the message metadata and routing to the required concrete handler. Keep the resource usage in mind before you think that this is a great feature at all; although in some cases, this may be definitely a great feature.</p><p>The usage is definitely simple. Here's an example:</p><pre class="programlisting">
//a simple sequence of DateTime 
var sequence1 = new Subject&lt;DateTime&gt;(); 
 
//a console observer 
sequence1.Subscribe(x =&gt; Console.WriteLine("{0}", x)); 
 
//a tracing sequence 
//of materialized notifications 
IObservable&lt;Notification&lt;DateTime&gt;&gt; tracingSequence = sequence1.Materialize(); 
tracingSequence.Subscribe(notification =&gt; 
{ 
    //this represents the operation 
    Console.WriteLine("Operation: {0}", notification.Kind); 
 
    //has a value 
    if (notification.HasValue) 
        Console.WriteLine("Value: {0}", notification.Value); 
 
    //has an exception 
    else if (notification.Exception != null) 
        Console.WriteLine("Exception: {0}", notification.Exception); 
}); 
 
//flows a new value 
sequence1.OnNext(DateTime.Now); 
 
//flows the oncomplete message 
sequence1.OnCompleted(); 
 
Console.ReadLine(); 
</pre><p>The preceding example shows the basic usage of the <code class="literal">Materialize</code> operator. This gives us a new sequence of the <code class="literal">Notification&lt;T&gt;</code> messages, where <code class="literal">T</code> is the original message type. These messages will contain full information/metadata about the flowing message. The <code class="literal">Notification&lt;T&gt;</code> method contains everything we need to trace out our messages or dump message data by reading its <code class="literal">Kind</code>, <code class="literal">Value</code>, or <code class="literal">Exception</code> properties as visible in the preceding example.</p><p>Regarding performance, the suggestion is to avoid the massive usage of materialized sequences because these are very expensive considering the overall resource usage.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Tip</h3><p>By using the <code class="literal">Sample</code> or the <code class="literal">Throttle</code> operator together with the <code class="literal">Materialize</code> operator, we can trace messages at a slower rate. This may be an interesting compromise when we want to trace without destroying the overall performance of our application. Their description is available in the <span class="emphasis"><em>Transforming operators</em></span> or <span class="emphasis"><em>Combining operators</em></span> sections of <a class="link" href="#" linkend="ch03">
Chapter 3</a>, <span class="emphasis"><em>Reactive Extension Programming</em></span>
.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec65"></a>Dematerialize</h3></div></div></div><p>Once we have a materialized sequence of the <code class="literal">Notification&lt;T&gt;</code> messages, if we need to produce a value sequence, we can use the <code class="literal">Dematerialize</code> extension method.</p><p>Obviously, recreating the original value sequence from a materialized sequence is odd, but it is sometimes necessary. Here's an example:</p><pre class="programlisting">//a dematerialized sequence 
var valueSequence = tracingSequence.Dematerialize(); 
//a console observer 
valueSequence.Subscribe(x =&gt; Console.WriteLine("D: {0}", x)); 
</pre><p>Regarding performance, the usage of the <code class="literal">Materialize</code>/<code class="literal">Dematerialize</code> sequences produces some visible overheads. Other than when debugging, the suggestion is to avoid the usage of similar sequences.</p><p>A similar feature is available when debugging with Visual Studio under the name <code class="literal">IntelliTrace</code>. With this feature, Visual Studio logs all that is happening in our executing code with the ability to replay specific code portions or verify already handled exceptions that don't bubble up in the debugger. The same feature is obviously available when programming with Rx, but <code class="literal">Materialize</code>/<code class="literal">Dematerialize</code> gives a coarse-grained ability to reproduce the message flow of a production environment without the cost of having a debugger online, as <code class="literal">IntelliTrace</code> needs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec66"></a>TimeInterval</h3></div></div></div><p>Although we have already seen this sequence in <a class="link" href="#" linkend="ch04">
Chapter 4</a>, <span class="emphasis"><em>Observable Sequence Programming</em></span>
, kindly consider that its usage in debugging is visibly useful. Here's a short example.</p><p>Let's assume that we're writing an application that reads data from an IO port as a serial or TCP port. We want the messages to always come on time. In other words, we cannot accept delays of more than a specific duration because we're writing a real-time application.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Tip</h3><p>Bear in mind that a real-time application must have a deterministic execution time in addition to fast/immediate reactions to events/input.</p></div><p>We can use the <code class="literal">TimeInterval</code> operator to skip messages that are outside our timing policy and produce a log of these messages for further analysis or simply as a waste sequence.</p><p>Here's an example:</p><pre class="programlisting">
var r = new Random(DateTime.Now.GetHashCode());
 
//an infinite message source 
var source = Observable.Interval(TimeSpan.FromSeconds(1)) 
    .Select(i =&gt; 
    { 
        //let's add some random delay 
        Thread.Sleep(r.Next(100, 1000)); 
 
        return DateTime.Now; 
    }); 
 
//the timing tracing sequence 
var timingsTracingSequence = source.TimeInterval(); 
 
//valid messages 
var validMessagesSequence = timingsTracingSequence.Where(x =&gt; x.Interval.TotalMilliseconds &lt;= 1200); 
//var exceeding messages 
var exceedingMessagesSequence = timingsTracingSequence.Where(x =&gt; x.Interval.TotalMilliseconds &gt; 1200); 
 
//some console output 
validMessagesSequence.Subscribe(x =&gt; Console.WriteLine(x.Value)); 
exceedingMessagesSequence.Subscribe(x =&gt; Console.WriteLine("Exceeding timing limits for: {0} ({1:N0}ms)", x.Value, x.Interval.TotalMilliseconds)); 
 
Console.ReadLine(); 
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec67"></a>Do</h3></div></div></div><p>The <code class="literal">Do</code> extension method is very similar to the <code class="literal">Materialize</code> one with a single great difference. The <code class="literal">Materialize</code> method produces a new sequence of <code class="literal">Notification&lt;T&gt;</code> that will add message-related metadata information to each sourcing message, while the <code class="literal">Do</code> method will return the same sourcing sequence, registering and passing each message of each type to the proper C# handler (<code class="literal">Action</code> or <code class="literal">Action&lt;Exception&gt;</code>).</p><p>In other words, the <code class="literal">Do</code> method gives us the ability to specify an external message handler in a way similar to CLR event handling with the usage of delegates (<code class="literal">Action</code>, <code class="literal">Action&lt;Exception&gt;</code>).</p><p>Although this option may seem more comfortable to any experienced state-driven programmer, here, in any reactive programming project, it may bring more issues than it resolves. This is because of the different programming approach that is very useful for diagnostics needs and contemporarily very dangerous in production time execution because it may lead the developer into an undesired <code class="literal">Action at a distance</code> anti-pattern.</p><p>Here's a complete example:</p><pre class="programlisting">
static void Main(string[] args)
{ 
    var source = Observable.Interval(TimeSpan.FromSeconds(1)) 
        .Select(x =&gt; DateTime.Now) 
        .Take(5) 
        .Select(x =&gt; 
        { 
            if (x.Second % 10 == 0) 
                throw new ArgumentException(); 
 
            return x; 
        }) 
        .Do(OnNext, OnError, OnCompleted) 
                 
        .Catch(Observable.Empty&lt;DateTime&gt;()); 
 
    //starts the source 
    source.Subscribe(); 
 
    Console.ReadLine(); 
} 
 
private static void OnError(Exception ex) 
{ 
    Console.WriteLine("-&gt; {0}", ex.Message); 
} 
 
private static void OnCompleted() 
{ 
    Console.WriteLine("-&gt; END"); 
} 
 
private static void OnNext(DateTime obj) 
{ 
    Console.WriteLine("-&gt; {0}", obj); 
} 
</pre><p>The example is very simple: we have a sourcing sequence of no more than <code class="literal">5</code> messages. In addition, we will raise an error when the timestamp's seconds are divisible by <code class="literal">10</code>.</p><p>The <code class="literal">Do</code> method expects up to three handlers for the three message types.</p><p>Kindly consider, anything that executes within the handlers, actually executes within the sequence change pipeline in a synchronous way.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip18"></a>Tip</h3><p>A side effect happens anytime we produce an action at a distance by editing some state or by executing some logic outside our function. In a reactive world, our function is our sequence chain. We can do anything we want within our chain, but when we interact outside the chain within a single chain node or message transformation/filtering node, we are causing a side effect.</p></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Inspecting sequences</h2></div></div><hr /></div><p>After tracing what flows within a sequence, the second most useful diagnostic feature is to verify the sequence content against a predicted content or a static content (usually for testing purposes with mocking objects) simply because we need to check the message homogeneity. Luckily, there are different operators that help us achieve this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec68"></a>Contains</h3></div></div></div><p>This is maybe the easiest case to deal with when we need to check if/when a sequence contains a given value.</p><p>In reactive, we always deal with sequences; this is true also when we want to aspect a Boolean value, as in this case, if we were programming in a nonreactive way. The <code class="literal">Contains</code> extension method produces a new sequence that will fire a single message with a value informing us if we found what we're searching for immediately after the sourcing sequence is complete. This is easily visible by instrumenting Rx materializing our <code class="literal">Contains</code> sequence. Here's an example:</p><pre class="programlisting">
var r = new Random(DateTime.Now.GetHashCode());
 
//an infinite message source of integer numbers 
//running at 10hz 
var source = Observable.Interval(TimeSpan.FromMilliseconds(100)) 
    .Select(x =&gt; r.Next(1, 20)); 
 
var contains = source.Contains(10) 
    //we want message metadata              
    .Materialize(); 
 
//some console output 
source.Subscribe(x =&gt; Console.WriteLine(x)); 
contains.Subscribe(x =&gt; Console.WriteLine("FOUND: {0}", x)); 
 
Console.ReadLine(); 
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec69"></a>Any</h3></div></div></div><p>Almost identical to the <code class="literal">Contains</code> extensions method, <code class="literal">Any</code> produces a sequence that flows messages about its search results. The difference is the overload; it needs a <code class="literal">Func&lt;T,bool&gt;</code>. Instead, the <code class="literal">Contains</code> method needs a raw value.</p><p>Here is a short example:</p><pre class="programlisting">var any = source.Any(x =&gt; x == 10) 
    //we want message metadata              
    .Materialize(); 
any.Subscribe(x =&gt; Console.WriteLine("FOUND ANY: {0}", x)); 
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec70"></a>All</h3></div></div></div><p>Similar to the <code class="literal">Any</code> method, the <code class="literal">All</code> extension method produces a sequence flowing the result of our search. The difference is that the <code class="literal">All</code> method fires only when all the sourcing messages succeed in passing the predicate expression, waiting for the completion of the sourcing sequence before sourcing its result message. Instead, if any message fails the validating expression, the <code class="literal">All</code> sequence immediately flows out the failure result.</p><p>Here's an example:</p><pre class="programlisting">
var r = new Random(DateTime.Now.GetHashCode());
 
var stopperSequence = new Subject&lt;bool&gt;(); 
 
//an infinite message source of integer numbers 
//running at 10hz 
var source = Observable.Interval(TimeSpan.FromMilliseconds(100)) 
    .Select(x =&gt; r.Next(1, 20)) 
    //take only until we press RETURN 
    .TakeUntil(stopperSequence); 
 
source.Subscribe(x =&gt; Console.WriteLine(x)); 
 
var all = source.All(x =&gt; x &lt; 18) 
    //we want message metadata              
    .Materialize(); 
 
all.Subscribe(x =&gt; Console.WriteLine("FOUND ALL: {0}", x)); 
 
//wait until user press RETURN 
Console.ReadLine(); 
//notify the stop message 
stopperSequence.OnNext(true); 
//wait again to see the result 
Console.ReadLine(); 
</pre><p>The preceding example is similar to the <code class="literal">Any</code> method and the <code class="literal">Contains</code> method. But this one needs a more detailed explanation.</p><p>First of all, we're using another sequence (<code class="literal">stopperSequence</code>) to signal the other sequence (<code class="literal">source</code>) when to stop flowing messages.</p><p>This is accomplished by using the <code class="literal">TakeUntil</code> method on the <code class="literal">source</code> sequence that returns a new sequence to flow messages until a message flows from the parameter sequence (<code class="literal">stopperSequence</code>).</p><p>Take a look at the result; it takes only a few seconds. When we press the <span class="strong"><strong>Enter</strong></span> key, the <code class="literal">All</code> sequence intercepts the <code class="literal">OnCompleted</code> message and executes its logic returning result as to whether all the messages are complying with the lambda expression.</p><p>In other words, to ensure the <code class="literal">True</code> result, the <code class="literal">All</code> sequence waits for the sourcing sequence's <code class="literal">OnCompleted</code> message, while any failing message immediately produces a <code class="literal">False</code> result.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec71"></a>SequenceEqual</h3></div></div></div><p>The <code class="literal">SequenceEqual</code> extension method produces a sequence almost identical to the one from the <code class="literal">All</code> method. The difference is that the <code class="literal">All</code> method checks whether all the messages of a single sourcing sequence comply with a specified predicate, while <code class="literal">SequenceEqual</code> produces a sequence that returns if two sourcing sequences are identical in their content.</p><p>Similar to the <code class="literal">All</code> sequence, <code class="literal">SequenceEqual</code> immediately outputs a failing result while waiting for the completion of all sourcing sequences leads to a succeeding result.</p><p>Here's an example:</p><pre class="programlisting">
//two random generators
//without the random initial seed 
var r1 = new Random(); 
var r2 = new Random(); 
 
//two infinite message source of integer numbers running at 1hz 
var source1 = Observable.Interval(TimeSpan.FromMilliseconds(1000)) 
    .Select(x =&gt; r1.Next(1, 20)); 
 
var source2 = Observable.Interval(TimeSpan.FromMilliseconds(1000)) 
    .Select(x =&gt; r2.Next(1, 20)); 
 
var identical = source1.SequenceEqual(source2) 
    .Materialize(); 
 
source1.Subscribe(x =&gt; Console.WriteLine("1: {0}", x)); 
source2.Subscribe(x =&gt; Console.WriteLine("2: {0}", x)); 
identical.Subscribe(x =&gt; Console.WriteLine("Equals: {0}", x)); 
 
Console.ReadLine(); 
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec39"></a>Exception handling</h2></div></div><hr /></div><p>Handling exceptions in reactive programming with Rx is something odd. We're used to handling exceptions by writing code that executes when some other code hangs. More precisely, we write multiple execution flows that execute when the application runs properly or badly. The real meaning of exception handling means handling an exception in the usual way of doing something. Exception handling is not error handling.</p><p>Although, this being a philosophical definition, we're used to using exception handling to handle unpredictable behaviors.</p><p>In Rx, exception handling is identical with the difference that here we don't deal with code rows that execute one by one; we actually deal with the sequences of messages that must continue flowing regardless of whether an exception may invalidate one or multiple messages. In smarter words, the show must go on. Obviously, a single exception must prevent the whole sequence from running anymore.</p><p>In other (simpler) words, when we want to handle an exception message, we will define the new sequence that will flow messages in place of the initial source sequence.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec72"></a>Catch</h3></div></div></div><p>
<code class="literal">Catch</code> is the main extension method that gives us the ability to handle exceptions in Rx sequences. It simply starts flowing messages from a second source sequence when the first hangs. Kindly consider that in state-driven programming, catching an exception means executing some other code from the one in the <code class="literal">Try</code> clause, while in reactive programming, catching an exception means flowing from another sequence. We can choose to source from a fruitful sequence or an empty one to cause the sequence's premature ending.</p><p>Here's a complete example:</p><pre class="programlisting">
var r = new Random(DateTime.Now.GetHashCode());
 
//an infinite message source of integer numbers running at 10hz 
var source1 = Observable.Interval(TimeSpan.FromMilliseconds(100)) 
    .Select(x =&gt; r.Next(1, 20)) 
    //raise an exception on high values 
    .Select(x =&gt; 
    { 
        if (x &gt;= 19) 
            throw new ArgumentException("Value too high"); 
        else 
            return x; 
    }) 
    //a single shared subscription available to all following subscribers 
    .Publish(); 
 
//enable the connectable sequence 
source1.Connect(); 
 
//an infinite message source of integer numbers running at 1hz 
var source2 = Observable.Interval(TimeSpan.FromMilliseconds(1000)) 
    .Select(x =&gt; r.Next(20, 40)); 
 
//a new sequence that continues with source2 when source1 raise an error 
var output = source1.Catch(source2) 
    //we want message metadata for out testing purpose 
    .Materialize(); 
 
//output all values 
output.Subscribe(x =&gt; Console.WriteLine(x)); 
//output when source1 raise the error 
source1.Materialize() 
    .Where(x =&gt; x.Kind == NotificationKind.OnError) 
    .Subscribe(x =&gt; Console.WriteLine("Error: {0}", x.Exception)); 
 
Console.ReadLine(); 
</pre><p>The preceding example shows the usage of the <code class="literal">Catch</code> extension method; we use it to source from <code class="literal">source2</code> when <code class="literal">source1</code> faults. Because of testing needs, we have to use the <code class="literal">Publish</code>/<code class="literal">Connect</code> pattern to share a single subscription with the <code class="literal">source1</code> sequence from the <code class="literal">Catch</code> operator and from the <code class="literal">Materialize</code> one we use to see when the exception occurs.</p><p>An interesting aspect is the availability of another overload that allows the <code class="literal">Catch</code> method to accept a specific exception type to handle:</p><pre class="programlisting">//specific exception handling 
var output2 = source1.Catch&lt;int, ArgumentException&gt;(exType =&gt; source2); 
</pre><p>As mentioned if we want a premature sequence end, we can simply specify an empty continuing sequence as the parameter for the <code class="literal">Catch</code> operator:</p><pre class="programlisting">//handle excetion and stop flowing messages 
var output3 = source1.Catch(Observable.Empty&lt;int&gt;()); 
</pre><p>Real-world experience says that we have to carefully use this method because it may bring your application into unintentional exception hiding logics. This may make your application difficult to debug or in an inconsistent state, as happens in the case where we hide the exception without logging the event.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec73"></a>OnErrorResumeNext</h3></div></div></div><p>Similar to the <code class="literal">Catch</code> method, there is the <code class="literal">OnErrorResumeNext</code> method. Although many experienced developers may remember this name that was a specific error handling logic in the old <code class="literal">VisualBasic</code> languages (prior to .NET), the old one from VB was instead identical to the reactive <code class="literal">Catch</code> implementation. The <code class="literal">OnErrorResumeNext</code> method produces a sequence concatenation regardless of whether the first sequence experiences some errors or not. The only exception handling here is that if the first sequence hangs, the second sequence immediately starts flowing messages. However, the <code class="literal">Catch</code> method does not concatenate sourcing sequences. It simply starts flowing messages from another sequence if the first hangs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec74"></a>Finally</h3></div></div></div><p>The <code class="literal">Finally</code> method gives us the ability to execute some code when a sequence completes regardless of whether it completes with an <code class="literal">OnComplete</code> message or with an <code class="literal">OnError</code> message. Here's a complete example:</p><pre class="programlisting">
var source = Observable.Interval(TimeSpan.FromSeconds(1)) 
    //stops after 5 seconds 
    .TakeUntil(Observable.Return(0).Delay(TimeSpan.FromSeconds(5))); 
 
source.Subscribe(x =&gt; Console.WriteLine(x)); 
 
//log the completion of the source 
source.Finally(() =&gt; Console.WriteLine("END")) 
    //force the Finally sequence to  
    //start working by registering 
    //an empty subscriber 
    .Subscribe(); 
 
Console.ReadLine(); 
</pre><p>In the preceding example, we can see the <code class="literal">Finally</code> method in action. The example is extremely useful because it shows a more reactive-styled programming.</p><p>First, we will create a sourcing sequence that must flow messages only for <code class="literal">5</code> seconds. To specify the timeout, we will use another sequence as the parameter that will fire its only message to stop the main sourcing sequence from flowing. Then, by using the <code class="literal">Finally</code> operator, we will specify <code class="literal">Action</code> that will fire when the sourcing sequence completes.</p><p>An interesting aspect of this example is that to force the <code class="literal">Finally</code> sequence to start its job we need to attach a subscriber. To accomplish this, we can simply use the <code class="literal">Subscribe</code> method without passing any concrete subscriber. This happens because the result sequence from the <code class="literal">Finally</code> operator runs in a lazy fashion, waiting for a subscription to exist before doing its job.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"></a>Tip</h3><p>A sequence that starts producing messages only when a subscription exists is a <code class="literal">Cold</code> sequence. These are lazy execution sequences. On the other hand, a sequence that produces messages regardless of whether a subscriber exists or not is a <code class="literal">Hot</code> sequence. Although the practical difference when using the two sequence types from other sequences or operators is slightly visible, because all the sequences produce messages once subscribed, the difference when no subscription exists is evident. Another great difference is that, often, the <code class="literal">Cold</code> sequences produce the same message flow for all their subscribers regardless of how many times we subscribe to the sourcing sequence, while <code class="literal">Hot</code> observers usually have their own message flow that will continue flowing regardless of whether a subscription exists or not. This means that a message repetition may never occur, but in case we need it, it is possible with external operators.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec75"></a>Retry</h3></div></div></div><p>Another widely used approach when experiencing unwanted behaviors from external systems or unpredictable functions is the ability to repeat our logic until we get our desired result.</p><p>This choice has its pros, such as the ability to avoid unintentional network errors or system low availability. However, the choice has its cons, such as the ability to reduce system response time, increase overall resource usage, and (the terrifying one) the possibility to duplicate data or create inconsistent data stores if we don't properly manage all repeating logics.</p><p>The most critical time in a retry logic is when an attempt fails, in other words, when we eventually need to rollback the partially saved data, the partially executed logics, or the partially sent commands (to external systems).</p><p>This doesn't mean that the retry logic is wrong in itself. It simply focuses a lot on its usage because it may bring the invisible issues. Here's a complete example (it is better to execute this example without the debugger by pressing <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>F5</strong></span>
</em></span>):</p><pre class="programlisting">
//a finite sequence of 5 values
var source = Observable.Interval(TimeSpan.FromSeconds(1)) 
    .Take(5) 
    .Select(x =&gt; DateTime.Now) 
    .Select(x =&gt; 
    { 
        //lets raise some error 
        if (x.Second % 10 == 0) 
            throw new ArgumentException("Wrong milliseconds value"); 
        else 
            return x; 
    }) 
    //restart he sourcing sequence on error (max 2 times) 
    .Retry(2) 
    //materialize to read message metadata 
    .Materialize(); 
 
source.Subscribe(x =&gt; Console.WriteLine(x)); 
Console.ReadLine(); 
</pre><p>The preceding example shows a usage of the <code class="literal">Reply</code> sequence available through the <code class="literal">Reply</code> extension method.</p><p>The execution shows that we have to produce <code class="literal">5</code> messages. If any message has a timestamp with seconds divisible by <code class="literal">10</code> an exception raises. When an exception reaches the <code class="literal">Retry</code> sequence, this simply closes the subscription and starts another subscription, restarting the counter of <code class="literal">5</code> messages.</p><p>At the end of the sequence construction, although we materialize the <code class="literal">Reply</code> sequence, we will never see the error message. We will simply receive the concatenation of all the messages before and after the error. Obviously, this may bring an unintentional hidden exception that may make it tricky to find unwanted behaviors.</p><p>The solution lies in the usage of the <code class="literal">Materialize</code> operator together with a filter that will let us trace only unwanted exceptions when we're running our application in the production stage. This choice will give us the ability to know when an exception occurred with a light additional resource usage. Differently, once we're trying to investigate an exception we already know, we may edit the filter to trace multiple information other than exceptions to help us find the root cause of the investigating exception.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec40"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we had the opportunity of looking at reactive programming in action with real-world needs: diagnostics and exception handling.</p><p>Debugging a reactive application in production is something very different from debugging a typical state-driven application because we deal with sequence chains that are usually very long and articulated. The same applies in the case of exception handling; whereas in reactive, the approach changes totally.</p><p>In the next chapter, we will go deeper into Rx programming with advanced features and techniques, such as time scheduling and CLR integration.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch06"></a>Chapter 6. CLR Integration and Scheduling</h2></div></div></div><p>This chapter will cover two very important aspects of reactive programming: the ability to configure how time changes within the sequences and their workers (observers/observables) and the ability to interact with all the other elements of the classic CLR, such as events, threads, tasks, and so on. Here's a short index:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Sourcing from CLR events</p></li><li style="list-style-type: disc"><p>Threading integration</p></li><li style="list-style-type: disc"><p>Asynchronous sourcing</p></li><li style="list-style-type: disc"><p>Time scheduling</p></li><li style="list-style-type: disc"><p>Advanced time scheduling</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Sourcing from CLR events</h2></div></div><hr /></div><p>An event is the occurrence of something we can handle somehow with our code. More precisely, in .NET, an event is a kind of <code class="literal">Delegate</code> object, an object that represents one or multiple actions to run. The <code class="literal">Delegate</code> object is the .NET implementation of the <code class="literal">Observer</code> pattern with the addition of other features, such as asynchronous execution.</p><p>By convention, any event in .NET uses the <code class="literal">Delegate</code> implementation specific to <code class="literal">System.EventHandler</code> or any other childhood according to the inheritance <code class="literal">tenet</code>. This implementation accepts handlers (subscribers) that must accept two parameters, such as the following example:</p><pre class="programlisting">static void EventHandler1(object o, EventArgs e)
{
    Console.WriteLine("Handling for object {0}", o);
}
</pre><p>In place of using the generic <code class="literal">EventArgs</code> type as an event parameter as specified by the <code class="literal">EventHandler</code> delegate, when using the related generic version <code class="literal">EventHandler&lt;T&gt;</code>, we can use any other type as an argument parameter.</p><p>By using reactive programming, we can handle events or produce events to interact with classic .NET desktop/mobile applications or server-side workflow/web applications in a simplified way, producing or sourcing events from an observable sequence. In the following section, we will divert all the main operators that help us in this absolutely useful task</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>FromEventPattern</h3></div></div></div><p>By using the <code class="literal">FromEventPattern</code> extension method of the <code class="literal">Observable</code> class, we can produce a sequence of the <code class="literal">EventPattern</code> messages containing the firing event parameters as the sender and the argument. Here's a complete example for console applications:</p><pre class="programlisting">
public static event EventHandler userIsTiredEvent;
static void Main(string[] args)
{
    //raise the event in 5 seconds
    Task.Factory.StartNew(() =&gt;
    {
        Thread.Sleep(5000);

        //check event is handled
        if (userIsTiredEvent != null)
            userIsTiredEvent("Program.Main", new EventArgs());
    });

    //classic event handler registration
    userIsTiredEvent += EventHandler1;

    //reactive registration
    var eventSequence = Observable.FromEventPattern(typeof(Program),
    "userIsTiredEvent");

    //some output
    eventSequence.Materialize().Subscribe(x =&gt; Console.WriteLine("From Rx: {0}",
    x));

    Console.ReadLine();
}

static void EventHandler1(object o, EventArgs e)
{
    Console.WriteLine("Handling for object {0}", o);
}
</pre><p>The <code class="literal">FromEventPattern</code> operator wraps events into <code class="literal">EventPattern&lt;T&gt;</code> that will flow as usual in an observable sequence. In the preceding example, we wrapped the <code class="literal">EventPattern</code> message into the <code class="literal">Notification</code> message (with the <code class="literal">Materialize</code> operator) to receive details about the message's type, as you learned to do in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>
Debugging Reactive Extensions
</em></span>.</p><p>With our code, we created two subscribers to <code class="literal">userIsTiredEvent</code>; one outputs the result directly to the console as it is usually done by any event handler, while the second subscriber is totally created and handled by the implementation of the <code class="literal">FromEventPattern</code> method.</p><p>In the nonreactive world, we're used to seeing one or more handlers per event because event delegates support multiple subscribers (bear in mind that it's an implementation of the <code class="literal">Observable</code> pattern). However, we rarely see a single handler handling multiple events. On the other hand, in the Rx world, it's absolutely usual to share handlers with a pipeline of sequences that may use the <code class="literal">EventPattern</code> parameters to make needed decisions.</p><p>Here's a complete example for a <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>) desktop application. The following code examples focus only on single application portions to explain event bridging to Rx. The full example is available with the other examples.</p><p>The UI XAML codes are as follows:</p><pre class="programlisting">&lt;Grid&gt;
    &lt;DockPanel&gt;
        &lt;UniformGrid Rows="1" DockPanel.Dock="Top"&gt;
            &lt;Button Content="- 10" Command="{Binding ChangeValueCommand}" CommandParameter="-10" /&gt;
            &lt;Button Content="- 1" Command="{Binding ChangeValueCommand}" CommandParameter="-1" /&gt;
            &lt;Button Content="+ 1" Command="{Binding ChangeValueCommand}" CommandParameter="+1" /&gt;
            &lt;Button Content="+ 10" Command="{Binding ChangeValueCommand}" CommandParameter="+10" /&gt;
        &lt;/UniformGrid&gt;

        &lt;Grid&gt;
            &lt;Viewbox&gt;
                &lt;TextBlock Text="{Binding Result}" /&gt;
            &lt;/Viewbox&gt;
        &lt;/Grid&gt;
    &lt;/DockPanel&gt;
&lt;/Grid&gt;
</pre><p>This XAML will produce a view similar to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_06_001.jpg" /><div class="caption"><p>A command based simple UI in WPF</p></div></div><p>
</p><p>The WPF application has a specific command: <code class="literal">CommandBinding</code> pattern for implementing events that support natively the <span class="strong"><strong>Model View ViewModel</strong></span> (<span class="strong"><strong>MVVM</strong></span>) pattern. Different from the classic .NET event pattern, the command-binding pattern supports the <span class="emphasis"><em>N</em></span>-<span class="emphasis"><em>N</em></span> association between command raisers and handlers. Differently, in the .NET event pattern, only the event owner can raise the event, while multiple subscribers may exist.</p><p>In the following code, we will register a single command (the event definition) with multiple button subscribers (the event raisers) and a single command-binding (the event handler):</p><pre class="programlisting">public MainWindow()
{
    InitializeComponent();
    DataContext = this;

    //command definition
    ChangeValueCommand = new RoutedCommand(Guid.NewGuid().ToString(),
    typeof(MainWindow));
    //command binding registration
    CommandBindings.Add(new CommandBinding(ChangeValueCommand,
    OnChangeValueCommand));
}

public event PropertyChangedEventHandler PropertyChanged;

//classic WPF implementation
private void OnChangeValueCommand(object sender, ExecutedRoutedEventArgs e)
{
    Result += Convert.ToInt32(e.Parameter);
    //notify value update
    Notify("Result");
}
</pre><p>The preceding example is pretty simple. We passed a numeric value as a command parameter from the view (the XAML) and we added/subtracted such a value parameter to/from the <code class="literal">Result</code> property that is visible as a label in the middle of the view.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"></a>Tip</h3><p>The preceding code uses the MVVM pattern. To keep it short, we flattened the <code class="literal">ViewModel</code> and the <code class="literal">View</code> classes into a single class. Because this book focuses on reactive programming, if something is not clear here, kindly read more about MVVM by referring to a more specific book or the Internet as follows:
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/hh848246.aspx
</a>.</p></div><p>The same example is available by handling the command wrapped into an event with the <code class="literal">EventCommand</code> class and then wrapped into an <code class="literal">EventPattern</code> message for reactive usage. Here's the code:</p><pre class="programlisting">public MainWindow()
{
    InitializeComponent();
    DataContext = this;

    //command definition
    var command = new EventCommand();
    ChangeValueCommand = command;

    //sequence initialization

    //register to the event from the command
    Observable.FromEventPattern(command, "ExecuteRaised")
    //subscribe to messages from the sequence
    .Subscribe(eventDetail =&gt;
    {
        //EventArgs contains the Parameter of the command
        Result += Convert.ToInt32(eventDetail.EventArgs);
        //notify the value update
        Notify("Result");
    });
}
</pre><p>Here's the <code class="literal">EventCommand</code> class:</p><pre class="programlisting">//a simplified CommandToEvent command
public class EventCommand : ICommand
{
    public event EventHandler&lt;object&gt; ExecuteRaised;
    public event EventHandler CanExecuteChanged;

    public bool CanExecute(object parameter)
    {
        return true;
    }

    public void Execute(object parameter)
    {
        if (ExecuteRaised != null)
            ExecuteRaised(this, parameter);
    }
}
</pre><p>The first difference that exists between the previous example and the one with <code class="literal">ConsoleApplication</code> in the preceding example is that, here, we injected into <code class="literal">FromEventPattern</code> a specific object (<code class="literal">instance</code>) that raises its event, while in the <code class="literal">ConsoleApplication</code> example, we specified a <code class="literal">Type</code> parameter because that event is static.</p><p>Other than this difference, the example is identical (in its design), because the WPF command-binding pattern is somehow already changing the event design into the Rx direction. What if we use a classic window/web form design? Here's an example:</p><pre class="programlisting">//sequence initialization

//register to buttons
var button1Sequence = Observable.FromEventPattern(button1, "Click")
//create the message to specify right numeric value
.Select(x =&gt; -10);

var button2Sequence = Observable.FromEventPattern(button2, "Click")
//create the message to specify right numeric value
.Select(x =&gt; -1);

var button3Sequence = Observable.FromEventPattern(button3, "Click")
//create the message to specify right numeric value
.Select(x =&gt; +1);

var button4Sequence = Observable.FromEventPattern(button4, "Click")
//create the message to specify right numeric value
.Select(x =&gt; +10);

//create a single merged sequence
button1Sequence.Merge(button2Sequence).Merge(button3Sequence).Merge(button4Sequence)
//flatten values into a single
.Scan((previous, actual) =&gt; previous + actual)
//subscribe to handle value change
.Subscribe(x =&gt;
{
    //notify the value update
    textBox1.Text = x.ToString();
});
</pre><p>The preceding example is within the constructor of a form. We have <code class="literal">4</code>
<code class="literal">buttons</code> and <code class="literal">TextBox</code> for displaying the result. The example is identical to the WPF one, but here, we have a completely different Rx sequence. In Windows Forms, each button raises its <code class="literal">Click</code> event; this means that we need to create <code class="literal">4</code> sequences from the event pattern and merge these sequences into a single sequence. Once we have flattened the changing values, we need to find the result by using the <code class="literal">Scan</code> operator that gives us a rolling result. At the end of the sequence, a simple subscription sets the result to the <code class="literal">textbox1.Text</code> property.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>FromEvent</h3></div></div></div><p>The <code class="literal">FromEvent</code> method, similar to <code class="literal">FromEventPattern</code>, returns a sequence of the messages that represent event occurrences. The difference is that <code class="literal">FromEvent</code> gives us the ability to interact more deeply with the internals of the <code class="literal">FromEvent</code> sequence generation.</p><p>Instead of asking for a CLR event, as was the case with <code class="literal">FromEventPattern</code>, the <code class="literal">FromEvent</code> method asks for two actions. The first (registration) action gives us the internal <code class="literal">Action&lt;T&gt;</code> method that <code class="literal">FromEvent</code> uses to generate messages. The second (unregister) action give us again the same inner action to inform us to stop using that inner action to produce messages.</p><p>Here's a short example:</p><pre class="programlisting">
//the action from the FromEvent
Action&lt;string&gt; fromEventAction = null;

//setup the FromEvent sequence
Observable.FromEvent&lt;string&gt;(
    //register the inner action
    innerAction =&gt; { fromEventAction = innerAction; },
    //unregister the inner action
    innerAction =&gt; { fromEventAction = null; }
    )
    .Subscribe(x =&gt; Console.WriteLine("-&gt; {0}", x));

while (true)
{
    //invoke the inner action
    fromEventAction(DateTime.Now.ToString());
    Thread.Sleep(1000);
}
</pre><p>This is one of the most powerful implementations within Rx between all the message generator operators available throughout the <code class="literal">Observable</code> class, because here, we have the ability to produce an arbitrary amount of messages simply with the delegate method available with <code class="literal">Action&lt;T&gt;</code>, a generic delegate.</p><p>Another way of using the <code class="literal">FromEvent</code> method is by using its inner actions to handle an external event. In a few words, we will receive a couple of delegates to ensure the registration/deregistration of our sequence. Then, we will append these delegates (as an event handler) to the external event we want to intercept to create messages. The message flow will start by intercepting the event.</p><p>Here's an example:</p><pre class="programlisting">
public static event Action MyStaticEvent;
static void Main(string[] args)
{
    //event sequence
    var sequence = Observable.FromEvent(
        //register the inner action as handler of the static event
        x =&gt; MyStaticEvent += x,
        //unregister the inner action from the static event
        x =&gt; MyStaticEvent -= x);

    //observer
    sequence.Subscribe(unit =&gt; Console.WriteLine(unit));

    //manually raise the event
    MyStaticEvent();

    Console.ReadLine();
}
</pre><p>This usage of the <code class="literal">FromEvent</code> method is a bit useless because we could use the <code class="literal">FromEventPattern</code> instead. The difference is always that, with the <code class="literal">FromEvent</code> method we can register to the event (or to multiple events) by ourselves and later unregister in the same way.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec78"></a>ToEvent</h3></div></div></div><p>The opposite of handling events as messages in the <code class="literal">observable</code> sequence is exposing a reactive message as events. This is a useful way of interacting with the existing (usually desktop) applications, because this choice makes available intercepting <code class="literal">OnNext</code>, <code class="literal">OnCompleted</code>, and <code class="literal">OnError</code> messages as events.</p><p>Here's a short example:</p><pre class="programlisting">
//an infinite sequence
var sequence = Observable.Interval(TimeSpan.FromSeconds(1)).Select(x =&gt; DateTime.Now);

//the event wrapper
var eventWrapper = sequence.ToEvent();

//register the event handler
eventWrapper.OnNext += x =&gt; Console.WriteLine("{0}", x);

Console.ReadLine();
</pre></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec42"></a>Threading integration</h2></div></div><hr /></div><p>With Rx, we have the ability to let our messages flow in specific threads to achieve high concurrency computation or we can define to use the main thread to comply with the UI controls requirements. This kind of thread integration is discussed in the <span class="emphasis"><em>Scheduling</em></span> section.</p><p>Differently, in this section, we will cover the ability to flow the result of an asynchronous operation within a sequence.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec79"></a>Sourcing from a Task</h3></div></div></div><p>A <code class="literal">Task</code> process is an asynchronous operation wrapped into an object that gives us the ability to create task hierarchy, task cancellation, and so on.</p><p>Often, in our applications, we use tasks to handle CPU-bound or IO-bound operations. When we're dealing with reactive applications, the best way to acknowledge a task completion is by routing <code class="literal">ack</code> as a message within a sequence. This is available throughout the <code class="literal">ToObservable</code> extension method of the <code class="literal">Task</code> class. Here's an example:</p><pre class="programlisting">
//as simple task
var task = Task.Factory.StartNew(() =&gt;
{
    Thread.Sleep(1000);
    return DateTime.Now;
});

//a sequence to ack the task's result
//need using System.Reactive.Threading.Tasks
var ackSequence = task.ToObservable();

//some output
ackSequence.Subscribe(x =&gt; Console.WriteLine(x));

Console.ReadLine();
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec80"></a>Task cancellation</h3></div></div></div><p>We can use task cancellation within the sequence creation to have the opportunity to cancel internal subscription executions with the usual task cancellation design. Here's a complete example:</p><pre class="programlisting">
//a cancellable sequence
var fromDatabase = Observable.Create&lt;DateTime&gt;(o =&gt;
{
    //a cancellation token source for timeout
    var tks = new CancellationTokenSource(TimeSpan.FromSeconds(5));
    var token = tks.Token;

    //the cancellable task within the sequence
    return Task.Factory.StartNew(() =&gt;
    {
        //run until cancel requested
        while (!token.IsCancellationRequested)
            using (var cn = new SqlConnection(@"data source=(local);integrated security=true;"))
            using (var cm = new SqlCommand("select getdate()", cn))
            {
                Thread.Sleep(1000);
                cn.Open();
                //read time from DB
                o.OnNext((DateTime)cm.ExecuteScalar());
            }

        //signal oncompleted
        o.OnCompleted();

        //returns a disposable subscription completed object
        //with an OnCompleted callback
        return Disposable.Create(() =&gt; Console.WriteLine("Killing
        subscription"));
    }, token);
});

fromDatabase.Subscribe(x =&gt; Console.WriteLine(x));
</pre><p>The preceding example shows how to cancel the internal per subscription message generation function. Essentially, it's a classic task cancellation example. The only difference is that this executes within a <code class="literal">Create</code> operator that specifies the message generation workflow that runs per subscriber. In this example, we specified a <code class="literal">5</code> seconds timeout that signals <code class="literal">CancellationToken</code> to end the internal execution of <code class="literal">Task</code>, exits its execution loop, and correctly completes its job.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Scheduling</h2></div></div><hr /></div><p>Programming observable sequences is a powerful way to achieve a highly modularized programming experience. Although this offers high flexibility, an observable sequence is single-threaded by default and is similar to a lot of other CLR objects. This means that although a sequence can push messages to multiple subscribers, this operation happens in the same thread where the messages originate and then the messages reach all the subscribers, sequentially following their subscription order.</p><p>This means that using an observable sequence instead of any other .NET object does not convert automatically our code into a multithreaded one.</p><p>Luckily, to address this automatic multithreading need in the Rx world, there are <code class="literal">Schedulers</code>. These are objects that choose when a message can flow and which thread must handle a message.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Tip</h3><p>It is important to understand the huge difference that exists between using a CLR <code class="literal">delegate</code>/<code class="literal">event</code> and Rx scheduling. When using scheduling in Rx, we would always have an asynchronous implementation in an in-memory queue of messages that act as a message pump supporting <span class="strong"><strong>Quality of Service</strong></span> (<span class="strong"><strong>QoS</strong></span>) for routing messages at different speeds. These messages flow and are observed in a thread or another based on the scheduler's choice. This is actually the most critical task of a scheduler.</p></div><p>In short, a scheduler is in charge of choosing the <code class="literal">message</code>/<code class="literal">thread</code> association. Let's take a look at this familiar code:</p><pre class="programlisting">
var loopBasedSequence = Observable.Create&lt;DateTime&gt;(x =&gt;
{
    while (true)
    {
        Console.WriteLine("{0} -&gt; Yielding new value...",
        Thread.CurrentThread.ManagedThreadId);
        x.OnNext(DateTime.Now);
        Thread.Sleep(1000);
    }
    return Disposable.Empty;
});

loopBasedSequence.Subscribe(x =&gt; Console.WriteLine("-&gt; {0}", x));
</pre><p>The preceding example shows us a very simple implementation of an infinite sequence. Based on a simple infinite loop, this example produces messages that originate always from the same thread. This is obvious because we are looping within a <code class="literal">While</code> loop; the same behavior is available in nonreactive coding.</p><p>Let's take a look at another example that shows a timer-based sequence:</p><pre class="programlisting">
var timerBasedSequence = Observable.Interval(TimeSpan.FromSeconds(1))
.Select(x =&gt;
{
    Console.WriteLine("{0} -&gt; Yielding new value...",
    Thread.CurrentThread.ManagedThreadId);
    return DateTime.Now;
});

timerBasedSequence.Subscribe(x =&gt; Console.WriteLine("-&gt; {0}", x));
</pre><p>This example shows another infinite sequence that is slightly different from the previous one. This sequence is timer-based, such as when we use <code class="literal">System.Threading.Timer</code> in classic CLR programming or any similar object. A <code class="literal">Timer</code> method produces a signal at a fixed time interval. This signal originates from a thread in <code class="literal">ThreadPool</code>. We cannot choose the thread by ourselves. The same happens in the reactive version of <code class="literal">Timer</code> available through the <code class="literal">Interval</code> method.</p><p>Other than these built-in behaviors, we have the ability to set up a specific thread for our sequence by specifying the scheduler to be used. Here's an example:</p><pre class="programlisting">
var loopBasedSequence = Observable.Create&lt;DateTime&gt;(x =&gt;
{
    while (true)
    {
        Console.WriteLine("{0} -&gt; Yielding new value...", Thread.CurrentThread.ManagedThreadId);
        x.OnNext(DateTime.Now);
        Thread.Sleep(1000);
    }
    return Disposable.Empty;
});

loopBasedSequence.SubscribeOn(Scheduler.Default).Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));
loopBasedSequence.SubscribeOn(Scheduler.Default).Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));
loopBasedSequence.SubscribeOn(Scheduler.Default).Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));
</pre><p>The preceding example shows another implementation of the loop-based infinite sequence. This time, before the subscription, we specified to use a specific <code class="literal">Scheduler</code> class with the <code class="literal">SubscribeOn</code> extension method (discussed in detail later in this chapter). In the previous example, only the subscriber creates a subscription on the creation thread (the main thread) that prevented the application to exit from that infinite loop. Differently, in this new example, <code class="literal">Scheduler</code> assigned a thread to each observer subscription. This means that we have altogether three different threads running their infinite logic.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Tip</h3><p>To use the <code class="literal">Scheduler</code> helper class, we need to import the <code class="literal">System.Reactive.Concurrency</code> namespace.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec81"></a>Default schedulers</h3></div></div></div><p>We have the ability to select the desired scheduler between those available in the <code class="literal">Scheduler</code> helper class as static properties. Each prebuild scheduler is optimized for a specific kind of usage as background tasks, UI programming, and so on. Here's a short explanation of the available schedulers.</p><p>The <code class="literal">Scheduler.Default</code> (former <code class="literal">Scheduler.ThreadPool</code>) scheduler is the default concurrent scheduler that lets us interact with multithreaded execution in a simple way. It uses threads from <code class="literal">ThreadPool</code>. Bear in mind that <code class="literal">ThreadPool</code> has a finite number of threads and that its threads fulfil the needs of other CLR objects as tasks from <code class="literal">TaskFactory</code>. Obviously, we can set up the minimum and maximum number of threads with the <code class="literal">ThreadPool.SetMinThreads</code> and <code class="literal">ThreadPool.SetMaxThreads</code> static methods.</p><p>On the other hand, <code class="literal">Scheduler.Immediate</code> is definitely the default scheduler that runs when we don't ask for a scheduler. This is the blocking one that executes any subscription life cycle in the main thread.</p><p>The <code class="literal">Scheduler.CurrentThread</code> method is very similar to the <code class="literal">Immediate</code> one, but the <code class="literal">Immediate</code> one executes without queuing messages. This means that the <code class="literal">CurrentThread</code> one schedules messages to execute sequentially on the same creation thread, preventing these messages from creating a race/deadlock condition.</p><p>The <code class="literal">Scheduler.Dispatcher</code> method lets the observers execute on the UI thread for WPF or Silverlight applications.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Tip</h3><p>To use the <code class="literal">Dispatcher</code> scheduler, import the NuGet package <code class="literal">Rx-WPF</code> or <code class="literal">Rx-Silverlight</code>.</p></div><p>The <code class="literal">NewThreadScheduler.Default</code> method (former <code class="literal">Scheduler.NewThread</code>) executes each observer on a new foreground thread (<code class="literal">System.Threading.Thread</code>) to avoid consuming a thread from <code class="literal">ThreadPool</code> as it happens with the <code class="literal">Default</code> scheduler. This means that we can virtually execute the maximum number of threads (~65K) the OS can handle, but this also means that this choice can dramatically reduce the application's (and OS) reliability because there is no throttling on thread amount, causing huge resource usages and the possibility to reach the starvation state that will impact the OS, too.</p><p>The <code class="literal">Scheduler.TaskPool</code> method executes the observer within <code class="literal">Task</code> from the default task factory. There are two main benefits in using this scheduler: threads in the thread pool (<code class="literal">TaskFactory</code>, by default, uses threads from <code class="literal">ThreadPool</code>) are pregenerated; this means that we don't have to wait for their creation (if there are enough threads ready in the pool). This is useful for reducing the delay in the message's response. Another benefit is that the pool contains a finite number of threads, acting as a throttling that doesn't allow an unpredictable number of threads to run together.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Tip</h3><p>Each Rx operator comes with its default scheduler. This means that timer-based schedulers (for instance, Interval) run on the <code class="literal">ThreadPool</code> scheduler, while sequences that produce few messages will usually run on the <code class="literal">Immediate</code> scheduler. This design choice is made by preferring the less concurrent scheduler, while, when we select a specific scheduler or when we select the <code class="literal">Default</code> scheduler, we're asking Rx to configure its message pump to route messages to multiple threads to improve the messages' concurrency.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec82"></a>SubscribeOn/ObserveOn</h3></div></div></div><p>In the previous example, we had the opportunity of seeing the <code class="literal">SubscribeOn</code> method in action. This method allows us to specify a scheduler to queue messages on different threads.</p><p>The same result is available with the <code class="literal">ObserveOn</code> method with the difference that the <code class="literal">SubscribeOn</code> method registers the scheduler on the whole the subscriber and, eventually, the observer code that produces messages related to the same observer. Differently, the <code class="literal">ObserveOn</code> method registers to the given scheduler only the output message by letting all the messages source from the same thread.</p><p>It's time to understand in detail how these methods work. The following example shows a sequence made with the <code class="literal">Create</code> operator. This operator lets us specify a custom code to produce messages per registration. Later, we will register two subscribers with <code class="literal">SubscribeOn</code> and then with the <code class="literal">ObserveOn</code> method specifying the <code class="literal">Default</code> (<code class="literal">ThreadPool</code>) scheduler. This will route execution on the thread pool. The two different operators will produce different results because the <code class="literal">SubscribeOn</code> method will put the whole <code class="literal">Create</code> operator on the pool's thread, while the <code class="literal">ObserveOn</code> will only put the resulting messages on the pool's thread. Here's the code:</p><pre class="programlisting">
var sequence = Observable.Create&lt;DateTime&gt;(x =&gt;
{
    //let take some time before registering the new observer
    for(int i=0;i&lt;10;i++)
    {
        Console.WriteLine("Registering observer on thread {0}...", Thread.CurrentThread.ManagedThreadId);
        Thread.Sleep(100);
    }

    //produce 10 messages
    for(int i=0;i&lt;10;i++)
    {
        x.OnNext(DateTime.Now);
        Thread.Sleep(100);
    }

    //exit
    return Disposable.Empty;
});

//register two subscribers
sequence.SubscribeOn(Scheduler.Default).Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));
sequence.SubscribeOn(Scheduler.Default).Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));

Console.ReadLine();
</pre><p>The example code is identical whether we use the <code class="literal">SubscribeOn</code> or the <code class="literal">ObserveOn</code> method. Let's evaluate the behavior of the two methods.</p><p>When using the <code class="literal">ObserveOn</code> method, the two observers will register sequentially. The second observer will register only when the first stops receiving messages. Then, each observer will receive its messages. Talking about the threading design, each observer will register on the same thread (the main one). Then, each observer will receive its messages on another thread of the pool. This means that the observer creational code that runs within the <code class="literal">Create</code> method will always run in the main thread per each observer. In other words, each subscription will execute on thread <span class="emphasis"><em>A</em></span> (the main one); the first observer will handle messages on thread <span class="emphasis"><em>B</em></span>, and the second observer will handle messages on thread <span class="emphasis"><em>C</em></span>.</p><p>When using the <code class="literal">SubscribeOn</code> method, each observer will get correlated to a specific thread from the subscription to the completion. This means that the first observer will subscribe and receive messages on thread <span class="emphasis"><em>A</em></span> (not the main one), while the second observer will subscribe and receive messages on thread <span class="emphasis"><em>B</em></span> (not the main one).</p><p>The immediate result of these two implementations is that, with <code class="literal">SubscribeOn</code>, the two subscriptions will run in parallel by avoiding the second observer waiting for the first one to complete its job before registering. Obviously, this method produces the most concurrent result and is preferable in any case if we want to increase parallelism in our coding. However, this method cannot directly interact with UI controls as WPF or Windows Forms controls because all these controls require that the request (in the example, the code within the <code class="literal">Create</code> method) comes from the UI thread. In such cases, the <code class="literal">ObserveOn</code> method is definitely our choice.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec83"></a>Injecting schedulers</h3></div></div></div><p>Other than injecting schedulers within the sequence chain by using the <code class="literal">SubscribeOn</code> or the <code class="literal">ObserveOn</code> method, we can pass a specific scheduler in almost any Rx operator's extension method, changing the default scheduler of the operator itself. Here's an example:</p><pre class="programlisting">
Console.WriteLine("Main thread: {0}", Thread.CurrentThread.ManagedThreadId);

//numeric sequence
var sequence = Observable.Range(1, 10, Scheduler.Default);

//observers
sequence.Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));
sequence.Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x));
</pre><p>In the preceding example, we will see an implementation almost identical to the <code class="literal">ObserveOn</code> one because the two observers will run sequentially, receiving the same values from the sourcing sequence. This happens because the <code class="literal">Range</code> method produces a <code class="literal">Cold</code> sequence.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>The <code class="literal">Cold</code> sequences are sequences that start their messaging workflow each time an observer subscribes. But, each <code class="literal">Hot</code> observer has its own messaging workflow regardless of whether one or multiple subscriptions exist.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec84"></a>Custom scheduling</h3></div></div></div><p>A <code class="literal">Scheduler</code> class, as the name implies, other than something that deals with threads, is something that schedules some action at a given time. We can use <code class="literal">Schedulers</code> to schedule jobs of any kind at any absolute or relative or repetitive time. In the real-world reactive programming, we can use scheduled jobs to push messages into sequences or because of their ability to virtualize the time (later explained in the <span class="emphasis"><em>Virtual time</em></span> section).</p><p>Here's an example of <code class="literal">Immediate</code> scheduling:</p><pre class="programlisting">
static void Main(string[] args)
{
    using (var job1 = Scheduler.Default.Schedule(OnJob1Executed))
        //job timeout
        Thread.Sleep(2000);

    Console.WriteLine("END");
    Console.ReadLine();
}

static void OnJob1Executed()
{
    for (int i = 0; i &lt; 10; i++)
    {
        Console.Write(".");
        Thread.Sleep(100);
    }

    Console.WriteLine();
    Console.WriteLine("JOB END");
}
</pre><p>The preceding example shows how to schedule a simple job immediately. Consider a real-world usage where we schedule immediate jobs by receiving inputs from a user or by handling an event. Although we could simply execute the same job immediately without <code class="literal">Scheduler</code>, by using <code class="literal">Scheduler</code>, we may, in future, replay the scheduled job sequence by saving this sequence somewhere. This gives us a great diagnostic tool. More details on it are available in the <span class="emphasis"><em>Virtual time</em></span> section.</p><p>Another interesting thing to focus on by looking at this example is the job timeout that we can invoke by simply disposing the job token (in the code, this is the <code class="literal">job1</code> variable).</p><p>The token represents the scheduled job, not its implementation. This means that it is cancelling <code class="literal">job</code>, preventing it from being executed, but not from breaking an eventual execution if this has already been triggered by <code class="literal">Scheduler</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec85"></a>Future scheduling</h3></div></div></div><p>Future scheduling is the ability to schedule at a given (future) absolute time, or relative time, or periodic time. The usage is pretty identical to the generic scheduling with the addition of a scheduling time value.</p><p>An important aspect is that, here, the timeout we give to the job token may actually prevent the scheduled job from firing.</p><p>Here are a few examples:</p><pre class="programlisting">
//starts a job in absolute time
using (var job2 = Scheduler.Default.Schedule(DateTimeOffset.Now.AddSeconds(1), ()
.0=&gt; Console.WriteLine("OK")))
    //job timeout
    Thread.Sleep(2000);

//starts a job in relative time
using (var job3 = Scheduler.Default.Schedule(TimeSpan.FromSeconds(10), () =&gt; Console.WriteLine("OK")))
    //job timeout
    //this job will never fire because its schedule is greater than how time timeout will grant
    Thread.Sleep(2000);

//starts a job periodically
using (var job4 = Scheduler.Default.SchedulePeriodic(TimeSpan.FromSeconds(1), () =&gt; Console.WriteLine("OK")))
    //timeout at 5 seconds
    Thread.Sleep(5000);

Console.WriteLine("END");
Console.ReadLine();
</pre><p>The periodic example (the third) will fire our scheduled job until we don't kill it by disposing the token (<code class="literal">job2</code>).</p><p>The ability to create custom future scheduling with multiple different <code class="literal">Schedulers</code> gives us tremendous chances of designing our solution the best we can.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec86"></a>Virtual time</h3></div></div></div><p>When we create complex scheduling, we can work in virtual time to achieve testability or to have the ability to replay some real-world (in production) execution because of testing needs, diagnostic needs, or production needs.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Tip</h3><p>To execute the following examples, import the <code class="literal">Microsoft.Reactive.Testing</code> and <code class="literal">System.Reactive.Concurrency</code> namespaces.</p></div><p>The concept is very easy. We can create a scheduler specific for testing purposes, <code class="literal">TestScheduler</code> (import the NuGet <code class="literal">Rx-Testing</code> package). Then, we can use it as usual by scheduling jobs. We can advance the virtual clock by letting the scheduler execute as in the real world. Here's a short example to understand it easily:</p><pre class="programlisting">//a scheduler for testing purposes
var scheduler = new TestScheduler();

//records to schedule an immediate action
scheduler.Schedule(() =&gt; Console.WriteLine("Hi"));

//advance the virtual clock to let execute the recorded actions
scheduler.AdvanceBy(TimeSpan.FromSeconds(1).Ticks);
</pre><p>The preceding example shows how to use <code class="literal">TestScheduler</code>. <code class="literal">Scheduler</code> will record each scheduled job we ask it to execute. It never executes jobs as usual schedulers; it only records jobs. Bear in mind that we always need to manually play the recorded job schedule to actually execute jobs.</p><p>Alternatively, to manually move the virtual clock forward with the <code class="literal">AdvanceBy</code> method, we can simply play the record by invoking the <code class="literal">Start</code> method. Here's an example:</p><pre class="programlisting">////advance the virtual clock to let execute the recorded actions
//scheduler.AdvanceBy(TimeSpan.FromSeconds(1).Ticks);

//play the recorded scheduled jobs at normal speed
scheduler.Start();
</pre><p>The <code class="literal">Start</code> method will let the scheduler immediately output all the outputs regardless of the job's absolute timings while respecting the sequence order. Here's a more complete example:</p><pre class="programlisting">//output the virtual clock
Console.WriteLine("-&gt; {0}", scheduler.Now);

//schedule a future job
scheduler.Schedule(TimeSpan.FromDays(22), () =&gt; Console.WriteLine("2 seconds now"));
Console.WriteLine("-&gt; {0}", scheduler.Now);

//play the recorded scheduled jobs at normal speed
scheduler.Start();
Console.WriteLine("-&gt; {0}", scheduler.Now);
</pre><p>In the preceding example, we created a future job that will start with a <code class="literal">22 days</code> delay. However, by invoking the <code class="literal">Start</code> method, the scheduler will immediately advance the virtual clock (available with the <code class="literal">Now</code> property) to the next job time, causing the related action's execution. This will leave the internal virtual clock to the last job time (in this example, <code class="literal">22 days</code>).</p><p>We can register other jobs even after we invoke the <code class="literal">Start</code> method. These jobs will not fire until we invoke the <code class="literal">Start</code> method again.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Tip</h3><p>If multiple jobs are scheduled at the same identical virtual time, <code class="literal">Scheduler</code> will execute these jobs according to the registration time.</p></div><p>We can advance to a specific virtual time by using the <code class="literal">AdvanceTo</code> method. Here's an example:</p><pre class="programlisting">//schedule a future job at 1 minute
scheduler.Schedule(TimeSpan.FromMinutes(1), () =&gt; Console.WriteLine("2 seconds now"));
Console.WriteLine("-&gt; {0}", scheduler.Now);

//advance to 00:00:30
scheduler.AdvanceTo(TimeSpan.FromSeconds(30).Ticks);
Console.WriteLine("-&gt; {0}", scheduler.Now);

//advance to 00:01:00
scheduler.AdvanceTo(TimeSpan.FromSeconds(60).Ticks);
Console.WriteLine("-&gt; {0}", scheduler.Now);
</pre><p>By invoking the <code class="literal">AdvanceTo</code> method of the <code class="literal">Scheduler</code> class, we can advance the virtual time as we wish. Obviously, we cannot advance back in time! <code class="literal">Scheduler</code> is a forward-only virtual time clock.</p><p>Another interesting feature is the ability to schedule a <code class="literal">Stop</code> execution on the scheduler itself. This will pause the scheduler (another <code class="literal">Start</code> will let the scheduler start again, playing newly recorded jobs eventually) at a specified time. Here's a complete example:</p><pre class="programlisting">//schedule a periodic job and output the virtual time
scheduler.SchedulePeriodic(TimeSpan.FromSeconds(1), () =&gt; Console.WriteLine("{0} -&gt; Periodic", scheduler.Now));

//this would produce an infinite output
//scheduler.Start();

//to avoid the infinite output, we will need to schedule a Stop request
scheduler.Schedule(TimeSpan.FromSeconds(60), () =&gt; scheduler.Stop());

//play the whole record
scheduler.Start();

//append immediately
scheduler.Schedule(TimeSpan.FromTicks(1), () =&gt; Console.WriteLine("Running again"));

//schedule another Stop
scheduler.Schedule(TimeSpan.FromSeconds(60), () =&gt; scheduler.Stop());

//start again the scheduler
scheduler.Start();

Console.ReadLine();
</pre><p>In the preceding example, we can see the <code class="literal">Stop</code> usage. Bear in mind that after the first <code class="literal">Start</code> method executes, the whole record will play until <code class="literal">Stop</code> fires. This will pause the scheduler setting in its <code class="literal">IsEnabled</code> property to <code class="literal">False</code>. Then, we will enqueue the other two jobs, an immediate output and another <code class="literal">Stop</code>. This second <code class="literal">Stop</code> method will prevent <code class="literal">Scheduler</code> from running indefinitely after the second <code class="literal">Start</code> request. This would happen because the virtual clock can only advance, meaning that after the first <code class="literal">Stop</code>, it will never go back to running the same (first) <code class="literal">Stop</code> method again. In other words, invoking multiple times the <code class="literal">Start</code> method will not restart the <code class="literal">Scheduler</code> object from the beginning. It will simply start again from its last virtual clock time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec87"></a>Testing schedulers</h3></div></div></div><p>Now that we know how to start/stop virtual <code class="literal">Schedulers</code>, we need to look at how to test <code class="literal">TestScheduler</code> in an automated way, as we may do in nonreactive coding with unit testing.</p><p>To test scheduler and sequences, we need to create the mock version of a sequence and of an observer. They are available as a helper method using the <code class="literal">TestScheduler</code> class. We can create a mock observer with the <code class="literal">CreateObserver&lt;T&gt;</code> method and mock sequences with the <code class="literal">CreateColdObservable</code> or <code class="literal">CreateHotObservable</code> methods. Bear in mind that a <code class="literal">Cold</code> sequence produces the same message flow at each subscription while a <code class="literal">Hot</code> sequence fires its message regardless of the live subscriptions.</p><p>Here's a short example regarding a cold sequence:</p><pre class="programlisting">
var scheduler = new TestScheduler();

//a cold sequence
var sequence = scheduler.CreateColdObservable&lt;int&gt;(
    //some recorded message
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(1).Ticks,
    Notification.CreateOnNext(10)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(2).Ticks,
    Notification.CreateOnNext(20)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(3).Ticks,
    Notification.CreateOnNext(30)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(4).Ticks,
    Notification.CreateOnNext(40)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(5).Ticks,
    Notification.CreateOnNext(50)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(6).Ticks,
    Notification.CreateOnNext(60)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(7).Ticks,
    Notification.CreateOnCompleted&lt;int&gt;())
);

//a new testable observer
var observer1 = scheduler.CreateObserver&lt;int&gt;();

//subscribe the observer at a given virtual time
scheduler.Schedule(TimeSpan.FromSeconds(2), () =&gt; sequence.Subscribe(observer1));

//play the record
scheduler.Start();
</pre><p>As visible in the preceding example, we can simply create a sequence with the <code class="literal">TestScheduler.CreateColdObservable</code> method by specifying the message record list to be produced when playing. To produce recorded messages, we will wrap our values (integer values in this example or none for the <code class="literal">OnCompleted</code> message) into a <code class="literal">Notification</code> object. Then, we will wrap the notification into a <code class="literal">Recorded</code> object by providing the relative time defer to use to flow the specified message.</p><p>We will subscribe the observer to the sequence within another job in virtual time (after <code class="literal">2</code> seconds in the example). This will let the observer receive <code class="literal">7</code> messages regardless of the delay of <code class="literal">2</code> seconds of the subscription. This happens because we're using a <code class="literal">Cold</code> observable sequence.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip28"></a>Tip</h3><p>We can substitute <code class="literal">CreateColdObservable</code> with <code class="literal">CreateHotObservable</code>. With a <code class="literal">Hot</code> observable sequence, we will receive only <code class="literal">5</code> messages into the observer because the hot observer will produce messages regardless of whether the subscriber exists.</p></div><p>To verify message flowing at the observer's point of view, we can evaluate its <code class="literal">Messages</code> property after the <code class="literal">TestScheduler.Start</code> is complete. Here's an example:</p><pre class="programlisting">foreach (var m in observer1.Messages)
{
    var time = m.Time;
    //available only for OnNext messages
    //var value = m.Value.Value;
    //var exception = m.Value.Exception;
    //var kind = m.Value.Kind;
    //var hasValue = m.Value.HasValue;

    Console.WriteLine("{0}", m);
}
</pre><p>As visible, there are a lot of interesting properties available in the <code class="literal">Notification</code> object that details the flowing message. This object is the same as we had while using the <code class="literal">Materialize</code> method to produce a tracing sequence, as we have already seen in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>
Debugging Reactive Extension
</em></span>.</p><p>Now, it is time to make some assertions to check whether messages within the observer behave as expected. The next example will use <code class="literal">AssertEquals</code> of the <code class="literal">Messages</code> property of the mock observer. Here's the short code:</p><pre class="programlisting">observer1.Messages.AssertEqual(
    //same messages
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(1).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(10)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(2).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(20)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(3).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(30)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(4).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(40)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(5).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(50)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(6).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnNext(60)),
    new Recorded&lt;Notification&lt;int&gt;&gt;(TimeSpan.FromSeconds(7).Ticks +
    TimeSpan.FromSeconds(2).Ticks, Notification.CreateOnCompleted&lt;int&gt;())
);
</pre><p>Kindly focus on the need for adding <code class="literal">2</code> seconds (observer subscription virtual time) to the virtual time value of the messages we're testing.</p><p>An in-depth explanation of the Rx scheduler testing (by Rx team) is available at:</p><p>

<a class="ulink" href="https://blogs.msdn.microsoft.com/rxteam/2012/06/14/testing-rx-queries-using-virtual-time-scheduling/" target="_blank">https://blogs.msdn.microsoft.com/rxteam/2012/06/14/testing-rx-queries-using-virtual-time-scheduling/</a>
.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec88"></a>Historical records</h3></div></div></div><p>Another class similar to <code class="literal">TestScheduler</code> is available to produce a real-life replay of messages flowing from usual sequences, <code class="literal">HistoricalScheduler</code>. This class is almost identical to <code class="literal">TestScheduler</code> with the difference that we can use it to replay dumped messages. To dump messages from a sequence, we need to store the physical time together with the value message by using the <code class="literal">Timestamp</code> extension method. Once we have this time-stamped sequence, we need to move back from a continuous (reactive) programming to a state-driven programming by dumping messages into a finite collection by using the <code class="literal">ToList</code> extension method. Then, we need to use the <code class="literal">Wait</code> extension method to pause the sequence completion and produce the required collection.</p><p>Now, we're ready to use this collection in the <code class="literal">Observable.Generate</code> method that will recreate a sequence from a timestamped finite message collection. This method will need <code class="literal">HistoricalScheduler</code> as a parameter to handle virtual time advancement, as we have already seen with the usual virtual time of <code class="literal">TestScheduler</code>. Here's a complete example:</p><pre class="programlisting">
Console.WriteLine("{0} -&gt; Playing...", DateTime.Now);

//a sourcing sequence
var sequence = Observable.Interval(TimeSpan.FromSeconds(1)).Take(5);

var trace = sequence
    //marks each message with a timestamp
    .Timestamp()
    //route messages into a list of timestamped messages
    .ToList()
    //materialize the list when the sequence completes
    //and return only the list
    .Wait();

//a scheduler for historical records
var scheduler = new HistoricalScheduler();

Console.WriteLine("{0} -&gt; Replaying...", DateTime.Now);

//generate a new sequence from a collection
var replay = Observable.Generate(
    //the enumerator to read values from
    trace.GetEnumerator(),
    //the condition to check until False
    x =&gt; x.MoveNext(),
    //the item
    x =&gt; x,
    //the item's value
    x =&gt; x.Current.Value,
    //the item's virtual time
    x =&gt; x.Current.Timestamp,
    //the scheduler
    scheduler);

//some output
replay.Subscribe(x =&gt; Console.WriteLine("{0} -&gt; {1}", scheduler.Now, x));

//play the record
scheduler.Start();

Console.ReadLine();
</pre><p>By running the preceding example, we will see the replay producing with the same real-time progression. Similar to <code class="literal">TestScheduler</code>, <code class="literal">HistoricalScheduler</code> will flatten virtual time by outputting all the messages immediately after the invocation of the <code class="literal">Start</code> method.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
You can download the example code files for this book from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.
You can download the code files by following these steps: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Log in or register to our website using your e-mail address and password.</p></li><li><p>Hover the mouse pointer on the <span class="strong"><strong>SUPPORT</strong></span> tab at the top.</p></li><li><p>Click on <span class="strong"><strong>Code Downloads &amp; Errata</strong></span>.</p></li><li><p>Enter the name of the book in the <span class="strong"><strong>Search</strong></span> box.</p></li><li><p>Select the book for which you're looking to download the code files.</p></li><li><p>Choose from the drop-down menu where you purchased this book from.</p></li><li><p>Click on <span class="strong"><strong>Code Download</strong></span>.</p></li></ol></div><p>You can also download the code files by clicking on the <span class="strong"><strong>Code Files</strong></span> button on the book's webpage at the Packt Publishing website. This page can be accessed by entering the book's name in the <span class="strong"><strong>Search</strong></span> box. Please note that you need to be logged in to your Packt account.
Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>WinRAR / 7-Zip for Windows</p></li><li style="list-style-type: disc"><p>Zipeg / iZip / UnRarX for Mac</p></li><li style="list-style-type: disc"><p>7-Zip / PeaZip for Linux</p></li></ul></div><p>The code bundle for the book is also hosted on GitHub at <a class="ulink" href="https://github.com/PacktPublishing/Reactive-Programming-for-.NET-Developers" target="_blank">https://github.com/PacktPublishing/Reactive-Programming-for-.NET-Developers</a>. We also have other code bundles from our rich catalog of books and videos available at <a class="ulink" href="https://github.com/PacktPublishing/" target="_blank">https://github.com/PacktPublishing/</a>. Check them out!</p></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec44"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we had the ability to see the most critical Rx internal component: the schedulers. Understanding scheduling and using scheduling allows applications to get the best from Rx. Together, the ability to interact with classic CLR events extends the power of Rx to classic .NET application integration.</p><p>In the next chapter, we will see more of CLR integration and custom Rx component creation with multiple case studies on real-world Rx applications.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch07"></a>Chapter 7. Advanced Techniques</h2></div></div></div><p>This chapter will show us how to create custom operators and custom schedulers. We will cover some advanced techniques, such as <span class="strong"><strong>Interactive Extensions</strong></span> (<span class="strong"><strong>Ix</strong></span>) and event sourcing with Reactive Extension (Rx).</p><p>Here is a short list:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Designing a custom operator</p></li><li style="list-style-type: disc"><p>Designing a custom scheduler</p></li><li style="list-style-type: disc"><p>Creating <code class="literal">Pattern&lt;T&gt;</code>
</p></li><li style="list-style-type: disc"><p>Event sourcing with Rx</p></li><li style="list-style-type: disc"><p>Interactive Extensions (Ix)</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec45"></a>Designing a custom operator</h2></div></div><hr /></div><p>In the Rx framework, there are multiple extension methods that help us transform a sequence into another one, subscribe to a sequence, or create a new sequence from other objects or from scratch.</p><p>In classic .NET development, all these methods are simply functions, because they almost always provide a result. In Reactive Programming, any function that returns an observable sequence is an operator. There are transforming operators, creational operators, diagnostic operators, and so on.</p><p>Usually, we use operators from the <code class="literal">Observable</code> helper class or by using other helper classes from the official Rx library set available throughout the NuGet package explorer. When we cannot find the right operator, or when we want to improve an operator already available, maybe, by adding new overloads or changing its implementation, we can create a new operator by creating an extension method that supports the generic pattern. With this design, we will be able to reuse our operators in the future in all our projects or redistribute them within libraries or components.</p><p>Another great usage of custom operators is composing other operators to behave as desired. Usually, the goal of adding an overload to an already available operator or adding a new composite operator or other operators is to make it easier to use.</p><p>As the last choice, we may create a custom operator from scratch using LINQ or other features of the CLR together with the low level Rx elements, such as <code class="literal">IObservable</code>, <code class="literal">IObserver</code>, or <code class="literal">Subject</code>.</p><p>Usually, making use of operator composition reduces the chances of releasing bugs and unwanted behaviors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec89"></a>Designing the AsObservable operator</h3></div></div></div><p>In the following example, we will create an operator to source from a generic <code class="literal">IEnumerable&lt;T&gt;</code> variable.</p><p>To create a similar operator, we will use a <code class="literal">Create</code> operator. Here is the code:</p><pre class="programlisting">
static void Main(string[] args)
        {
            //1000 items to source from
            var items = Enumerable.Range(0, 1000)
                .Select(x =&gt;
                {
                    //raise an exception on item #400
                    //within VS the debugger will stop the execution as the
                      exception bubbles
                    //simply press F5 again to continue bubble the exception to Rx
                      sequence
                    if (x == 400)
                        throw new ArgumentException("The item #400 has been
                        sourcing");


                    return x;
                });

            //invoke our custom operator
            var sequence = items.AsObservable();

            //output value and metadata
            sequence.Materialize().Subscribe(x =&gt; Console.WriteLine("-&gt; {0}", x));

            Console.ReadLine();
        }
    }

    public static class RxOperators
    {
        public static IObservable&lt;T&gt; AsObservable&lt;T&gt;(this IEnumerable&lt;T&gt; source)
        {
            return Observable.Create&lt;T&gt;(observer =&gt;
            {
                foreach (var item in source)
                    try
                    {
                        observer.OnNext(item);
                    }
                    catch (Exception ex)
                    {
                        observer.OnError(ex);
                        break;
                    }

                observer.OnCompleted();
                return Disposable.Empty;
            });
        }
    }
</pre><p>The <code class="literal">AsObservable</code> operator we created in the preceding example sources data from a generic enumerable with the <code class="literal">for-each</code> clause. This means that we will never materialize the whole collection in the memory. Instead, we will stream data, as this is available at the enumerator, routing data into the messages available to the returning sequence. Together, we will eventually handle generated exceptions by routing these as error messages. At the end, we will signal the completion by routing the proper message. Regarding this implementation, we don't need to implement the disposal of the observer. Wherever we implement this feature, we can use the <code class="literal">Disposable.Create</code> method to write an action to stop flowing useless messages to an observer that has just been disposed.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip30"></a>Tip</h3><p>Consider that when raising an exception in the <code class="literal">Observer</code> implementation instead of the sourcing sequence implementation, the behavior is different. In the preceding example, we handled errors from the source. This means that we will route properly only these kind of errors. Otherwise, by raising an exception within the <code class="literal">observer</code> implementation, <code class="literal">observer</code> will simply cause the exit from the underlying <code class="literal">Create</code> implementation, stopping its execution immediately. Carefully, let this happen because this is an error hiding (anti-pattern) case.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec90"></a>Designing the AcceptObservableClient operator</h3></div></div></div><p>When network programming, there are multiple high-level systems that may help us create amazing applications. Web services (WCF or ASMX), binary remote services (WCF, Remoting), Enterprise Services (COM+), RESTful services and API (WebApi, WCF, MVC), OData services, queues (MSMQ, Azure Service Bus Queue, Storage Queue), and so on use it. Often, when dealing with IoT devices, we need work at a lower level acting as a network socket server.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"></a>Tip</h3><p>Consider that, within Microsoft Azure, we can deal with IoT devices with the IotHub that already supports a lot of standard IoT protocols, such as MQTT. When a protocol is not yet implemented, we can still develop a custom protocol for the IotHub gateway. This lets the hub work with our protocol without having to redefine the whole system's architecture.</p></div><p>In this case, we can use the CLR <code class="literal">TcpListener</code> class that helps us create a socket server with a few code lines with a good level of scalability and reliability (if properly used). Obviously, this choice is available in Rx programming too, but we need to change the application's design a bit to work in the reactive way.</p><p>When programming <code class="literal">TcpListener</code> in a reactive programming way, we need to route something from the listener. At the lowest level, we can only route the client connection as a message; we will route any <code class="literal">TcpClient</code> connecting to our listener. To route the <code class="literal">TcpClient</code> messages, we will write a reusable operator named <code class="literal">AcceptObservableClient</code>.</p><p>Here is the code:</p><pre class="programlisting">
//the extension method must be put in a static class
public static IObservable&lt;TcpClient&gt; AcceptObservableClient(this TcpListener listener)
{
    //start listening with a 4 clients buffer backlog
    listener.Start(4);

    return Observable.Create&lt;TcpClient&gt;(observer =&gt;
    {
        while (true)
        {
            //accept newly clients from the listener
            var client = listener.AcceptTcpClient();
            //route the client to the observer
            //into an asynchronous task to let multiple clients connect
              altogether
            Task.Factory.StartNew(() =&gt; observer.OnNext(client),
            TaskCreationOptions.LongRunning);
        }

        //mandatory to comply with the .Create action signature
        return Disposable.Empty;
    });
}
</pre><p>The operator will start listening for a remote connection with the help of a <code class="literal">TcpListener</code> object. Then, each client will flow out as a message within a sequence executing into an asynchronous <code class="literal">Task</code>, letting other clients connect to the same listener.</p><p>Now, we will see how to use this operator. Here is the code:</p><pre class="programlisting">
//convert a TcpListener into an observable sequence on port 23 (telnet)
var tcpClientsSequence = TcpListener.Create(23)
    .AcceptObservableClient();

//subscribe to newly remote clients
var observer = tcpClientsSequence.Subscribe(client =&gt;
{
    //remote endpoint (IP:PORT)
    var endpoint = client.Client.RemoteEndPoint as IPEndPoint;
    Console.Write("{0} -&gt; ", endpoint);
    //get the remote stream
    using (var stream = client.GetStream())
        while (true)
        {
            //read bytes until available
            var b = stream.ReadByte();
            if (b &lt; 0)
                break;
            else
                Console.Write((char)b);
        }
    Console.WriteLine();
    Console.WriteLine("{0} -&gt; END", endpoint);
    Console.WriteLine();
});
</pre><p>The preceding code is pretty easy. We will create a new <code class="literal">TcpListener</code> variable on <code class="literal">port 23</code>, and with the help of our newly created operator, we will obtain a sequence of <code class="literal">TcpClients</code>.</p><p>Now, we can subscribe to the remote client connection in the usual way. In this implementation, we will simply get access to the remote stream (we're using the stream as a read-only stream, but it accepts writes too) and we will wait until the end of the stream by evaluating the read byte value.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec91"></a>Case study - writing a reactive socket server</h3></div></div></div><p>Now, that we created the <code class="literal">AcceptObservableClient</code> operator, to create a complete socket server in Reactive Programming, we simply have to go a bit higher in the level of our design. <code class="literal">AcceptObservableClient</code> flows out very low level network programming objects (<code class="literal">TcpClient</code>), while we need an operator that flows out data messages. As a general choice, we will use <code class="literal">Byte</code>, as it is the only reusable data message that can contains any kind of other messages. In real world implementations, we will use specific business messages instead of general purpose <code class="literal">Byte</code> type messages.</p><p>We need to create another operator, the <code class="literal">AsNetworkByteSource</code>, which will route messages from the underlying <code class="literal">TcpClient</code> sequence into another sequence (of <code class="literal">Byte</code>) with a different granularity, because a single <code class="literal">TcpClient</code> variable flows out multiple or no <code class="literal">bytes</code>. This means that routing 10 <code class="literal">TcpClients</code> means not routing 10 <code class="literal">bytes</code> (usually more).</p><p>The operator will route the <code class="literal">KeyValuePair&lt;IPEndPoint, byte&gt;</code> messages to give us the ability to correlate multiple bytes of the same source.</p><p>Here is the code:</p><pre class="programlisting">
public static IObservable&lt;KeyValuePair&lt;IPEndPoint, byte&gt;&gt; AsNetworkByteSource(this IObservable&lt;TcpClient&gt; source)
{
    return Observable.Create&lt;KeyValuePair&lt;IPEndPoint, byte&gt;&gt;(observer =&gt;
    {
        using (var innerObserver = source.Subscribe(client =&gt;
            {
                using (var stream = client.GetStream())
                    while (true)
                    {
                        var b = stream.ReadByte();
                        if (b &lt; 0)
                            break;
                        else
                            observer.OnNext(new KeyValuePair&lt;IPEndPoint,
                            byte&gt;(client.Client.RemoteEndPoint
                            as IPEndPoint, (byte)b));
                    }
            }))
        {
            //dispose the innerObserver when completes
        }

        observer.OnCompleted();

        //mandatory to comply with the .Create action signature
        return Disposable.Empty;
    });
}
</pre><p>The code is similar to the one that we have already seen in the previous operator usage. The difference is that, here, we wrapped the <code class="literal">TcpClient</code> usage within a <code class="literal">Create</code> operator to flow out different messages.</p><p>Here is the usage code:</p><pre class="programlisting">
//convert a TcpListener into an observable sequence on port 23 (telnet)
var tcpClientsSequence = TcpListener.Create(23)
    .AcceptObservableClient()
    .AsNetworkByteSource();

Console.WriteLine("Subscribing...");
var bytesObserver = tcpClientsSequence.Subscribe(x =&gt;
{
    Console.WriteLine("{0} -&gt; {1} ({2})", x.Key, x.Value, (char)x.Value);
});
</pre><p>With this example, we can see that the usage complexity has been heavily reduced. We don't have to deal with low level <code class="literal">TcpClient</code> objects because we have already received bytes within our sequence together with the source IP and port detail.</p><p>Now, we need to abstract more of our code to deal with higher level messages. In the next example, we will consider a text row as a single message. This means that we need to move from per-byte messaging to per-row messaging without losing the client session isolation. To accomplish this task, we need the following flowchart:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Flow messaging of remote clients from <code class="literal">TcpListener</code>.</p></li><li><p>Convert <code class="literal">TcpClient</code> messaging into byte messaging.</p></li><li><p>Shape single byte messages into single-byte buffered messages to have the ability to manipulate byte buffers later.</p></li><li><p>Group byte buffers' messages per client session.</p></li><li><p>Within the single group subscription, create a client sequence of bytes.</p></li><li><p>Scan the client sequence to accumulate byte buffers until a CR and LF flows out.</p></li><li><p>Let flow out-only buffers that are correctly terminated.</p></li></ol></div><p>For a better understanding, here is the simplified flowchart:</p><p>
</p><div class="mediaobject"><img src="graphics/4954_07_01.jpg" /><div class="caption"><p>The flow chart of the TcpListener demo</p></div></div><p>
</p><p>Here is the complete example:</p><pre class="programlisting">
//convert a TcpListener into an observable sequence on port 23 (telnet)
var tcpClientsSequence = TcpListener.Create(23)
    .AcceptObservableClient()
    .AsNetworkByteSource();

//map the source message into another with a byte buffer of a single byte
var bufferUntileCRLFSequence = tcpClientsSequence
    .Select(x =&gt; new { x.Key, buffer = new[] { x.Value }.AsEnumerable() })
    //group by client session IPEndPoint (IP/Port)
    .GroupBy(x =&gt; x.Key);

//a crlf byte buffer
var crlf = new byte[] { 0x000d, 0x000a };

//subscribe to all nested sequence groups per remote endpoint
bufferUntileCRLFSequence.Subscribe(endpoint =&gt;
{
    var clientSequence = endpoint
        //apply an accumulator function to obtain the byte buffer per client
        //the function will check if the buffer terminates with the CRLF then in the case will create a new buffer otherwise it will concat the previous buffer with the new byte
        .Scan((last, i) =&gt; new { last.Key, buffer = last.buffer.Skip(last.buffer.Count() - 2).SequenceEqual(crlf) ? i.buffer : last.buffer.Concat(i.buffer) })
        //wait the CR+LF message to read per row
        .Where(x =&gt; x.buffer.Skip(x.buffer.Count() - 2).SequenceEqual(crlf));

    //subscribe to the client sequence
    clientSequence.Subscribe(row =&gt;
        Console.WriteLine("{0} -&gt; {1}", row.Key, Encoding.ASCII.GetString(row.buffer.ToArray())));
});
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec92"></a>Disposing Create&lt;T&gt;</h3></div></div></div><p>In the previous examples, we often saw the use of the <code class="literal">Create</code> operator to start flowing messages based on our needs without the right implementation of the <code class="literal">IDisposable</code> interface to handle multithreaded code because of editorial needs (shortness and readability). In a real-world application, mostly, it is a good idea to provide the right cancellation support to our sequences, although created with a low level <code class="literal">Create</code> operator.</p><p>Here is the complete example:</p><pre class="programlisting">
var sequence = Observable.Create&lt;int&gt;(observer =&gt;
{
    //a task is required for all time consuming activities
    Task.Factory.StartNew(() =&gt;
    {
        for (int i = 0; i &lt; 100; i++)
        {
            //lot of CPU time
            Thread.SpinWait(10000000);
            //diagnostic output
            Debug.WriteLine(string.Format("Flowing value: {0}", i));
            //flow out a message
            observer.OnNext(i);
        }

        observer.OnCompleted();
    });

    return Disposable.Empty;
});


var subscription = sequence.Subscribe(x =&gt; Console.WriteLine(x));

//wait 5 seconds
Thread.Sleep(1000);
//kill the subscription
subscription.Dispose();

Console.ReadLine();
</pre><p>The preceding example shows that although we can stop the subscription as we wish (effectively the observer stops receiving messages), the inner loop will continue wasting our resources. In the case of the usage of <code class="literal">Task</code> in the <code class="literal">Create</code> inner implementation, we can use the <code class="literal">Task</code> cancellation to gracefully stop the loop.</p><p>Here is an example:</p><pre class="programlisting">
var sequence = Observable.Create&lt;int&gt;(observer =&gt;
{
    var cts = new CancellationTokenSource();
    var token = cts.Token;

    var task = Task.Factory.StartNew(() =&gt;
    {
        for (int i = 0; i &lt; 100; i++)
        {
            //raise an exception to stop thread's execution on task cancellation
             request
            token.ThrowIfCancellationRequested();

            //lot of CPU time
            Thread.SpinWait(10000000);
            //diagnostic output
            Debug.WriteLine(string.Format("Flowing value: {0}", i));
            //flow out a message
            observer.OnNext(i);
        }
    }, token);

    //executes the following action at the subscription disposal
    return Disposable.Create(() =&gt; cts.Cancel());
});
</pre><p>This other implementation of the <code class="literal">Create</code> operator will correctly handle the subscription's disposal by stopping the inner loop from wasting resources.</p><p>If we are lazy, we can avoid implementing the <code class="literal">Disposable.Create</code> method by using a <code class="literal">Disposable</code> object from the <code class="literal">System.Reactive.Disposable</code> namespace. The direct substitute to raise a <code class="literal">Task</code> cancellation is <code class="literal">CancellationDisposable</code>:</p><pre class="programlisting">//raise the token cancellation at the disposal
return new CancellationDisposable(cts);
</pre><p>Other usable disposables are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">BooleanDisposable</code>: We can check for the dispose status with a Boolean flag</p></li><li style="list-style-type: disc"><p>
<code class="literal">ContextDisposable</code>: Routes the disposal to <code class="literal">SynchronizationContext</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">SerialDisposable</code>: We can change the underlying disposable object with a new one causing the old one's disposal</p></li><li style="list-style-type: disc"><p>
<code class="literal">CompositeDisposable</code>: Disposes multiple resources</p></li><li style="list-style-type: disc"><p>
<code class="literal">ScheduledDisposable</code>: We can schedule the disposal within our scheduler</p></li><li style="list-style-type: disc"><p>
<code class="literal">RefCountDisposable</code>: Waits for referred disposables that are already disposed before triggering the disposal of their inner disposable resources</p></li><li style="list-style-type: disc"><p>
<code class="literal">SingleAssignmentDisposable</code>: The underlying disposable resource can never change</p></li><li style="list-style-type: disc"><p>
<code class="literal">MultipleAssignmentDisposable</code>: We can reuse the inner disposable resource in other <code class="literal">MultipleAssignmentDisposable</code> objects</p></li></ul></div><p>In the rare case where we have still not found our right disposing design, as in the case where we don't have a loop that lets us check for the <code class="literal">Task</code> cancellation, we can still make a low-level <code class="literal">Thread</code> kill with the usage of the <code class="literal">Thread.Abort</code> method.</p><p>Here is an example:</p><pre class="programlisting">var sequence = Observable.Create&lt;int&gt;(observer =&gt;
{
    var thread = new Thread(new ThreadStart(() =&gt;
    {
        for (int i = 0; i &lt; 100; i++)
        {
            //lot of CPU time
            Thread.SpinWait(10000000);
            //diagnostic output
            Debug.WriteLine(string.Format("Flowing value: {0}", i));

            Thread.BeginCriticalRegion();
            //don't kill me here
            Thread.EndCriticalRegion();

            //flow out a message
            observer.OnNext(i);
        }
    }));

    thread.Start();

    //executes the following action at the subscription disposal
    return Disposable.Create(() =&gt; thread.Abort());
});
</pre><p>As is evident in the previous example, there is the ability to specify a <code class="literal">Critical</code> section to avoid killing <code class="literal">Thread</code> in a potentially dangerous code block. Although we have the ability to specify a <code class="literal">Critical</code> section, killing <code class="literal">Thread</code> is always something potentially dangerous because it may lead to state-drive systems in unwanted states or with data inconsistency that is usually difficult to diagnose.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec93"></a>Designing a custom provider</h3></div></div></div><p>When designing a custom operator is not enough for our needs, we can write a custom provider similar to what happens with LINQ.</p><p>Within the Rx world, we can write a custom provider by implementing the <code class="literal">IQbservable</code> interface. This interface acts in a similar way as the <code class="literal">IQueryable</code> interface of LINQ that exposes a query made by <code class="literal">Expression</code> that may contain any composition of <code class="literal">Linq.Expression</code> in a hierarchical structure that names the <code class="literal">Expression</code> tree.</p><p>The creation of a custom provider is outside the scope of this book because it needs deep LINQ knowledge and requires a lot of pages. As a suggestion to anyone wanting to try writing their own custom provider, there are valid examples and already made providers that can behave as a starting point to design the wanted provider.</p><p>A custom provider overview (MSDN) with a downloadable example can be found at the following link:</p><p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh242971(v=vs.103).aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/hh242971(v=vs.103).aspx
</a>
</p><p>The <code class="literal">IQbservable</code> interface (MSDN) is available at:</p><p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.reactive.linq.iqbservableprovider(v=vs.103).aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/system.reactive.linq.iqbservableprovider(v=vs.103).aspx
</a>
</p><p>The <code class="literal">IQbservable</code> over wire (Dave Sexton) can be found at the following link:</p><p>
<a class="ulink" href="http://davesexton.com/blog/post/LINQ-to-Cloud-IQbservable-Over-the-Wire.aspx" target="_blank">
http://davesexton.com/blog/post/LINQ-to-Cloud-IQbservable-Over-the-Wire.aspx
</a>
</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec46"></a>Designing a custom scheduler</h2></div></div><hr /></div><p>Usually, all the needed schedulers already exists. Although, sometimes, it may happen that we may need a custom scheduler because we may need to choose how to schedule our jobs by ourselves. In the next example, we will see how to create a scheduler to throttle message flowing based on the CPU time. The <code class="literal">CpuThrottlingScheduler</code> method will verify each message flowing if the CPU time is at the desired level. Then, eventually, the observer's implementation will receive the message in the context thread of the <code class="literal">ThreadPool</code> thread to achieve multithreading if multiple subscribers exist.</p><p>Here is the scheduler code:</p><pre class="programlisting">
/// &lt;summary&gt;
/// Enqueues unit of works only if the current CPU time is lower than the
/// specified limit.
/// &lt;/summary&gt;
public class CpuThrottlingScheduler : IScheduler, IDisposable
{
    public int CpuLimitPercentage { get; set; } = 80;
    public DateTimeOffset Now { get; private set; }

    private static PerformanceCounter cpuTimeCounter = new PerformanceCounter("Processor Information", "% Processor Time", "_Total");
    public IDisposable Schedule&lt;TState&gt;(TState state, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        while (true)
        {
            //checks the CPU time
            var cpu = cpuTimeCounter.NextValue();
            if (cpu &gt;= CpuLimitPercentage)
                Thread.Sleep(200);
            else
                break;
        }

        //once the CPU time is lower than the limit
        //enqueue the job on the thread pool
        new Thread(new ThreadStart(() =&gt; action(this, state))).Start();
        Now += TimeSpan.FromTicks(1);

        return Disposable.Empty;
    }

    /// &lt;summary&gt;
    /// Not supported! Will be scheduled immediately
    /// &lt;/summary&gt;
    public IDisposable Schedule&lt;TState&gt;(TState state, DateTimeOffset dueTime, Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        return Schedule&lt;TState&gt;(state, action);
    }

    /// &lt;summary&gt;
    /// Not supported! Will be scheduled immediately
    /// &lt;/summary&gt;
    public IDisposable Schedule&lt;TState&gt;(TState state, TimeSpan dueTime,
    Func&lt;IScheduler, TState, IDisposable&gt; action)
    {
        return Schedule&lt;TState&gt;(state, action);
    }

    public void Dispose()
    {
        cpuTimeCounter.Dispose();
    }
}
</pre><p>As can be seen, the class <code class="literal">CpuThrottlingScheduler</code> implements the <code class="literal">IScheduler</code> interface. In this implementation, we're not dealing with future scheduling because this kind of <code class="literal">scheduler</code> works best for immediate scheduling. The <code class="literal">Schedule</code> method body executes a check against the CPU time performance counter, waiting until the value is within the limit. Then, the job is sent to <code class="literal">ThreadPool</code> for execution.</p><p>Here is the usage code:</p><pre class="programlisting">
var scheduler = new CpuThrottlingScheduler() { CpuLimitPercentage = 50 };

//a simple looping sequence
var sequence = Observable.Range(0, 50, scheduler);

//a huge observer list
for (int i = 0; i &lt; 10; i++)
    sequence.Subscribe(x=&gt;
    {
        Thread.SpinWait(100000000);
        Console.WriteLine("{0} -&gt; {1}", Thread.CurrentThread.ManagedThreadId, x);
    });

Console.ReadLine();
</pre><p>As we have already seen in <a class="link" href="#" linkend="ch06">
Chapter 6
</a>, <span class="emphasis"><em>CLR Integration and Event Scheduling</em></span>, we're specifying the <code class="literal">scheduler</code> class as a parameter of the <code class="literal">Range</code> operator. Later, multiple observers will subscribe to the sequence by inheriting the same <code class="literal">scheduler</code> class of the underlying sequence. The scheduler configuration set a 50% time limit to the CPU usage; this means that wherever our other applications use the CPU time more than the limit, the <code class="literal">scheduler</code> class will continue throttling requests until the CPU time is lower than specified.</p><p>Although this implementation is too simplified for editorial needs, it shows us the powerfulness of the scheduling that supports complete customization.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec94"></a>Dealing with the scheduler state</h3></div></div></div><p>In the previous example about <code class="literal">IScheduler</code> implementation, we had the opportunity to see that the <code class="literal">scheduler</code> class supports a state value. Although in a reactive world, it is something odd to deal with, sometimes, we need the help of some external variables to complete our task.</p><p>Anytime we use external variables, an unintentional behavior may happen. Although a <code class="literal">Scheduler</code> schedules the execution of its jobs in the virtual time following its own order (the virtual time and then the registration time of jobs), this doesn't means that other involved CLR objects will do the same, eventually causing unwanted inconsistent data states. Take a look at <code class="literal">Thread</code> from <code class="literal">ThreadPool</code> or <code class="literal">Task</code> that will execute the inner job action; although <code class="literal">Scheduler</code> will follow the right order in firing these jobs, the CLR object may alter the right execution order by some milliseconds. This is why immediate scheduling may produce unpredictable behaviors that we should avoid. In case we cannot avoid this design, we could be in a situation like the following example:</p><pre class="programlisting">
int value = 0;

//a scheduler
var scheduler = Scheduler.Default;

//multiple immediate jobs
scheduler.Schedule(x =&gt; { value = 14; });
scheduler.Schedule(x =&gt; { Console.WriteLine(value); });
scheduler.Schedule(x =&gt; { value = 15; });
scheduler.Schedule(x =&gt; { Console.WriteLine(value); });
scheduler.Schedule(x =&gt; { value = 16; });
scheduler.Schedule(x =&gt; { Console.WriteLine(value); });
</pre><p>Although, usually, the result is correct, often, there is a repetition of the same value in the console output of this code.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"></a>Tip</h3><p>Respecting reactive jobs, this behavior of using the same external (and distant talking about layers) variable creates <code class="literal">Action</code> at a distance anti-pattern. More information on <code class="literal">Action</code> at a distance anti-pattern is available here:
<a class="ulink" href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)" target="_blank">https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)</a>
</p></div><p>To avoid this unwanted behavior, we can pass the state variable within the <code class="literal">Schedule</code> method instead of letting the <code class="literal">Lambda</code> function embed it into the <code class="literal">Lambda</code> scope itself. Here is an example:</p><pre class="programlisting">value = 14;
scheduler.Schedule&lt;int&gt;(value, (_scheduler, state) =&gt;
{
    Console.WriteLine(state);
    return Disposable.Empty;
});

value = 15;
scheduler.Schedule&lt;int&gt;(value, (_scheduler, state) =&gt;
{
    Console.WriteLine(state);
    return Disposable.Empty;
});

value = 16;
scheduler.Schedule&lt;int&gt;(value, (_scheduler, state) =&gt;
{
    Console.WriteLine(state);
    return Disposable.Empty;
});
</pre><p>This overload of the <code class="literal">Schedule</code> method accepts a state parameter and <code class="literal">Action</code> that contains <code class="literal">Scheduler</code> itself and the state parameter, as it was valued when the job was scheduled. A great difference from the previous example is that, although we cannot guarantee the execution order of CLR objects (<code class="literal">Threads</code>) involved in the execution, we can now guarantee that all the three values will output correctly.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec47"></a>Creating Pattern&lt;T&gt;</h2></div></div><hr /></div><p>The <code class="literal">Pattern&lt;T&gt;</code> is an odd kind of message that we can use to create flattened sequences of values sourcing from multiple sources.</p><p>As we have already seen in the <span class="emphasis"><em>Combining operators</em></span> section of <a class="link" href="#" linkend="ch03">
Chapter 3,
</a>
<span class="emphasis"><em>Reactive Extension Programming</em></span>, we can use the <code class="literal">Zip</code> operator to create a single output from multiple sources:</p><pre class="programlisting">
var values2 = Observable.Range(0, 100).Where(x =&gt; x % 2 == 0);
var values3 = Observable.Range(0, 100).Where(x =&gt; x % 3 == 0);
var values5 = Observable.Range(0, 100).Where(x =&gt; x % 5 == 0);

//flatten sourcing sequences into a new sequence
//based on the sourcing message index
var zip = values2.Zip(values3, values5, (a, b, c) =&gt; new { a, b, c });

Console.WriteLine("Zip:");
zip.Subscribe(x =&gt; Console.WriteLine(x));
</pre><p>Other than the <code class="literal">Zip</code> operator, the Rx library give us the ability to create <code class="literal">Pattern</code>, a group of messages sourcing from different sequences at the same speed by correlating messages with their index in the sourcing sequence.</p><p>Here is an example:</p><pre class="programlisting">
//create a pattern by grouping messages based on their index
var pattern = values2.And(values3).And(values5)
    //then produce a single output
    .Then((a, b, c) =&gt; new { a, b, c });

//creates a sequence from the pattern
var then = Observable.When(pattern);

Console.WriteLine("Then:");
then.Subscribe(x =&gt; Console.WriteLine(x));
</pre><p>The key operators of the preceding example are <code class="literal">And</code>, <code class="literal">Then</code>, and <code class="literal">When</code>. The <code class="literal">And</code> operator creates the pattern from the sourcing sequences. Multiple uses of the <code class="literal">And</code> operator will increase the sourcing sequence's availability, making it later available to the <code class="literal">Then</code> operator. The <code class="literal">Then</code> operator will shape all the sourcing messages into a single message similar to what happens with the selector <code class="literal">Action</code> of the <code class="literal">Zip</code> operator. The difference is that the <code class="literal">And</code> operator produces an output we can store somewhere, flow somehow, or schedule in time, while the selector <code class="literal">Action</code> of the <code class="literal">Zip</code> operator offers less programmability.</p><p>At the end of the example, the <code class="literal">Observable.When</code> operator will flatten the pattern into an observable sequence usable as we're now used to. Just to be clear, the <code class="literal">Pattern</code> class is unable to directly interact with the core Rx interfaces.</p><p>Another interesting feature is the ability to flatten multiple patterns within the <code class="literal">When</code> operator.</p><p>Here is an example:</p><pre class="programlisting">
//multiple patterns
var values7 = Observable.Range(0, 100).Where(x =&gt; x % 7 == 0);
var values9 = Observable.Range(0, 100).Where(x =&gt; x % 9 == 0);
var values11 = Observable.Range(0, 100).Where(x =&gt; x % 11 == 0);

var pattern79 = values7.And(values9).And(values11).Then((a, b, c) =&gt; new { a, b, c, });

//flatten multiple sourcing pattern into a new sequence
var then79 = Observable.When(pattern, pattern79);

//the message order will follow the sourcing patterns message index
Console.WriteLine("Then79:");
then79.Subscribe(x =&gt; Console.WriteLine(x));
</pre><p>As is evident in this last example, although the <code class="literal">Zip</code> operator is very powerful, the implementation based on <code class="literal">Pattern</code> made with the <code class="literal">And</code>/<code class="literal">Then</code>/<code class="literal">When</code> operators may give a higher programmability level and a great flexibility to use in our applications.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Implementing event sourcing with Rx</h2></div></div><hr /></div><p>
<span class="strong"><strong>Event Sourcing</strong></span> (<span class="strong"><strong>ES</strong></span>) is a software design that requires the persistence of events instead of results. In the <span class="emphasis"><em>Programming experience</em></span> section of <a class="link" href="#" linkend="ch01">
Chapter 1
</a>, <span class="emphasis"><em>First Steps Toward Reactive Programming</em></span>, we had the opportunity to understand how to persist data in a reactive way. Even though this is not mandatory using ES when programming reactive, this is the most natural way of dealing with data persistence from an observable sequence.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip33"></a>Tip</h3><p>Talking exhaustively about ES is outside the scope of this book. We will assume the reader already has some knowledge about ES. Otherwise, here are some details:
ES:<a class="ulink" href="https://msdn.microsoft.com/en-us/library/jj591559.aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/jj591559.aspx
</a>CQRS with Event Sourcing:<a class="ulink" href="https://msdn.microsoft.com/en-us/library/jj591577.aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/jj591577.aspx
</a>Further reading:
<span class="emphasis"><em>Microsoft .NET: Architecting Applications for the Enterprise</em></span>, <span class="emphasis"><em>2nd Edition</em></span>, <span class="emphasis"><em>Microsoft</em></span>.</p></div><p>By implementing the ES design instead of persisting results at specific dates, we persist data exactly as we receive it from an external system or a user. This means that if a user creates an invoice on a web application, we will persist what the user changes, not the result of any change.</p><p>Usually, when working with Rx and ES, we are already working with <span class="strong"><strong>Command/Query Responsibility Segregation</strong></span> (<span class="strong"><strong>CQRS</strong></span>). This design asks the subdivision of business object retrieval (<code class="literal">query</code>) and business object persistence (<code class="literal">command</code>) from a unique global business domain. In other words, we will divide a classic domain into two specialized domains with the need of dealing, persistence, or retrieval.</p><p>Within this design, Rx fits perfectly into the <code class="literal">Command</code> side. We can create commands as Rx messages that can flow throughout multiple sequence operators to apply all the required transformations, validations, and business logic. At the end, these messages will flow to a persistence observer that will be in charge of storing these messages into a dedicated database. To persist this kind of data, the best fitting choice is using a NoSQL database that is able to persist documents without having to deal with external languages as SQL or different data layouts as what happens within a relational database. Obviously, this doesn't mean that we cannot use a relational database. We can. In the real world, we should, because together with an event persistence, usually, we need to persist an updated state to address the future needs of data retrieval of the huge amounts of events to compute the right ending state. Different from what happens in normal state persistence, this is only a data cache.</p><p>When dealing with data persistence messages, the ES behaves excellently with CQRS because when we create a specific object to model any single event or action our system may receive, this mapping will be pretty perfect. Differently, think of a classic object model that tries to model in the same classes the needs of data reading for the UI, data validations for user input, data consistency checks for business needs, and so on. At best it is difficult, at worst we're left with a nightmare to maintain.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec95"></a>Creating and validating an invoice</h3></div></div></div><p>The following example will show how to create an invoice, validate an invoice, update an invoice detail, and add multiple validated items to get all the resulting calculations immediately. The example will not store data in a real persistence store. We will only take a look at the overall application's design. As already mentioned, any NoSQL database is the most fitting choice of doing such persistences, such as Microsoft DocumentDB, RavenDB, MongoDB, and so on.</p><p>Let's have some code. A simple validation framework is available to our application to make all the messages <code class="literal">validable</code> required within the observable sequence pipeline:</p><pre class="programlisting">
public interface IValidable { }

public interface IValidableObjectResult&lt;T&gt;
        where T : IValidable
{
    bool IsValid { get; }
    IEnumerable&lt;ValidationResult&gt; Result { get; }
    T Instance { get; }
}

public sealed class ValidableObjectResult&lt;T&gt; : IValidableObjectResult&lt;T&gt;
        where T : IValidable
{
    public bool IsValid { get; set; }
    public IEnumerable&lt;ValidationResult&gt; Result { get; set; }
    public T Instance { get; set; }
}

public static class ValidableObjectHelper
{
    /// &lt;summary&gt;
    /// Validates the argument
    /// &lt;/summary&gt;
    public static IValidableObjectResult&lt;T&gt; Validate&lt;T&gt;(T arg)
        where T : IValidable
    {
        var context = new ValidationContext(arg);
        var errors = new List&lt;ValidationResult&gt;();

        if (Validator.TryValidateObject(arg, context, errors))
            return new ValidableObjectResult&lt;T&gt;()
            {
                Instance = arg,
                IsValid = true,
                Result = Enumerable.Empty&lt;ValidationResult&gt;(),
            };
        else
            return new ValidableObjectResult&lt;T&gt;()
            {
                Instance = arg,
                IsValid = false,
                Result = errors.AsEnumerable(),
            };
    }
}
</pre><p>Now that we're ready to validate messages, we can create all the basic message types to flow invoice events. We will only map the invoice creation, update, and item addition events that act as commands regarding the event sourcing:</p><pre class="programlisting">
/// &lt;summary&gt;
/// Represents a command message
/// &lt;/summary&gt;
public interface ICommand { }

public class CreateNewInvoice : ICommand, IValidable
{
    [Required, Range(1, 100000)]
    public int InvoiceNumber { get; set; }

    [Required]
    public DateTime Date { get; set; }

    [Required(AllowEmptyStrings = false), StringLength(50)]
    public string CustomerName { get; set; }

    [Required(AllowEmptyStrings = false), StringLength(50)]
    public string CustomerAddress { get; set; }

    //apply updates
    public static CreateNewInvoice operator +(CreateNewInvoice invoice, UpdateInvoiceCustomerAddress updater)
    {
        if (!invoice.InvoiceNumber.Equals(updater.InvoiceNumber))
            throw new ArgumentException();

            return new CreateNewInvoice
            {
                InvoiceNumber = invoice.InvoiceNumber,
                Date = invoice.Date,
                CustomerName = invoice.CustomerName,
                CustomerAddress = updater.CustomerAddress,
            };
    }
}

public class UpdateInvoiceCustomerAddress : ICommand, IValidable
{
    [Required]
    public int InvoiceNumber { get; set; }

    [Required(AllowEmptyStrings = false), StringLength(50)]
    public string CustomerAddress { get; set; }
}

public class AddInvoiceItem : ICommand, IValidable
{
    [Required]
    public int InvoiceNumber { get; set; }

    [Required]
    public string ItemCode { get; set; }

    [Required(AllowEmptyStrings = false), StringLength(50)]
    public string Description { get; set; }

    [Required, Range(1, 10000)]
    public int Amount { get; set; }

    [Required, Range(-10000, 10000)]
    public decimal Price { get; set; }

    public decimal TotalPrice { get { return Amount * Price; } }
}
</pre><p>In the preceding code, there is an interesting method, the operator <code class="literal">+</code> that specifies the result of the addition of a <code class="literal">CreateNewInvoice</code> object with an <code class="literal">UpdateInvoiceCustomerAddresss</code> object. This lets multiple updating objects create newly running (updated) totals regarding the invoice's details. Later, we will see the usage.</p><p>Now, all the requirements are already set. The first step is having a subject to deal with that acts as a sequence for messages and targets for user inputs:</p><pre class="programlisting">
//the root sequence of all user input messages
var commandSource = new Subject&lt;ICommand&gt;();

//register the diagnostic output of all messages
commandSource.Materialize().Subscribe(Console.WriteLine);
</pre><p>Now that we have the sourcing sequence and a useful live logging system, we will create a reusable validation result sequence to route validation results from the commands flowing within our sequence:</p><pre class="programlisting">
//register validation error output
var validables = commandSource
    //routes only validable messages
    .OfType&lt;IValidable&gt;()
    //convert messages into validation results
    .Select(x =&gt; ValidableObjectHelper.Validate(x));

//filter in search of invalid messages
validables.Where(x =&gt; !x.IsValid)
    //notify the error on the output
    .Subscribe(x =&gt; Console.WriteLine("Validation errors: {0}", string.Join(",", x.Result)));
</pre><p>With this sequence, we can easily evaluate invalid messages and produce outputs, as we saw  in the preceding example. The same sequence is useful for producing results against valid messages. Mainly, there are two different types of valid messages we can see flowing: invoice detail messages and invoice item messages. To get the running total amount of the invoice, we need to filter the desired messages from other messages (with the <code class="literal">OfType</code> operator). Then, we need to group per invoice number and get the running total by applying an accumulator function:</p><pre class="programlisting">
//filter in search of valid messages
validables.Where(x =&gt; x.IsValid)
    //get back the command message
    .Select(x =&gt; x.Instance as ICommand)
    //routes only invoice item messages
    .OfType&lt;AddInvoiceItem&gt;()
    //group items per invoice
    .GroupBy(x =&gt; x.InvoiceNumber)
    .Subscribe(group =&gt; group
        //project the message to a new shape for getting the result
        .Select(x =&gt; new { NewItem = x, TotalPrice = x.TotalPrice })
        //apply the accumulator function to get the result
        .Scan((old, x) =&gt; new { NewItem = x.NewItem, TotalPrice = old.TotalPrice +
        x.TotalPrice })
        //output the result
        .Subscribe(x =&gt; Console.WriteLine("Current total amount: {0:N2}",
        x.TotalPrice))
    );
</pre><p>Similarly, we will filter, group, shape, and accumulate values regarding the invoice detail messages. But here, we will use the operator we've just created to add invoice detail and invoice detail update messages to get a new message with the last state:</p><pre class="programlisting">
//filter in search of valid messages
validables.Where(x =&gt; x.IsValid)
    //get back the command message
    .Select(x =&gt; x.Instance as ICommand)
    //routes only new invoices or invoice updates messages
    .Where(x =&gt; x is CreateNewInvoice || x is UpdateInvoiceCustomerAddress)
    //group items per invoice
    .GroupBy(x =&gt; x is CreateNewInvoice ? (x as CreateNewInvoice).InvoiceNumber :
    (x as UpdateInvoiceCustomerAddress).InvoiceNumber)
    .Subscribe(group =&gt; group
        //apply the updates to get the last state
        //a custom "+" operator to apply updates to the original invoice
        //is available into the CreateNewInvoice class
        .Scan((old, x) =&gt; x is CreateNewInvoice ? x as CreateNewInvoice : (old as
        CreateNewInvoice) + (x as UpdateInvoiceCustomerAddress))
        //change type
        .OfType&lt;CreateNewInvoice&gt;()
        //output the new invoice details
        .Subscribe(x =&gt; Console.WriteLine("Available an invoice nr: {0} to {1}
         living in {2}", x.InvoiceNumber, x.CustomerName, x.CustomerAddress))
    );
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec96"></a>Event sourcing an invoice creation</h3></div></div></div><p>Now, we're ready to execute a simple test to check the usage of all the commands:</p><pre class="programlisting">
Console.WriteLine("Return to start saving an invoice");
Console.ReadLine();

var invoicenr = new Random(DateTime.Now.GetHashCode()).Next(0, 1000);
//create a new invoice

commandSource.OnNext(new CreateNewInvoice { InvoiceNumber = invoicenr, Date = DateTime.Now });
//now a validation error will flow out the sequence
Console.WriteLine("Return to continue");
Console.ReadLine();

//create a valid invoice
commandSource.OnNext(new CreateNewInvoice { InvoiceNumber = invoicenr, Date = DateTime.Now.Date, CustomerName = "Mr. Red", CustomerAddress = "1234, London Road, Milan, Italy" });
Console.WriteLine("Return to continue");
Console.ReadLine();

//updates the invoice customer address
commandSource.OnNext(new UpdateInvoiceCustomerAddress { InvoiceNumber = invoicenr, CustomerAddress = "1234, Milan Road, London, UK" });
Console.WriteLine("Return to continue");
Console.ReadLine();

//adds some item
commandSource.OnNext(new AddInvoiceItem { InvoiceNumber = invoicenr, ItemCode = "WMOUSE", Price = 44.40m, Amount = 10, Description = "Wireless Mouse" });
Console.WriteLine("Return to continue");
Console.ReadLine();

commandSource.OnNext(new AddInvoiceItem { InvoiceNumber = invoicenr, ItemCode = "DMOUSE", Price = 17.32m, Amount = 5, Description = "Wired Mouse" });
Console.WriteLine("Return to continue");
Console.ReadLine();

commandSource.OnNext(new AddInvoiceItem { InvoiceNumber = invoicenr, ItemCode = "USBC1MT", Price = 2.00m, Amount = 100, Description = "Usb cable 1mt" });

Console.WriteLine("END");
Console.ReadLine();
</pre><p>The overall result is an application to flow commands to subscribers that will inform users of the eventually available validation errors or will flow messages to the right accumulator functions to inform the user of the last invoice status.</p><p>Although the example is very simple and lacks in any kind of UI, it should show the difference with state-driven programming when dealing with invoice creation. An activity that usually any developer will be familiar with. To store messages into a database, simply save valid messages. Nothing more. We simply store commands without any transformation. Later, when we need to read back these messages from the database, we can get them back into another (or the same) sequence and they will be available to the application with the same behavior of the new messages. This is the difference with the state-driven system. Here, we can review whole command history read from a database instead of getting the only the final result.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Creating Interactive Extensions (Ix) operators</h2></div></div><hr /></div><p>Ix is the LINQ-based operator library that contains operators similar to the ones available within Rx. The design goal of developing a library like Ix is reusing designs and solutions from reactive programming to state-driven programming.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"></a>Tip</h3><p>The following examples require referencing the NuGet package <code class="literal">Ix-Main</code>.</p></div><p>This library is powerful to help developers get access operators reactive, like into classic state-drive <span class="strong"><strong>Programming with LINQ</strong></span> (<span class="strong"><strong>PLINQ</strong></span>), without having to convert in sequences and back all enumerables. The usage is almost identical to the one with real Rx operators; the difference is that within Ix, there is the support of only a short list of operators. Let's see some operators in action:</p><pre class="programlisting">
var buffer = Enumerable.Range(0, 1000)
    //split enumerable into multiple buffers
    .Buffer(100);

//enumerate from the first enumerable
//in case of exception continue enumerating
//from the second enumerable
//similarly there is the OnErrorResumeNext operator
var catched = Enumerable.Range(0, 1000).Catch(Enumerable.Range(0, 1000));

//returns a list from a single instance
var returned = EnumerableEx.Return(10);

//retry if an error occurs
var retry = Enumerable.Range(0, 1000).Retry(10);

//creates an enumerable from a yielder
var enumerable = EnumerableEx.Create&lt;int&gt;(async yielder =&gt;
{
    for (int i = 0; i &lt; 1000; i++)
        await yielder.Return(i);
});

//start yelding values
var enumerableValues = enumerable.ToArray();

//opposite of Any
enumerable.IsEmpty();

//create a finite buffer of values
//materializing values only on usage
//instead ToArray/ToList always materialize
//act as a cache of elements from the source enumerable
var memoized = enumerable.Memoize();

//cause memoize to materialize the internal collection
var firstValue = memoized.FirstOrDefault();

//accumulator function
var runningTotal = enumerable.Scan((old, x) =&gt; old + x);
</pre><p>This is only a short list, even though there are very interesting operators, such as <code class="literal">Memoize</code> (caches enumerable data), <code class="literal">Scan</code> (accumulate running totals), <code class="literal">Catch</code>/<code class="literal">OnErroResumeNext</code> for exception handling, and so on.</p><p>Another useful list is available here:</p><p>

<a class="ulink" href="https://www.infoq.com/news/2011/07/Ix" target="_blank">https://www.infoq.com/news/2011/07/Ix</a>

</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec50"></a>Summary</h2></div></div><hr /></div><p>In this chapter, you have seen Rx internals at work with the ability to create custom implementations or operators and schedulers. You even have an idea of how to create custom providers. Together, we had the opportunity to look at some case studies that help to illustrate more realistic implementations of Rx-based applications.</p><p>In the next chapter, we will see how to deal with classic functional F# programming and how to use F# in FRP.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch08"></a>Chapter 8. F# and Functional Reactive Programming</h2></div></div></div><p>F# (pronounced as F sharp) is an open source programming multiparadigm language introduced for the first time by Microsoft in Visual Studio 2010. F# is a first class member of the .NET Framework languages and derives from the ML family of functional languages. F# supports the functional paradigm in addition to the traditional object-oriented and imperative paradigm of the Microsoft .NET Framework. Microsoft Visual F# is the real language implementation of Visual Studio. In the previous chapters, we have already seen some examples of functional programming (the <span class="emphasis"><em>Functional programming</em></span> section of <a class="link" href="#" linkend="ch01">
Chapter 1</a>, <span class="emphasis"><em>First Steps Toward Reactive Programming</em></span>
) written in C# using Reactive Programming concepts.</p><p>In the next two chapters, we will extend the information combining F# and Rx to introduce and understand <span class="strong"><strong>Functional Reactive Programming</strong></span> (<span class="strong"><strong>FRP</strong></span>).</p><p>In particular, in this chapter, we will see the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The F# language and its syntax as an introduction to Functional Programming</p></li><li style="list-style-type: disc"><p>The key points to differentiate object-oriented and functional paradigm</p></li><li style="list-style-type: disc"><p>Functional design pattern (<span class="strong"><strong>Active Pattern</strong></span>, <span class="strong"><strong>Pattern Matching</strong></span>, choice result, and so on) and the types to implement them</p></li><li style="list-style-type: disc"><p>Asynchronous programming in F#</p></li><li style="list-style-type: disc"><p>Introduction to F# for Reactive Programming</p></li><li style="list-style-type: disc"><p>A few examples based on collections and the F# Rx functions</p></li><li style="list-style-type: disc"><p>The concepts of asynchronous data flow and push-pull bases through a real scenario</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec51"></a>F# - first time</h2></div></div><hr /></div><p>When we use .NET Framework, the first thought goes to languages such as C# and VB.NET. If you want to write a program or services using a functional paradigm, probably your choice would include other languages, for example, Erlang, Haskell, Scala, Wolframe Language (Mathematica), and so on.</p><p>This occurs for a variety of reasons, such as the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The .NET Framework and its principal languages are related to object-oriented programming</p></li><li style="list-style-type: disc"><p>The syntax of F# and the applications in the functional paradigm are totally different from any other .NET language</p></li><li style="list-style-type: disc"><p>F# was born in Microsoft research and later used in specific sectors and environments</p></li><li style="list-style-type: disc"><p>More functional languages, some of which were created many years before, were thought of exclusively for this paradigm</p></li></ul></div><p>Contrary to the reasons just written, F# is a very interesting language, because it combines the potential of the .NET Framework with a simple syntax and the functional paradigm.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec97"></a>Introduction to F# and FRP</h3></div></div></div><p>F# is different from the C# and VB.NET languages. This is mainly due to the basic paradigm.</p><p>The principal features of F# are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The types are immutable</p></li><li style="list-style-type: disc"><p>The concept of null values does not exist</p></li><li style="list-style-type: disc"><p>The concurrence never occurs if the context is purely functional</p></li><li style="list-style-type: disc"><p>The intrinsically multiprocessor approach for the reasons listed above</p></li></ul></div><p>Moreover, writing functions in F# is very simple and advantageous because the syntax is very concise:</p><pre class="programlisting">
let sum a b = a + b
let add5 = sum 5
let result = add5 2 // the result value is 7
let result2 = add5 3 // the result value is 8
</pre><p>As you can see in the first row of the previous example, a <code class="literal">sum</code> function is declared between two values (<code class="literal">a</code>, <code class="literal">b</code>). In the second row, the function <code class="literal">add5</code> is equivalent to <code class="literal">sum 5</code>, where <code class="literal">5</code> is the value of the parameter <code class="literal">a</code>. The <code class="literal">add5</code> variable is a partial function because we have to declare the second parameter if we want to execute <code class="literal">sum</code>, as we can see in <code class="literal">result</code> and <code class="literal">result2</code>:</p><pre class="programlisting">[0..100] |&gt; List.map (fun x -&gt; x * x)
   |&gt; List.iter (fun y -&gt; printfn "the value is: %i " y)
</pre><p>Instead, in the preceding example, you have more instructions concatenated with the <code class="literal">|&gt;</code> (pipe forward) operator. In particular, declare a list of <code class="literal">int</code>. After this, for each value, it is applied to the square and it returns a new list. In the end, through <code class="literal">List.iter</code>, print a visual result value.</p><p>By using C# and <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>), the code to write these functions will be bigger than in F#. Instead, by using the functional paradigm with C#, the result would be more or less the same.</p><p>The functions <code class="literal">iter</code> and <code class="literal">map</code> are also a useful example to introduce the FRP.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec98"></a>The immutable and deduce type</h3></div></div></div><p>One of the most important features of F# is the immutability. This is fundamental to writing a function that respects the algebraic principles:</p><pre class="programlisting">//C# code
int x = 5;
x = x + 1;
</pre><p>In mathematics, no value attributed to <code class="literal">x</code> could solve the function <code class="literal">x = x + 1</code>. In F#, writing this code directly, without using the keyword <code class="literal">mutable</code>, would generate the following error:</p><pre class="programlisting">//F# code:
let x = 5
x &lt;- x + 1

error FS0027: This value is not mutable
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"></a>Tip</h3><p>The operator <code class="literal">&lt;-</code> indicates the allocation of the value to the right on the left-hand side (called variable). It is conceptually equal to the <code class="literal">=</code> operator in C# or VB.NET.</p></div><p>To execute this code correctly, it will be sufficient to change the declaration of <code class="literal">x</code> in the following way:</p><pre class="programlisting">let mutable x = 6
</pre><p>The result of the operation using <code class="literal">F# Interactive</code> is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_001.jpg" /></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>
<code class="literal">F# Interactive</code> is a tool available in Microsoft Visual Studio used to run F# directly. It also exists in another version called <code class="literal">Fsi.exe</code> and you can find it in the path <code class="literal">c:\Program Files (x86)\Microsoft SDKs\F#\ &lt;version&gt;\Framework\ &lt;version&gt;\</code>.</p></div><p>They both allow you to run F # code and the file <code class="literal">.fsx</code> (F# script).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p>Performing the code is simple: you just have to select rows of interest and press <span class="strong"><strong>Alt</strong></span> + <span class="strong"><strong>Enter</strong></span> or right-click and use the command <code class="literal">Execute In Interactive</code>. The selected text will be executed by generating a result or an exception.</p><p>
Instead, if you want to run script files, it's preferable to use <code class="literal">Fsi.exe</code> from the windows console by specifying the file path; in this way, you will get the result in real time in the output window.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec5"></a>Type inference</h4></div></div></div><p>Another important feature of the language is its ability to <span class="emphasis"><em>interpret the types</em></span>. In reality, this is not a real characteristic, but a technique for the system to deduce the type.</p><p>Indeed, F# has a powerful type inference system. Take a look at the following code:</p><pre class="programlisting">//declare a tuple
let tupleValues = 1, "one"

//unpack values
let v1, v2 = tupleValues

let sumfloat values = List.reduce (+) values
printfn "The sum is: %A" (sumfloat [4.6; 10.3])
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"></a>Tip</h3><p>
<code class="literal">List.reduce</code> is a function applicable to a list of values and reduces two elements of a collection to a single one. In the preceding example, the function <code class="literal">List.reduce (+) values</code> adds the first two elements of the collection. Then, the result is processed with the third element and so on, until the final result is obtained.</p><p>
The same operation could be written using the operator pipe forward:
<code class="literal">values |&gt; List.reduce (fun x y -&gt; x + y)</code> or
<code class="literal">values |&gt; List.reduce (+)</code>
</p></div><p>In this example, in the first four lines, we have declared a <code class="literal">tuple</code> from which individual values are extracted. The result in the console F # Interactive is the following:</p><pre class="programlisting">val tupleValues : int * string = (1, "one")
val v2 : string = "one"
val v1 : int = 1
</pre><p>Due to the inherent ability to infer the type, the compiler links <code class="literal">v1</code> and <code class="literal">v2</code> with the correct type, respectively, <code class="literal">int</code> and string. Similarly, for the subsequent lines, the first use of the function <code class="literal">sumfloat</code> is deduced by the declaration of the <code class="literal">float</code> type items of the list <code class="literal">[4.6</code>; <code class="literal">10.3]</code>. The result is as follows:</p><pre class="programlisting">The sum is: 14.9
val sumfloat : values:float list -&gt; float
</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec99"></a>Functions as first class values</h3></div></div></div><p>The title of this section is not easy to understand. It is true that the functions are the basis of F# and its paradigm, but first class values does not mean anything.</p><p>However, to make sense of these words, you need to think in functional programming sense.</p><p>The key to understand this is much easier than you might think.</p><p>F# is a functional language and, as such, it is functional-oriented.</p><p>This is one main difference compared to the other .NET languages, which are object-oriented.</p><p>Moreover, if one considers the functions in F#, they are everywhere. All of the examples, even the rows, done so far are functions!</p><p>Even the simplest of instructions, <code class="literal">let x = 5</code>, is a function.</p><p>For correctness, it is good to talk about identities and not pure values. In fact, when you declare an identifier assigning a value, it can no longer be changed.</p><p>Being functional-oriented forces F# to comply with certain rules and to have some benefits and drawbacks.</p><p>The rules are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A function cannot change the status of the program</p></li><li style="list-style-type: disc"><p>The result of the function cannot be influenced from the outside</p></li><li style="list-style-type: disc"><p>Regarding immutability, each identifier is considered as a value and then it can be passed as a parameter or simply be the result of a function itself</p></li></ul></div><p>The benefits are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The factoring and refactoring is a plus with F# and its functions. Refactoring in F# does not require significant time and does not impact the entire project as in C#. This is true only if we apply functional paradigm.</p></li><li style="list-style-type: disc"><p>The pattern of composition is the basis of functional programming. In this way, you can interpret and solve any problem, from the most complex one to the simplest. Any function can be divided into simpler functions.</p></li><li style="list-style-type: disc"><p>The functional programming and, in particular, the syntax of functions make the code more concise and thus easier to maintain.</p></li></ul></div><p>The drawbacks are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>F# is a functional programming language; consequently, it is mathematics-oriented, and writing functional code could take much more time than writing object-oriented code.</p></li><li style="list-style-type: disc"><p>It is not convenient to develop a whole application using F#, because both the development tools and some aspects of the project, such as the GUI, are not optimized for this language.</p></li></ul></div><p>Naturally, these features are valid only in a functional context. By declaring an identifier using the keyword mutable, as seen previously, you can change the value of the identifier itself.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>In mathematics, a function can be represented in this way: <span class="emphasis"><em>y = f(x)</em></span>. Also, given a function, the same input value will give the same output value.
This rule is one of the reasons why, in F#, it's easier to code and avoid concurrency.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec100"></a>Using the Type function for object-oriented programming</h3></div></div></div><p>F# is <span class="emphasis"><em>not only a</em></span> functional programming language. This is a fundamental principle to remember. By definition, F# is a programming language that provides support for functional programming in addition to traditional object-oriented and imperative (procedural) programming.</p><p>If you want object-oriented programming in F#, the language makes all the necessary constructs available. One of the main types of object-oriented programming is <span class="emphasis"><em>classes</em></span>.</p><p>The syntax to declare a class is as follows:</p><pre class="programlisting">type CustomerName(firstName : string, middleName, lastName) =
    member __.FirstName = firstName
    member __.MiddleName = middleName
    member __.LastName = lastName
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"></a>Tip</h3><p>The keyword <code class="literal">__</code> is the equivalent of the keyword <code class="literal">this</code> in C#.</p></div><p>In the first row of the previous example, the keyword type suggests that <code class="literal">CustomerName</code> is a class. Unlike C#, you can see that the constructor signature is declared in the same row.</p><p>Instead, the keyword member indicates all the class members. In this particular case, members are properties, but they could be also methods.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>It is very important to point out that let declarations in the classes have the same meaning as a private member in C#.</p></div><p>In the following example, you can observe how the signature of the <code class="literal">member</code> method is declared and one of these <code class="literal">this.SetMutable</code> method allows us to change the mutable value of the private member:</p><pre class="programlisting">type MyClass(intParam : int, strParam : string) =
    let mutable mutableValue = 42
    member this.SetMutable x = mutableValue &lt;- x
    member this.CurriedAdd x y = x + y
    member this.TupleAdd(x,y) = x + y
</pre><p>Like in C# and VB, in these functional languages, derivate and abstract class concepts exist:</p><pre class="programlisting">type DerivedClass(param1, param2) =
   inherit BaseClass(param1)

[&lt;AbstractClass&gt;]
type GeometricBaseClass() =
   abstract member Add: int -&gt; int -&gt; int  // abstract method
   abstract member Pi : float // abstract immutable property
   abstract member Area : float with get,set // abstract read/write property
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Tip</h3><p>It is interesting to see how the signature of the <code class="literal">add</code> method is written. Regarding <code class="literal">int -&gt; int -&gt; int</code>, the first two stand for parameters, and the last one is the result.</p></div><p>The code to declare <code class="literal">interface</code> is similar to the abstract class signature, as you can see in the following example:</p><pre class="programlisting">type IGeometricBase =
   abstract member Add: int -&gt; int -&gt; int  // abstract method
   abstract member Pi : float // abstract immutable property
   abstract member Area : float with get,set // abstract read/write property
</pre><p>The main syntax difference between the <code class="literal">abstract</code> class and <code class="literal">interface</code> is the signature. In the first one, the parenthesis must be written straight after the name, contrary to the other one.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec101"></a>Collection – The heart of F#</h3></div></div></div><p>In the .NET Framework, when it comes to collections, the first thing that comes to mind is the <span class="strong"><strong>Language Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>). It is a revolutionary component, included for the first time in .NET version 3.5, which provides a set of instructions and keywords to query objects, in particular, collections.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p>The peculiarity of LINQ is its origin with functional nature. LINQ implements the functional paradigm through the use of query expressions, through extension methods, and the lambda expression related to the collections of the namespace <code class="literal">System.Collection.Generic</code>.</p></div><p>It is easy to see at this point how important the collections and all that concerns them are.</p><p>In F#, there are three major types of collection: <code class="literal">array</code>, <code class="literal">list</code>, and <code class="literal">n</code>. Each of them exhibits a set of functions and properties to elaborate the collection themselves.</p><p>
<code class="literal">Array</code>, by definition, is fixed-size, zero-based, mutable collection of consecutive data elements that are all of the same type:</p><pre class="programlisting">let myArr1 = [| 'a'; 'b'; 'c' |]
</pre><p>The <code class="literal">myArr1</code> variable identifies an array of chars. The keywords <code class="literal">[| |]</code> are used to declare <code class="literal">array</code> and, in this case, the values are entered by separating them with a semicolon(<code class="literal">;</code>).</p><p>There are many other ways to create <code class="literal">array</code>, and <code class="literal">array</code> of different dimension exist. Some of them are shown in the following examples:</p><pre class="programlisting">let myArr2 = [| 1 .. 5 |]
let myArr3 = [| for i in 1 .. 5 -&gt; i * i |]
let arrayOfZeroes : int array = Array.zeroCreate 5
let multiArr = [| [|0,0|]; [|1,1|] |]
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip44"></a>Tip</h3><p>The keyword <code class="literal">..</code> specifies an interval of values and is an abbreviation of <code class="literal">for .. in.</code> Moreover, there is a variant that allows us to insert an increment value, as follows:</p></div><pre class="programlisting">let arr = [|0..4..16|]
//val arr : int [] = [|0; 2; 4; 6; 8; 10; 12; 14; 16|]
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Tip</h3><p>The function <code class="literal">Array.zeroCreate</code> creates an array with five values set to <code class="literal">0</code>. There are many different ways to enter the items. It is important to remember that the value between square brackets refers to the position in zero-based.</p></div><pre class="programlisting">let a = myArr2.[1] // 2
let b = myArr2.[2..] // 3,4,5
let c = myArr2.[..2] // 1,2,3
let d = multiArr.[1] // [|(1, 1)|]

myArr2.[1 ] &lt;- 3 // to change a value
</pre><p>List, in F#, is an ordered and immutable series of elements of the same type. The syntax is not very different other than the keywords used for declaration; <code class="literal">list</code> uses <code class="literal">[ ]</code> and array uses <code class="literal">[| |]</code>:</p><pre class="programlisting">let myList2 = [ 1 .. 5 ]
let myList3 = [ for i in 1 .. 5 -&gt; i * i ]
let list = [0..2..16]
let a = myList2.[1] // 2
let b = myList2.[2..] // 3,4,5
let c = myList2.[..2] // 1,2,3
</pre><p>A sequence can be easily confused with <code class="literal">list</code> because both the collections are used to represent an ordered and huge series of elements, all of the same type. However, sequences, unlike lists, are useful if you do not want to use all the elements of the collection.</p><p>Elements can represent numerous data structures and can be managed in many different ways, for example, through some operations, such as grouping, counting, and extracting functions.</p><p>In F#, sequences are defined with the syntax <code class="literal">seq&lt;T&gt;</code> also known as <code class="literal">IEnumerable&lt;T&gt;</code>, as you can see in the following example:</p><pre class="programlisting">let myseq1 = seq { 0 .. 10 .. 100 }
let myseq2 = seq { for i in 1 .. 5 do yield i * i }
let myList3 = Seq.init 5 (fun n -&gt; n * 5)
</pre><p>The real power of arrays, lists, and sequences is their ability to manipulate data using their methods and the possibility to concatenate methods through the pipe operator or others.</p><p>In the following example, you can notice how simple it is to transform data and type collection only with a few instructions using the type array, sequence, and list. In the end, values are printed:</p><pre class="programlisting">[| 1 .. 100 |]
    |&gt; Seq.ofArray
    |&gt; Seq.map (fun x -&gt; x * x)
    |&gt; List.ofSeq
    |&gt; List.iter (fun y -&gt; printfn "the value is: %i " y)
</pre><p>The code also suggests how essential it is to know collections and their methods. As you can see in the following table, there are so many methods and overloads of them that could be useful having on hand the table with all the possibilities (refer to complete table MSDN link <a class="ulink" href="https://msdn.microsoft.com/en-us/library/hh967652.aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/hh967652.aspx)
</a>. Take a look at the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Function</strong></span>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Array</strong></span>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>List</strong></span>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Seq</strong></span>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">append</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a new collection that contains the elements of the first collection, followed by elements of the second collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">add</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a new collection with the element added.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">average</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the average of the elements in the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">averageBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the average of the results of the provided function applied to each element.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">blit</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Copies a section of an array.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">cache</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Computes and stores elements of a sequence.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">cast</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Converts the elements to the specified type.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">choose</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function <code class="literal">f</code> to each element <code class="literal">x</code> of the list. Returns the list that contains the results for each element where the function returns <code class="literal">Some(f(x))</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">collect</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to each element of the collection, concatenates all the results, and returns the combined list.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">compareWith</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Compares two sequences by using the given comparison function element by element.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">concat</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Combines the given enumeration-of-enumerations as a single concatenated enumeration.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">contains</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns true if the set contains the specified element.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">containsKey</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Tests whether an element is in the domain of a map.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">count</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the number of elements in the set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">countBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a key generating function to each element of a sequence, and returns a sequence that yields unique keys and their number of occurrences in the original sequence.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">copy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Copies the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">create</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates an array of whole elements that are all initially the given value.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">delay</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that's built from the given delayed specification of a sequence.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">difference</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a new set with the elements of the second set removed from the first set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">distinct</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence, later occurrences are discarded.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">distinctBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys that the given key generating function returns. If an element occurs multiple times in the sequence, later occurrences are discarded.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">empty</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates an empty collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">exists</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Tests whether any element of the sequence satisfies the given predicate.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">exists2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Tests whether any pair of corresponding elements of the input sequences satisfies the given predicate.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">fill</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sets a range of elements of the array to the given value.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">filter</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a new collection that contains only the elements of the collection for which the given predicate returns <code class="literal">true</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">find</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the first element for which the given function returns true. Returns <code class="literal">KeyNotFoundException</code> if no such element exists.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">findIndex</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the index of the first element in the array that satisfies the given predicate. Raises <code class="literal">KeyNotFoundException</code> if no element satisfies the predicate.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">findKey</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Evaluates the function on each mapping in the collection, and returns the key for the first mapping where the function returns true. If no such element exists, this function raises <code class="literal">KeyNotFoundException</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">fold</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is <code class="literal">f</code> and the elements are <code class="literal">i0...iN</code>, this function will compute <code class="literal">f (...(f s i0)...) iN</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">fold2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to the corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is <code class="literal">f</code> and the elements are <code class="literal">i0...iN</code> and <code class="literal">j0...jN</code>, this function will compute <code class="literal">f (...(f s i0 j0)...) iN jN</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">foldBack</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is <code class="literal">f</code> and the elements are <code class="literal">i0...iN</code>, this function will compute <code class="literal">f i0 (...(f iN s))</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">foldBack2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to the corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are <code class="literal">i0...iN</code> and <code class="literal">j0...jN</code>, this function will compute <code class="literal">f i0 j0 (...(f iN jN s))</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">forall</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Tests whether all the elements of the collection satisfy the given predicate.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">forall2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Tests whether all the corresponding elements of the collection satisfy the given predicate pairwise.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">get / nth</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns an element from the collection given its index.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">head</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the first element of the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">init</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates a collection given the dimension and a <code class="literal">generator</code> function to compute the elements.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">initInfinite</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Generates a sequence that, when iterated, returns successive elements by calling the given function.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">intersect</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Computes the intersection of two sets.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">intersectMany</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Computes the intersection of a sequence of sets. The sequence must not be empty.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">isEmpty</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns <code class="literal">true</code> if the collection is empty.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">isProperSubset</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns <code class="literal">true</code> if all the elements of the first set are in the second set, and at least one element of the second set isn't in the first set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">isProperSuperset</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns <code class="literal">true</code> if all the elements of the second set are in the first set, and at least one element of the first set isn't in the second set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">isSubset</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns <code class="literal">true</code> if all the elements of the first set are in the second set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">isSuperset</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns <code class="literal">true</code> if all the elements of the second set are in the first set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">iter</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to each element of the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">iteri</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to each element of the collection. The integer that's passed to the function indicates the index of the element.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">iteri2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to a pair of elements that are drawn from matching indices in two arrays. The integer that's passed to the function indicates the index of the elements. The two arrays must have the same length.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">iter2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to a pair of elements that are drawn from matching indices in two arrays. The two arrays must have the same length.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">length</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the number of elements in the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">map</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Builds a collection whose elements are the results of applying the given function to each element of the array.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">map2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Builds a collection whose elements are the results of applying the given function to the corresponding elements of the two collections pairwise. The two input arrays must have the same length.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">map3</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Builds a collection whose elements are the results of applying the given function to the corresponding elements of the three collections simultaneously.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">mapi</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Builds an array whose elements are the results of applying the given function to each element of the array. The integer index that's passed to the function indicates the index of the element that's being transformed.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">mapi2</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Builds a collection whose elements are the results of applying the given function to the corresponding elements of the two collections pairwise, also passing the index of the elements. The two input arrays must have the same length.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">max</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the greatest element in the collection, compared by using the <code class="literal">max</code> operator.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">maxBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the greatest element in the collection, compared by using <code class="literal">max</code> on the function result.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">maxElement</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the greatest element in the set according to the ordering that's used for the set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">min</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the least element in the collection, compared by using the <code class="literal">min</code> operator.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">minBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the least element in the collection, compared by using the <code class="literal">min</code> operator on the function result.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">minElement</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the lowest element in the set according to the ordering that's used for the set.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">ofArray</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates <code class="literal">collection</code> that contains the same elements as the given array.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">ofList</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates <code class="literal">collection</code> that contains the same elements as the given list.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">ofSeq</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates <code class="literal">collection</code> that contains the same elements as the given sequence.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">pairwise</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence of each element in the input sequence and its predecessor except for the first element, which is returned only as the predecessor of the second element.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">partition</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Splits the collection into two collections. The first collection contains the elements for which the given predicate returns <code class="literal">true</code>, and the second collection contains the elements for which the given predicate returns <code class="literal">false</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">permute</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns an array with all the elements permuted according to the specified permutation.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">pick</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to successive elements, returning the first result where the function returns <code class="literal">Some</code>. If the function never returns <code class="literal">Some</code>, <code class="literal">KeyNotFoundException</code> will be raised.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">readonly</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates a sequence object that delegates to the given sequence object. This operation ensures that a type cast can't rediscover and mutate the original sequence. For example, if given an array, the returned sequence will return the elements of the array, but you can't cast the returned sequence object to an array.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">reduce</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function starts by applying the function to the first two elements, passes this result into the function along with the third element, and so on. The function returns the final result.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">reduceBack</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is <code class="literal">f</code> and the elements are <code class="literal">i0...iN</code>, this function will compute <code class="literal">f i0 (...(f iN-1 iN))</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">remove</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Removes an element from the domain of the map. No exception is raised if the element isn't present.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">replicate</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates a list of a specified length with every element set to the given value.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">rev</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a new list with the elements in reverse order.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">scan</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies a function to each element of the collection, threading an <code class="literal">accumulator</code> argument through the computation. This operation applies the function to the second argument and the first element of the list. The operation then passes this result into the function along with the second element and so on. Finally, the operation returns the list of intermediate results and the final result.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">scanBack</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Resembles the <code class="literal">foldBack</code> operation but returns both the intermediate and final results.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">singleton</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that yields only one item.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">set</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sets an element of an array to the specified value.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">skip</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that skips <code class="literal">N</code> elements of the underlying sequence and then yields the remaining elements of the sequence.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">skipWhile</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that, when iterated, skips elements of the underlying sequence while the given predicate returns true and then yields the remaining elements of the sequence.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sort</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sorts the collection by element value. Elements are compared using compare.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sortBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sorts the given list by using keys that the given projection provides. Keys are compared using compare.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sortInPlace</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sorts the elements of an array by mutating it in place and using the given comparison function. Elements are compared by using <code class="literal">compare</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sortInPlaceBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sorts the elements of an array by mutating it in place and using the given projection for the keys. Elements are compared by using <code class="literal">compare</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sortInPlaceWith</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sorts the elements of an array by mutating it in place and using the given <code class="literal">comparison</code> function as the order.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sortWith</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Sorts the elements of <code class="literal">collection</code> using the given <code class="literal">comparison</code> function as the order and returning a new collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sub</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Builds an array that contains the given subrange that's specified by starting <code class="literal">index</code> and <code class="literal">length</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sum</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the sum of the elements in the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">sumBy</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the sum of the results that are generated by applying the function to each element of the collection.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">tail</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the list without its first element.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">take</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the elements of the sequence up to a specified count.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">takeWhile</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that, when iterated, yields the elements of the underlying sequence while the given predicate returns true and then returns no more elements.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">toArray</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates an array from the given <code class="literal">collection</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">toList</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates a list from the given <code class="literal">collection</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">toSeq</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Creates a sequence from the given <code class="literal">collection</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">truncate</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that, when enumerated, returns no more than <span class="emphasis"><em>N</em></span> elements.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">tryFind</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Searches for an element that satisfies a given predicate.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">tryFindIndex</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Searches for the first element that satisfies a given predicate and returns the index of the matching element or <code class="literal">None</code> if no such element exists.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">tryFindKey</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns the key of the first mapping in the collection that satisfies the given predicate or returns <code class="literal">None</code> if no such element exists.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">tryPick</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Applies the given function to successive elements, returning the first result where the function returns something for some value. If no such element exists, the operation will return <code class="literal">None</code>.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">unfold</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that contains the elements that the given computation generates.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">union</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Computes the union of the two sets.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">unionMany</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Computes the union of a sequence of sets.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">unzip</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Splits a list of pairs into two lists.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">unzip3</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Splits a list of triples into three lists.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">windowed</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>-</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a sequence that yields the sliding windows of containing elements that are drawn from the input sequence. Each window is returned as a fresh array.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">zip</code>
</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Combines the two collections into a list of pairs. The two lists must have equal lengths.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; ">
<p>
<code class="literal">zip3</code>
</p>
</td><td style="border-right: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; ">
<p>●</p>
</td><td style="border-right: 0.5pt solid ; ">
<p>●</p>
</td><td style="">
<p>Combines the three collections into a list of triples. The lists must have equal lengths.</p>
</td></tr></tbody></table></div><p>In addition, in the next paragraph, you will see how to apply a case condition for each possibility of interrogation, manipulation, or extrapolation data.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec52"></a>F# – how to use it</h2></div></div><hr /></div><p>Up to this point, we have been discussing the general characteristics of F# without even taking into consideration FRP. In addition, we have seen some of the theoretical aspects of the language. They detailed the general nature of the programming that is functional through simple examples.</p><p>Through this section, we will show how you can leverage the features of F#: both syntactic and technical. We will precisely discuss this in the various sections of some constructors required to exploit the full potential of the language. In this way, it will be easier to introduce and above all understand FRP, which will be addressed later.</p><p>In detail, you will see the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Pattern Matching and pipeline for very concise code and functions</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Record</strong></span> type and <span class="strong"><strong>Discriminate Union</strong></span> to represent and query simple types in F#</p></li><li style="list-style-type: disc"><p>Active Pattern to customize the code used in Pattern Matching</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec102"></a>Pattern Matching and pipe forward</h3></div></div></div><p>Pattern Matching is a very important model for comparison. In particular, through Pattern Matching, you can write input data conditions and output actions to transform data from the condition to the right action. Pattern Matching can be a constructor, or a model, or perhaps, even better called a <span class="emphasis"><em>syntax to compare</em></span>.</p><p>It is easy; refer to the following code:</p><pre class="programlisting">let v1 = 3
let v2 = 2

let printEvenOdd x =
    match x % 2 with
    | 0 -&gt; printfn "The value is odd"
    | _ -&gt; printfn "The value is even"

printEvenOdd v1
printEvenOdd v2
</pre><p>The result for <code class="literal">v1</code> and <code class="literal">v2</code> will be <code class="literal">even</code> and <code class="literal">odd</code>, respectively.</p><p>The composition of this pattern requires an expression of control to indicate the keywords <code class="literal">match &lt;expression&gt;</code> with <code class="literal">=</code>. Then, it should include a set of models of the condition and the result to be obtained. The expected syntax is the following: <code class="literal">| pattern [when condition] -&gt; result-expression</code>.</p><p>All of this is similar to the switch case of C#, but in fact, Pattern Matching is much more powerful.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note46"></a>Note</h3><p>The heart of this matching is the pattern of the condition. The model can be any constant or identifier, any Boolean condition, <code class="literal">list</code>, <code class="literal">array</code>, <code class="literal">tuple</code>, record, type, wildcard, and much more.</p></div><p>In the example, you can see precisely the use of the wildcard (<code class="literal">_</code>). This is a jolly character and represents a <span class="emphasis"><em>placeholder</em></span> for any input value that does not match a specific case of a result or simply groups all the other values in a single output. The wildcard can be seen as the default keyword in the C# switch construct.</p><p>In the syntax of the pattern condition <code class="literal">| pattern [when condition] -&gt; result-expression</code>, <code class="literal">when</code> is an optional keyword to indicate or compare, for example, group-specific cases. For example, the following code is used to compare the first value to the second:</p><pre class="programlisting">let compareTwoValue x =
    match x with
    | (v1, v2) when v1 &gt; v2 -&gt; printfn "%d is greater than %d" v1 v2
    | (v1, v2) when v1 &lt; v2 -&gt; printfn "%d is less than %d" v1 v2
    | (v1, v2) -&gt; printfn "%d equals %d" v1 v2

compareTwoValue (0, 1)
compareTwoValue (1, 0)
compareTwoValue (0, 0)
</pre><p>Once you understand the operation of Pattern Matching, it is easy to see that, in the functional-oriented context, writing code using Pattern Matching instead of the usual comparison conditions, such as <code class="literal">if &lt;..&gt; then &lt;..&gt; else</code>, is a best practice. In fact, the design of the code turns out to be cleaner and certainly more concise.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec0"></a>Pipeline and composition</h4></div></div></div><p>Pipe forward is one of the most commonly used operators in F#. It is so common that it has been used since the earliest examples of the chapter. The operation is very simple and it involves the passage of the result of the one work to the next one.</p><p>There are two types of operator. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The classic pipe forward (<code class="literal">|&gt;</code>) passes the result of the operation to the left toward the right function. Refer to the following example:</p></li></ul></div><pre class="programlisting">[ 0..10 ] |&gt; List.iter (fun x -&gt; printfn "the value is %d" x)
</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The pipe backward (<code class="literal">&lt;|</code>) inversely passes the result of the operation to the right toward the left function. Refer to the following example:</p></li></ul></div><pre class="programlisting">List.iter (fun x -&gt; printfn "the value is %d" x) &lt;| [ 0..10]
</pre><p>The <code class="literal">Composition</code> operator (forward is <code class="literal">&gt;&gt;</code> and backward is <code class="literal">&lt;&lt;</code>) is similar to pipeline, but it is used to concatenate the <code class="literal">n</code> functions with a single result, as shown in the following example:</p><pre class="programlisting">let add1 x = x + 1
let times2 x = 2 * x

let Compose2 = add1 &gt;&gt; times2 //Forward
let Compose1 = add1 &lt;&lt; times2 //Backward

Compose2 1 //The result is 4
Compose1 1 //The result is 4
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>The main difference between <code class="literal">pipeline</code> and <code class="literal">composition</code> is the signature and the use. The <code class="literal">pipeline</code> operator takes functions and arguments, while <code class="literal">composition</code> combines the functions.</p></div><p>Even through these two operators, it is known when the syntax of F# favors a concise code writing and, especially in this case, with the possibility of making it very readable. Nothing prevents you from writing multiple lines respecting the rules of indentation, or just one:</p><pre class="programlisting">[ 0..10 ]
|&gt; List.map (fun x -&gt; x * x)
|&gt; List.iter (fun y -&gt; printfn "the value is: %i " y)

//or

[ 0..10 ] |&gt; List.map (fun x -&gt; x * x) |&gt; List.iter (fun y -&gt; printfn "the value is: %i " y)
</pre></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl2sec103"></a>Discriminated Unions and the Record type</h2></div></div><hr /></div><p>Discriminated Unions and Union types represent for the first time since the beginning of the chapter constructs not necessarily related to functional programming. They are essential to simplify the development of libraries and applications in F#.</p><p>The Record type is a set of simple values that are named and can optionally have members.</p><p>Their syntax is as follows:</p><pre class="programlisting">[ attributes ]
type [accessibility-modifier] typename = {
    [ mutable ] label1 : type1;
    [ mutable ] label2 : type2;
    ...
    }
    member-list
</pre><p>Take a look at the following example:</p><pre class="programlisting">//Record Type
type Point = { x : float; y: float; z: float option; }

let point2D = { x = 1.0; y = 1.0; z = None}
let point3D = { point2D with z = Some(-1.0)}
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Tip</h3><p>In this example, you can see some of the syntactic features of the Record type.</p><p>
The keyword option declared during the type definition indicates that value can be inserted or not. <code class="literal">None</code> and <code class="literal">Some (&lt;value&gt;)</code> are used precisely to indicate in the first variable not assigned a value and in the second such award, respectively.</p><p>
The keyword <code class="literal">with</code> preceded by an identifier already valued permits passing all the values of the first variable to the declaration of the new variable. In this way, we don't have to change the values every time, but we have the advantage to replace only the values that you want to change.</p></div><p>The Record type might seem like a class of C #, but in reality, there are some important differences. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The fields come directly exposed as properties: in read-only by default and read-write with the keyword <code class="literal">mutable</code>
</p></li><li style="list-style-type: disc"><p>In a Record type, you cannot define a constructor</p></li><li style="list-style-type: disc"><p>Importantly, the Record type, unlike classes, are compared as value types (similar to the structures of the C#) and not as reference types</p></li></ul></div><p>Instead, Discriminated Unions provide support for <span class="emphasis"><em>tagged</em></span> values with a label, forming a casuistic. In addition, each of them can have completely different values and types.</p><p>The syntax is as follows:</p><pre class="programlisting">type type-name =
   | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]
   | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]
</pre><p>An example is as follows:</p><pre class="programlisting">//Discriminated unions
type Shape =
    | Rectangle of width : float * length : float
    | Circle of radius : float
    | Prism of width : float * float * height : float

let rect = Rectangle(length = 1.3, width = 10.0)
let circ = Circle (1.0)
let prism = Prism(5., 2.0, height = 3.0)
</pre><p>The <code class="literal">labelable</code> type can be anything. If there are no values, discriminated unions are similar to the enumeration of .NET. Instead, if there are values, each of them can be a primitive type or <code class="literal">tuple</code> or just one Record type.</p><p>One particular development of discriminated unions is the possibility to insert them into another through the association with a label. These discriminated recursive unions are used to represent the tree structures.</p><p>In Microsoft Visual Studio, by creating a new F# project called <code class="literal">Tutorial</code>, you can see the sample code of most language constructs.</p><p>Here, we will report a good example of Record and Discriminated Unions type. In addition, this code portion allows us to understand the concepts discussed previously with regard to the good design and conciseness of F#. Take a look at the following example:</p><pre class="programlisting">type Suit = | Hearts | Club | Diamonds| Spades
    // Represents the rank of a playing card
    type Rank =
        | Value of int // Represents the rank of cards 2 .. 10
        | Ace
        | King
        | Queen
        | Jack
        static member GetAllRanks() =
            [ yield Ace
              for i in 2 .. 10 do yield Value i
              yield Jack
              yield Queen
              yield King ]

    type Card =  { Suit: Suit; Rank: Rank }

    // Returns a list representing all the cards in the deck
    let fullDeck =
        [ for suit in [ Hearts; Diamonds; Clubs; Spades] do
              for rank in Rank.GetAllRanks() do
                  yield { Suit=suit; Rank=rank } ]
</pre></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl2sec104"></a>Active Patterns</h2></div></div><hr /></div><p>Active Patterns are conceptually similar to discriminated unions. What really changes is how they are used, not the syntax.</p><p>By definition, it can be said that an active pattern is a set of called partitions used to compare the input data. Also, these partitions (labels) can be used in <code class="literal">expression</code>.</p><p>This is the syntax:</p><pre class="programlisting">let (|identifer1|identifier2|...|) [ arguments ] = expression
let (|identifier|_|) [ arguments ] = expression
</pre><p>As we can see in the preceding code lines, there are two different implementations. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Complete Active Patterns</strong></span>: They are described in the first row and all the labels are explicitly denominated. They must be a maximum of seven and each one must have a result return.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Partial Active Patterns</strong></span>: It is similar, but one's choice must be the wildcard operator <code class="literal">|_|</code> seen previously. This operator is used to define all the cases in which the input must not be partitioned.</p></li></ul></div><p>The main example to understand how to use the action pattern is as follows:</p><pre class="programlisting">let (|Even|Odd|) input = if input % 2 = 0 then Even else Odd
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip49"></a>Tip</h3><p>Placing more than seven items in Visual Studio at write-compiled time phase would generate an exception. In this case, you might rethink the logic using the Record type.</p></div><p>Instead, an easy example of the partial Active Pattern is as follows:</p><pre class="programlisting">let (|BooleanValue|_|) input =
    match input with
        | 0 -&gt; Some true
        | 1 -&gt; Some false
        | _ -&gt; None

let IntBoolIdentification value =
    match value with
        |BooleanValue a -&gt; printfn "The bool value is %b" a
        |_ -&gt; printfn "The value is invalid"

IntBoolIdentification 0 //The bool value is true
IntBoolIdentification 1 //The bool value is false
IntBoolIdentification 2 //The value is invalid
</pre><p>It defines a partial Active Pattern that allows us to understand and extrapolate a Boolean value by an integer. For any value greater than one, nothing is returned (the keyword <code class="literal">None</code>).</p><p>A partial implementation must be composed exclusively of a single label and a single operator wildcard; otherwise, it will generate an exception.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec53"></a>Asynchronous pattern in F#</h2></div></div><hr /></div><p>In the previous sections, we first discussed functional programming. Then, we introduced F# and its main features. Finally, we described how to use the most important constructs in the F# language. The meaning of all this is to be able to deal with the main topic: FRP.</p><p>An important element is missing in order to introduce FRP. This is required because without it, you cannot fully understand reactive programming.</p><p>F#, like any other language of the .NET Framework, supports asynchronous programming. It is crucial to perform portions of code in a separate thread.</p><p>The syntax for applying asynchronous code is really simple. The following is the syntax:</p><pre class="programlisting">async { &lt;expression&gt; }
</pre><p>The code inserted in place of <code class="literal">&lt;expression&gt;</code> will be withdrawn in various ways through the use of specific types and their methods of asynchronous invocation. For example, the <code class="literal">async</code> class provides several methods that allow you to run this code on different threads.</p><p>A very important concept is surely to understand why asynchronous programming is crucial, especially in recent years.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>The main task of <code class="literal">async</code> is to offer the ability to run code on different threads. In this way, the application will not have delays or even worse blocks during execution This will prove to be much more fluid to the end user.</p></div><p>In the next sections, we will show in detail all the features and keywords to be used in asynchronous programming.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec105"></a>The concept of asynchronous workflow</h3></div></div></div><p>In .NET Framework, there are several ways to implement a workflow asynchronously. First of all, the workflow represents the complete management of our code asynchronously. That is, in addition to implementing the code, it will run the results returning any exceptions thrown in the threads and synchronization.</p><p>In F#, to do this, there are the syntax rules to be followed:</p><pre class="programlisting">open System.IO

let fileContent (path : string) =
    async {
        use stream = new StreamReader(path)
        return stream.ReadToEnd()
    }

Async.RunSynchronously(fileContent "&lt;filepath&gt;")
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip51"></a>Tip</h3><p>The <code class="literal">use</code> keyword is used instead of <code class="literal">let</code> for all those objects that inherit from <code class="literal">IDisposable</code>. However, with <code class="literal">return</code>, it indicates what must be returned.</p></div><p>The behavior of <code class="literal">use</code>-<code class="literal">return</code> is analogous to C#'s <code class="literal">using</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip52"></a>Tip</h3><p>In addition, in the sample code, you can see how you can instantiate the object <code class="literal">StreamReader</code> belonging to the .NET Framework. The keyword <code class="literal">open</code> indicates the module or the namespace of the elements that you want to see without using the full name.</p></div><p>In this first example, you can see a function that returns the content of a file through its path. Inside the core of the function, the <code class="literal">async</code> keyword followed by a set of statements enclosed in brackets braces indicates the code to be executed in a context asynchronous.</p><p>Trying to run the code of the first two instructions into the <code class="literal">F# Interactive</code> console, the result would be <code class="literal">val fileStr : path:string -&gt; Async&lt;string&gt;</code>. This is because any asynchronous method returns <code class="literal">Async &lt;'T&gt;</code>: an asynchronous operation, where <code class="literal">'T</code> stands for the return type. <code class="literal">'T</code>, in the example, is a string.</p><p>With the instruction <code class="literal">Async.RunSynchronously</code>, you can run the code in the current thread. In this way, it will be possible to extract the contents of the method.</p><p>The <code class="literal">Async</code> class is the heart of the asynchronous programming in F#. In the next section, we will see many of its features.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec106"></a>Asynchronous code and examples</h3></div></div></div><p>In the previous example, it is shown how to extract from an <code class="literal">Async &lt;'T&gt;</code> type its generic through the method <code class="literal">Async.RunSynchronously</code>. But in some cases, it is necessary to wait for the execution of some asynchronous instructions and get their result.</p><p>Naturally, all of this must take place in an asynchronous context:</p><pre class="programlisting">let tupleByteArray =
    async {
        use stream = new System.IO.StreamReader("&lt;filepath&gt;")
        let result1 = stream.BaseStream.AsyncRead(10)
        let! result2 = stream.BaseStream.AsyncRead(10)
        return (Async.RunSynchronously result1), result2
    }

let item1, item2 = Async.RunSynchronously tupleByteArray
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip53"></a>Tip</h3><p>In the last line of code, there is a special initialization syntax identifier. <code class="literal">letitem1</code>,<code class="literal">item2</code> allows you to extract the values of a <code class="literal">tuple</code> for each variable according to the internal sorting.</p></div><p>In the example, there are two identifiers: <code class="literal">result1</code> and <code class="literal">result2</code>. Both of them have an equal function core. However, they differ in the case of the keyword header identifier.</p><p>The keyword <code class="literal">let!</code> (unlike <code class="literal">let</code>) allows you to extract directly the generic types from an object <code class="literal">Async &lt;'T&gt;</code>, executing the following code synchronously. To be used, it must be inserted in an asynchronous expression. It will be used in the same way you use the <code class="literal">use!</code> keyword for the types that inherit from <code class="literal">IDisposable</code>.</p><p>The function <code class="literal">tupleByteArray</code> returns a tuple with two equal type items (<code class="literal">byte[]</code>). This is possible because, before returning the value, the call to the identifier <code class="literal">result1</code> runs <code class="literal">Async.RunSynchronously</code> to extract the byte array.</p><p>Basically, it writes the following command:</p><pre class="programlisting">let! result2 = stream.BaseStream.AsyncRead(10)
</pre><p>The preceding code is similar to the following:</p><pre class="programlisting">let result1 = Async.RunSynchronously (stream.BaseStream.AsyncRead(10))
</pre><p>The <code class="literal">Async</code> object also provides a number of additional methods to run code in parallel. A very interesting example of how you can exploit parallelism with many other features of the class is by declaring a list of links that is calculated by the number of characters in the web page:</p><pre class="programlisting">Open System.Net

let urlList =
    [ "Microsoft.com", "http://www.microsoft.com/"
      "MSDN", "http://msdn.microsoft.com/"
      "Bing", "http://www.bing.com" ]

let fetchAsync (name, url : string) =
    async {
        try
            let uri = new System.Uri(url)
            let webClient = new WebClient()
            let! html = webClient.AsyncDownloadString(uri)
            printfn "Read %d chars for %s" html.Length name
        with ex -&gt; printfn "%s" (ex.Message)
    }

let runAll() =
    urlList
    |&gt; Seq.map fetchAsync
    |&gt; Async.Parallel
    |&gt; Async.RunSynchronously
    |&gt; ignore

runAll()
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note54"></a>Note</h3><p>Using the pipe forward in this example shows the enormous potential of F#. Thinking about function-oriented code combinations, you can write functions that are structurally complex, but simple. All these have the ability to break up into simple functions.</p><p>
The expression <code class="literal">try...with</code> is used to manage a possible exception that occurs within the statements enclosed between the two keywords. It is similar to the <code class="literal">try...catch</code> statement in C#.</p><p>
One interesting feature is the syntax with which they have differentiated behaviors depending on the type of exception:
let divide2 x y =
<code class="literal"> try</code>
<code class="literal">    Some( x / y )</code>
<code class="literal">  with</code>
<code class="literal">    | :? System.DivideByZeroException as ex -&gt; printfn "Exception! %s " (ex.Message); None </code>
</p></div><p>Finally, in this last example, it is shown how to simulate a kind of complex computational task:</p><pre class="programlisting">// Simulate CPU calc.
let child() =
    for i in [ 1..4000 ] do
        for i in [ 1..400 ] do
            do "Fsharp".Contains("F") |&gt; ignore

let parentTask =
    child
    |&gt; List.replicate 30
    |&gt; List.reduce (&gt;&gt;)

let asyncChild = async { return child() }

let asyncParentTask =
    asyncChild
    |&gt; List.replicate 30
    |&gt; Async.Parallel


//test single
#time
parentTask()
#time

//test async with parallel
#time
asyncParentTask |&gt; Async.RunSynchronously
#time
</pre><p>In the previous code, there is a method that simulates an operation (<code class="literal">child()</code>) for calculation. Then, there are two other instructions through the function <code class="literal">List.replicate</code> that replicates the code of calculation <span class="emphasis"><em>n</em></span> times.</p><p>One of the main key points in this code is how we can obtain some benefits (or not) if we run code in parallel. The preprocessor directive <code class="literal">#time</code> allows you to see inside the console <code class="literal">F# Interactive</code> some useful counters. Take a look at the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_002.jpg" /></div><p>
</p><p>The screenshot shows that running in parallel is much more powerful than running it synchronously. In addition, the directive <code class="literal">#time</code> shows a series of useful counters. It is activated at the beginning and deactivated at the end of counting.</p><p>The counters are represented as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Real</code>: This is the real-time execution expressed in <code class="literal">hh:mm:ss:fff</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">CPU</code>: This is the sum of the calculation time of the CPU in <code class="literal">hh:mm:ss:fff</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">GC</code>, <code class="literal">gen0</code>, <code class="literal">gen</code> and <code class="literal">gen2</code>: These are counters, <code class="literal">0</code>,<code class="literal">1</code>, and <code class="literal">2</code> collections of <code class="literal">Garbage Collection</code>
</p></li></ul></div><p>F# Interactive<code class="literal">(FSI</code>) is a very powerful tool.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p>The <code class="literal">FSI</code> tool is very useful, not only for F# developers, but also for those developing in C# or VB.NET. Having full access to the .NET Framework, you can query (in real-time) each library with a little knowledge of the basic syntax of F#.</p></div><p>In the following table taken from the website of Microsoft MSDN (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233175.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/dd233175.aspx</a>), you can see the main <code class="literal">FSI</code> directives of the preprocessor:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Directive</strong></span>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">#help</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Displays information about available directives.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">#I</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Specifies an assembly search path in quotation marks.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">#load</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Reads a source file, compiles it, and runs it.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">#quit</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Terminates an F# Interactive session.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">#r</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>References an assembly.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; ">
<p>
<code class="literal">#time ["on"|"off"]</code>
</p>
</td><td style="">
<p>By itself, <code class="literal">#time</code> toggles whether to display performance information. When it is enabled, F# Interactive measures real time, CPU time, and garbage collection information for each section of code that is interpreted and executed.</p>
</td></tr></tbody></table></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec54"></a>Functional Reactive Programming</h2></div></div><hr /></div><p>FRP, the central theme of the second half of the chapter, may be considered by definition as a programming paradigm. In fact, this paradigm is different from the more common ones, such as imperative, object-oriented and functional, because it applies only to Reactive Programming. The context of use is much smaller.</p><p>In the previous chapters, we understood how the library <code class="literal">Rx</code> represents all these data sequences as observable sequences and how it can be used to compose asynchronous and event-based programs.</p><p>Similarly, we will now introduce FRP exploiting objects and, in general, all the features of F# and functional programming. This is possible due to the inherent ability of the language to make almost every instruction in a function block.</p><p>In the following sections, we will see in detail the following points:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>What is FRP and how can you represent it?</p></li><li style="list-style-type: disc"><p>What are the main features and applicable scenarios?</p></li><li style="list-style-type: disc"><p>The concept of asynchronous data flow</p></li><li style="list-style-type: disc"><p>The types on push-based and pull-based</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec107"></a>What is FRP and how is it represented?</h3></div></div></div><p>We previously introduced FRP (acronym for Functional Reactive Programming) as a type of paradigm. Actually, it is not a real paradigm because it can be described using simple functions, similar to many other functional patterns.</p><p>To better understand this concept, we should take a little step back and discuss object-oriented programming, especially events. Events are everywhere and are the basis to understand FRP. Managing them individually is a very simple procedure, but if we want to develop more advanced functionalities, such as event handling, then it will become more complex.</p><p>Observer is a kind of design pattern based on events and it is one of the most common patterns in object-oriented programming. Furthermore, it is the basis of <span class="emphasis"><em>Reactive Extensions</em></span> and <span class="emphasis"><em>event flow</em></span>, as mentioned in the previous chapters.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>Instead, in functional programming with F#, Reactive Programming is supported natively through the functions themselves.</p></div><p>Reactive programming together with the functional paradigm explains the concept of FRP. This simplification is a starting point to better understand basic concepts up to more complicated ones.</p><p>Since FRP is based on functions, will it be possible to understand or simply represent it in .NET Framework and F#? Actually, we have already seen numerous examples.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>Consider the following code:
</p><pre class="programlisting">
<code class="literal">let numberList = [ 2.0; 4.0; 6.0]</code>
<code class="literal">let result = numberList |&gt; List.map (fun x -&gt; x**2.0)</code>
</pre><p>
The symbol <code class="literal">**</code> is the mathematical operator that represents the mathematical function <span class="emphasis"><em>power</em></span>. It is recommended in particular that the elements are of the <code class="literal">double</code> type.</p></div><p>The <code class="literal">map</code> method is a suitable example of FRP. In the same way, almost all the members of the type method of collections are appropriate examples, such as <code class="literal">filter</code>, <code class="literal">reduce</code>, <code class="literal">zip</code>, and many others.</p><p>In functional programming, one of the main features is immutability. Consequently, the methods that operate on the elements of collections don't modify the list itself, but instead they process a function event on every single element creating a new object.</p><p>In particular, in FRP, there are two different fundamental types of data: <code class="literal">Event</code> and behavior.</p><p>A value of the behavior type is characterized by the ability to continuously change over time. A classic example of behavior is all the time objects, but it could also be an <code class="literal">int</code> type or a constant (object color).</p><p>A value of the event type is instead a sequence of the occurrence of the <code class="literal">Event</code> itself with a value for each occurrence of the value type.</p><p>In the preceding example, both the types are represented: a flow of events that change the values in every element of the list by adopting the function <code class="literal">power</code> and returning a new sequence with different values.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>In other words, it is possible to combine different behaviors and events (<code class="literal">combinators</code>) together to create new ones, as seen in the example.</p></div><p>This introduces concept of <span class="emphasis"><em>time flows</em></span>, which will be described in detail in the following chapters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec6"></a>Introduction to functional reactive programming</h4></div></div></div><p>FRP is defined as a programming paradigm for Reactive Programming. It is actually much more than that.</p><p>When we program in .NET, events are everywhere. Many of these events are based on the delegate called <code class="literal">EventHandler</code> and the base class called <code class="literal">EventArgs</code>. Along with object-oriented programming, they are used for the technique called event programming.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note59"></a>Note</h3><p>In Visual Studio, if you create a WinForm project, it will be clearly seen as it is set to work on events. Not only this, even the newest template <span class="strong"><strong>Windows Presentation Framework</strong></span> (<span class="strong"><strong>WPF</strong></span>) fully supports the programming events. Though, with the latter, it is more appropriate to use the <span class="strong"><strong>Model View ViewModel</strong></span> (<span class="strong"><strong>MVVM</strong></span>) pattern for a series of structural advantages and more.</p></div><p>With the expansion of asynchronous programming, the event-based model has evolved as well. As a consequence, in the .NET Framework, a standard called <span class="strong"><strong>Event-based Asynchronous Programming</strong></span> (<span class="strong"><strong>EAP</strong></span>) was developed. It will only make available the asynchronous methods that run on a different thread of the same operation as the corresponding synchronous method. Also, some of these classes exhibit events for flow control as asynchronous, such as <code class="literal">methodCompleted</code> or <code class="literal">methodCancel</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note60"></a>Note</h3><p>FRP extends a host programming language with the notion of time flow. In this way, it will be possible to obtain powerful control over the flow of data through a model of observation (the <code class="literal">Observable</code> pattern).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec7"></a>Collections and functions in a flow</h4></div></div></div><p>In the previous chapters dedicated to LINQ and C#, it has been shown that collections are at the heart of reactive programming. We will explain an example of FRP in F# that includes all the main features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The concept of time flow</p></li><li style="list-style-type: disc"><p>The intrinsic characteristics of the event flow</p></li><li style="list-style-type: disc"><p>The concept of asynchronous data flow and the <code class="literal">Observable</code> pattern</p></li></ul></div><p>
</p><div class="mediaobject"><img src="graphics/image_08_003.jpg" /></div><p>
</p><p>In the preceding graphic, the line with circular points shows the three input values of the list, while the line with square points, shows three output values to which the function <code class="literal">List.map</code> is adopted. It is important to notice how the function is gradually applied to every single value, respecting exactly the input time flow.</p><p>It means that the event of execution of the function is processed for each value added in the list. Furthermore, thanks to functional programming (in this case, to F# and the .NET Framework that provides this method by default) and its intrinsic features, this execution is completely thread safe. So, as a consequence, in terms of reactive programming, it is possible to obtain an asynchronous data flow.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec108"></a>FRP and its scenarios</h3></div></div></div><p>We briefly introduced FRP and how we can use it in software applications. Actually, FRP is applicable not only to basic implementations as a synchronous or asynchronous event flow handling. We also can introduce a set of features able to solve different problems in a very simple way.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note61"></a>Note</h3><p>Thanks to FRP, we can have a full-scale supervision of the entire event flow introducing the concept of continuous time, where events and behaviors are stream transformers.</p></div><p>So, we can see which possible scenarios are appropriate for FRP.</p><p>As previously described, given an event flow, we can execute some functions maintaining time flow control in a particular domain.</p><p>Therefore, there are particular domains suitablefor the reactive system. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Interactive computer animation</p></li><li style="list-style-type: disc"><p>Robotics</p></li><li style="list-style-type: disc"><p>Control and real-time systems</p></li><li style="list-style-type: disc"><p>GUIs</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec8"></a>Event data flow</h4></div></div></div><p>We assumed so far, especially in the examples in the previous chapters, that in FRP, there is a flow of events and that these events can be defined as signals. Moreover, we understood that the workflow is well defined and it is processed in a synchronous way. Nevertheless, signals change continuously, so it could be necessary to interrupt or modify the flow. It could be essential having an asynchronous data flow.</p><p>Graphic applications better related to GUI are definitely some of the most interesting cases where we can verify how synchronous event data flows work.</p><p>For example, we can imagine the change of position or color of a graphic object inside an application.</p><p>It is essential to understand the following three concepts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Changes always occur through an event. For example, in the color type, a <code class="literal">ValueChanged</code> event related to any control that supports it can modify one or more of the three RGB channels.</p></li><li style="list-style-type: disc"><p>Changes can occur regularly, but in a completely discontinuous way. Once again, in the case of a change of the color type, it is not possible to predict neither how many times nor when an event originating from the user will occur.</p></li><li style="list-style-type: disc"><p>It could be necessary to filter or add some events. As an example, we could think of a user that frantically keeps changing the contrast value of an image. It is very expensive in terms of performance, and useless to reprocess the image if the new image is already elaborated.</p></li></ul></div><p>Fortunately, F# and the assembly <code class="literal">Fsharp.Core.dll</code> in particular, can help us, and it makes available the <code class="literal">Event</code> type to manage the functions of the events themselves:</p><pre class="programlisting">type Event&lt;'T&gt; =
 class
  new Event : unit -&gt; Event&lt;'T&gt;
  member this.Trigger : 'T -&gt; unit
  member this.Publish :  IEvent&lt;'T&gt;
 end
</pre><p>
<code class="literal">&lt;'T&gt;</code> is the syntax that identifies generic type. Moreover, the Event type is also called <code class="literal">FSharpEvent</code>. It is important to know to use the object through reflection.</p><p>
<code class="literal">IEvent&lt;'T&gt;</code> represents the interface every single event should have. It does nothing but combine the other two interfaces, <code class="literal">IObservable&lt;T&gt;</code> and <code class="literal">IDelegateEvent</code>.</p><p>In this way, an F# event through <code class="literal">IDelegateEvent</code> has at its disposal all the features of delegates of the event type of the .NET Framework. Thanks to the <code class="literal">IObservable</code> interface, it also acquires the ability to apply functions to events, such as filtering or mapping, as well as using the lambda expression. This is possible thanks to the <code class="literal">Event</code> module of F#, which exhibits all these member functions.</p><p>A very interesting example of how powerful it is to use the <code class="literal">IObservable</code> interface is the following example. It demonstrates how powerful the <code class="literal">IObservable</code> interface is. The code is taken from the Microsoft MSDN website (
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233189.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/dd233189.aspx</a>
) and it is slightly modified to avoid a runtime error:</p><pre class="programlisting">open System.Windows.Forms
let form = new Form(Text = "F# Windows Form",
                    Visible = true,
                    TopMost = true)
form.MouseMove
    |&gt; Event.filter ( fun evArgs -&gt;
        evArgs.X &gt; 0 &amp;&amp; evArgs.Y &gt; 0 &amp;&amp;
        evArgs.X &lt; 255 &amp;&amp; evArgs.Y &lt; 255)
    |&gt; Event.add ( fun evArgs -&gt;
        form.BackColor &lt;- System.Drawing.Color.FromArgb(
            evArgs.X, evArgs.Y, evArgs.X ^^^ evArgs.Y))
</pre><p>Interestingly, here we can see how, in three simple blocks of instructions, we created a form with the relative namespace. The form is composed of two different events, each of them with a specific behavior.</p><p>In the preceding code, we can see how the <code class="literal">Event.filter</code> function acts as a predicate. In fact, it also requires a lambda expression with the argument of the event (in this specific case, <code class="literal">MouseEventsArgs</code>) as a parameter and the results of a condition as a result value.</p><p>Consequently, if the condition is respected, the <code class="literal">callback</code>
<code class="literal">Event.add</code> function will be processed and run the body function. For this reason, the background color of the window changes to the movement of the mouse through the coordinate positions of the mouse itself.</p><p>Given that the <code class="literal">Event</code> module is one of the F# first-class, it exposes a wide set of functions, as in most cases. You can refer to the following link on the Microsoft MSDN website 
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee340422.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/ee340422.aspx</a>
.</p><p>Some of the main functions are provided in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Value</strong></span>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">add</code>:<code class="literal">('T -&gt; unit) -&gt; Event&lt;'Del,'T&gt; -&gt; unit</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Runs the given function each time the given event is triggered.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">filter:('T -&gt; bool) -&gt; IEvent&lt;'Del,'T&gt; -&gt; IEvent&lt;'T&gt;</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>Returns a new event that listens to the original event and triggers the resulting event only when the argument to the event passes the given function.</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; ">
<p>
<code class="literal">choose:('T -&gt; 'U option) -&gt; IEvent&lt;'Del,'T&gt; -&gt; IEvent&lt;'U&gt;</code>
</p>
</td><td style="">
<p>Returns a new event that fires on a selection of messages from the original event. The selection function takes an original message to an optional new message.</p>
</td></tr></tbody></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec9"></a>Push and pull-based domains</h4></div></div></div><p>In the previous chapter, we analyzed how it is possible to implement and use a synchronous data flow using F#. However, it represents only a part of FRP. In fact, we ignored the asynchronous world.</p><p>When discussing FRP, it is important to distinguish the two scenarios because they have two <span class="emphasis"><em>different conceptual domains</em></span>. The synchronous and asynchronous domains reflect their different characteristics also in the strategy of implementation that is respectively push-based and pull-based.</p><p>So, we can better identify the two scenarios:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>When we refer to <span class="strong"><strong>synchrony</strong></span>, we are in a push-based oriented context, which is a data-driven context typically used in reactive systems</p></li><li style="list-style-type: disc"><p>When we refer to <span class="strong"><strong>asynchrony</strong></span>, we are in a pull-based oriented context, which is a demand-driven context, for example, any kind of behavior</p></li></ul></div><p>If we think about the example mentioned in the previous section, it is easy to understand that we discussed a synchronous push-based oriented context, so we are in a reactive system.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note62"></a>Note</h3><p>Usually, when the user or even an automation system generates events in graphical interface of software, we are using a reactive system.</p><p>
In our specific case, in the .NET Framework, <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>) could be projects that implement events. Moreover, WPF can also implement <code class="literal">ObservableCollection</code>.</p></div><p>Let's see the main differences between these scenarios.</p><p>For push-based scenarios:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Synchronous context</p></li><li style="list-style-type: disc"><p>Data-driven implementation</p></li><li style="list-style-type: disc"><p>No control creation</p></li><li style="list-style-type: disc"><p>An example of the representation interface in F# is <code class="literal">IObervable&lt;T'&gt;</code>
</p></li><li style="list-style-type: disc"><p>Events change continuously and randomly, for example, <code class="literal">ButtonClick</code>
</p></li></ul></div><p>For pull-based scenarios:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Asynchronous context.</p></li><li style="list-style-type: disc"><p>Demand-driven implementation.</p></li><li style="list-style-type: disc"><p>How rapidly the events are generated doesn't count; in fact, they are all elaborated because it is an asynchronous context.</p></li><li style="list-style-type: disc"><p>An example of the representation interface in F# is <code class="literal">AsyncSeq&lt;T'&gt;</code>.</p></li><li style="list-style-type: disc"><p>In this case, it doesn't matter when events change, but rather how they occur. In fact, the term behavior. As an example, usually, the parameter passed by reference is a <code class="literal">Time object</code> type.</p></li></ul></div><p>It is useful knowing that there are particular scenarios in which it is possible to have both a push-based context and a pull-based context.</p><p>In the next section, we will find an example of a pull-based scenario.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec10"></a>Examples of scenarios with AsyncSeq</h4></div></div></div><p>When we introduced the main features that distinguish the two different scenarios and pull-based in particular, we used the <code class="literal">AsyncSeq&lt;T'&gt;</code> representation as an example.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note63"></a>Note</h3><p>
<code class="literal">AsyncSeq</code> is a sequence in which individual elements are retrieved using an <code class="literal">Async</code> computation. It is similar to <code class="literal">seq&lt;'a&gt;</code>, where subsequent elements are demand-driven.</p></div><p>The assembly <code class="literal">FSharp.Control.AsyncSeq.dll</code> is not a part of the F# libraries natively, so this type of assembly must be downloaded using the NuGet console and referenced into the project:</p><pre class="programlisting">#r "../packages/FSharp.Control.AsyncSeq.2.0.8/lib/net45/FSharp.Control.AsyncSeq.dll"
open FSharp.Control

let asyncSeq = asyncSeq {
   do! Async.Sleep(100)
   yield 1
   do! Async.Sleep(100)
   yield 2 }

let two = asyncSeq |&gt; AsyncSeq.filter (fun x -&gt; x = 2)
let res = two |&gt; Async.RunSynchronously //result is 2
</pre><p>To download <code class="literal">FSharp.Control.AsyncSeq</code> from NuGet, we just have to select the right project in <span class="strong"><strong>Package Manager Console</strong></span> and select <span class="strong"><strong>Install-Package </strong></span>
<code class="literal">FSharp.Control.AsyncSeq</code>.</p><p>The key word <code class="literal">do!</code> indicates the asynchronous execution of an instruction without any assignment (corresponding to <code class="literal">let! () = istr</code>).</p><p>Similarly, concerning the <code class="literal">Observable</code> interface mentioned in the preceding lines, another possibility is to filter the elements of the list using the specific method <code class="literal">AsyncSeq.filter</code>. The module <code class="literal">AsyncSeq</code>, indeed, exposes all the required functionalities of interrogation and modification together with the possibility of using the lambda expression.</p><p>The following lines show us how to create a sequence in a completely asynchronous context using the keywords <code class="literal">asyncSeq</code> and yield.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip64"></a>Tip</h3><p>On the other hand, if we tried to create a similar sequence with no asynchrony, then the access to static <code class="literal">Sleep</code> method of the <code class="literal">Thread</code> class would stop the execution of the thread itself:</p><p>
</p><pre class="programlisting">
let syncSeq = seq {  System.Threading.Thread.Sleep(100)  yield 1 System.Threading.Thread.Sleep(100)  yield 2
}
</pre><p>
</p></div></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec55"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we introduced the F# language and the functional paradigm. This is essential if we want to understand how functional programming works. Furthermore, it is a necessary step if we want to apply and implement FRP. In particular, we discussed event data flow and the two kinds of FRP: pull-based and push-based.</p><p>In the next chapter, you will learn about FRP in depth, starting from the basic theoretical concepts to the practical examples of real scenarios. Afterward, we will enter the second part of FRP, where we will discuss advanced concepts such as discrete-continuous components and time-flow with dynamic change. Finally, we will look at different examples of the scenarios (pull- based and pull-based) using F# and FRP.</p></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>Chapter 9. Advanced FRP and Best Practices</h2></div></div></div><p>In the previous chapter, we introduced a 360-degree description of FRP. We discussed the main features related to this type of programming, passing from a theoretical introduction to the concrete examples of the scenarios. We also described how the <code class="literal">Event</code> module of the F# language exposes functionalities to manage the <code class="literal">Event</code> type delegate in the .NET Framework and how this module amplifies its capabilities, adding also a set of functionalities to manage events, such as collection (the <code class="literal">IObservable</code> interface). Finally, we conclude the chapter showing the main differences between <span class="emphasis"><em>push-based</em></span> and <span class="emphasis"><em>pull-based</em></span> scenarios.</p><p>FRP is not a simple subject to understand; in fact, it is frequently considered very difficult to assimilate. This problem depends on the complexity of the concepts; anyway, once you understand their meaning, it is not so straightforward to put them into practice. In other words, the only relatively simple aspect is the presence of objects that can create a more complete description of FRP.</p><p>This chapter aims to examine in depth the previous introduction of FRP, implementing the description with other information in order to have a general and complete overview of FRP.</p><p>In particular, we will discuss the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Differences between the <span class="emphasis"><em>discrete</em></span> and <span class="emphasis"><em>continuous</em></span> components with related examples of scenarios</p></li><li style="list-style-type: disc"><p>Concepts of <span class="emphasis"><em>time flow</em></span> and <span class="emphasis"><em>dynamic change</em></span>, in detail, through a synchronous data flow</p></li><li style="list-style-type: disc"><p>Interoperability between the F# observable and FRP from a comparison to an example in the .NET multiparadigm</p></li></ul></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec56"></a>Discrete and continuous components</h2></div></div><hr /></div><p>Discrete and continuous components are fundamental to better understand FRP. From the first introduction, one of the main axes is exactly the distinction between discrete and continuous. In the previous chapter, we analyzed many aspects related to these two components, but we never mentioned them. If we had so, then the argument could have been too complicated and theoretical.</p><p>By definition, discrete and continuous components can be described as the two main characteristics which FRP provides. In other words, they are the basics to apply time flow in our application or to improve our scenario of use.</p><p>We previously discussed the execution of the following function:</p><pre class="programlisting">List.map (fun x -&gt; x ** x)
</pre><p>While doing so, we introduced the concept of time flow to underline that every execution of the mathematical function <span class="emphasis"><em>power</em></span> occurs step by step.</p><p>In the example, it seems that this scenario is continuous, because for every input value of the list, a new output value is generated.</p><p>Actually, with a more in-depth analysis, <code class="literal">List.map</code> could be seen as a <span class="emphasis"><em>hybrid scenario</em></span>. In fact, the exponentiation of every single value shall be made according to the order of the elements, which is a prerogative of discrete scenarios.</p><p>As a consequence, we will obtain combinators made up of behavior and <code class="literal">Event</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip65"></a>Tip</h3><p>Most of the concrete applications of FRP adopt a hybrid scenario. This is because, given a time flow, it is highly probable using both the <span class="emphasis"><em>time-varying</em></span> and <span class="emphasis"><em>time-ordered</em></span> implementations.</p></div><p>In the next sections, we will discuss in more detail about discrete components, while continuous components will be treated later.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec109"></a>Discrete components</h3></div></div></div><p>The <code class="literal">Event</code> module is the basis of discrete components. They are the milestones of FRP in an event-driven context.</p><p>In the previous chapter, we introduced the concept of signals.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note66"></a>Note</h3><p>Events are a collection of particular signals that can be separated from one another as <span class="emphasis"><em>discrete occurrences</em></span>.</p></div><p>In other words, each event is able to modify a reactive system independently from other signals. We will consider the following graphic:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_001.jpg" /></div><p>
</p><p>Each orange arrow shows the occurrence of an event. We can easily understand that it is <span class="emphasis"><em>impossible</em></span> to determine when an occurrence happens between a signal and the next one.</p><p>In a discrete component, events are considered as a set and they are called <code class="literal">Event Stream</code>. This <span class="emphasis"><em>event flow</em></span> is nothing but the scenario called <span class="emphasis"><em>push-based</em></span> in the previous chapter:</p><pre class="programlisting">
open System.Windows.Forms
let form = new Form(Text = "F# Windows Form",
                    Visible = true,
                    TopMost = true)
form.MouseMove
    |&gt; Event.filter ( fun evArgs -&gt;
        evArgs.X &gt; 100 &amp;&amp; evArgs.Y &gt; 100 &amp;&amp;          evArgs.X &lt; 255 &amp;&amp; evArgs.Y &lt; 255)
    |&gt; Event.add ( fun evArgs -&gt;
        form.BackColor &lt;- System.Drawing.Color.FromArgb(
            evArgs.X, evArgs.Y, evArgs.X ^^^ evArgs.Y))
</pre><p>It is interesting to notice that we can decide how to act once the occurrence happened. We can't stop the event, but only filter or ignore it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note67"></a>Note</h3><p>This leads us to question ourselves that a discrete implementation is always possible in counting the number of occurrences, whether the count is finite or infinite.</p></div><p>For example, the graphical representation of the function <span class="emphasis"><em>y=x</em></span>
<span class="emphasis"><em>
<sup>2</sup>
</em></span> is discrete if the axis domain is composed only of integers. As a result, we will obtain a set of separated points, but in a countable range.</p><p>In the next example, the <code class="literal">Charting</code> library using NuGet is used to represent data. Notice that it is necessary to install the library if you want to run the code and pay attention to the current version of the library.</p><p>We will start with the following F# code:</p><pre class="programlisting">
#r @"../packages/FSharp.Charting.0.90.14/lib/net40/FSharp.Charting.dll"
#load @"..\packages\FSharp.Charting.0.90.14\FSharp.Charting.fsx"

open System
open System.Drawing
open System.Windows.Forms
open FSharp.Charting

let list = [for x in -10 .. 10 -&gt; (x, x * x)]
Chart.Point(list,Name="Integer")
</pre><p>We will obtain this graphic:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_002.jpg" /></div><p>
</p><p>To sum up, a discrete component has the following features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Event-driven (or data-driven) context</p></li><li style="list-style-type: disc"><p>Push-based scenario</p></li><li style="list-style-type: disc"><p>Events are <span class="emphasis"><em>streams of event occurrences</em></span>
</p></li><li style="list-style-type: disc"><p>Time domain is of the type discrete</p></li><li style="list-style-type: disc"><p>We can always count the number of signals</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec11"></a>The discrete event example with the discriminated union</h4></div></div></div><p>It is very important to remember that, when we discuss about events in F#, we are dealing with the type <code class="literal">Event</code> of the module in the assembly <code class="literal">Fsharp.Core.dll</code> with the namespace <code class="literal">Microsoft.FSharp.Control</code>, not with <code class="literal">DelegateEvent</code> of the .NET framework.</p><p>In fact, this particular type of events offers many more functionalities, as previously seen.</p><p>When we presented an example of code related to the events, we confined ourselves to filter the stream of occurrences by using the position of the mouse. However, thanks to F#, now it is possible to apply more powerful flow controls:</p><pre class="programlisting">
open System
open System.Windows.Forms

let form = new Form(Text = "F# Windows Form",
                    Visible = true,
                    TopMost = true)
form.MouseMove
    |&gt; Event.choose(fun evArgs -&gt;
        match evArgs.Button with
            | MouseButtons.None -&gt; None
            | _ -&gt; Some( evArgs.X, evArgs.Y))

    |&gt; Event.filter (fun (x, y) -&gt;
        x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt; 255 &amp;&amp; y &lt; 255)

    |&gt; Event.add (fun (x, y) -&gt;
        form.BackColor &lt;- System.Drawing.Color.FromArgb(
            x, y, x ^^^ y))
</pre><p>The <code class="literal">Event.choose</code> function is similar to <code class="literal">Event.filter</code>; however, it creates a selection of messages from the original event, so it creates a new message.</p><p>Notice that through <span class="emphasis"><em>Pattern Matching</em></span> and <span class="emphasis"><em>Built-In Discriminate union (option-choice)</em></span>, we can pass values with different types using <code class="literal">Some</code> and we can also stop the execution using <code class="literal">None</code> when <code class="literal">MouseButtons</code> is in the status <code class="literal">none</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec110"></a>Continuous components</h3></div></div></div><p>Continuous components differ from discrete ones in many aspects. Anyway, together, they represent one of the main axes of FRP.</p><p>In this specific case, signals are called <span class="emphasis"><em>behavior</em></span> and they change continuously over time. In other words, a continuous component is composed of a constant value (signals) that can become any value during the time flow in a set of definite or indefinite values.</p><p>The following graphic shows how the time flow of a behavior works over time:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_003.jpg" /></div><p>
</p><p>Unlike a discrete scenario, there are no events in a continuous component, but a continuous change flow. Therefore, if a signal changes continuously, the calculation performed at each modification will be <span class="emphasis"><em>greater</em></span>, since it will occur <span class="emphasis"><em>many more times</em></span>.</p><p>When working with continuous components, we can find a <span class="emphasis"><em>latency state</em></span> and the scenario will be different because it will be pull-based. Regardless of how many times signals change, every new state of these signals will be elaborated, almost exclusively, in an <span class="emphasis"><em>asynchronous</em></span> context.</p><p>In a continuous implementation, it is not possible to count the number of occurences (changes), but every change will certainly be elaborated.</p><p>We can see the mathematical example and the related F# code again.</p><p>If we consider the function <span class="emphasis"><em>y= x<sup>2</sup>
</em></span> and we move the axis domain from integer to real, we will obtain <span class="emphasis"><em>a continuous line, not a set of different points</em></span>. This will happen because the scenario will move <span class="emphasis"><em>from discrete to continuous</em></span>, since any value will be included in the set of real numbers.</p><p>As a consequence, the representative F# code will be as follows:</p><pre class="programlisting">
#r @"../packages/FSharp.Charting.0.90.14/lib/net40/FSharp.Charting.dll"
#load @"..\packages\FSharp.Charting.0.90.14\FSharp.Charting.fsx"

open System
open System.Drawing
open System.Windows.Forms
open FSharp.Charting

let list = [for x in -10.0 .. 10.0 -&gt; (x, x ** 2.0)]
Chart.Line(list,Name="Float")
</pre><p>We will get the following graphical output:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_004.jpg" /></div><p>
</p><p>In conclusion, a continuous component has the following features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Demand-driven context</p></li><li style="list-style-type: disc"><p>As a consequence, the scenario will be pull-based</p></li><li style="list-style-type: disc"><p>Behaviors are <span class="emphasis"><em>indefinite occurrences of the change of scenario</em></span>
</p></li><li style="list-style-type: disc"><p>Time domain is of the type continuous</p></li><li style="list-style-type: disc"><p>There is a <span class="emphasis"><em>reactive system</em></span>
</p></li><li style="list-style-type: disc"><p>Often, we cannot count the number of occurred changes, but we know that they all are certainly processed</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec12"></a>Changing continuous value and event stream</h4></div></div></div><p>In F#, if we want to represent a discrete scenario, we have the module <code class="literal">Event</code> at our disposal, which expresses the <code class="literal">Event Stream</code> concept in detail.</p><p>However, in a continuous component, we do not find the type <code class="literal">Event</code>; in fact, it is more correct to talk about values and constants.</p><p>A good example of behavior is any <code class="literal">object Time</code> that continuously changes values over time. This modification can be negative or positive, but it certainly has different values in two different moments of the time flow.</p><p>It is not easy to find other cases in which it is simple to imagine an object that changes over time. Actually, in the example of the code used in the previous chapter, there is a kind of value that frequently changes:</p><pre class="programlisting">form.MouseMove
    |&gt; Event.filter( fun evArgs -&gt;
        evArgs.X &gt; 0 &amp;&amp; evArgs.Y &gt; 0 &amp;&amp;
        evArgs.X &lt; 255 &amp;&amp; evArgs.Y &lt; 255)
</pre><p>We have already defined a value that changes over time. The example shows how the position of the mouse (struct point) updates at every movement of the mouse with the value of the position of the absolute coordinates in the application window.</p><p>This is another good example of behavior. So, why did we previously consider it as an example of <code class="literal">Event Stream</code>?</p><p>In FRP, <code class="literal">Event</code> and behavior, such as discrete and continuous, <span class="emphasis"><em>are conceptually similar</em></span> and together they represent one of the main fundamentals.</p><p>By definition, we can state that:</p><p>
<span class="emphasis"><em>Event a ≈ Behavior (Maybe a) =&gt; Signals</em></span>
</p><p>Symbol <code class="literal">≈</code> means <span class="emphasis"><em>circa</em></span> or <span class="emphasis"><em>approximately the same</em></span>.</p><p>Now that we understand the main object of FRP, we can go further and analyze the common use scenario that includes both the concepts discussed up to this point.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec111"></a>Hybrid system</h3></div></div></div><p>The use of the signals is almost always essential in cases in which the system has to respond in realtime. Usually, these scenarios have as their objective the need to respond to incentives and they have to occur in a definite period of time. As a consequence, an essential aspect that comes to light is the fact that, in a <span class="emphasis"><em>reactive system</em></span>, it's very important to consider all the costs related to <span class="emphasis"><em>execution time</em></span> and <span class="emphasis"><em>used memory</em></span>. Imagine how much it could cost to not analyze these aspects in depth. It might result in memory leak or infinite cycles.</p><p>When referring to hybrid system or simply the <span class="strong"><strong>Real Time FRP</strong></span> (<span class="strong"><strong>RT-FRP</strong></span>) in FRP, a reactive system is made up mainly of two parts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Reactive part</em></span>, which contains everything that has to be technically developed, such as FRP</p></li><li style="list-style-type: disc"><p>A <span class="emphasis"><em>base language part</em></span>, developed in any language and paradigm of programming on which it is always possible to stop the execution and use definite resources</p></li></ul></div><p>Scenarios where it is possible to apply RT-FRP and create a hybrid system are numerous, for example, animations and <span class="strong"><strong>Graphical User Interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) seen in the code in the previous chapter.</p><p>Otherwise, it is very interesting, considering the application in robotics where responding to incentives in a reactive way is fundamental and it is important to accurately manage all data and the memory used.</p><p>Moreover, it is also important to notice that the evolution of technology in the last few years, such as the Cloud and <span class="strong"><strong>Internet of Things</strong></span> (<span class="strong"><strong>IoT</strong></span>), opens the way for new possibilities concerning the application of FRP and also the reactive system, or more aptly called the hybrid system, in particular. In fact, thanks to FRP and F#, it is possible to simplify the development of technologies by using the lambda architecture, composite functions, and actors.</p><p>In the following section, we will explain in detail how to interact with and integrate RT-FRP with some examples.</p></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec57"></a>Time flow and dynamic change</h2></div></div><hr /></div><p>Time flow and dynamic change are now clear concepts of FRP. In the previous chapter, we discussed over and over again what they are. They represent one of the main axes of FRP together with discrete and continuous semantics.</p><p>Concerning reactive systems (hybrid systems), we immediately understood how much important the concepts of execution time and used memory are. These two features may have some problems that could make the system nonreactive. The title of this section suggests a solution for them both. The following are the methods which can be used:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A good approach to avoid prolonged execution time or, even worse, the inability to manage the time flow; this results in having control on information flow (data or events)</p></li><li style="list-style-type: disc"><p>Instead, if we want to control used memory, for example, useless information or instances, it would be interesting to use a dynamically changing system according to the information obtained and architecture that already support these two features</p></li></ul></div><p>F# and any other language based on functional paradigm exposes and uses functions and architecture that already support these two features This is one of main reasons why languages that allow a functional approach are usually used for reactive scenarios</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec112"></a>Time flow in asynchronous data flow</h3></div></div></div><p>In FRP and also in real time scenarios, it is very likely that data flow and its manipulation happens in an asynchronous way.</p><p>Anyway, we know that in an asynchronous context it is not possible to establish with certainty the execution time of any operation. We can analyze the following code taken from MSDN (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee370262.aspx" target="_blank">
https://msdn.microsoft.com/en-us/library/ee370262.aspx
</a>):</p><pre class="programlisting">let bufferData (number:int) =
    [| for count in 1 .. 10 -&gt; byte (count % 256) |]
    |&gt; Array.permute (fun index -&gt; index)

let writeFile fileName bufferData =
    async {
      use outputFile = System.IO.File.Create(fileName)
      do! outputFile.AsyncWrite(bufferData)
    }

Seq.init 10 (fun num -&gt; bufferData num)
|&gt; Seq.mapi (fun num value -&gt; writeFile ("file" + num.ToString() + ".dat") value)
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; ignore
</pre><p>The function <code class="literal">Array.permute</code> performs the mapping from the input index to the output index.</p><p>The keyword <code class="literal">do!</code> and the asynchronous counterpart of the keyword <code class="literal">do</code> is the equivalent of the instruction <code class="literal">let () = expr.</code>, that is, the execution of an expression that returns a value unit type.</p><p>If we try to perform the function in <code class="literal">Interactive Console</code> of F#, in the Windows <code class="literal">Temp</code> folder, the following code will generate <code class="literal">10</code> files with <code class="literal">1000</code> chars in each one.</p><p>Anyway, if instead of <code class="literal">10</code> files, there are thousands or even worse infinite files, then it would not be possible to determine the time flow. In this case, it would be pointless to add a timeout to control the flow. Take a look at the following code:</p><pre class="programlisting">
let bufferData (number:int) =
    [| for i in 1 .. 1000 -&gt; byte (i % 256) |]
    |&gt; Array.permute (fun index -&gt; index)

let counter = ref 0

let writeFileInner (stream:System.IO.Stream) data =
    let result = stream.AsyncWrite(data)
    lock counter (fun () -&gt; counter := !counter + 1)
    result

let writeFile fileName bufferData =
    async {
      use outputFile = System.IO.File.Create(fileName)
      do! writeFileInner outputFile bufferData
    }

let async1 = Seq.init 1000 (fun num -&gt; bufferData num)
             |&gt; Seq.mapi (fun num value -&gt;
                 writeFile ("file_timeout" + num.ToString() + ".dat") value)
             |&gt; Async.Parallel
try
    Async.RunSynchronously(async1, 200) |&gt; ignore
with
   | exc -&gt; printfn "%s" exc.Message
            printfn "%d write operations completed successfully." !counter
</pre><p>Through the second parameter of the method <code class="literal">Async.RunSynchronously(async1, 200)</code>, we can set up the maximum execution time value in order to be able to control the time flow.</p><p>In this specific case, it will stop the flow that generates files when the countdown hits zero. In fact, if we look into the <code class="literal">Temp</code> folder or simply read the output message in <code class="literal">Interactive Console</code>, we can find a number of generated <span class="emphasis"><em>N</em></span> files that can change slightly at every execution, according to CPU work.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note68"></a>Note</h3><p>You should take into account that the number of generated files depends very much on your personal computer configuration and performance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec13"></a>Using F# and collection function for dynamic changing</h4></div></div></div><p>When we presented F# and FRP in particular, we introduced the following set of essential concepts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Everything can be considered as a stream of data or events</p></li><li style="list-style-type: disc"><p>A reactive system is dynamic and flexible, and allows the management of a time flow</p></li></ul></div><p>Now, if we try to put together these features, we can obtain an evolution of FRP, or better, a chance to organize our code and logical architecture through a <span class="emphasis"><em>flow of choices</em></span>.</p><p>To be able to handle a set of choices, such as a set of objects or functions, first of all we should have a common denominator which represents them, otherwise it won't be possible. In informatics term, we could say <span class="emphasis"><em>switch from a concrete implementation to an abstract one</em></span>.</p><p>In particular, functional programming has a strict connection with mathematics, so we should create <span class="strong"><strong>Computation Expressions</strong></span>. These expressions are inspired by the <span class="strong"><strong>Monads</strong></span> of the functional language Haskell, which in turn are inspired by the Monads concept in mathematics.</p><p>Computation Expressions are merely expressions that execute a function given an input and return a result (output). Otherwise, in terms more similar to programming, they are interfaces with rules for the execution of their own methods. For example, this allows us to connect more Monads and handle a workflow.</p><p>In F#, one of the simplest representations of Computation Expression during the flow of choices is the following:</p><pre class="programlisting">type Result&lt;'TSuccess,'TFailure&gt; =
    | Success of 'TSuccess
    | Failure of 'TFailure
</pre><p>This code represents a general discriminate union that has as a possible result <code class="literal">Success</code> or <code class="literal">Failure</code> of the type <code class="literal">'TSuccess</code> or <code class="literal">'Tfailure</code>, respectively.</p><p>The next code shows how we can take full advantage of Monads, connecting more functions that return always the same output:</p><pre class="programlisting">
type Result&lt;'TSuccess,'TFailure&gt; =
    | Success of 'TSuccess
    | Failure of 'TFailure

let bind inputFunc =
    function
    | Success s -&gt; inputFunc s
    | Failure f -&gt; Failure f


type Account = { UserName : string; IsLogged : bool; Email : string  }

let validateAccount account =
    match account with
    | account when account.UserName = "" -&gt; Failure "UserName is not valid"
    | account when account.Email = "" -&gt; Failure " Email is not empty"
    | _ -&gt; Success account


let checkLogin account =
    if(account.IsLogged) then
        Success account
    else
        Failure "User is not logged"

let LogIn account =
    if(account.IsLogged) then
        Failure "User has already Logged"
    else
        Success {account with IsLogged = true}

let LogOut account =
    if(account.IsLogged) then
        Success {account with IsLogged = false}
    else
        Failure "User has already Logged"

let ProcessNewAccount =
    let checkLogin = bind checkLogin
    let login = bind LogIn
    validateAccount &gt;&gt; login &gt;&gt; checkLogin

let NewFakeAccount = { UserName = ""; Email = ""; IsLogged = false }
let AccountLogged = { UserName = "User"; Email = "user@user.net"; IsLogged = true }
let NewAccount = { UserName = "User1"; Email = " user1@user.net "; IsLogged = false }

ProcessNewAccount NewFakeAccount |&gt; printfn "Result = %A"
ProcessNewAccount AccountLogged |&gt; printfn "Result = %A"
ProcessNewAccount NewAccount |&gt; printfn "Result = %A"
</pre><p>As you can see, we created different Monads: <code class="literal">validateAccount</code>, <code class="literal">checkLogin</code>, and <code class="literal">LogIn</code>, which return a type <code class="literal">Result&lt;Account,string&gt;</code> as a result. Later, we created a function called <code class="literal">ProcessNewAccount</code> that, through the use of the composition operator, (<code class="literal">&gt;&gt;</code>) connects each Monads in a definite flow. It is important to note how, for every function, it is necessary to use the method <code class="literal">bind</code> to avoid cast and anonymous type errors.</p><p>In the last row, three different accounts are defined, which are processed with the function <code class="literal">ProcessNewAccount</code>.</p><p>The result obtained through <code class="literal">Interactive Console</code> is as follows:</p><pre class="programlisting">Result = Failure "UserName is not valid"
Result = Failure "User has already Logged"
Result = Success {UserName = "User1";
         IsLogged = true;
         Email = " user1@user.net ";}
</pre></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec58"></a>Even more on FRP and F#</h2></div></div><hr /></div><p>The second half of the chapter shows how we can make the best use of F# and what the Microsoft .NET Framework makes available to enjoy and adopt FRP.</p><p>In the last few years, technology has evolved at an increasing rate. Nowadays, everything is connected and, in the future, each and every device will be able to receive and send data to and from each other. This will certainly lead to a technical evolution about the way we write the code. Let's think, only for a minute, about the notification messages that appear in our smartphone, our personal computer, and even in our smartwatch. All these need is a <span class="emphasis"><em>reactive system that is able to send millions if not billions of these messages simultaneously</em></span> on multiple devices.</p><p>This is why functional programming and (Functional) Reactive Programming in particular play a key role in this evolution.</p><p>Social networks, e-commerce servers dedicated in sending information from and to IoT devices, are already using hybrid systems that complement part of their architecture as a reactive system.</p><p>They communicate through <span class="emphasis"><em>signals</em></span> that are constantly processed in a time flow, sometimes well defined and sometimes indefinite. In the past, FRP was applied only to a specific domain, such as image elaboration or military terms. Now, even front end-web framework in JavaScript is designed for a reactive use (see Bacon.js 
<a class="ulink" href="https://baconjs.github.io/" target="_blank">https://baconjs.github.io/</a>
).</p><p>In this introduction, we summarized most of the concepts detailed in the previous chapters. Now, we will examine in depth some of the possibilities offered by the F# language and .NET Framework, particularly the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>We will see the last example on Computation Expression defining effectively what we will apply in that context</p></li><li style="list-style-type: disc"><p>We will analyze the F# <code class="literal">Obeservable</code> module</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec113"></a>Railway-oriented Programming</h3></div></div></div><p>We know that F# and functional paradigms can be recognized, in the previous example regarding Monads, as a particular programming technique. We are talking indeed about <span class="strong"><strong>Railway-oriented Programming</strong></span>, so let's figure out what it is. Railway-oriented Programming refers to a programming technique that connects different functions in a <span class="emphasis"><em>composition function</em></span> (called <code class="literal">path</code>), which has the task of sending the output of a single request to the following function in case of the success or failure of the management of the exception, prematurely ending the execution of the composition function itself.</p><p>The following image represents an execution path using this technique and is based on the function <code class="literal">ProcessNewAccount</code> of the previous example:</p><p>
</p><div class="mediaobject"><img src="graphics/image_09_005.jpg" /></div><p>
</p><p>As you can see, the diagram depicts three functions held in the Computation Expression that return <span class="strong"><strong>Success</strong></span> or <span class="strong"><strong>Failure</strong></span>. In case of failure, we can notice how the flow stops without passing to the next Monad and, in this specific case, it returns a string:</p><pre class="programlisting">let ProcessNewAccount =
    let checkLogin = bind checkLogin
    let login = bind LogIn
    validateAccount &gt;&gt; login &gt;&gt; checkLogin

//OutPut in interactive
//val ProcessNewAccount : (Account -&gt; Result&lt;Account,string&gt;)
</pre><p>It becomes clear that one of the aims of Railway-oriented Programming is the unified management of errors in a process. However, this kind of programming can be used in other domains provided that they can all be translated in a choice.</p><p>F# helps us in implementing this technique, presenting a general type that has whatever is necessary to manage a Monad without having to create a custom interface.</p><p>In the assembly <code class="literal">FSharp.Core</code>, there are a lot of types called <code class="literal">Choice</code> that contain a set of overloads for the type <code class="literal">Choice</code> varying from <code class="literal">2</code> to <code class="literal">8</code> in the multiple implementations. Actually, we are interested in the following one that has two choices:</p><pre class="programlisting">[&lt;StructuralEquality&gt;]
[&lt;StructuralComparison&gt;]
type Choice&lt;'T1,'T2&gt; =
| Choice1Of2 of 'T1
| Choice2Of2 of 'T2
 with
  interface IStructuralEquatable
  interface IComparable
  interface IComparable
  interface IStructuralComparable
 end
</pre><p>If we change the previous code with the implementation of the type <code class="literal">Choice</code>, the code in the example would be easier and concise, eliminating the general type 
<code class="literal">Result&lt;'TSuccess,'TFailure&gt;</code>, as you can see in the following code:</p><pre class="programlisting">let bind inputFunc =
    function
    | Choice1Of2 s -&gt; inputFunc s
    | Choice2Of2 f -&gt; Choice2Of2 f

type Account = { UserName : string; IsLogged : bool; Email : string  }

let validateAccount account =
    match account with
    | account when account.UserName = "" -&gt; Choice2Of2 "UserName is not valid"
    | account when account.Email = "" -&gt; Choice2Of2 " Email is not empty"
    | _ -&gt; Choice1Of2 account


let checkLogin account =
    if(account.IsLogged) then
        Choice1Of2 account
    else
        Choice2Of2 "User is not logged"

let LogIn account =
    if(account.IsLogged) then
        Choice2Of2 "User has already Logged"
    else
        Choice1Of2 {account with IsLogged = true}

let LogOut account =
    if(account.IsLogged) then
        Choice1Of2 {account with IsLogged = false}
    else
        Choice2Of2 "User has already Logged"

let ProcessNewAccount =
    validateAccount &gt;&gt; (bind LogIn) &gt;&gt; (bind checkLogin)

let NewFakeAccount = { UserName = ""; Email = ""; IsLogged = false }
let AccountLogged = { UserName = "User"; Email = "user@user.net"; IsLogged = true }
let NewAccount = { UserName = "User1"; Email = " user1@user.net "; IsLogged = false }

ProcessNewAccount NewFakeAccount |&gt; printfn "Result = %A"
ProcessNewAccount AccountLogged |&gt; printfn "Result = %A"
ProcessNewAccount NewAccount |&gt; printfn "Result = %A"
</pre><p>It is important to notice how much Railway-oriented Programming is strictly connected to FRP. In fact, thanks to these composed functions, it is possible to manage the personalized Monads flow in a reactive way. For example, we can create one for <code class="literal">LogOut</code>:</p><pre class="programlisting">let ProcessLogOutAccount =
    validateAccount &gt;&gt; (bind LogOut) &gt;&gt; (bind checkLogin)
</pre><p>We can also create another one for the validation and the login state:</p><pre class="programlisting">let ControlAccount =
    validateAccount &gt;&gt; (bind checkLogin)
</pre><p>Finally, we could even connect the composed functions to each other:</p><pre class="programlisting">let ControlAndLoginAccount =
    ProcessNewAccount &gt;&gt; (bind ControlAccount)
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec14"></a>Making an Observable in FRP</h4></div></div></div><p>In the previous chapter, we presented how the type <code class="literal">FsharpEvent</code> from the assembly <code class="literal">Fsharp.Core</code> includes a set of methods for event management:</p><pre class="programlisting">type Event&lt;'T&gt; =
 class
  new Event : unit -&gt; Event&lt;'T&gt;
  member this.Trigger : 'T -&gt; unit
  member this.Publish :  IEvent&lt;'T&gt;
 end
</pre><p>The interface <code class="literal">IEvent</code> inherits in turn <code class="literal">IObservable</code> and <code class="literal">IdelegateEvent</code> from two other interfaces.</p><p>The first one defines an agreement for the shipping of push-based notifications. In other words, we are talking about the same type used in .NET. In fact, its counterpart is the interface <code class="literal">IObserver</code>, which represents the agreement of notification reception.</p><p>Such as for the module <code class="literal">Event</code>, also for the type <code class="literal">IObservable</code> there exists a module called <code class="literal">Observable</code> that exposes a set of functions useful for the management and registration of observer.</p><p>Also, in this case, by using the guideline MSDN at the link <a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee370313(v=VS.100).aspx" target="_blank">https://msdn.microsoft.com/en-us/library/ee370313(v=VS.100).aspx</a>, we can find a table that summarizes the functions of the module.</p><p>In this short extract, we report single methods with their signatures:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<span class="strong"><strong>Function</strong></span>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><p>
<span class="strong"><strong>Value</strong></span>
</p><p>
 </p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">add</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; unit) -&gt;   IObservable&lt;'T&gt; -&gt; unit</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">choose</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; 'U option) -&gt;   IObservable&lt;'T&gt; -&gt; IObservable&lt;'U&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">filter</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; bool) -&gt;   IObservable&lt;'T&gt; -&gt; IObservable&lt;'T&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">map</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; 'U) -&gt;   IObservable&lt;'T&gt; -&gt; IObservable&lt;'U&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">merge</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>IObservable&lt;'T&gt; -&gt;   IObservable&lt;'T&gt; -&gt; IObservable&lt;'T&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">pairwise</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>IObservable&lt;'T&gt; -&gt;   IObservable&lt;'T * 'T&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">partition</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; bool) -&gt;   IObservable&lt;'T&gt; -&gt; IObservable&lt;'T&gt; * IObservable&lt;'T&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">scan</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('U -&gt; 'T -&gt; 'U) -&gt;   'U -&gt; IObservable&lt;'T&gt; -&gt; IObservable&lt;'T&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
<p>
<code class="literal">split</code>
</p>
</td><td style="border-bottom: 0.5pt solid ; ">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; Choice&lt;'U1,'U2&gt;)   -&gt; IObservable&lt;'T&gt; -&gt; IObservable&lt;'U1&gt; * IObservable&lt;'U2&gt;</strong></span>
</pre><p>
</p>
</td></tr><tr><td style="border-right: 0.5pt solid ; ">
<p>
<code class="literal">subscribe</code>
</p>
</td><td style="">
<p>
</p><pre class="programlisting">
<span class="strong"><strong>('T -&gt; unit) -&gt;   IObservable&lt;'T&gt; -&gt; IDisposable</strong></span>
</pre><p>
</p>
</td></tr></tbody></table></div><p>Through these functions, it is possible to create a subscriber, such as in C#. Then, we can use it to manage notifications:</p><pre class="programlisting">
module Observable =
   open System
   let ofSeq (values:'T seq) : IObservable&lt;'T&gt; =
      {
      new IObservable&lt;'T&gt; with
         member __.Subscribe(obs) =
            for x in values do obs.OnNext(x)
            {
            new IDisposable with
                member __.Dispose() = ()
            }
      }
   let inline print (observable:IObservable&lt; ^T &gt;) : IObservable&lt; ^T &gt; =
      {
      new IObservable&lt;'T&gt; with
         member this.Subscribe(observer:IObserver&lt;'T&gt;) =
            let value = ref (Unchecked.defaultof&lt;'T&gt;)
            let iterator =
               {
               new IObserver&lt;'T&gt; with
                  member __.OnNext(x) = printfn "%A" x
                  member __.OnCompleted() = observer.OnNext(!value)
                  member __.OnError(_) = failwith "Error"
               }
            observable.Subscribe(iterator)
      }
   let first (obs:IObservable&lt;'T&gt;) : 'T =
      let value = ref (Unchecked.defaultof&lt;'T&gt;)
      let _ = obs.Subscribe(fun x -&gt; value := x)
      !value


let obsValue =
   {0.0..100.0}
   |&gt; Observable.ofSeq
   |&gt; Observable.filter (fun x -&gt; x % 2.0 = 0.0)
   |&gt; Observable.map (fun x -&gt; x ** 3.0)
   |&gt; Observable.print
     |&gt; Observable.first
</pre><p>In the preceding example, the module F# has been extended with the following functions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">first</code> to return the first subscribed element</p></li><li style="list-style-type: disc"><p>
<code class="literal">print</code> to process all the elements one by one and display their values</p></li><li style="list-style-type: disc"><p>
<code class="literal">ofSeq</code> to cast a sequence in a observable list</p></li></ul></div></div></div></div></div></div></div>
﻿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec59"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we further deepened the main concepts of FRP.</p><p>In the first part, we presented the main differences between the discrete and continuous components, showing both theoretical analysis and examples of code. Afterward, we discussed the time flow and the asynchronous data flow. Then, we introduced Computation Expressions and also the concept of Monad.</p><p>In the second and last half of the chapter, we discussed the flow of choices, Railway-oriented Programming, and finally, the module <code class="literal">Observable</code>.</p><p>On reaching this point, we acquired all theoretical basic information to apply Reactive Programming and Functional Reactive Programming.</p><p>It is fundamental to understand how much these two paradigms are continuously intertwined. In fact, talking about Linq and Rx is almost the same as FRP and vice versa.</p><p>On the Web, there are not many concrete examples about using FRP through F# language. However, with little practice and knowledge of functional language Haskell, on the site Microsoft Academic (Link: <a class="ulink" href="https://academic.microsoft.com/" target="_blank">https://academic.microsoft.com/</a> ) there are lots of documents you can  download that either implement and extend FRP to real cases or simply describe the principles.</p><p>To those who develop and program with object-oriented languages, I also suggest to learn to get used to compositional thinking when dealing with functional programming.</p><p>In fact, most of everyday architecture and design pattern used in OOP are just simple functions in F# and in functional paradigm languages in general. Therefore, it could be useful to extend the way of thinking to a better subdivision of these functions, so compositional thinking could be the right way.</p></div></div></div></div>
</div></div></div></body></html>
