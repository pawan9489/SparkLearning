<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"> <!--320-->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

    <link rel="icon" href="../../mapt/images/favicon.ico">

    <link rel="stylesheet" href="../../mapt/css/font-awesome.css">
    <link rel="stylesheet" href="../../mapt/css/google-fonts.css">
    <link rel="stylesheet" href="../../mapt/css/devicon.css">

    <link rel="stylesheet" href="../../mapt/css/bootstrap.css">
    <link rel="stylesheet" href="../../mapt/css/bootstrap-xl.css">
    <link rel="stylesheet" href="../../mapt/css/magnific-popup.css">
    <link rel="stylesheet" href="../../mapt/css/prism.css">
    <link rel="stylesheet" href="../../mapt/css/hljs-github.css">

    <link rel="stylesheet" href="../../mapt/css/mapt.css">
    <link rel="stylesheet" href="../../mapt/css/custom.css">

    <script src="../../mapt/js/jquery.js"></script>
    <script src="../../mapt/js/bootstrap.js"></script>
    <script src="../../mapt/js/jquery.magnific-popup.js"></script>
    <script src="../../mapt/js/highlight.min.js"></script>

    <script src="../../mapt/js/custom.js"></script>
    
    <title>Multithreading with C# Cookbook - Second Edition</title>
</head>

<body class="home-body">
    <div id="wrapper">
        <div id="sidebar-wrapper">    
            <ul class="sidebar-nav">
                <div class="list-group" id="sidebar-nav" role="tablist">
                    <li>
                        <a href="../../index.html" class="sidenav-menu-holder back-btn" id="back-link">
                            <span class="sidenav-menu">Book List</span>
                            <span class="pull-left mr5"><i class="fa fa-chevron-left"></i></span>
                        </a>
                    </li>
                    
                    <li class="book-info copyright">
                        <span class="info text-nowrap"><span class="copyleft">&copy;</span><span><strong>RuTracker</strong>.org</span></span>
                    </li>          
                    <li class="book-info copyright">
                        <span class="info text-nowrap">Pub date: <strong>21 Apr 2016</strong></span>
                    </li>         
                    <li class="book-info">
                        <span class="info text-nowrap">Price: â‚¬<strong>35.99</strong></span>
                        <span class="info text-nowrap">ISBN: <strong>9781785881251</strong></span>
                    </li>     
            
                    <li>
                        <a href="graphics/cover.jpg" class="sidenav-menu-holder cover-img">
                            <img src="graphics/cover.jpg" class="cover-image">
                        </a>
                    </li>        
            
                    <div class="book_navigation">
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse1">
                                <div class="section-name">1: Threading Basics</div>
                            </a>
                        </li>
                        <div id="collapse1" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="1" class="sub-nav">
                                <a href="#ch01">
                                    <div class="section-name">Chapter 1: Threading Basics</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec08" class="sub-nav">
                                <a href="#ch01lvl1sec08">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec09" class="sub-nav">
                                <a href="#ch01lvl1sec09">                    
                                    <div class="section-name">Creating a thread in C#</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec10" class="sub-nav">
                                <a href="#ch01lvl1sec10">                    
                                    <div class="section-name">Pausing a thread</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec11" class="sub-nav">
                                <a href="#ch01lvl1sec11">                    
                                    <div class="section-name">Making a thread wait</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec12" class="sub-nav">
                                <a href="#ch01lvl1sec12">                    
                                    <div class="section-name">Aborting a thread</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec13" class="sub-nav">
                                <a href="#ch01lvl1sec13">                    
                                    <div class="section-name">Determining a thread state</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec14" class="sub-nav">
                                <a href="#ch01lvl1sec14">                    
                                    <div class="section-name">Thread priority</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec15" class="sub-nav">
                                <a href="#ch01lvl1sec15">                    
                                    <div class="section-name">Foreground and background threads</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec16" class="sub-nav">
                                <a href="#ch01lvl1sec16">                    
                                    <div class="section-name">Passing parameters to a thread</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec17" class="sub-nav">
                                <a href="#ch01lvl1sec17">                    
                                    <div class="section-name">Locking with a C# lock keyword</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec18" class="sub-nav">
                                <a href="#ch01lvl1sec18">                    
                                    <div class="section-name">Locking with a Monitor construct</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec19" class="sub-nav">
                                <a href="#ch01lvl1sec19">                    
                                    <div class="section-name">Handling exceptions</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse2">
                                <div class="section-name">2: Thread Synchronization</div>
                            </a>
                        </li>
                        <div id="collapse2" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="2" class="sub-nav">
                                <a href="#ch02">
                                    <div class="section-name">Chapter 2: Thread Synchronization</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec20" class="sub-nav">
                                <a href="#ch02lvl1sec20">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec21" class="sub-nav">
                                <a href="#ch02lvl1sec21">                    
                                    <div class="section-name">Performing basic atomic operations</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec22" class="sub-nav">
                                <a href="#ch02lvl1sec22">                    
                                    <div class="section-name">Using the Mutex construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec23" class="sub-nav">
                                <a href="#ch02lvl1sec23">                    
                                    <div class="section-name">Using the SemaphoreSlim construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec24" class="sub-nav">
                                <a href="#ch02lvl1sec24">                    
                                    <div class="section-name">Using the AutoResetEvent construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec25" class="sub-nav">
                                <a href="#ch02lvl1sec25">                    
                                    <div class="section-name">Using the ManualResetEventSlim construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec26" class="sub-nav">
                                <a href="#ch02lvl1sec26">                    
                                    <div class="section-name">Using the CountDownEvent construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec27" class="sub-nav">
                                <a href="#ch02lvl1sec27">                    
                                    <div class="section-name">Using the Barrier construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec28" class="sub-nav">
                                <a href="#ch02lvl1sec28">                    
                                    <div class="section-name">Using the ReaderWriterLockSlim construct</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec29" class="sub-nav">
                                <a href="#ch02lvl1sec29">                    
                                    <div class="section-name">Using the SpinWait construct</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse3">
                                <div class="section-name">3: Using a Thread Pool</div>
                            </a>
                        </li>
                        <div id="collapse3" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="3" class="sub-nav">
                                <a href="#ch03">
                                    <div class="section-name">Chapter 3: Using a Thread Pool</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec30" class="sub-nav">
                                <a href="#ch03lvl1sec30">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec31" class="sub-nav">
                                <a href="#ch03lvl1sec31">                    
                                    <div class="section-name">Invoking a delegate on a thread pool</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec32" class="sub-nav">
                                <a href="#ch03lvl1sec32">                    
                                    <div class="section-name">Posting an asynchronous operation on a thread pool</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec33" class="sub-nav">
                                <a href="#ch03lvl1sec33">                    
                                    <div class="section-name">A thread pool and the degree of parallelism</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec34" class="sub-nav">
                                <a href="#ch03lvl1sec34">                    
                                    <div class="section-name">Implementing a cancellation option</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec35" class="sub-nav">
                                <a href="#ch03lvl1sec35">                    
                                    <div class="section-name">Using a wait handle and timeout with a thread pool</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec36" class="sub-nav">
                                <a href="#ch03lvl1sec36">                    
                                    <div class="section-name">Using a timer</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec37" class="sub-nav">
                                <a href="#ch03lvl1sec37">                    
                                    <div class="section-name">Using the BackgroundWorker component</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse4">
                                <div class="section-name">4: Using the Task Parallel Library</div>
                            </a>
                        </li>
                        <div id="collapse4" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="4" class="sub-nav">
                                <a href="#ch04">
                                    <div class="section-name">Chapter 4: Using the Task Parallel Library</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec38" class="sub-nav">
                                <a href="#ch04lvl1sec38">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec39" class="sub-nav">
                                <a href="#ch04lvl1sec39">                    
                                    <div class="section-name">Creating a task</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec40" class="sub-nav">
                                <a href="#ch04lvl1sec40">                    
                                    <div class="section-name">Performing basic operations with a task</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec41" class="sub-nav">
                                <a href="#ch04lvl1sec41">                    
                                    <div class="section-name">Combining tasks</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec42" class="sub-nav">
                                <a href="#ch04lvl1sec42">                    
                                    <div class="section-name">Converting the APM pattern to tasks</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec43" class="sub-nav">
                                <a href="#ch04lvl1sec43">                    
                                    <div class="section-name">Converting the EAP pattern to tasks</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec44" class="sub-nav">
                                <a href="#ch04lvl1sec44">                    
                                    <div class="section-name">Implementing a cancelation option</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec45" class="sub-nav">
                                <a href="#ch04lvl1sec45">                    
                                    <div class="section-name">Handling exceptions in tasks</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec46" class="sub-nav">
                                <a href="#ch04lvl1sec46">                    
                                    <div class="section-name">Running tasks in parallel</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec47" class="sub-nav">
                                <a href="#ch04lvl1sec47">                    
                                    <div class="section-name">Tweaking the execution of tasks with TaskScheduler</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse5">
                                <div class="section-name">5: Using C# 6.0</div>
                            </a>
                        </li>
                        <div id="collapse5" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="5" class="sub-nav">
                                <a href="#ch05">
                                    <div class="section-name">Chapter 5: Using C# 6.0</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec48" class="sub-nav">
                                <a href="#ch05lvl1sec48">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec49" class="sub-nav">
                                <a href="#ch05lvl1sec49">                    
                                    <div class="section-name">Using the await operator to get asynchronous task results</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec50" class="sub-nav">
                                <a href="#ch05lvl1sec50">                    
                                    <div class="section-name">Using the await operator in a lambda expression</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec51" class="sub-nav">
                                <a href="#ch05lvl1sec51">                    
                                    <div class="section-name">Using the await operator with consequent asynchronous tasks</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec52" class="sub-nav">
                                <a href="#ch05lvl1sec52">                    
                                    <div class="section-name">Using the await operator for the execution of parallel asynchronous tasks</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec53" class="sub-nav">
                                <a href="#ch05lvl1sec53">                    
                                    <div class="section-name">Handling exceptions in asynchronous operations</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec54" class="sub-nav">
                                <a href="#ch05lvl1sec54">                    
                                    <div class="section-name">Avoiding the use of the captured synchronization context</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec55" class="sub-nav">
                                <a href="#ch05lvl1sec55">                    
                                    <div class="section-name">Working around the async void method</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec56" class="sub-nav">
                                <a href="#ch05lvl1sec56">                    
                                    <div class="section-name">Designing a custom awaitable type</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec57" class="sub-nav">
                                <a href="#ch05lvl1sec57">                    
                                    <div class="section-name">Using the dynamic type with await</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse6">
                                <div class="section-name">6: Using Concurrent Collections</div>
                            </a>
                        </li>
                        <div id="collapse6" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="6" class="sub-nav">
                                <a href="#ch06">
                                    <div class="section-name">Chapter 6: Using Concurrent Collections</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec58" class="sub-nav">
                                <a href="#ch06lvl1sec58">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec59" class="sub-nav">
                                <a href="#ch06lvl1sec59">                    
                                    <div class="section-name">Using ConcurrentDictionary</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec60" class="sub-nav">
                                <a href="#ch06lvl1sec60">                    
                                    <div class="section-name">Implementing asynchronous processing using ConcurrentQueue</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec61" class="sub-nav">
                                <a href="#ch06lvl1sec61">                    
                                    <div class="section-name">Changing asynchronous processing order with ConcurrentStack</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec62" class="sub-nav">
                                <a href="#ch06lvl1sec62">                    
                                    <div class="section-name">Creating a scalable crawler with ConcurrentBag</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec63" class="sub-nav">
                                <a href="#ch06lvl1sec63">                    
                                    <div class="section-name">Generalizing asynchronous processing with BlockingCollection</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse7">
                                <div class="section-name">7: Using PLINQ</div>
                            </a>
                        </li>
                        <div id="collapse7" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="7" class="sub-nav">
                                <a href="#ch07">
                                    <div class="section-name">Chapter 7: Using PLINQ</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec64" class="sub-nav">
                                <a href="#ch07lvl1sec64">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec65" class="sub-nav">
                                <a href="#ch07lvl1sec65">                    
                                    <div class="section-name">Using the Parallel class</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec66" class="sub-nav">
                                <a href="#ch07lvl1sec66">                    
                                    <div class="section-name">Parallelizing a LINQ query</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec67" class="sub-nav">
                                <a href="#ch07lvl1sec67">                    
                                    <div class="section-name">Tweaking the parameters of a PLINQ query</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec68" class="sub-nav">
                                <a href="#ch07lvl1sec68">                    
                                    <div class="section-name">Handling exceptions in a PLINQ query</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec69" class="sub-nav">
                                <a href="#ch07lvl1sec69">                    
                                    <div class="section-name">Managing data partitioning in a PLINQ query</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec70" class="sub-nav">
                                <a href="#ch07lvl1sec70">                    
                                    <div class="section-name">Creating a custom aggregator for a PLINQ query</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse8">
                                <div class="section-name">8: Reactive Extensions</div>
                            </a>
                        </li>
                        <div id="collapse8" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="8" class="sub-nav">
                                <a href="#ch08">
                                    <div class="section-name">Chapter 8: Reactive Extensions</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec71" class="sub-nav">
                                <a href="#ch08lvl1sec71">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec72" class="sub-nav">
                                <a href="#ch08lvl1sec72">                    
                                    <div class="section-name">Converting a collection to an asynchronous Observable</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec73" class="sub-nav">
                                <a href="#ch08lvl1sec73">                    
                                    <div class="section-name">Writing custom Observable</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec74" class="sub-nav">
                                <a href="#ch08lvl1sec74">                    
                                    <div class="section-name">Using the Subject type family</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec75" class="sub-nav">
                                <a href="#ch08lvl1sec75">                    
                                    <div class="section-name">Creating an Observable object</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec76" class="sub-nav">
                                <a href="#ch08lvl1sec76">                    
                                    <div class="section-name">Using LINQ queries against an observable collection</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec77" class="sub-nav">
                                <a href="#ch08lvl1sec77">                    
                                    <div class="section-name">Creating asynchronous operations with Rx</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse9">
                                <div class="section-name">9: Using Asynchronous I/O</div>
                            </a>
                        </li>
                        <div id="collapse9" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="9" class="sub-nav">
                                <a href="#ch09">
                                    <div class="section-name">Chapter 9: Using Asynchronous I/O</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec78" class="sub-nav">
                                <a href="#ch09lvl1sec78">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec79" class="sub-nav">
                                <a href="#ch09lvl1sec79">                    
                                    <div class="section-name">Working with files asynchronously</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec80" class="sub-nav">
                                <a href="#ch09lvl1sec80">                    
                                    <div class="section-name">Writing an asynchronous HTTP server and client</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec81" class="sub-nav">
                                <a href="#ch09lvl1sec81">                    
                                    <div class="section-name">Working with a database asynchronously</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec82" class="sub-nav">
                                <a href="#ch09lvl1sec82">                    
                                    <div class="section-name">Calling a WCF service asynchronously</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse10">
                                <div class="section-name">10: Parallel Programming Patterns</div>
                            </a>
                        </li>
                        <div id="collapse10" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="10" class="sub-nav">
                                <a href="#ch10">
                                    <div class="section-name">Chapter 10: Parallel Programming Patterns</div>
                                </a>
                            </li>
                            <li data-chapter="10" data-section-id="ch10lvl1sec83" class="sub-nav">
                                <a href="#ch10lvl1sec83">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="10" data-section-id="ch10lvl1sec84" class="sub-nav">
                                <a href="#ch10lvl1sec84">                    
                                    <div class="section-name">Implementing Lazy-evaluated shared states</div>
                                </a>
                            </li>
                            <li data-chapter="10" data-section-id="ch10lvl1sec85" class="sub-nav">
                                <a href="#ch10lvl1sec85">                    
                                    <div class="section-name">Implementing Parallel Pipeline with BlockingCollection</div>
                                </a>
                            </li>
                            <li data-chapter="10" data-section-id="ch10lvl1sec86" class="sub-nav">
                                <a href="#ch10lvl1sec86">                    
                                    <div class="section-name">Implementing Parallel Pipeline with TPL DataFlow</div>
                                </a>
                            </li>
                            <li data-chapter="10" data-section-id="ch10lvl1sec87" class="sub-nav">
                                <a href="#ch10lvl1sec87">                    
                                    <div class="section-name">Implementing Map/Reduce with PLINQ</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse11">
                                <div class="section-name">11: There&#x27;s More</div>
                            </a>
                        </li>
                        <div id="collapse11" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="11" class="sub-nav">
                                <a href="#ch11">
                                    <div class="section-name">Chapter 11: There&#x27;s More</div>
                                </a>
                            </li>
                            <li data-chapter="11" data-section-id="ch11lvl1sec88" class="sub-nav">
                                <a href="#ch11lvl1sec88">                    
                                    <div class="section-name">Introduction</div>
                                </a>
                            </li>
                            <li data-chapter="11" data-section-id="ch11lvl1sec89" class="sub-nav">
                                <a href="#ch11lvl1sec89">                    
                                    <div class="section-name">Using a timer in a Universal Windows Platform application</div>
                                </a>
                            </li>
                            <li data-chapter="11" data-section-id="ch11lvl1sec90" class="sub-nav">
                                <a href="#ch11lvl1sec90">                    
                                    <div class="section-name">Using WinRT from usual applications</div>
                                </a>
                            </li>
                            <li data-chapter="11" data-section-id="ch11lvl1sec91" class="sub-nav">
                                <a href="#ch11lvl1sec91">                    
                                    <div class="section-name">Using BackgroundTask in Universal Windows Platform applications</div>
                                </a>
                            </li>
                            <li data-chapter="11" data-section-id="ch11lvl1sec92" class="sub-nav">
                                <a href="#ch11lvl1sec92">                    
                                    <div class="section-name">Running a .NET Core application on OS X</div>
                                </a>
                            </li>
                            <li data-chapter="11" data-section-id="ch11lvl1sec93" class="sub-nav">
                                <a href="#ch11lvl1sec93">                    
                                    <div class="section-name">Running a .NET Core application on Ubuntu Linux</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapsebackindex">
                                <div class="section-name">Appendix A: Index</div>
                            </a>
                        </li>
                        <div id="collapsebackindex" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="backindex" class="sub-nav">
                                <a href="#backindex">
                                    <div class="section-name">Chapter Appendix A: Index</div>
                                </a>
                            </li>
                        </div>
                    </div>
                </div>
            </ul>
        </div>
        
        <div id="page-content-wrapper" class="book-page">
            <a href="#" id="menu-toggle" class="toggle-nav"><i class="fa fa-bars fa-2x mr5"></i></a>
            
            <a href="#" id="back_to_top" class="back-to-top"><img src="../../mapt/images/kopimi.svg"></a>
            
            <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10">
                <div class="btn-group pull-right mt15 mb30" role="group">
                    <a href="#home" class="btn btn-default">
                        <i class="fa fa-share fa-lg no-text-padding"></i>
                        <span class="hidden-xs ml5">Book Home</span>
                    </a>
                    <button class="btn btn-default" data-nid="24643" id="code-download">
                        <i class="fa fa-file fa-lg"></i>
                        <span class="hidden-xs ml5">Download Code Files</span>
                    </button>
                </div>
            </div>
            <div class="clearfix"></div>
            
            <div id="book-wrapper" class="container-fluid">
                <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10" id="home">
                    <h2 class="product-title">Multithreading with C# Cookbook - Second Edition</h2>
                    <hr>
                    <div class="row">
                        <div class="col-sm-12">
                            <h5 class="mt10">By Eugene Agafonov</h5>
                            <div>
                                <p class="mb20"><b>Over 70 recipes to get you writing powerful and efficient multithreaded, asynchronous, and parallel programs in C# 6.0</b></p>
                                <a href="#ch01" class="btn btn-info btn-lg pull-right hidden-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <a href="#ch01" class="btn btn-info btn-lg btn-block mt20 mb20 visible-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <div class="clearfix"></div>
                                <div class="col-sm-12">
                                    <ul id="myTabs" class="nav nav-tabs nav-justified hidden-xs mt20" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab" data-toggle="tab">
                                                <h5>Info</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab" data-toggle="tab">
                                                <h5>Contents</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab" data-toggle="tab">
                                                <h5>Author</h5>
                                            </a>
                                        </li>
                                    </ul>
                
                                    <ul id="myTabsMobile" class="nav nav-pills text-center nav-stacked visible-xs mb60" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab-responsive" data-toggle="tab">
                                                Info
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab-responsive" data-toggle="tab">
                                                Contents
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab-responsive" data-toggle="tab">
                                                Author
                                            </a>
                                        </li>
                                    </ul>
                
                                    <div id="myTabContent" class="tab-content pt30">
                                    
                                        <div role="tabpanel" class="tab-pane active fade in" id="info">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Features</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Features</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li>Rewritten and updated to take advantage of the latest C# 6 features</li>
                <li>Learn about multithreaded, asynchronous, and parallel programming through hands-on, code-first examples</li>
                <li>Use these recipes to build fast, scalable, and reliable applications in C#</li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Learning</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Learning</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li>Use C# 6.0 asynchronous language features</li>
                <li>Work with raw threads, synchronize threads, and coordinate their work</li>
                <li>Develop your own asynchronous API with Task Parallel Library</li>
                <li>Work effectively with a thread pool</li>
                <li>Scale up your server application with I/O threads</li>
                <li>Parallelize your LINQ queries with PLINQ</li>
                <li>Use common concurrent collections</li>
                <li>Apply different parallel programming patterns</li>
                <li>Use Reactive Extensions to run asynchronous operations and manage their options</li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">About</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>About</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <p>Multi-core processors are synonymous with computing speed and power in todayâ€™s world, which is why multithreading has become a key concern for C# developers. Multithreaded code helps you create effective, scalable, and responsive applications.</p>
                <p>This is an easy-to-follow guide that will show you difficult programming problems in context. You will learn how to solve them with practical, hands-on, recipes. With these recipes, youâ€™ll be able to start creating your own scalable and reliable multithreaded applications. Starting from learning what a thread is, we guide you through the basics and then move on to more advanced concepts such as task parallel libraries, C# asynchronous functions, and much more.</p>
                <p>Rewritten to the latest C# specification, C# 6, and updated with new and modern recipes to help you make the most of the hardware you have available, this book will help you push the boundaries of what you thought possible in C#.</p>
                                            </div>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade in" id="content">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Contents</h5>
                                                <hr>
                                            </div>
                                            <ul>
                                                <div>
                                                    <li data-chapter="1">
                                                        <div class="section-name">1: Threading Basics</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="1" class="chapter-section">
                                                                    <a href="#ch01">        
                                                                        <div class="section-name">Chapter 1: Threading Basics</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec08" class="chapter-section">
                                                                    <a href="#ch01lvl1sec08">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec09" class="chapter-section">
                                                                    <a href="#ch01lvl1sec09">                    
                                                                        <div class="section-name">Creating a thread in C#</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec10" class="chapter-section">
                                                                    <a href="#ch01lvl1sec10">                    
                                                                        <div class="section-name">Pausing a thread</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec11" class="chapter-section">
                                                                    <a href="#ch01lvl1sec11">                    
                                                                        <div class="section-name">Making a thread wait</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec12" class="chapter-section">
                                                                    <a href="#ch01lvl1sec12">                    
                                                                        <div class="section-name">Aborting a thread</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec13" class="chapter-section">
                                                                    <a href="#ch01lvl1sec13">                    
                                                                        <div class="section-name">Determining a thread state</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec14" class="chapter-section">
                                                                    <a href="#ch01lvl1sec14">                    
                                                                        <div class="section-name">Thread priority</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec15" class="chapter-section">
                                                                    <a href="#ch01lvl1sec15">                    
                                                                        <div class="section-name">Foreground and background threads</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec16" class="chapter-section">
                                                                    <a href="#ch01lvl1sec16">                    
                                                                        <div class="section-name">Passing parameters to a thread</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec17" class="chapter-section">
                                                                    <a href="#ch01lvl1sec17">                    
                                                                        <div class="section-name">Locking with a C# lock keyword</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec18" class="chapter-section">
                                                                    <a href="#ch01lvl1sec18">                    
                                                                        <div class="section-name">Locking with a Monitor construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec19" class="chapter-section">
                                                                    <a href="#ch01lvl1sec19">                    
                                                                        <div class="section-name">Handling exceptions</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="2">
                                                        <div class="section-name">2: Thread Synchronization</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="2" class="chapter-section">
                                                                    <a href="#ch02">        
                                                                        <div class="section-name">Chapter 2: Thread Synchronization</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec20" class="chapter-section">
                                                                    <a href="#ch02lvl1sec20">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec21" class="chapter-section">
                                                                    <a href="#ch02lvl1sec21">                    
                                                                        <div class="section-name">Performing basic atomic operations</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec22" class="chapter-section">
                                                                    <a href="#ch02lvl1sec22">                    
                                                                        <div class="section-name">Using the Mutex construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec23" class="chapter-section">
                                                                    <a href="#ch02lvl1sec23">                    
                                                                        <div class="section-name">Using the SemaphoreSlim construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec24" class="chapter-section">
                                                                    <a href="#ch02lvl1sec24">                    
                                                                        <div class="section-name">Using the AutoResetEvent construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec25" class="chapter-section">
                                                                    <a href="#ch02lvl1sec25">                    
                                                                        <div class="section-name">Using the ManualResetEventSlim construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec26" class="chapter-section">
                                                                    <a href="#ch02lvl1sec26">                    
                                                                        <div class="section-name">Using the CountDownEvent construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec27" class="chapter-section">
                                                                    <a href="#ch02lvl1sec27">                    
                                                                        <div class="section-name">Using the Barrier construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec28" class="chapter-section">
                                                                    <a href="#ch02lvl1sec28">                    
                                                                        <div class="section-name">Using the ReaderWriterLockSlim construct</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec29" class="chapter-section">
                                                                    <a href="#ch02lvl1sec29">                    
                                                                        <div class="section-name">Using the SpinWait construct</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="3">
                                                        <div class="section-name">3: Using a Thread Pool</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="3" class="chapter-section">
                                                                    <a href="#ch03">        
                                                                        <div class="section-name">Chapter 3: Using a Thread Pool</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec30" class="chapter-section">
                                                                    <a href="#ch03lvl1sec30">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec31" class="chapter-section">
                                                                    <a href="#ch03lvl1sec31">                    
                                                                        <div class="section-name">Invoking a delegate on a thread pool</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec32" class="chapter-section">
                                                                    <a href="#ch03lvl1sec32">                    
                                                                        <div class="section-name">Posting an asynchronous operation on a thread pool</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec33" class="chapter-section">
                                                                    <a href="#ch03lvl1sec33">                    
                                                                        <div class="section-name">A thread pool and the degree of parallelism</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec34" class="chapter-section">
                                                                    <a href="#ch03lvl1sec34">                    
                                                                        <div class="section-name">Implementing a cancellation option</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec35" class="chapter-section">
                                                                    <a href="#ch03lvl1sec35">                    
                                                                        <div class="section-name">Using a wait handle and timeout with a thread pool</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec36" class="chapter-section">
                                                                    <a href="#ch03lvl1sec36">                    
                                                                        <div class="section-name">Using a timer</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec37" class="chapter-section">
                                                                    <a href="#ch03lvl1sec37">                    
                                                                        <div class="section-name">Using the BackgroundWorker component</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="4">
                                                        <div class="section-name">4: Using the Task Parallel Library</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="4" class="chapter-section">
                                                                    <a href="#ch04">        
                                                                        <div class="section-name">Chapter 4: Using the Task Parallel Library</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec38" class="chapter-section">
                                                                    <a href="#ch04lvl1sec38">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec39" class="chapter-section">
                                                                    <a href="#ch04lvl1sec39">                    
                                                                        <div class="section-name">Creating a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec40" class="chapter-section">
                                                                    <a href="#ch04lvl1sec40">                    
                                                                        <div class="section-name">Performing basic operations with a task</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec41" class="chapter-section">
                                                                    <a href="#ch04lvl1sec41">                    
                                                                        <div class="section-name">Combining tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec42" class="chapter-section">
                                                                    <a href="#ch04lvl1sec42">                    
                                                                        <div class="section-name">Converting the APM pattern to tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec43" class="chapter-section">
                                                                    <a href="#ch04lvl1sec43">                    
                                                                        <div class="section-name">Converting the EAP pattern to tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec44" class="chapter-section">
                                                                    <a href="#ch04lvl1sec44">                    
                                                                        <div class="section-name">Implementing a cancelation option</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec45" class="chapter-section">
                                                                    <a href="#ch04lvl1sec45">                    
                                                                        <div class="section-name">Handling exceptions in tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec46" class="chapter-section">
                                                                    <a href="#ch04lvl1sec46">                    
                                                                        <div class="section-name">Running tasks in parallel</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec47" class="chapter-section">
                                                                    <a href="#ch04lvl1sec47">                    
                                                                        <div class="section-name">Tweaking the execution of tasks with TaskScheduler</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="5">
                                                        <div class="section-name">5: Using C# 6.0</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="5" class="chapter-section">
                                                                    <a href="#ch05">        
                                                                        <div class="section-name">Chapter 5: Using C# 6.0</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec48" class="chapter-section">
                                                                    <a href="#ch05lvl1sec48">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec49" class="chapter-section">
                                                                    <a href="#ch05lvl1sec49">                    
                                                                        <div class="section-name">Using the await operator to get asynchronous task results</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec50" class="chapter-section">
                                                                    <a href="#ch05lvl1sec50">                    
                                                                        <div class="section-name">Using the await operator in a lambda expression</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec51" class="chapter-section">
                                                                    <a href="#ch05lvl1sec51">                    
                                                                        <div class="section-name">Using the await operator with consequent asynchronous tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec52" class="chapter-section">
                                                                    <a href="#ch05lvl1sec52">                    
                                                                        <div class="section-name">Using the await operator for the execution of parallel asynchronous tasks</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec53" class="chapter-section">
                                                                    <a href="#ch05lvl1sec53">                    
                                                                        <div class="section-name">Handling exceptions in asynchronous operations</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec54" class="chapter-section">
                                                                    <a href="#ch05lvl1sec54">                    
                                                                        <div class="section-name">Avoiding the use of the captured synchronization context</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec55" class="chapter-section">
                                                                    <a href="#ch05lvl1sec55">                    
                                                                        <div class="section-name">Working around the async void method</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec56" class="chapter-section">
                                                                    <a href="#ch05lvl1sec56">                    
                                                                        <div class="section-name">Designing a custom awaitable type</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec57" class="chapter-section">
                                                                    <a href="#ch05lvl1sec57">                    
                                                                        <div class="section-name">Using the dynamic type with await</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="6">
                                                        <div class="section-name">6: Using Concurrent Collections</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="6" class="chapter-section">
                                                                    <a href="#ch06">        
                                                                        <div class="section-name">Chapter 6: Using Concurrent Collections</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec58" class="chapter-section">
                                                                    <a href="#ch06lvl1sec58">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec59" class="chapter-section">
                                                                    <a href="#ch06lvl1sec59">                    
                                                                        <div class="section-name">Using ConcurrentDictionary</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec60" class="chapter-section">
                                                                    <a href="#ch06lvl1sec60">                    
                                                                        <div class="section-name">Implementing asynchronous processing using ConcurrentQueue</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec61" class="chapter-section">
                                                                    <a href="#ch06lvl1sec61">                    
                                                                        <div class="section-name">Changing asynchronous processing order with ConcurrentStack</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec62" class="chapter-section">
                                                                    <a href="#ch06lvl1sec62">                    
                                                                        <div class="section-name">Creating a scalable crawler with ConcurrentBag</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec63" class="chapter-section">
                                                                    <a href="#ch06lvl1sec63">                    
                                                                        <div class="section-name">Generalizing asynchronous processing with BlockingCollection</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="7">
                                                        <div class="section-name">7: Using PLINQ</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="7" class="chapter-section">
                                                                    <a href="#ch07">        
                                                                        <div class="section-name">Chapter 7: Using PLINQ</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec64" class="chapter-section">
                                                                    <a href="#ch07lvl1sec64">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec65" class="chapter-section">
                                                                    <a href="#ch07lvl1sec65">                    
                                                                        <div class="section-name">Using the Parallel class</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec66" class="chapter-section">
                                                                    <a href="#ch07lvl1sec66">                    
                                                                        <div class="section-name">Parallelizing a LINQ query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec67" class="chapter-section">
                                                                    <a href="#ch07lvl1sec67">                    
                                                                        <div class="section-name">Tweaking the parameters of a PLINQ query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec68" class="chapter-section">
                                                                    <a href="#ch07lvl1sec68">                    
                                                                        <div class="section-name">Handling exceptions in a PLINQ query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec69" class="chapter-section">
                                                                    <a href="#ch07lvl1sec69">                    
                                                                        <div class="section-name">Managing data partitioning in a PLINQ query</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec70" class="chapter-section">
                                                                    <a href="#ch07lvl1sec70">                    
                                                                        <div class="section-name">Creating a custom aggregator for a PLINQ query</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="8">
                                                        <div class="section-name">8: Reactive Extensions</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="8" class="chapter-section">
                                                                    <a href="#ch08">        
                                                                        <div class="section-name">Chapter 8: Reactive Extensions</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec71" class="chapter-section">
                                                                    <a href="#ch08lvl1sec71">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec72" class="chapter-section">
                                                                    <a href="#ch08lvl1sec72">                    
                                                                        <div class="section-name">Converting a collection to an asynchronous Observable</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec73" class="chapter-section">
                                                                    <a href="#ch08lvl1sec73">                    
                                                                        <div class="section-name">Writing custom Observable</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec74" class="chapter-section">
                                                                    <a href="#ch08lvl1sec74">                    
                                                                        <div class="section-name">Using the Subject type family</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec75" class="chapter-section">
                                                                    <a href="#ch08lvl1sec75">                    
                                                                        <div class="section-name">Creating an Observable object</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec76" class="chapter-section">
                                                                    <a href="#ch08lvl1sec76">                    
                                                                        <div class="section-name">Using LINQ queries against an observable collection</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec77" class="chapter-section">
                                                                    <a href="#ch08lvl1sec77">                    
                                                                        <div class="section-name">Creating asynchronous operations with Rx</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="9">
                                                        <div class="section-name">9: Using Asynchronous I/O</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="9" class="chapter-section">
                                                                    <a href="#ch09">        
                                                                        <div class="section-name">Chapter 9: Using Asynchronous I/O</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec78" class="chapter-section">
                                                                    <a href="#ch09lvl1sec78">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec79" class="chapter-section">
                                                                    <a href="#ch09lvl1sec79">                    
                                                                        <div class="section-name">Working with files asynchronously</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec80" class="chapter-section">
                                                                    <a href="#ch09lvl1sec80">                    
                                                                        <div class="section-name">Writing an asynchronous HTTP server and client</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec81" class="chapter-section">
                                                                    <a href="#ch09lvl1sec81">                    
                                                                        <div class="section-name">Working with a database asynchronously</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec82" class="chapter-section">
                                                                    <a href="#ch09lvl1sec82">                    
                                                                        <div class="section-name">Calling a WCF service asynchronously</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="10">
                                                        <div class="section-name">10: Parallel Programming Patterns</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="10" class="chapter-section">
                                                                    <a href="#ch10">        
                                                                        <div class="section-name">Chapter 10: Parallel Programming Patterns</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="10" data-section-id="ch10lvl1sec83" class="chapter-section">
                                                                    <a href="#ch10lvl1sec83">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="10" data-section-id="ch10lvl1sec84" class="chapter-section">
                                                                    <a href="#ch10lvl1sec84">                    
                                                                        <div class="section-name">Implementing Lazy-evaluated shared states</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="10" data-section-id="ch10lvl1sec85" class="chapter-section">
                                                                    <a href="#ch10lvl1sec85">                    
                                                                        <div class="section-name">Implementing Parallel Pipeline with BlockingCollection</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="10" data-section-id="ch10lvl1sec86" class="chapter-section">
                                                                    <a href="#ch10lvl1sec86">                    
                                                                        <div class="section-name">Implementing Parallel Pipeline with TPL DataFlow</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="10" data-section-id="ch10lvl1sec87" class="chapter-section">
                                                                    <a href="#ch10lvl1sec87">                    
                                                                        <div class="section-name">Implementing Map/Reduce with PLINQ</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="11">
                                                        <div class="section-name">11: There&#x27;s More</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="11" class="chapter-section">
                                                                    <a href="#ch11">        
                                                                        <div class="section-name">Chapter 11: There&#x27;s More</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="11" data-section-id="ch11lvl1sec88" class="chapter-section">
                                                                    <a href="#ch11lvl1sec88">                    
                                                                        <div class="section-name">Introduction</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="11" data-section-id="ch11lvl1sec89" class="chapter-section">
                                                                    <a href="#ch11lvl1sec89">                    
                                                                        <div class="section-name">Using a timer in a Universal Windows Platform application</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="11" data-section-id="ch11lvl1sec90" class="chapter-section">
                                                                    <a href="#ch11lvl1sec90">                    
                                                                        <div class="section-name">Using WinRT from usual applications</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="11" data-section-id="ch11lvl1sec91" class="chapter-section">
                                                                    <a href="#ch11lvl1sec91">                    
                                                                        <div class="section-name">Using BackgroundTask in Universal Windows Platform applications</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="11" data-section-id="ch11lvl1sec92" class="chapter-section">
                                                                    <a href="#ch11lvl1sec92">                    
                                                                        <div class="section-name">Running a .NET Core application on OS X</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="11" data-section-id="ch11lvl1sec93" class="chapter-section">
                                                                    <a href="#ch11lvl1sec93">                    
                                                                        <div class="section-name">Running a .NET Core application on Ubuntu Linux</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="backindex">
                                                        <div class="section-name">Appendix A: Index</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="backindex" class="chapter-section">
                                                                    <a href="#backindex">
                                                                        <div class="section-name">Chapter Appendix A: Index</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                            </ul>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade" id="author">
                                            <div class="visible-xs">
                                                <h4 class="mobile-title">About the Author</h4>
                                                <hr>
                                            </div>
                                            <p><strong>Eugene Agafonov</strong></p>
                                            <div>
                                                <p>Eugene Agafonov leads the development department at ABBYY and lives in Moscow. He has over 15 years of professional experience in software development, and he started working with C# when it was in beta version. He is a Microsoft MVP in ASP.NET since 2006, and he often speaks at local software development conferences, such as DevCon Russia, about cutting-edge technologies in modern web and server-side application development. His main professional interests are cloud-based software architecture, scalability, and reliability. Eugene is a huge fan of football and plays the guitar with a local rock band. You can reach him at his personal blog, <a href="http://eugeneagafonov.com" target="_blank">eugeneagafonov.com</a>, or find him on Twitter at @eugene_agafonov.</p>
                <p>ABBYY is a global leader in the development of document recognition, content capture, and language-based technologies and solutions that are integrated across the entire information life cycle.</p>
                <p>He is the author of Multhreading in C# 5.0 Cookbook and Mastering C# Concurrency by Packt Publishing.</p>
                                            </div>
                                        </div>
                                        
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="next-wrapper">
                        <div class="row ns">
                            <hr />
                            <span class="hidden-xs">
                                <h4 class="pull-left">
                                    <strong>Up Next: </strong><span class="section-title"></span>
                                </h4>
                                <a href="#" class="btn btn-primary pull-right btn-lg">
                                    Next Section
                                </a>
                            </span>
                            <span class="visible-xs">
                                <a href="#" class="btn btn-primary btn-block btn-lg">
                                    Next Section
                                </a>
                            </span>
                        </div>
                        <div class="row ns">
                            <hr>
                        </div>
                    </div>
                </div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch01"></a>ChapterÂ 1.Â Threading Basics</h2></div></div></div><p>In this chapter, we will cover the basic tasks to work with threads in C#. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating a thread in C#</p></li><li style="list-style-type: disc"><p>Pausing a thread</p></li><li style="list-style-type: disc"><p>Making a thread wait</p></li><li style="list-style-type: disc"><p>Aborting a thread</p></li><li style="list-style-type: disc"><p>Determining a thread state</p></li><li style="list-style-type: disc"><p>Thread priority</p></li><li style="list-style-type: disc"><p>Foreground and background threads</p></li><li style="list-style-type: disc"><p>Passing parameters to a thread</p></li><li style="list-style-type: disc"><p>Locking with a C# lock keyword</p></li><li style="list-style-type: disc"><p>Locking with a <code class="literal">Monitor</code> construct</p></li><li style="list-style-type: disc"><p>Handling exceptions</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec08"></a>Introduction</h2></div></div><hr /></div><p>At some point of time in the past, the common computer had only one computing unit and could not execute several computing tasks simultaneously. However, operating systems could already work with multiple programs simultaneously, implementing the concept of multitasking. To prevent the possibility of one program taking control of the CPU forever, causing other applications and the operating system itself to hang, the operating systems had to split a physical computing unit across a few virtualized processors in some way and give a certain amount of computing power to each executing program. Moreover, an operating system must always have priority access to the CPU and should be able to prioritize CPU access to different programs. A thread is an implementation of this concept. It could be considered as a  virtual processor that is given to the one specific program and runs it independently.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>Remember that a thread consumes a significant amount of operating system resources. Trying to share one physical processor across many threads will lead to a situation where an operating system is busy just managing threads instead of running programs.</p></div><p>Therefore, while it was possible to enhance computer processors, making them execute more and more commands per second, working with threads was usually an operating system task. There was no sense in trying to compute some tasks in parallel on a single-core CPU because it would take more time than running those computations sequentially. However, when processors started to have more computing cores, older programs could not take advantage of this because they just used one processor core.</p><p>To use a modern processor's computing power effectively, it is very important to be able to compose a program in a way that it can use more than one computing core, which leads to organizing it as several threads that communicate and synchronize with each other.</p><p>The recipes in this chapter focus on performing some very basic operations with threads in the C# language. We will cover a thread's life cycle, which includes creating, suspending, making a thread wait, and aborting a thread, and then, we will go through the basic synchronization techniques.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec09"></a>Creating a thread in C#</h2></div></div><hr /></div><p>Throughout <a id="id0" class="indexterm"></a>the following recipes, we will use Visual Studio 2015 as the <a id="id1" class="indexterm"></a>main tool to write multithreaded programs in C#. This recipe will show you how to create a new C# program and use threads in it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note03"></a>Note</h3><p>A free Visual Studio Community 2015 IDE can be downloaded from the Microsoft website and used to run the code samples.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec06"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found in the <code class="literal">BookSamples\Chapter1\Recipe1</code> directory.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip02"></a>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for this book from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>You can download the code files by following these steps:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Log in or register to our website using your e-mail address and password.</p></li><li style="list-style-type: disc"><p>Hover the mouse pointer on the <span class="strong"><strong>SUPPORT</strong></span> tab at the top.</p></li><li style="list-style-type: disc"><p>Click on <span class="strong"><strong>Code Downloads &amp; Errata</strong></span>.</p></li><li style="list-style-type: disc"><p>Enter the name of the book in the <span class="strong"><strong>Search</strong></span> box.</p></li><li style="list-style-type: disc"><p>Select the book for which you're looking to download the code files.</p></li><li style="list-style-type: disc"><p>Choose from the drop-down menu where you purchased this book from.</p></li><li style="list-style-type: disc"><p>Click on <span class="strong"><strong>Code Download</strong></span>.</p></li></ul></div><p>Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>WinRAR/7-Zip for Windows</p></li><li style="list-style-type: disc"><p>Zipeg/iZip / UnRarX for Mac</p></li><li style="list-style-type: disc"><p>7-Zip/PeaZip for Linux</p></li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec07"></a>How to do it...</h3></div></div></div><p>To understand how to <a id="id2" class="indexterm"></a>create a new C# program and use threads in it, perform the <a id="id3" class="indexterm"></a>following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Make sure that the project uses .NET Framework 4.6 or higher; however, the code in this chapter will work with previous versions.</p><div class="mediaobject"><img src="graphics/B05292_01_01.jpg" /></div></li><li><p>In the <a id="id4" class="indexterm"></a>
<code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> <a id="id5" class="indexterm"></a>directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void PrintNumbers()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    WriteLine(i);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Thread t = new Thread(PrintNumbers);
t.Start();
PrintNumbers();</pre></div></li><li><p>Run the program. The output will be something like the following screenshot:</p><div class="mediaobject"><img src="graphics/B05292_01_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>How it works...</h3></div></div></div><p>In step 1 and 2, we created a simple console application in C# using .Net Framework version 4.0. Then, in step 3, we included the <code class="literal">System.Threading</code> namespace, which contains all the types needed for the program. Then, we used the <code class="literal">using static</code> feature from C# 6.0, which allows us to use the <code class="literal">System.Console</code> type's static methods without specifying the type name.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note04"></a>Note</h3><p>An instance of a program that is being executed can be referred to as a process. A process consists of one or more threads. This means that when we run a program, we always have one main thread that executes the program code.</p></div><p>In step 4, we defined the <code class="literal">PrintNumbers</code> method, which will be used in both the main and newly created <a id="id6" class="indexterm"></a>threads. Then, in step 5, we created a thread that runs <a id="id7" class="indexterm"></a>
<code class="literal">PrintNumbers</code>. When we construct a thread, an instance of the <code class="literal">ThreadStart</code> or <code class="literal">ParameterizedThreadStart</code> delegate is passed to the constructor. The C# compiler creates this object behind the scenes when we just type the name of the method we want to run in a different thread. Then, we start a thread and run <code class="literal">PrintNumbers</code> in the usual manner on the main thread.</p><p>As a result, there will be two ranges of numbers from 1 to 10 randomly crossing each other. This illustrates <a id="id8" class="indexterm"></a>that the <code class="literal">PrintNumbers</code> method runs simultaneously on the main thread and on the other thread.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Pausing a thread</h2></div></div><hr /></div><p>This recipe <a id="id9" class="indexterm"></a>will show you how to make a thread wait for some time without wasting operating system resources.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec09"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>How to do it...</h3></div></div></div><p>To understand how to make a thread wait without wasting operating system resources, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void PrintNumbers()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    WriteLine(i);
  }
}
static void PrintNumbersWithDelay()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Thread t = new Thread(PrintNumbersWithDelay);
t.Start();
PrintNumbers();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>How it works...</h3></div></div></div><p>When the program is run, it creates a thread that will execute a code in the <code class="literal">PrintNumbersWithDelay</code> method. Immediately after that, it runs the <code class="literal">PrintNumbers</code> method. The key feature <a id="id10" class="indexterm"></a>here is adding the <code class="literal">Thread.Sleep</code> method call to a <code class="literal">PrintNumbersWithDelay</code> method. It causes the thread executing this code to wait a specified amount of time (2 seconds in our case) before printing each number. While a thread sleeps, it uses as little CPU time as possible. As a result, we will see that the code in the <code class="literal">PrintNumbers</code> method, which usually runs later, will be executed before the code in the <code class="literal">PrintNumbersWithDelay</code> method in a separate thread.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Making a thread wait</h2></div></div><hr /></div><p>This recipe will <a id="id11" class="indexterm"></a>show you how a program can wait for some computation in another thread to complete to use its result later in the code. It is not enough to use the <code class="literal">Thread.Sleep</code> method because we don't know the exact time the computation will take.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>How to do it...</h3></div></div></div><p>To understand how a program waits for some computation in another thread to complete in order to use its result later, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void PrintNumbersWithDelay()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Starting...");
Thread t = new Thread(PrintNumbersWithDelay);
t.Start();
t.Join();
WriteLine("Thread completed");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>How it works...</h3></div></div></div><p>When the program is run, it runs a long-running thread that prints out numbers and waits two seconds before <a id="id12" class="indexterm"></a>printing each number. But, in the main program, we called the <code class="literal">t.Join</code> method, which allows us to wait for the thread <code class="literal">t</code> to complete working. When it is complete, the main program continues to run. With the help of this technique, it is possible to synchronize execution steps between two threads. The first one waits until another one is complete and then continues to work. While the first thread waits, it is in a <code class="literal">blocked</code> state (as it is in the previous recipe when you call <code class="literal">Thread.Sleep</code>).</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec12"></a>Aborting a thread</h2></div></div><hr /></div><p>In this recipe, we will <a id="id13" class="indexterm"></a>describe how to abort another thread's execution.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec16"></a>How to do it...</h3></div></div></div><p>To understand how to abort another thread's execution, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li><p>Using the static <code class="literal">System.Threading.Thread</code>, add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void PrintNumbersWithDelay()
{
  WriteLine("Starting...");
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Starting program...");
Thread t = new Thread(PrintNumbersWithDelay);
t.Start();
Thread.Sleep(TimeSpan.FromSeconds(6));
t.Abort();
WriteLine("A thread has been aborted");
Thread t = new Thread(PrintNumbers);
t.Start();
PrintNumbers();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec17"></a>How it works...</h3></div></div></div><p>When the main program <a id="id14" class="indexterm"></a>and a separate number-printing thread run, we wait for six seconds and then call a <code class="literal">t.Abort</code> method on a thread. This injects a <code class="literal">ThreadAbortException</code> method into a thread, causing it to terminate. It is very dangerous, generally because this exception can happen at any point and may totally destroy the application. In addition, it is not always possible to terminate a thread with this technique. The target thread may refuse to abort by handling this exception by calling the <code class="literal">Thread.ResetAbort</code> method. Thus, it is not recommended that you use the <code class="literal">Abort</code> method to close a thread. There are different methods that are preferred, such as providing a <code class="literal">CancellationToken</code> object to cancel a thread execution. This approach will be described in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Using a Thread Pool</em></span>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec13"></a>Determining a thread state</h2></div></div><hr /></div><p>This recipe will <a id="id15" class="indexterm"></a>describe the possible states a thread could have. It is useful to get information about whether a thread is started yet or whether it is in a blocked state. Note that because a thread runs independently, its state could be changed at any time.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec18"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec19"></a>How to do it...</h3></div></div></div><p>To understand how to determine a thread state and acquire useful information about it, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void DoNothing()
{
  Sleep(TimeSpan.FromSeconds(2));
}

static void PrintNumbersWithStatus()
{
  WriteLine("Starting...");
  WriteLine(CurrentThread.ThreadState.ToString());
  for (int i = 1; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(2));
    WriteLine(i);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Starting program...");
Thread t = new Thread(PrintNumbersWithStatus);
Thread t2 = new Thread(DoNothing);
WriteLine(t.ThreadState.ToString());
t2.Start();
t.Start();
for (int i = 1; i &lt; 30; i++)
{
  WriteLine(t.ThreadState.ToString());
}
Sleep(TimeSpan.FromSeconds(6));
t.Abort();
WriteLine("A thread has been aborted");
WriteLine(t.ThreadState.ToString());
WriteLine(t2.ThreadState.ToString());</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>How it works...</h3></div></div></div><p>When the main program <a id="id16" class="indexterm"></a>starts, it defines two different threads; one of them will be aborted and the other runs successfully. The thread state is located in the <code class="literal">ThreadState</code> property of a <code class="literal">Thread</code> object, which is a C# enumeration. At first, the thread has a <code class="literal">ThreadState.Unstarted</code> state. Then, we run it and assume that for the duration of 30 iterations of a cycle, the thread will change its state from <code class="literal">ThreadState.Running</code> to <code class="literal">ThreadState.WaitSleepJoin</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>Note that the current <code class="literal">Thread</code> object is always accessible through the <code class="literal">Thread.CurrentThread</code> static property.</p></div><p>If this does not happen, just increase the number of iterations. Then, we abort the first thread and see that now it has a <code class="literal">ThreadState.Aborted</code> state. It is also possible that the program will print out the <code class="literal">ThreadState.AbortRequested</code> state. This illustrates, very well, the complexity of synchronizing two threads. Keep in mind that you should not use thread abortion in your programs. I've covered it here only to show the corresponding thread state.</p><p>Finally, we can see that our second thread <code class="literal">t2</code> was completed successfully and now has a <code class="literal">ThreadState.Stopped</code> state. There are several other states, but they are partly deprecated and not as useful as those we examined.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>Thread priority</h2></div></div><hr /></div><p>This recipe will <a id="id17" class="indexterm"></a>describe the different options for thread priority. Setting a thread priority determines how much CPU time a thread will be given.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>How to do it...</h3></div></div></div><p>To understand the <a id="id18" class="indexterm"></a>workings of thread priority, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;
using static System.Diagnostics.Process;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void RunThreads()
{
  var sample = new ThreadSample();

  var threadOne = new Thread(sample.CountNumbers);
  threadOne.Name = "ThreadOne";
  var threadTwo = new Thread(sample.CountNumbers);
  threadTwo.Name = "ThreadTwo";

  threadOne.Priority = ThreadPriority.Highest;
  threadTwo.Priority = ThreadPriority.Lowest;
  threadOne.Start();
  threadTwo.Start();

  Sleep(TimeSpan.FromSeconds(2));
  sample.Stop();
}

class ThreadSample
{
  private bool _isStopped = false;

  public void Stop()
  {
    _isStopped = true;
  }

  public void CountNumbers()
  {
    long counter = 0;

    while (!_isStopped)
    {
      counter++;
    }

    WriteLine($"{CurrentThread.Name} with " +
      $"{CurrentThread.Priority,11} priority " +
      $"has a count = {counter,13:N0}");
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine($"Current thread priority: {CurrentThread.Priority}");
WriteLine("Running on all cores available");
RunThreads();
Sleep(TimeSpan.FromSeconds(2));
WriteLine("Running on a single core");
GetCurrentProcess().ProcessorAffinity = new IntPtr(1);
RunThreads();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"></a>How it works...</h3></div></div></div><p>When the main program starts, it defines two different threads. The first one, <code class="literal">threadOne</code>, has the highest thread priority <code class="literal">ThreadPriority.Highest</code>, while the second one, that is <code class="literal">threadTwo</code>, has the lowest <code class="literal">ThreadPriority.Lowest</code> priority. We print out the main thread priority value and then start these two threads on all available cores. If we have more than one computing core, we should get an initial result within two seconds. The highest priority thread should calculate more iterations usually, but both values should be close. However, if there are any other programs running that load all the CPU cores, the situation could be quite different.</p><p>To simulate this situation, we <a id="id19" class="indexterm"></a>set up the <code class="literal">ProcessorAffinity</code> option, instructing the operating system to run all our threads on a single CPU core (number 1). Now, the results should be very different, and the calculations will take more than two seconds. This happens because the CPU core runs mostly the high-priority thread, giving the rest of the threads very little time.</p><p>Note that this is an illustration of how an operating system works with thread prioritization. Usually, you <a id="id20" class="indexterm"></a>should not write programs relying on this behavior.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec15"></a>Foreground and background threads</h2></div></div><hr /></div><p>This recipe will <a id="id21" class="indexterm"></a>describe what foreground and background threads are and how <a id="id22" class="indexterm"></a>setting this option affects the program's behavior.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec24"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe7</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec25"></a>How to do it...</h3></div></div></div><p>To understand the effect of foreground and background threads on a program, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">class ThreadSample
{
  private readonly int _iterations;

  public ThreadSample(int iterations)
  {
    _iterations = iterations;
  }
  public void CountNumbers()
  {
    for (int i = 0; i &lt; _iterations; i++)
    {
      Sleep(TimeSpan.FromSeconds(0.5));
      WriteLine($"{CurrentThread.Name} prints {i}");
    }
  }
}</pre></div></li><li><p>Add the <a id="id23" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var sampleForeground = new ThreadSample(10);
var sampleBackground = new ThreadSample(20);

var threadOne = new Thread(sampleForeground.CountNumbers);
threadOne.Name = "ForegroundThread";
var threadTwo = new Thread(sampleBackground.CountNumbers);
threadTwo.Name = "BackgroundThread";
threadTwo.IsBackground = true;

threadOne.Start();
threadTwo.Start();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec26"></a>How it works...</h3></div></div></div><p>When the main program starts, it defines two different threads. By default, a thread that we create explicitly is a foreground thread. To create a background thread, we manually set the <code class="literal">IsBackground</code> <a id="id24" class="indexterm"></a>property of the <code class="literal">threadTwo</code> object to <code class="literal">true</code>. We configure these threads in a way that the first one will be completed faster, and then we run the program.</p><p>After the first thread is complete, the program shuts down and the background thread is terminated. This is the main difference between the two: a process waits for all the foreground threads to complete before finishing the work, but if it has background threads, they just shut down.</p><p>It is also important to mention that if a program defines a foreground thread that does not get completed; the main program does not end properly.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec16"></a>Passing parameters to a thread</h2></div></div><hr /></div><p>This recipe will <a id="id25" class="indexterm"></a>describe how to provide code that we run in another <a id="id26" class="indexterm"></a>thread with the required data. We will go through the different ways to fulfill this task and review common mistakes.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec27"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe8</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec28"></a>How to do it...</h3></div></div></div><p>To understand how to <a id="id27" class="indexterm"></a>pass parameters to a thread, perform the <a id="id28" class="indexterm"></a>following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void Count(object iterations)
{
  CountNumbers((int)iterations);
}

static void CountNumbers(int iterations)
{
  for (int i = 1; i &lt;= iterations; i++)
  {
    Sleep(TimeSpan.FromSeconds(0.5));
    WriteLine($"{CurrentThread.Name} prints {i}");
  }
}

static void PrintNumber(int number)
{
  WriteLine(number);
}

class ThreadSample
{
  private readonly int _iterations;

  public ThreadSample(int iterations)
  {
    _iterations = iterations;
  }
  public void CountNumbers()
  {
    for (int i = 1; i &lt;= _iterations; i++)
    {
      Sleep(TimeSpan.FromSeconds(0.5));
            WriteLine($"{CurrentThread.Name} prints {i}");
    }
  }
}</pre></div></li><li><p>Add the <a id="id29" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> <a id="id30" class="indexterm"></a>method:</p><div class="informalexample"><pre class="programlisting">var sample = new ThreadSample(10);

var threadOne = new Thread(sample.CountNumbers);
threadOne.Name = "ThreadOne";
threadOne.Start();
threadOne.Join();

WriteLine("--------------------------");

var threadTwo = new Thread(Count);
threadTwo.Name = "ThreadTwo";
threadTwo.Start(8);
threadTwo.Join();

WriteLine("--------------------------");

var threadThree = new Thread(() =&gt; CountNumbers(12));
threadThree.Name = "ThreadThree";
threadThree.Start();
threadThree.Join();
WriteLine("--------------------------");

int i = 10;
var threadFour = new Thread(() =&gt; PrintNumber(i));
i = 20;
var threadFive = new Thread(() =&gt; PrintNumber(i));
threadFour.Start(); 
threadFive.Start();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec29"></a>How it works...</h3></div></div></div><p>When the main program starts, it first creates an object of the <code class="literal">ThreadSample</code> class, providing it with a number of iterations. Then, we start a thread with the object's <code class="literal">CountNumbers</code> method. This method runs in another thread, but it uses the number <code class="literal">10</code>, which is the value that we passed to the object's constructor. Therefore, we just passed this number of iterations to another thread in the same indirect way.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec30"></a>There's moreâ€¦</h3></div></div></div><p>Another way to pass data is to use the <code class="literal">Thread.Start</code> method by accepting an object that can be passed to another thread. To work this way, a method that we started in another thread must accept one single parameter of the type <code class="literal">object</code>. This option is illustrated by creating a <code class="literal">threadTwo</code> thread. We pass <code class="literal">8</code> as an object to the <code class="literal">Count</code> method, where it is cast to an <code class="literal">integer</code> type.</p><p>The next option involves the use of lambda expressions. A lambda expression defines a method that does not belong to any class. We create such a method that invokes another method with the arguments needed and start it in another thread. When we start the <code class="literal">threadThree</code> thread, it <a id="id31" class="indexterm"></a>prints out 12 numbers, which are exactly the numbers we passed to it via the lambda expression.</p><p>The use of lambda expressions involves another C# construct named <code class="literal">closure</code>. When we use any local variable in a <a id="id32" class="indexterm"></a>lambda expression, C# generates a class and makes this variable a property of this class. So, actually, we do the same thing as in the <code class="literal">threadOne</code> thread, but we do not define the class ourselves; the C# compiler does this automatically.</p><p>This could lead to several problems; for example, if we use the same variable from several lambdas, they will actually share this variable value. This is illustrated by the previous example where, when we start <code class="literal">threadFour</code> and <code class="literal">threadFive</code>, they both print <code class="literal">20</code> because the variable was changed to hold the value <code class="literal">20</code> before both threads were started.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec17"></a>Locking with a C# lock keyword</h2></div></div><hr /></div><p>This recipe will <a id="id33" class="indexterm"></a>describe how to ensure that when one thread uses some resource, another does not simultaneously use it. We will see why this is needed and what the thread safety concept is all about.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec31"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe9</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec32"></a>How to do it...</h3></div></div></div><p>To understand how to use the C# lock keyword, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li><p>Add the <a id="id34" class="indexterm"></a>following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void TestCounter(CounterBase c)
{
  for (int i = 0; i &lt; 100000; i++)
  {
    c.Increment();
    c.Decrement();
  }
}

class Counter : CounterBase
{
  public int Count { get; private set; }

  public override void Increment()
  {
    Count++;
  }

  public override void Decrement()
  {
    Count--;
  }
}

class CounterWithLock : CounterBase
{
  private readonly object _syncRoot = new Object();

  public int Count { get; private set; }

  public override void Increment()
  {
    lock (_syncRoot)
    {
      Count++;
    }
  }

  public override void Decrement()
  {
    lock (_syncRoot)
    {
      Count--;
    }
  }
}

abstract class CounterBase
{
  public abstract void Increment();

  public abstract void Decrement();
}</pre></div></li><li><p>Add the <a id="id35" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Incorrect counter");

var c = new Counter();

var t1 = new Thread(() =&gt; TestCounter(c));
var t2 = new Thread(() =&gt; TestCounter(c));
var t3 = new Thread(() =&gt; TestCounter(c));
t1.Start();
t2.Start();
t3.Start();
t1.Join();
t2.Join();
t3.Join();

WriteLine($"Total count: {c.Count}");
WriteLine("--------------------------");

WriteLine("Correct counter");

var c1 = new CounterWithLock();

t1 = new Thread(() =&gt; TestCounter(c1));
t2 = new Thread(() =&gt; TestCounter(c1));
t3 = new Thread(() =&gt; TestCounter(c1));
t1.Start();
t2.Start();
t3.Start();
t1.Join();
t2.Join();
t3.Join();
WriteLine($"Total count: {c1.Count}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec33"></a>How it works...</h3></div></div></div><p>When the main program starts, it first creates an object of the <code class="literal">Counter</code> class. This class defines a simple counter that can be incremented and decremented. Then, we start three threads that share the same counter instance and perform an increment and decrement in a cycle. This leads to nondeterministic results. If we run the program several times, it will print out several different counter values. It could be <code class="literal">0</code>, but mostly won't be.</p><p>This happens <a id="id36" class="indexterm"></a>because the <code class="literal">Counter</code> class is not thread-safe. When several threads access the counter at the same time, the first thread gets the counter value <code class="literal">10</code> and increments it to <code class="literal">11</code>. Then, a second thread gets the value <code class="literal">11</code> and increments it to <code class="literal">12</code>. The first thread gets the counter value <code class="literal">12</code>, but before a decrement takes place, a second thread gets the counter value <code class="literal">12</code> as well. Then, the first thread decrements <code class="literal">12</code> to <code class="literal">11</code> and saves it into the counter, and the second thread simultaneously does the same. As a result, we have two increments and only one decrement, which is obviously not right. This kind of a situation is called a race condition and is a very common cause of errors in a multithreaded environment.</p><p>To make sure that this does not happen, we must ensure that while one thread works with the counter, all other threads wait until the first one finishes the work. We can use the <code class="literal">lock</code> keyword to achieve this kind of behavior. If we lock an object, all the other threads that require an access to this object will wait in a blocked state until it is unlocked. This could be a serious performance issue and later, in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Thread Synchronization</em></span>, you will learn more about this.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec18"></a>Locking with a Monitor construct</h2></div></div><hr /></div><p>This recipe <a id="id37" class="indexterm"></a>illustrates another common multithreaded error called a deadlock. Since a deadlock will cause a program to stop working, the first piece in this example is a new <code class="literal">Monitor</code> construct that allows us to avoid a deadlock. Then, the previously described <code class="literal">lock</code> keyword is used to get a deadlock.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec34"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe10</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec35"></a>How to do it...</h3></div></div></div><p>To understand the <a id="id38" class="indexterm"></a>multithreaded error deadlock, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void LockTooMuch(object lock1, object lock2)
{
  lock (lock1)
  {
    Sleep(1000);
    lock (lock2);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">object lock1 = new object();
object lock2 = new object();

new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();

lock (lock2)
{
  Thread.Sleep(1000);
  WriteLine("Monitor.TryEnter allows not to get stuck, returning false after a specified timeout is elapsed");
  if (Monitor.TryEnter(lock1, TimeSpan.FromSeconds(5)))
  {
    WriteLine("Acquired a protected resource succesfully");
  }
  else
  {
    WriteLine("Timeout acquiring a resource!");
  }
}

new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();

WriteLine("----------------------------------");
lock (lock2)
{
  WriteLine("This will be a deadlock!");
  Sleep(1000);
  lock (lock1)
  {
    WriteLine("Acquired a protected resource succesfully");
  }
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec36"></a>How it works...</h3></div></div></div><p>Let's start with the <code class="literal">LockTooMuch</code> method. In this method, we just lock the first object, wait for a second, and then lock the second object. Then, we start this method in another thread and try to lock the second object and then the first object from the main thread.</p><p>If we use the <code class="literal">lock</code> keyword like in the second part of this demo, there will be a deadlock. The first thread <a id="id39" class="indexterm"></a>holds a <code class="literal">lock</code> on the <code class="literal">lock1</code> object and waits while the <code class="literal">lock2</code> object gets free; the main thread holds a <code class="literal">lock</code> on the <code class="literal">lock2</code> object and waits for the <code class="literal">lock1</code> object to become free, which will never happen in this situation.</p><p>Actually, the <code class="literal">lock</code> keyword is syntactic sugar for the <code class="literal">Monitor</code> class usage. If we were to disassemble code with <code class="literal">lock</code>, we would see that it turns into the following code snippet:</p><div class="informalexample"><pre class="programlisting">bool acquiredLock = false;
try
{
  Monitor.Enter(lockObject, ref acquiredLock);

// Code that accesses resources that are protected by the lock.

}
finally
{
  if (acquiredLock)
  {
    Monitor.Exit(lockObject);
  }
}</pre></div><p>Therefore, we can use the <code class="literal">Monitor</code> class directly; it has the <code class="literal">TryEnter</code> method, which accepts a timeout parameter <a id="id40" class="indexterm"></a>and returns <code class="literal">false</code> if this timeout parameter expires before we can acquire the resource protected by <code class="literal">lock</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec19"></a>Handling exceptions</h2></div></div><hr /></div><p>This recipe will describe how to handle exceptions in other threads properly. It is very important to always <a id="id41" class="indexterm"></a>place a <code class="literal">try/catch</code> block inside the thread because it is not possible to catch an exception outside a thread's code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec37"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter1\Recipe11</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec38"></a>How to do it...</h3></div></div></div><p>To understand the handling of exceptions in other threads, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void BadFaultyThread()
{
  WriteLine("Starting a faulty thread...");
  Sleep(TimeSpan.FromSeconds(2));
  throw new Exception("Boom!");
}

static void FaultyThread()
{
  try
  {
    WriteLine("Starting a faulty thread...");
    Sleep(TimeSpan.FromSeconds(1));
    throw new Exception("Boom!");
  }
  catch (Exception ex)
  {
    WriteLine($"Exception handled: {ex.Message}");
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var t = new Thread(FaultyThread);
t.Start();
t.Join();

try
{
  t = new Thread(BadFaultyThread);
  t.Start();
}
catch (Exception ex)
{
  WriteLine("We won't get here!");
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec39"></a>How it works...</h3></div></div></div><p>When the main program starts, it defines two threads that will throw an exception. One of these threads handles an exception, while the other does not. You can see that the second exception is not caught by a <code class="literal">try/catch</code> block around the code that starts the thread. So, if you work with <a id="id42" class="indexterm"></a>threads directly, the general rule is to not throw an exception from a thread, but to use a <code class="literal">try/catch</code> block inside a thread code instead.</p><p>In the older versions of .NET Framework (1.0 and 1.1), this behavior was different and uncaught exceptions did not force an application shutdown. It is possible to use this policy by adding an application configuration file (such as <code class="literal">app.config</code>) that contains the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;legacyUnhandledExceptionPolicy enabled="1" /&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;</pre></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch02"></a>ChapterÂ 2.Â Thread Synchronization</h2></div></div></div><p>In this chapter, we will describe some of the common techniques of working with shared resources from multiple threads. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Performing basic atomic operations</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">Mutex</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">SemaphoreSlim</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">AutoResetEvent</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">ManualResetEventSlim</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">CountDownEvent</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">Barrier</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">ReaderWriterLockSlim</code> construct</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">SpinWait</code> construct</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Introduction</h2></div></div><hr /></div><p>As we saw in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Threading Basics</em></span>, it is problematic to use a shared object simultaneously from several threads. However, it is very important to synchronize those threads so that they perform operations on that shared object in a proper sequence. In the <span class="emphasis"><em>Locking with a C# lock keyword</em></span> recipe, we faced a problem called the race condition. The problem occurred because the execution of those multiple threads was not synchronized properly. When one thread performs increment and decrement operations, the other threads must wait for their turn. Organizing <a id="id43" class="indexterm"></a>threads in such a way is often referred to as <span class="strong"><strong>thread synchronization</strong></span>.</p><p>There are several ways to achieve thread synchronization. First, if there is no shared object, there is no need for synchronization at all. Surprisingly, it is very often the case that we can get rid of complex synchronization constructs by just redesigning our program and removing a shared state. If possible, just avoid using a single object from several threads.</p><p>If we must have a shared <a id="id44" class="indexterm"></a>state, the second approach is to use only <span class="strong"><strong>atomic</strong></span> operations. This means that an operation takes a single quantum of time and completes at once, so no other thread can perform another operation until the first operation is complete. Therefore, there is no need to make other threads wait for this operation to complete and there is no need to use locks; this in turn, excludes the deadlock situation.</p><p>If this is not possible and the program's logic is more complicated, then we have to use different constructs to coordinate threads. One group of these constructs puts a waiting thread into a <code class="literal">blocked</code> state. In a <code class="literal">blocked</code> state, a thread uses as little CPU time as possible. However, this <a id="id45" class="indexterm"></a>means that it will include at least one so-called <span class="strong"><strong>context switch</strong></span>â€”the thread scheduler of an operating system will save the waiting thread's state and switch to another thread, restoring its state by turn. This takes a considerable amount of resources; however, if the thread is going to be suspended for a long time, it is good. These kind of constructs are <a id="id46" class="indexterm"></a>also called <span class="strong"><strong>kernel-mode</strong></span> constructs because only the kernel of an operating system is able to stop a thread from using CPU time.</p><p>In case, we have to wait for a short period of time, it is better to simply wait than switch the thread to a <code class="literal">blocked</code> state. This will save us the context switch at the cost of some wasted CPU time while <a id="id47" class="indexterm"></a>the thread is waiting. Such constructs are referred to as <span class="strong"><strong>user-mode</strong></span> constructs. They are very lightweight and fast, but they waste a lot of CPU time in case a thread has to wait for long.</p><p>To use the best of both <a id="id48" class="indexterm"></a>worlds, there are <span class="strong"><strong>hybrid</strong></span> constructs; these try to use user-mode waiting first, and then, if a thread waits long enough, it switches to the <code class="literal">blocked</code> state, saving CPU resources.</p><p>In this chapter, we will look through the aspects of thread synchronization. We will cover how to perform atomic operations and how to use the existing synchronization constructs included in .NET Framework.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Performing basic atomic operations</h2></div></div><hr /></div><p>This recipe will <a id="id49" class="indexterm"></a>show you how to perform basic atomic operations on an object to prevent the race condition without blocking threads.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec40"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec41"></a>How to do it...</h3></div></div></div><p>To understand basic atomic operations, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li><p>Below the <a id="id50" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">static void TestCounter(CounterBase c)
{
  for (int i = 0; i &lt; 100000; i++)
  {
    c.Increment();
    c.Decrement();
  }
}

class Counter : CounterBase
{
  private int _count;

  public int Count =&gt; _count;

  public override void Increment()
  {
    _count++;
  }

  public override void Decrement()
  {
    _count--;
  }
}

class CounterNoLock : CounterBase
{
  private int _count;

  public int Count =&gt; _count;

  public override void Increment()
  {
    Interlocked.Increment(ref _count);
  }

  public override void Decrement()
  {
    Interlocked.Decrement(ref _count);
  }
}

abstract class CounterBase
{
  public abstract void Increment();

  public abstract void Decrement();
}</pre></div></li><li><p>Inside the <a id="id51" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">WriteLine("Incorrect counter");

var c = new Counter();

var t1 = new Thread(() =&gt; TestCounter(c));
var t2 = new Thread(() =&gt; TestCounter(c));
var t3 = new Thread(() =&gt; TestCounter(c));
t1.Start();
t2.Start();
t3.Start();
t1.Join();
t2.Join();
t3.Join();

WriteLine($"Total count: {c.Count}");
WriteLine("--------------------------");

WriteLine("Correct counter");

var c1 = new CounterNoLock();

t1 = new Thread(() =&gt; TestCounter(c1));
t2 = new Thread(() =&gt; TestCounter(c1));
t3 = new Thread(() =&gt; TestCounter(c1));
t1.Start();
t2.Start();
t3.Start();
t1.Join();
t2.Join();
t3.Join();

WriteLine($"Total count: {c1.Count}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec42"></a>How it works...</h3></div></div></div><p>When the program runs, it creates three threads that will execute a code in the <code class="literal">TestCounter</code> method. This method runs a sequence of increment/decrement operations on an object. Initially, the <code class="literal">Counter</code> object is not thread-safe and we get a race condition here. So, in the first case, a counter value is not deterministic. We could get a zero value; however, if you run the program several times, you will eventually get some incorrect nonzero result.</p><p>In <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Threading Basics</em></span>, we resolved this problem by locking our object, causing other threads to be <a id="id52" class="indexterm"></a>blocked while one thread gets the old counter value and then computes and assigns a new value to the counter. However, if we execute this operation in such a way, it cannot be stopped midway, we would achieve the proper result without any locking, and this is possible with the help of the <code class="literal">Interlocked</code> construct. It provides the <code class="literal">Increment</code>, <code class="literal">Decrement</code>, and <code class="literal">Add</code> atomic methods for basic math, and it helps us to write the <code class="literal">Counter</code> class without the use of locking.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Using the Mutex construct</h2></div></div><hr /></div><p>This recipe will <a id="id53" class="indexterm"></a>describe how to synchronize two separate programs using the <code class="literal">Mutex</code> construct. A <code class="literal">Mutex</code> construct is a synchronization primitive that grants exclusive <a id="id54" class="indexterm"></a>access of the shared resource to only one thread.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec43"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec44"></a>How to do it...</h3></div></div></div><p>To understand the synchronization of two separate programs using the <code class="literal">Mutex</code> construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;</pre></div></li><li><p>Inside the <code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">const string MutexName = "CSharpThreadingCookbook";

using (var m = new Mutex(false, MutexName))
{
  if (!m.WaitOne(TimeSpan.FromSeconds(5), false))
  {
    WriteLine("Second instance is running!");
  }
  else
  {
    WriteLine("Running!");
    ReadLine();
    m.ReleaseMutex();
  }
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec45"></a>How it works...</h3></div></div></div><p>When the main program starts, it defines a mutex with a specific name, providing the <code class="literal">initialOwner</code> flag <a id="id55" class="indexterm"></a>as <code class="literal">false</code>. This allows the program to acquire a mutex if it is already created. Then, if no mutex is acquired, the program simply displays <span class="strong"><strong>Running</strong></span> and <a id="id56" class="indexterm"></a>waits for any key to be pressed in order to release the mutex and exit.</p><p>If we start a second copy of the program, it will wait for 5 seconds, trying to acquire the mutex. If we press any key in the first copy of a program, the second one will start the execution. However, if we keep waiting for 5 seconds, the second copy of the program will fail to acquire the mutex.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip05"></a>Tip</h3><p>Note that a mutex is a global operating system object! Always close the mutex properly; the best choice is to wrap a mutex object into a <code class="literal">using</code> block.</p></div><p>This makes it possible to synchronize threads in different programs, which could be useful in a large number of scenarios.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec23"></a>Using the SemaphoreSlim construct</h2></div></div><hr /></div><p>This recipe <a id="id57" class="indexterm"></a>will show you how to limit multithreaded access to some resources with the help of the <code class="literal">SemaphoreSlim</code> construct. <code class="literal">SemaphoreSlim</code> is a lightweight version of <code class="literal">Semaphore</code>; it limits the number of threads that can <a id="id58" class="indexterm"></a>access a resource concurrently.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec46"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec47"></a>How to do it...</h3></div></div></div><p>To understand how to limit a multithreaded access to a resource with the help of the <code class="literal">SemaphoreSlim</code> <a id="id59" class="indexterm"></a>construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">static SemaphoreSlim _semaphore = new SemaphoreSlim(4);

static void AccessDatabase(string name, int seconds)
{
  WriteLine($"{name} waits to access a database");
  _semaphore.Wait();
  WriteLine($"{name} was granted an access to a database");
  Sleep(TimeSpan.FromSeconds(seconds));
  WriteLine($"{name} is completed");
  _semaphore.Release();
}</pre></div></li><li><p>Inside the <code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">for (int i = 1; i &lt;= 6; i++)
{
  string threadName = "Thread " + i;
  int secondsToWait = 2 + 2 * i;
  var t = new Thread(() =&gt; AccessDatabase(threadName, secondsToWait));
  t.Start();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec48"></a>How it works...</h3></div></div></div><p>When the main program starts, it creates a <code class="literal">SemaphoreSlim</code> instance, specifying the number of concurrent threads allowed in its constructor. Then, it starts six threads with different names and start times to run.</p><p>Every thread tries to <a id="id60" class="indexterm"></a>acquire access to a database, but we restrict the number of concurrent accesses to a database to four threads with the help of a semaphore. When four threads get access to a database, the other two threads wait <a id="id61" class="indexterm"></a>until one of the previous threads finishes its work and signals to other threads by calling the <code class="literal">_semaphore.Release</code> method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec49"></a>There's moreâ€¦</h3></div></div></div><p>Here, we use a hybrid construct, which allows us to save a context switch in cases where the wait time is very short. However, there is an older version of this construct called <code class="literal">Semaphore</code>. This version is a pure, kernel-time construct. There is no sense in using it, except in one very important scenario; we can create a named semaphore like a named mutex and use it to synchronize threads in different programs. <code class="literal">SemaphoreSlim</code> does not use Windows kernel semaphores and does not support interprocess synchronization, so use <code class="literal">Semaphore</code> in this case.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec24"></a>Using the AutoResetEvent construct</h2></div></div><hr /></div><p>In this recipe, there <a id="id62" class="indexterm"></a>is an example of how to send notifications <a id="id63" class="indexterm"></a>from one thread to another with the help of an <code class="literal">AutoResetEvent</code> construct. <code class="literal">AutoResetEvent</code> notifies a waiting thread that an event has occurred.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec50"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec51"></a>How to do it...</h3></div></div></div><p>To understand how to send notifications from one thread to another with the help of the <code class="literal">AutoResetEvent</code> construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <a id="id64" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">private static AutoResetEvent _workerEvent = new AutoResetEvent(false);
private static AutoResetEvent _mainEvent = new AutoResetEvent(false);

static void Process(int seconds)
{
  WriteLine("Starting a long running work...");
  Sleep(TimeSpan.FromSeconds(seconds));
  WriteLine("Work is done!");
  _workerEvent.Set();
  WriteLine("Waiting for a main thread to complete its work");
  _mainEvent.WaitOne();
  WriteLine("Starting second operation...");
  Sleep(TimeSpan.FromSeconds(seconds));
  WriteLine("Work is done!");
  _workerEvent.Set();
}</pre></div></li><li><p>Inside the <a id="id65" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">var t = new Thread(() =&gt; Process(10));
t.Start();

WriteLine("Waiting for another thread to complete work");
_workerEvent.WaitOne();
WriteLine("First operation is completed!");
WriteLine("Performing an operation on a main thread");
Sleep(TimeSpan.FromSeconds(5));
_mainEvent.Set();
WriteLine("Now running the second operation on a second thread");
_workerEvent.WaitOne();
WriteLine("Second operation is completed!");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec52"></a>How it works...</h3></div></div></div><p>When the main program starts, it defines two <code class="literal">AutoResetEvent</code> instances. One of them is for signaling from the second thread to the main thread, and the second one is for signaling from the main thread to the second thread. We provide <code class="literal">false</code> to the <code class="literal">AutoResetEvent</code> constructor, specifying the initial sate of both the instances as <code class="literal">unsignaled</code>. This means that any thread calling the <code class="literal">WaitOne</code> method of one of these objects will be blocked until we call the <code class="literal">Set</code> method. If we initialize the event state to <code class="literal">true</code>, it becomes <code class="literal">signaled</code> and the first thread calling <code class="literal">WaitOne</code> will proceed immediately. The event state then becomes <code class="literal">unsignaled</code> automatically, so we need to call the <code class="literal">Set</code> method once again to let the other threads calling the <code class="literal">WaitOne</code> method on this instance to continue.</p><p>Then, we create a second thread, which executes the first operation for 10 seconds and waits for the signal from the second thread. The signal notifies that the first operation is completed. Now, the second thread waits for a signal from the main thread. We do some additional work on <a id="id66" class="indexterm"></a>the main thread and send a signal by calling the <code class="literal">_mainEvent.Set</code> method. Then, we wait for another signal from the second thread.</p><p><code class="literal">AutoResetEvent</code> <a id="id67" class="indexterm"></a>is a kernel-time construct, so if the wait time is not significant, it is better to use the next recipe with <code class="literal">ManualResetEventslim</code>, which is a hybrid construct.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec25"></a>Using the ManualResetEventSlim construct</h2></div></div><hr /></div><p>This recipe will <a id="id68" class="indexterm"></a>describe how to make signaling <a id="id69" class="indexterm"></a>between threads more flexible with the <code class="literal">ManualResetEventSlim</code> construct.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec53"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec54"></a>How to do it...</h3></div></div></div><p>To understand the use of the <code class="literal">ManualResetEventSlim</code> construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">static void TravelThroughGates(string threadName, int seconds)
{
  WriteLine($"{threadName} falls to sleep");
  Sleep(TimeSpan.FromSeconds(seconds));
  WriteLine($"{threadName} waits for the gates to open!");
  _mainEvent.Wait();
  WriteLine($"{threadName} enters the gates!");
}

static ManualResetEventSlim _mainEvent = new ManualResetEventSlim(false);</pre></div></li><li><p>Inside the <a id="id70" class="indexterm"></a>
<code class="literal">Main</code> method, add the <a id="id71" class="indexterm"></a>following code:</p><div class="informalexample"><pre class="programlisting">var t1 = new Thread(() =&gt; TravelThroughGates("Thread 1", 5));
var t2 = new Thread(() =&gt; TravelThroughGates("Thread 2", 6));
var t3 = new Thread(() =&gt; TravelThroughGates("Thread 3", 12));
t1.Start();
t2.Start();
t3.Start();
Sleep(TimeSpan.FromSeconds(6));
WriteLine("The gates are now open!");
_mainEvent.Set();
Sleep(TimeSpan.FromSeconds(2));
_mainEvent.Reset();
WriteLine("The gates have been closed!");
Sleep(TimeSpan.FromSeconds(10));
WriteLine("The gates are now open for the second time!");
_mainEvent.Set();
Sleep(TimeSpan.FromSeconds(2));
WriteLine("The gates have been closed!");
_mainEvent.Reset();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec55"></a>How it works...</h3></div></div></div><p>When the main program starts, it first creates an instance of the <code class="literal">ManualResetEventSlim </code>construct. Then, we start three threads that wait for this event to signal them to continue the execution.</p><p>The whole process of working with this construct is like letting people pass through a gate. The <code class="literal">AutoResetEvent</code> event that we looked at in the previous recipe works like a turnstile, allowing only one person to pass at a time. <code class="literal">ManualResetEventSlim</code>, which is a hybrid version of <code class="literal">ManualResetEvent</code>, stays open until we manually call the <code class="literal">Reset</code> method. Going back to the code, when we call <code class="literal">_mainEvent.Set</code>, we open it and allow the threads that are ready to accept this signal to continue working. However, thread number three is still sleeping and does not make it in time. We call <code class="literal">_mainEvent.Reset</code> and we thus close it. The last thread is now ready to go on, but it has to wait for the next signal, which will <a id="id72" class="indexterm"></a>happen a few seconds later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec56"></a>There's moreâ€¦</h3></div></div></div><p>As in one of the <a id="id73" class="indexterm"></a>previous recipes, we use a hybrid construct that lacks the possibility to work at the operating system level. If we need to have a global event, we should use the <code class="literal">EventWaitHandle</code> construct, which is the base class for <code class="literal">AutoResetEvent</code> and <code class="literal">ManualResetEvent</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec26"></a>Using the CountDownEvent construct</h2></div></div><hr /></div><p>This recipe <a id="id74" class="indexterm"></a>will describe how to use the <code class="literal">CountdownEvent</code> <a id="id75" class="indexterm"></a>signaling construct to wait until a certain number of operations complete.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec57"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec58"></a>How to do it...</h3></div></div></div><p>To understand the use of the <code class="literal">CountDownEvent</code> construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">static CountdownEvent _countdown = new CountdownEvent(2);

static void PerformOperation(string message, int seconds)
{
  Sleep(TimeSpan.FromSeconds(seconds));
  WriteLine(message);
  _countdown.Signal();
}</pre></div></li><li><p>Inside the <a id="id76" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">WriteLine("Starting two operations");
var t1 = new Thread(() =&gt; PerformOperation("Operation 1 is completed", 4));
var t2 = new Thread(() =&gt; PerformOperation("Operation 2 is completed", 8));
t1.Start();
t2.Start();
_countdown.Wait();
WriteLine("Both operations have been completed.");
_countdown.Dispose();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec59"></a>How it works...</h3></div></div></div><p>When the main program starts, we create a new <code class="literal">CountdownEvent</code> instance, specifying that we want it to signal when two operations complete in its constructor. Then, we start two threads that <a id="id77" class="indexterm"></a>signal to the event when they are complete. As soon as the second thread is complete, the main thread returns from waiting on <code class="literal">CountdownEvent</code> and proceeds further. Using this construct, it is very convenient to wait for multiple asynchronous operations to complete.</p><p>However, there is a significant disadvantage; <code class="literal">_countdown.Wait()</code> will wait forever if we fail to call <code class="literal">_countdown.Signal()</code> the required number of times. Make sure that all your threads <a id="id78" class="indexterm"></a>complete with the <code class="literal">Signal</code> method call when using <code class="literal">CountdownEvent</code>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec27"></a>Using the Barrier construct</h2></div></div><hr /></div><p>This recipe <a id="id79" class="indexterm"></a>illustrates another interesting synchronization construct called <code class="literal">Barrier</code>. The <code class="literal">Barrier</code> construct helps to organize several threads so that they meet at some point in time, providing a callback that will be executed each time the threads call <a id="id80" class="indexterm"></a>the <code class="literal">SignalAndWait</code> method.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec60"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe7</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec61"></a>How to do it...</h3></div></div></div><p>To understand the use of the <code class="literal">Barrier</code> construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <a id="id81" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">static Barrier _barrier = new Barrier(2,
  b =&gt; WriteLine($"End of phase {b.CurrentPhaseNumber + 1}"));

static void PlayMusic(string name, string message, int seconds)
{
  for (int i = 1; i &lt; 3; i++)
  {
    WriteLine("----------------------------------------------");
    Sleep(TimeSpan.FromSeconds(seconds));
    WriteLine($"{name} starts to {message}");
    Sleep(TimeSpan.FromSeconds(seconds));
    WriteLine($"{name} finishes to {message}");
    _barrier.SignalAndWait();
  }
}</pre></div></li><li><p>Inside the <code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">var t1 = new Thread(() =&gt; PlayMusic("the guitarist", "play an amazing solo", 5));
var t2 = new Thread(() =&gt; PlayMusic("the singer", "sing his song", 2));

t1.Start();
t2.Start();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec62"></a>How it works...</h3></div></div></div><p>We create a <code class="literal">Barrier</code> construct, specifying that we want to synchronize two threads, and after each of those two threads call the <code class="literal">_barrier.SignalAndWait</code> method, we need to execute a callback that will print out the number of phases completed.</p><p>Each thread will send a signal to <code class="literal">Barrier</code> twice, so we will have two phases. Every time both the threads call the <code class="literal">SignalAndWait</code> method, <code class="literal">Barrier</code> will execute the callback. It is useful for working with multithreaded iteration algorithms, to execute some calculations on each <a id="id82" class="indexterm"></a>iteration end. The end of the iteration is <a id="id83" class="indexterm"></a>reached when the last thread calls the <code class="literal">SignalAndWait</code> method.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec28"></a>Using the ReaderWriterLockSlim construct</h2></div></div><hr /></div><p>This recipe <a id="id84" class="indexterm"></a>will describe how to create a thread-safe mechanism to read and write to a collection from multiple threads using a <code class="literal">ReaderWriterLockSlim</code> construct. <code class="literal">ReaderWriterLockSlim</code> represents a lock that is used to manage <a id="id85" class="indexterm"></a>access to a resource, allowing multiple threads for reading or exclusive access for writing.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec63"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe8</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec64"></a>How to do it...</h3></div></div></div><p>To understand how to create a thread-safe mechanism to read and write to a collection from multiple threads using the <code class="literal">ReaderWriterLockSlim</code> construct, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <a id="id86" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">static ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();
static Dictionary&lt;int, int&gt; _items = new Dictionary&lt;int, int&gt;();

static void Read()
{
  WriteLine("Reading contents of a dictionary");
  while (true)
  {
    try
    {
      _rw.EnterReadLock();
      foreach (var key in _items.Keys)
      {
        Sleep(TimeSpan.FromSeconds(0.1));
      }
    }
    finally
    {
      _rw.ExitReadLock();
    }
  }
}

static void Write(string threadName)
{
  while (true)
  {
    try
    {
      int newKey = new Random().Next(250);
      _rw.EnterUpgradeableReadLock();
      if (!_items.ContainsKey(newKey))
      {
        try
        {
          _rw.EnterWriteLock();
          _items[newKey] = 1;
          WriteLine($"New key {newKey} is added to a dictionary by a {threadName}");
        }
        finally
        {
          _rw.ExitWriteLock();
        }
      }
      Sleep(TimeSpan.FromSeconds(0.1));
    }
    finally
    {
      _rw.ExitUpgradeableReadLock();
    }
  }
}</pre></div></li><li><p>Inside the <code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">new Thread(Read){ IsBackground = true }.Start();
new Thread(Read){ IsBackground = true }.Start();
new Thread(Read){ IsBackground = true }.Start();

new Thread(() =&gt; Write("Thread 1")){ IsBackground = true }.Start();
new Thread(() =&gt; Write("Thread 2")){ IsBackground = true }.Start();

Sleep(TimeSpan.FromSeconds(30)); </pre></div></li><li><p>Run the <a id="id87" class="indexterm"></a>program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec65"></a>How it works...</h3></div></div></div><p>When the main program starts, it simultaneously runs three threads that read data from a dictionary and two threads that write some data into this dictionary. To achieve thread safety, we use the <code class="literal">ReaderWriterLockSlim</code> construct, which was designed especially for such scenarios.</p><p>It has two kinds of <a id="id88" class="indexterm"></a>locks: a read lock that allows multiple threads to read and a write lock that blocks every operation from other threads until this write lock is released. There is also an interesting scenario when we obtain a read lock, read some data from the collection, and, depending on that data, decide to obtain a write lock and change the collection. If we get the write locks at once, too much time is spent, not allowing our readers to read the data because the collection is blocked when we get a write lock. To minimize this time, there are <code class="literal">EnterUpgradeableReadLock</code>/<code class="literal">ExitUpgradeableReadLock</code> methods. We get a read lock and read the data; if we find that we have to change the underlying collection, we just upgrade our lock using the <code class="literal">EnterWriteLock</code> method, then perform a write operation quickly and release a write lock using <code class="literal">ExitWriteLock</code>.</p><p>In our case, we <a id="id89" class="indexterm"></a>get a random number; we then get a read lock and check whether this number exists in the dictionary key collection. If not, we upgrade our lock to a write lock and then add this new key to a dictionary. It is a good practice to use <code class="literal">try</code>/<code class="literal">finally</code> blocks to make sure that we always release locks after acquiring them.</p><p>All our threads have been created as background threads, and after waiting for 30 seconds, the <a id="id90" class="indexterm"></a>main thread as well as all the background threads get completed.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec29"></a>Using the SpinWait construct</h2></div></div><hr /></div><p>This recipe will <a id="id91" class="indexterm"></a>describe how to wait on a thread without involving kernel-mode constructs. In addition, we introduce <code class="literal">SpinWait</code>, a hybrid synchronization <a id="id92" class="indexterm"></a>construct designed to wait in the user mode for some time, and then switch to the kernel mode to save CPU time.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec66"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter2\Recipe9</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec67"></a>How to do it...</h3></div></div></div><p>To understand how to wait on a thread without involving kernel-mode constructs, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Below the <code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">static volatile bool _isCompleted = false;

static void UserModeWait()
{
  while (!_isCompleted)
  {
    Write(".");
  }
  WriteLine();
  WriteLine("Waiting is complete");
}

static void HybridSpinWait()
{
  var w = new SpinWait();
  while (!_isCompleted)
  {
    w.SpinOnce();
    WriteLine(w.NextSpinWillYield);
  }
  WriteLine("Waiting is complete");
}</pre></div></li><li><p>Inside the <a id="id93" class="indexterm"></a>
<code class="literal">Main</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">var t1 = new Thread(UserModeWait);
var t2 = new Thread(HybridSpinWait);

WriteLine("Running user mode waiting");
t1.Start();
Sleep(20);
_isCompleted = true;
Sleep(TimeSpan.FromSeconds(1));
_isCompleted = false;
WriteLine("Running hybrid SpinWait construct waiting");
t2.Start();
Sleep(5);
_isCompleted = true;</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec68"></a>How it works...</h3></div></div></div><p>When the main program starts, it defines a thread that will execute an endless loop for 20 milliseconds until the main thread sets the <code class="literal">_isCompleted</code> variable to <code class="literal">true</code>. We could experiment and run this cycle for 20-30 seconds instead, measuring the CPU load with the Windows task manager. It will show a significant amount of processor time, depending on how many cores the CPU has.</p><p>We use the <code class="literal">volatile</code> <a id="id94" class="indexterm"></a>keyword to declare the <code class="literal">_isCompleted</code> static field. The <code class="literal">volatile</code> keyword indicates that a field might be modified by multiple threads being executed at the same time. Fields that are declared <code class="literal">volatile</code> are not subject to compiler and processor optimizations that assume access by a single thread. This ensures that the most up-to-date value is present in the field at all times.</p><p>Then, we use a <code class="literal">SpinWait</code> version, which on each iteration prints a special flag that shows us whether a thread is going to switch to a <code class="literal">blocked</code> state. We run this thread for 5 milliseconds to see that. In the beginning, <code class="literal">SpinWait</code> tries to stay in the user mode, and after about nine iterations, it begins to switch the thread to a blocked state. If we try to measure the CPU <a id="id95" class="indexterm"></a>load with this version, we will not see any CPU usage <a id="id96" class="indexterm"></a>in the Windows task manager.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch03"></a>ChapterÂ 3.Â Using a Thread Pool</h2></div></div></div><p>In this chapter, we will describe the common techniques that are used for working with shared resources from multiple threads. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Invoking a delegate on a thread pool</p></li><li style="list-style-type: disc"><p>Posting an asynchronous operation on a thread pool</p></li><li style="list-style-type: disc"><p>A thread pool and the degree of parallelism</p></li><li style="list-style-type: disc"><p>Implementing a cancellation option</p></li><li style="list-style-type: disc"><p>Using a wait handle and timeout with a thread pool</p></li><li style="list-style-type: disc"><p>Using a timer</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">BackgroundWorker</code> component</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Introduction</h2></div></div><hr /></div><p>In the previous chapters, we discussed several ways to create threads and organize their cooperation. Now, let's consider another scenario where we will create many asynchronous operations that take very little time to complete. As we discussed in the <span class="emphasis"><em>Introduction</em></span> section of <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Threading Basics</em></span>, creating a thread is an expensive operation, so doing this for each short-lived, asynchronous operation will include a significant overhead expense.</p><p>To deal with this problem, there <a id="id97" class="indexterm"></a>is a common approach called <span class="strong"><strong>pooling</strong></span> that can be successfully applied to any situation when we need many short-lived, expensive resources. We allocate a certain amount of these resources in advance and organize them into a resource pool. Each time we need a new resource, we just take it from the pool, instead of creating a new one, and return it to the pool after the resource is no longer needed.</p><p>The <span class="strong"><strong>.NET thread pool</strong></span> is <a id="id98" class="indexterm"></a>an implementation of this concept. It is accessible via the <code class="literal">System.Threading.ThreadPool</code> type. A thread pool is managed by the .NET <span class="strong"><strong>Common </strong></span><a id="id99" class="indexterm"></a>
<span class="strong"><strong>Language Runtime</strong></span> (<span class="strong"><strong>CLR</strong></span>), which means that there is one instance of a thread pool per CLR. The <code class="literal">ThreadPool</code> type has a <a id="id100" class="indexterm"></a>
<code class="literal">QueueUserWorkItem</code> static method that accepts a <span class="strong"><strong>delegate</strong></span>, representing a user-defined, asynchronous operation. After this method is called, this delegate goes to the internal queue. Then, if there are no threads inside the pool, it creates a new <a id="id101" class="indexterm"></a>
<span class="strong"><strong>worker thread</strong></span> and puts the first delegate in the queue on it.</p><p>If we put new operations on a thread pool, after the previous operations are completed, it is possible to reuse this one thread to execute these operations. However, if we put new operations faster, the thread pool will create more threads to serve these operations. There is a limit to prevent creating too many threads, and in that case, new operations wait in the queue until the worker threads in the pool become free to serve them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>It is very important to keep operations on a thread pool shortlived! Do not put long-running operations on a thread pool or block worker threads. This will lead to all worker threads becoming busy, and they will no longer be able to serve user operations. This, in turn, will lead to performance problems and errors that are very hard to debug.</p></div><p>When we stop putting new operations on a thread pool, it will eventually remove threads that are no longer needed after being idle for some time. This will free up any operating system resources that are no longer required.</p><p>I would like to emphasize once again that a thread pool is intended to execute short-running operations. Using a thread pool lets us save operating system resources at the cost of reducing the degree of parallelism. We use fewer threads, but execute asynchronous operations more slowly than usual, batching them by the number of worker threads available. This makes sense if operations complete rapidly, but this will degrade the performance if we execute many long-running, compute-bound operations.</p><p>Another important thing to be very careful of is using a thread pool in ASP.NET applications. The ASP.NET infrastructure uses a thread pool itself, and if you waste all worker threads from a thread pool, a web server will no longer be able to serve incoming requests. It is <a id="id102" class="indexterm"></a>recommended that you use only input/output-bound asynchronous operations in ASP.NET because they use different mechanics called <span class="strong"><strong>I/O threads</strong></span>. We will discuss I/O threads in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Using Asynchronous I/O</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note06"></a>Note</h3><p>Note that worker threads in a thread pool are background threads. This means that when all of the threads in the foreground (including the main application thread) are complete, then all the background threads will be stopped.</p></div><p>In this chapter, you will learn to use a thread pool to execute asynchronous operations. We will cover different ways to put an operation on a thread pool and how to cancel an operation and prevent it from running for a long time.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec31"></a>Invoking a delegate on a thread pool</h2></div></div><hr /></div><p>This recipe will show you how to execute a delegate asynchronously on a thread pool. In addition, we will <a id="id103" class="indexterm"></a>discuss an approach <a id="id104" class="indexterm"></a>called the <span class="strong"><strong>Asynchronous Programming </strong></span><a id="id105" class="indexterm"></a>
<span class="strong"><strong>Model</strong></span> (<span class="strong"><strong>APM</strong></span>), which was historically the first asynchronous programming pattern in .NET.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec69"></a>Getting ready</h3></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec70"></a>How to do it...</h3></div></div></div><p>To understand how to invoke a delegate on a thread pool, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">private delegate string RunOnThreadPool(out int threadId);

private static void Callback(IAsyncResult ar)
{
  WriteLine("Starting a callback...");
  WriteLine($"State passed to a callbak: {ar.AsyncState}");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  WriteLine($"Thread pool worker thread id: {CurrentThread.ManagedThreadId}");
}

private static string Test(out int threadId)
{
  WriteLine("Starting...");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  threadId = CurrentThread.ManagedThreadId;
  return $"Thread pool worker thread id was: {threadId}";
}</pre></div></li><li><p>Add the <a id="id106" class="indexterm"></a>following code inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">int threadId = 0;

RunOnThreadPool poolDelegate = Test;

var t = new Thread(() =&gt; Test(out threadId));
t.Start();
t.Join();

WriteLine($"Thread id: {threadId}");

IAsyncResult r = poolDelegate.BeginInvoke(out threadId, Callback, "a delegate asynchronous call");
r.AsyncWaitHandle.WaitOne();

string result = poolDelegate.EndInvoke(out threadId, r);

WriteLine($"Thread pool worker thread id: {threadId}");
WriteLine(result);

Sleep(TimeSpan.FromSeconds(2));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec71"></a>How it works...</h3></div></div></div><p>When the program runs, it creates a thread in the old-fashioned way and then starts it and waits for its completion. Since a thread constructor accepts only a method that does not return any result, we use a <a id="id107" class="indexterm"></a>
<span class="strong"><strong>lambda expression</strong></span> to wrap up a call to the <code class="literal">Test</code> method. We make sure that this thread is not from the thread pool by printing out the <code class="literal">Thread.CurrentThread.IsThreadPoolThread</code> property value. We also print out a managed thread ID to identify a thread on which this code was executed.</p><p>Then, we define a <a id="id108" class="indexterm"></a>delegate and run it by calling the <code class="literal">BeginInvoke</code> method. This method accepts a callback that will be called after the asynchronous operation is complete and a user-defined state to pass into the callback. This state is usually used to distinguish one asynchronous call from another. As a result, we get a <code class="literal">result</code> object that implements the <code class="literal">IAsyncResult</code> interface. The <code class="literal">BeginInvoke</code> method returns the result immediately, allowing us to continue with any work while the asynchronous operation is being executed on a worker thread of the thread pool. When we need the result of an asynchronous operation, we use the <code class="literal">result</code> object returned from the <code class="literal">BeginInvoke</code> method call. We <a id="id109" class="indexterm"></a>can poll on it using the <code class="literal">IsCompleted</code> result property, but in this case, we use the <code class="literal">AsyncWaitHandle</code> result property to wait on it until the operation is complete. After this is done, to get a result from it, we call the <code class="literal">EndInvoke</code> method on a delegate, passing the delegate arguments and our <code class="literal">IAsyncResult</code> object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note07"></a>Note</h3><p>Actually, using <code class="literal">AsyncWaitHandle</code> is not necessary. If we comment out <code class="literal">r.AsyncWaitHandle.WaitOne</code>, the code will still run successfully because the <code class="literal">EndInvoke</code> method actually waits for the asynchronous operation to complete. It is always important to call <code class="literal">EndInvoke</code> (or <code class="literal">EndOperationName</code> for other asynchronous APIs) because it throws any unhandled exceptions back to the calling thread. Always call both the <code class="literal">Begin</code> and <code class="literal">End</code> methods when using this kind of asynchronous API.</p></div><p>When the operation completes, a callback passed to the <code class="literal">BeginInvoke</code> method will be posted on a thread pool, more specifically, a worker thread. If we comment out the <code class="literal">Thread.Sleep</code> method call at the end of the <code class="literal">Main</code> method definition, the callback will not be executed. This is because when the main thread is completed, all the background threads will be stopped, including this callback. It is possible that both asynchronous calls to a delegate and a callback will be served by the same worker thread, which is easy to see by a worker thread ID.</p><p>This approach of using the <code class="literal">BeginOperationName</code>/<code class="literal">EndOperationName</code> method and the <code class="literal">IAsyncResult</code> object in .NET is called the Asynchronous Programming Model or the APM pattern, and such method pairs are called asynchronous methods. This pattern is still used in various .NET class library APIs, but in modern programming, it is preferable to use the <span class="strong"><strong>Task </strong></span><a id="id110" class="indexterm"></a>
<span class="strong"><strong>Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>) to organize an asynchronous API. We will cover this topic in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Using the Task Parallel Library</em></span>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec32"></a>Posting an asynchronous operation on a thread pool</h2></div></div><hr /></div><p>This recipe <a id="id111" class="indexterm"></a>will describe how to put an <a id="id112" class="indexterm"></a>asynchronous operation on a thread pool.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec72"></a>Getting ready</h3></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec73"></a>How to do it...</h3></div></div></div><p>To understand <a id="id113" class="indexterm"></a>how to post an asynchronous <a id="id114" class="indexterm"></a>operation on a thread pool, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">private static void AsyncOperation(object state)
{
  WriteLine($"Operation state: {state ?? "(null)"}");
  WriteLine($"Worker thread id: {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(2));
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">const int x = 1;
const int y = 2;
const string lambdaState = "lambda state 2";

ThreadPool.QueueUserWorkItem(AsyncOperation);
Sleep(TimeSpan.FromSeconds(1));

ThreadPool.QueueUserWorkItem(AsyncOperation, "async state");
Sleep(TimeSpan.FromSeconds(1));

ThreadPool.QueueUserWorkItem( state =&gt; {
  WriteLine($"Operation state: {state}");
  WriteLine($"Worker thread id: {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(2));
}, "lambda state");

ThreadPool.QueueUserWorkItem( _ =&gt;
{
  WriteLine($"Operation state: {x + y}, {lambdaState}");
  WriteLine($"Worker thread id: {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(2));
}, "lambda state");

Sleep(TimeSpan.FromSeconds(2));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec74"></a>How it works...</h3></div></div></div><p>First, we define <a id="id115" class="indexterm"></a>the <code class="literal">AsyncOperation</code> method that accepts a single parameter of the <code class="literal">object</code> type. Then, we post this method <a id="id116" class="indexterm"></a>on a thread pool using the <code class="literal">QueueUserWorkItem</code> method. Then, we post this method once again, but this time, we pass a <code class="literal">state</code> object to this method call. This object will be passed to the <code class="literal">AsynchronousOperation</code> method as the <code class="literal">state</code> parameter.</p><p>Making a thread sleep for 1 second after these operations allows the thread pool to reuse threads for new operations. If you comment on these <code class="literal">Thread.Sleep</code> calls, most certainly the thread IDs will be different in all cases. If not, probably the first two threads will be reused to run the following two operations.</p><p>First, we post a lambda expression to a thread pool. Nothing special here; instead of defining a separate method, we use the lambda expression syntax.</p><p>Secondly, instead of passing the state of a lambda expression, we use <span class="strong"><strong>closure</strong></span> mechanics. This gives us more <a id="id117" class="indexterm"></a>flexibility and allows us to provide more than one object to the asynchronous operation and static typing for those objects. So, the previous mechanism of passing an object into a method callback is really redundant and obsolete. There is no need to use it now when we have closures in C#.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec33"></a>A thread pool and the degree of parallelism</h2></div></div><hr /></div><p>This recipe will <a id="id118" class="indexterm"></a>show you how a thread pool works with <a id="id119" class="indexterm"></a>many asynchronous operations and how it is different from creating many separate threads.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec75"></a>Getting ready</h3></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found in <code class="literal">BookSamples\Chapter3\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec76"></a>How to do it...</h3></div></div></div><p>To learn how a <a id="id120" class="indexterm"></a>thread pool works with many <a id="id121" class="indexterm"></a>asynchronous operations and how it is different from creating many separate threads, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void UseThreads(int numberOfOperations)
{
  using (var countdown = new CountdownEvent(numberOfOperations))
  {
    WriteLine("Scheduling work by creating threads");
    for (int i = 0; i &lt; numberOfOperations; i++)
    {
      var thread = new Thread(() =&gt;
      {
        Write($"{CurrentThread.ManagedThreadId},");
        Sleep(TimeSpan.FromSeconds(0.1));
        countdown.Signal();
      });
      thread.Start();
    }
    countdown.Wait();
    WriteLine();
  }
}

static void UseThreadPool(int numberOfOperations)
{
  using (var countdown = new CountdownEvent(numberOfOperations))
  {
    WriteLine("Starting work on a threadpool");
    for (int i = 0; i &lt; numberOfOperations; i++)
    {
      ThreadPool.QueueUserWorkItem( _ =&gt; 
      {
        Write($"{CurrentThread.ManagedThreadId},");
        Sleep(TimeSpan.FromSeconds(0.1));
        countdown.Signal();
      });
    }
    countdown.Wait();
    WriteLine();
  }
}</pre></div></li><li><p>Add the <a id="id122" class="indexterm"></a>following code snippet <a id="id123" class="indexterm"></a>inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">const int numberOfOperations = 500;
var sw = new Stopwatch();
sw.Start();
UseThreads(numberOfOperations);
sw.Stop();
WriteLine($"Execution time using threads: {sw.ElapsedMilliseconds}");

sw.Reset();
sw.Start();
UseThreadPool(numberOfOperations);
sw.Stop();
WriteLine($"Execution time using the thread pool: {sw.ElapsedMilliseconds}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec77"></a>How it works...</h3></div></div></div><p>When the main program starts, we create many different threads and run an operation on each one of them. This operation prints out a thread ID and blocks a thread for 100 milliseconds. As a result, we create 500 threads running all these operations in parallel. The total time on my machine is about 300 milliseconds, but we consume many operating system resources for all these threads.</p><p>Then, we follow the same workflow, but instead of creating a thread for each operation, we post them on a thread pool. After this, the thread pool starts to serve these operations; it begins to create <a id="id124" class="indexterm"></a>more threads near the end; however, it still <a id="id125" class="indexterm"></a>takes much more time, about 12 seconds on my machine. We save memory and threads for operating system use but pay for it with application performance.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec34"></a>Implementing a cancellation option</h2></div></div><hr /></div><p>This recipe <a id="id126" class="indexterm"></a>shows an example on how to cancel an asynchronous operation on a thread pool.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec78"></a>Getting ready</h3></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found in <code class="literal">BookSamples\Chapter3\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec79"></a>How to do it...</h3></div></div></div><p>To understand how <a id="id127" class="indexterm"></a>to implement a cancellation <a id="id128" class="indexterm"></a>option on a thread, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void AsyncOperation1(CancellationToken token)
{
  WriteLine("Starting the first task");
  for (int i = 0; i &lt; 5; i++)
  {
    if (token.IsCancellationRequested)
    {
      WriteLine("The first task has been canceled.");
      return;
    }
    Sleep(TimeSpan.FromSeconds(1));
  }
  WriteLine("The first task has completed succesfully");
}

static void AsyncOperation2(CancellationToken token)
{
  try
  {
    WriteLine("Starting the second task");

    for (int i = 0; i &lt; 5; i++)
    {
      token.ThrowIfCancellationRequested();
      Sleep(TimeSpan.FromSeconds(1));
    }
    WriteLine("The second task has completed succesfully");
  }
  catch (OperationCanceledException)
  {
    WriteLine("The second task has been canceled.");
  }
}

static void AsyncOperation3(CancellationToken token)
{
  bool cancellationFlag = false;
  token.Register(() =&gt; cancellationFlag = true);
  WriteLine("Starting the third task");
  for (int i = 0; i &lt; 5; i++)
  {
    if (cancellationFlag)
    {
      WriteLine("The third task has been canceled.");
      return;
    }
    Sleep(TimeSpan.FromSeconds(1));
  }
  WriteLine("The third task has completed succesfully");
}</pre></div></li><li><p>Add the <a id="id129" class="indexterm"></a>following code snippet inside the <a id="id130" class="indexterm"></a>
<code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">using (var cts = new CancellationTokenSource())
{
  CancellationToken token = cts.Token;
  ThreadPool.QueueUserWorkItem(_ =&gt; AsyncOperation1(token));
  Sleep(TimeSpan.FromSeconds(2));
  cts.Cancel();
}

using (var cts = new CancellationTokenSource())
{
  CancellationToken token = cts.Token;
  ThreadPool.QueueUserWorkItem(_ =&gt; AsyncOperation2(token));
  Sleep(TimeSpan.FromSeconds(2));
  cts.Cancel();
}

using (var cts = new CancellationTokenSource())
{
  CancellationToken token = cts.Token;
  ThreadPool.QueueUserWorkItem(_ =&gt; AsyncOperation3(token));
  Sleep(TimeSpan.FromSeconds(2));
  cts.Cancel();
}

Sleep(TimeSpan.FromSeconds(2));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec80"></a>How it works...</h3></div></div></div><p>Here, we introduce the <code class="literal">CancellationTokenSource</code> and <code class="literal">CancellationToken</code> constructs. They <a id="id131" class="indexterm"></a>appeared in .NET 4.0 and now are the de facto standard to implement asynchronous operation cancellation processes. Since the thread pool has existed for a long time, it has no special API for cancellation tokens; however, they can still be used.</p><p>In this program, we see three ways to organize a cancellation process. The first is just to poll and check the <a id="id132" class="indexterm"></a>
<code class="literal">CancellationToken.IsCancellationRequested</code> property. If it is set to <code class="literal">true</code>, this means that our operation is being cancelled and we must abandon the operation.</p><p>The second way is to throw an <code class="literal">OperationCancelledException</code> exception. This allows us to control the cancellation process not from inside the operation, which is being canceled, but from the code on the outside.</p><p>The last option is to register a <a id="id133" class="indexterm"></a>
<span class="strong"><strong>callback</strong></span> that will be called on a thread pool when an operation is canceled. This will allow us to chain cancellation logic into another asynchronous operation.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec35"></a>Using a wait handle and timeout with a thread pool</h2></div></div><hr /></div><p>This recipe <a id="id134" class="indexterm"></a>will describe how to implement a timeout for <a id="id135" class="indexterm"></a>thread pool operations and how to wait properly <a id="id136" class="indexterm"></a>on a thread pool.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec81"></a>Getting ready</h3></div></div></div><p>To step into this <a id="id137" class="indexterm"></a>recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec82"></a>How to do it...</h3></div></div></div><p>To learn how to implement a timeout and how to wait properly on a thread pool, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void RunOperations(TimeSpan workerOperationTimeout)
{
  using (var evt = new ManualResetEvent(false))
  using (var cts = new CancellationTokenSource())
  {
    WriteLine("Registering timeout operation...");
    var worker = ThreadPool.RegisterWaitForSingleObject(evt
                , (state, isTimedOut) =&gt; WorkerOperationWait(cts, isTimedOut)
                , null
                , workerOperationTimeout
                , true);

    WriteLine("Starting long running operation...");
    ThreadPool.QueueUserWorkItem(_ =&gt; WorkerOperation(cts.Token, evt));

    Sleep(workerOperationTimeout.Add(TimeSpan.FromSeconds(2)));
    worker.Unregister(evt);
  }
}

static void WorkerOperation(CancellationToken token, ManualResetEvent evt)
{
  for(int i = 0; i &lt; 6; i++)
  {
    if (token.IsCancellationRequested)
    {
      return;
    }
    Sleep(TimeSpan.FromSeconds(1));
  }
  evt.Set();
}

static void WorkerOperationWait(CancellationTokenSource cts, bool isTimedOut)
{
  if (isTimedOut)
  {
    cts.Cancel();
    WriteLine("Worker operation timed out and was canceled.");
  }
  else
  {
    WriteLine("Worker operation succeded.");
  }
}</pre></div></li><li><p>Add the <a id="id138" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">RunOperations(TimeSpan.FromSeconds(5));
RunOperations(TimeSpan.FromSeconds(7));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec83"></a>How it works...</h3></div></div></div><p>A thread pool has <a id="id139" class="indexterm"></a>another useful method: <code class="literal">ThreadPool.RegisterWaitForSingleObject</code>. This method allows us to queue a callback on a thread <a id="id140" class="indexterm"></a>pool, and this callback will be executed when the <a id="id141" class="indexterm"></a>provided wait handle is signaled or a timeout has occurred. This allows us to implement a timeout for thread pool operations.</p><p>First, we register the timeout handling asynchronous operation. It will be called when one of the following events take place: on receiving a signal from the <code class="literal">ManualResetEvent</code> object, which is set by the worker operation when it is completed successfully, or when a timeout has occurred before the first operation is completed. If this happens, we use <code class="literal">CancellationToken</code> to cancel the first operation.</p><p>Then, we queue a long-running worker operation on a thread pool. It runs for 6 seconds and then sets a <code class="literal">ManualResetEvent</code> signaling construct, in case it completes successfully. In other case, if the cancellation is requested, the operation is just abandoned.</p><p>Finally, if we provide a 5-second timeout for the operation, that would not be enough. This is because the operation takes 6 seconds to complete, and we'd need to cancel this operation. So, if we <a id="id142" class="indexterm"></a>provide a 7-second timeout, which is acceptable, the <a id="id143" class="indexterm"></a>operation completes successfully.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec84"></a>There's moreâ€¦</h3></div></div></div><p>This is very useful <a id="id144" class="indexterm"></a>when you have a large number of threads that <a id="id145" class="indexterm"></a>must wait in the <code class="literal">blocked</code> state for some multithreaded event construct to signal. Instead of blocking all these threads, we are able to use the thread pool infrastructure. It will allow us to free up these threads until the event is set. This is a very important scenario for server applications, which require scalability and performance.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec36"></a>Using a timer</h2></div></div><hr /></div><p>This recipe will <a id="id146" class="indexterm"></a>describe how to use a <code class="literal">System.Threading.Timer</code> object to create periodically-called asynchronous operations on a thread pool.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec85"></a>Getting ready</h3></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec86"></a>How to do it...</h3></div></div></div><p>To learn how to create periodically-called asynchronous operations on a thread pool, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static Timer _timer;

static void TimerOperation(DateTime start)
{
  TimeSpan elapsed = DateTime.Now - start;
  WriteLine($"{elapsed.Seconds} seconds from {start}. " +
    $"Timer thread pool thread id: {CurrentThread.ManagedThreadId}");
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Press 'Enter' to stop the timer...");
DateTime start = DateTime.Now;
_timer = new Timer(_ =&gt; TimerOperation(start), null
    , TimeSpan.FromSeconds(1)
    , TimeSpan.FromSeconds(2));
try
{
  Sleep(TimeSpan.FromSeconds(6));

  _timer.Change(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(4));

  ReadLine();
}
finally
{
  _timer.Dispose();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec87"></a>How it works...</h3></div></div></div><p>First, we create a <a id="id147" class="indexterm"></a>new <code class="literal">Timer</code> instance. The first parameter is a lambda expression that will be executed on a thread pool. We call the <code class="literal">TimerOperation</code> method, providing it with a start date. We do not use the user <code class="literal">state</code> object, so the second parameter is null; then, we specify when are we going to run <code class="literal">TimerOperation</code> for the first time and what will be the period between calls. So, the first value actually means that we start the first operation in 1 second, and then, we run each of them in 2 seconds.</p><p>After this, we wait for 6 seconds and change our timer. We start <code class="literal">TimerOperation</code> in a second after calling the <code class="literal">_timer.Change</code> method, and then run each of them for 4 seconds.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip06"></a>Tip</h3><p><span class="strong"><strong>A timer could be more complex than this!</strong></span></p><p>It is possible to use a timer in more complicated ways. For instance, we can run the timer operation only once, by providing a timer period parameter with the <code class="literal">Timeout.Infinite</code> value. Then, inside the timer asynchronous operation, we are able to set the next time when the timer operation will be executed, depending on some custom logic.</p></div><p>Lastly, we wait for the <span class="emphasis"><em>Enter</em></span> key to be pressed and to finish the application. While it is running, we can see the <a id="id148" class="indexterm"></a>time passed since the program started.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec37"></a>Using the BackgroundWorker component</h2></div></div><hr /></div><p>This recipe <a id="id149" class="indexterm"></a>describes another approach to asynchronous programming via an example of a <code class="literal">BackgroundWorker</code> component. With the help of this object, we are able to organize our asynchronous code as a set of events and event handlers. You will learn how to use this component for asynchronous programming.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec88"></a>Getting ready</h3></div></div></div><p>To step into this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter3\Recipe7</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec89"></a>How to do it...</h3></div></div></div><p>To learn how to use the <code class="literal">BackgroundWorker</code> component, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.ComponentModel;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void Worker_DoWork(object sender, DoWorkEventArgs e)
{
  WriteLine($"DoWork thread pool thread id: {CurrentThread.ManagedThreadId}");
  var bw = (BackgroundWorker) sender;
  for (int i = 1; i &lt;= 100; i++)
  {
    if (bw.CancellationPending)
    {
      e.Cancel = true;
      return;
    }
    if (i%10 == 0)
    {
      bw.ReportProgress(i);
    }

    Sleep(TimeSpan.FromSeconds(0.1));
  }

  e.Result = 42;
}

static void Worker_ProgressChanged(object sender, ProgressChangedEventArgs e)
{
  WriteLine($"{e.ProgressPercentage}% completed. " +
    $"Progress thread pool thread id: {CurrentThread.ManagedThreadId}");
}

static void Worker_Completed(object sender, RunWorkerCompletedEventArgs e)
{
  WriteLine($"Completed thread pool thread id: {CurrentThread.ManagedThreadId}");
  if (e.Error != null)
  {
    WriteLine($"Exception {e.Error.Message} has occured.");
  }
  else if (e.Cancelled)
  {
    WriteLine($"Operation has been canceled.");
  }
  else
  {
    WriteLine($"The answer is: {e.Result}");
  }
}</pre></div></li><li><p>Add the <a id="id150" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var bw = new BackgroundWorker();
bw.WorkerReportsProgress = true;
bw.WorkerSupportsCancellation = true;

bw.DoWork += Worker_DoWork;
bw.ProgressChanged += Worker_ProgressChanged;
bw.RunWorkerCompleted += Worker_Completed;

bw.RunWorkerAsync();

WriteLine("Press C to cancel work");
do
{
  if (ReadKey(true).KeyChar == 'C')
  {
    bw.CancelAsync();
  }
}
while(bw.IsBusy);</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec90"></a>How it works...</h3></div></div></div><p>When the program <a id="id151" class="indexterm"></a>starts, we create an instance of a <code class="literal">BackgroundWorker</code> component. We explicitly state that we want our background worker to support cancellation and notifications on the operation's progress.</p><p>Now, this is where the most interesting part comes into play. Instead of manipulating with a thread pool and <a id="id152" class="indexterm"></a>delegates, we use another C# idiom called <span class="strong"><strong>events</strong></span>. An event represents a <span class="emphasis"><em>source </em></span>of notifications and a number of <span class="emphasis"><em>subscribers</em></span> ready to react when a notification arrives. In our case, we state that we will subscribe for three events, and when they occur, we <a id="id153" class="indexterm"></a>call the corresponding <span class="strong"><strong>event handlers</strong></span>. These are methods with a specially defined signature that will be called when an event notifies its subscribers.</p><p>Therefore, instead of organizing an asynchronous API in a pair of <code class="literal">Begin</code>/<code class="literal">End</code> methods, it is possible to just start an asynchronous operation and then subscribe to different events that could happen while this operation is executed. This approach is called an <span class="strong"><strong>Event-based </strong></span><a id="id154" class="indexterm"></a>
<span class="strong"><strong>Asynchronous Pattern</strong></span> (<span class="strong"><strong>EAP</strong></span>). It was historically the second attempt to structure asynchronous programs, and now, it is recommended to use TPL instead, which will be described in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Using the Task Parallel Library</em></span>.</p><p>So, we subscribed to three events. The first of them is the <code class="literal">DoWork</code> event. A handler of this event will be called when a background worker object starts an asynchronous operation with the <code class="literal">RunWorkerAsync</code> method. The event handler will be executed on a thread pool, and this is the main operating point where work is canceled if cancellation is requested and where we provide information on the progress of the operation. At last, when we get the result, we set it to event arguments, and then, the <code class="literal">RunWorkerCompleted</code> event handler is called. Inside this method, we find out whether our operation has succeeded, there were some errors, or it was canceled.</p><p>Besides this, a <code class="literal">BackgroundWorker</code> component is actually intended to be used in <span class="strong"><strong>Windows Forms </strong></span><a id="id155" class="indexterm"></a>
<span class="strong"><strong>Applications</strong></span> (<span class="strong"><strong>WPF</strong></span>). Its implementation makes working with UI controls possible from a background worker's event handler <a id="id156" class="indexterm"></a>code directly, which is very comfortable as compared to the interaction of worker threads in a thread pool with UI controls.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch04"></a>ChapterÂ 4.Â Using the Task Parallel Library</h2></div></div></div><p>In this chapter, we will dive into a new asynchronous programming paradigm, the Task Parallel Library. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating a task</p></li><li style="list-style-type: disc"><p>Performing basic operations with a task</p></li><li style="list-style-type: disc"><p>Combining tasks together</p></li><li style="list-style-type: disc"><p>Converting the APM pattern to tasks</p></li><li style="list-style-type: disc"><p>Converting the EAP pattern to tasks</p></li><li style="list-style-type: disc"><p>Implementing a cancelation option</p></li><li style="list-style-type: disc"><p>Handling exceptions in tasks</p></li><li style="list-style-type: disc"><p>Running tasks in parallel</p></li><li style="list-style-type: disc"><p>Tweaking the execution of tasks with <code class="literal">TaskScheduler</code></p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec38"></a>Introduction</h2></div></div><hr /></div><p>In the previous chapters, you learned what a thread is, how to use threads, and why we need a thread pool. Using a thread pool allows us to save operating system resources at the cost of reducing a parallelism degree. We <a id="id157" class="indexterm"></a>can think of a thread pool as an <span class="strong"><strong>abstraction layer</strong></span> that hides details of thread usage from a programmer, allowing us to concentrate on a program's logic rather than on threading issues.</p><p>However, using a thread pool is complicated as well. There is no easy way to get a result from a thread pool worker thread. We need to implement our own way to get a result back, and in case of an exception, we have to propagate it to the original thread properly. Besides this, there is no easy way to create a set of dependent asynchronous actions, where one action runs after another finishes its work.</p><p>There were several attempts to work around these issues, which resulted in the creation of the Asynchronous Programming Model and the Event-based Asynchronous Pattern, mentioned in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Using a Thread Pool</em></span>. These patterns made getting results easier and did a good job of propagating exceptions, but combining asynchronous actions together still required a lot of work and resulted in a large amount of code.</p><p>To resolve all these problems, a new API for asynchronous operations was introduced in .Net Framework 4.0. It was called the Task Parallel Library (TPL). It was changed slightly in .Net Framework 4.5 and to make it clear, we will work with the latest version of TPL using the 4.6 version of .Net Framework in our projects. TPL can be considered as one more abstraction layer over a thread pool, hiding the lower-level code that will work with the thread pool from a programmer and supplying a more convenient and fine-grained API.</p><p>The core concept of TPL is a task. A<a id="id158" class="indexterm"></a> task represents an asynchronous operation that can be run in a variety of ways, using a separate thread or not. We will look through all the possibilities in detail in this chapter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>By default, a programmer is not aware of how exactly a task is being executed. TPL raises the level of abstraction by hiding the task implementation details from the user. Unfortunately, in some cases, this could lead to mysterious errors, such as the application hanging while trying to get a result from the task. This chapter will help you understand the mechanics under the hood of TPL and how to avoid using it in improper ways.</p></div><p>A task can be combined with other tasks in different variations. For example, we are able to start several tasks simultaneously, wait for all of them to complete, and then run a task that will perform some calculations over all the previous tasks' results. Convenient APIs for task combination are one of the key advantages of TPL compared to the previous patterns.</p><p>There are also several ways to deal with exceptions resulting from tasks. Since a task may consist of several other tasks, and they in turn have their child tasks as well, there is the concept of <code class="literal">AggregateException</code>. This type of exception holds all exceptions from underlying tasks inside it, allowing us to handle them separately.</p><p>And, last but not least, C# has built-in support for TPL since version 5.0, allowing us to work with tasks in a very smooth and comfortable way using the new <code class="literal">await</code> and <code class="literal">async</code> keywords. We will discuss this topic in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Using C# 6.0</em></span>.</p><p>In this chapter, you will learn to use TPL to execute asynchronous operations. We will learn what a task is, cover different ways to create tasks, and will learn how to combine tasks. We will also discuss how to convert legacy APM and EAP patterns to use tasks, how to handle exceptions properly, how to cancel tasks, and how to work with several tasks that are being executed simultaneously. In addition, we will find out how to deal with tasks in Windows GUI applications properly.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec39"></a>Creating a task</h2></div></div><hr /></div><p>This<a id="id159" class="indexterm"></a> recipe shows the basic concept of what a task is. You will learn how to create and execute tasks.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec91"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec92"></a>How to do it...</h3></div></div></div><p>To create and execute a task, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"></a>Note</h3><p>This time, make sure that you are using .Net Framework 4.5 or higher for every project.</p></div></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void TaskMethod(string name)
{
  WriteLine($"Task {name} is running on a thread id " +
      $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
      $"{CurrentThread.IsThreadPoolThread}");
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var t1 = new Task(() =&gt; TaskMethod("Task 1"));
var t2 = new Task(() =&gt; TaskMethod("Task 2"));
t2.Start();
t1.Start();
Task.Run(() =&gt; TaskMethod("Task 3"));
Task.Factory.StartNew(() =&gt; TaskMethod("Task 4"));
Task.Factory.StartNew(() =&gt; TaskMethod("Task 5"), TaskCreationOptions.LongRunning);
Sleep(TimeSpan.FromSeconds(1));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec93"></a>How it works...</h3></div></div></div><p>When the<a id="id160" class="indexterm"></a> program runs, it creates two tasks with its constructor. We pass the lambda expression as the <code class="literal">Action</code> delegate; this allows us to provide a string parameter to <code class="literal">TaskMethod</code>. Then, we run these tasks using the <code class="literal">Start</code> method.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>Note that until we call the <code class="literal">Start</code> method on these tasks, they will not start execution. It is very easy to forget to actually start the task.</p></div><p>Then, we run two more tasks using the <code class="literal">Task.Run</code> and <code class="literal">Task.Factory.StartNew</code> methods. The difference is that both the created tasks immediately start working, so we do not need to call the <code class="literal">Start</code> method on the tasks explicitly. All of the tasks, numbered <code class="literal">Task 1</code> to <code class="literal">Task 4</code>, are placed on thread pool worker threads and run in an unspecified order. If you run the program several times, you will find that the task execution order is not defined.</p><p>The <code class="literal">Task.Run</code> method is just a shortcut to <code class="literal">Task.Factory.StartNew</code>, but the latter method has additional options. In general, use the former method unless you need to do something special, as in the case of <code class="literal">Task 5</code>. We mark this task as long-running, and as a result, this task will be run on a separate thread that does not use a thread pool. However, this behavior could change, depending on the current <a id="id161" class="indexterm"></a>
<span class="strong"><strong>task scheduler</strong></span> that runs the task. You will learn what a task scheduler is in the last recipe of this chapter.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec40"></a>Performing basic operations with a task</h2></div></div><hr /></div><p>This recipe<a id="id162" class="indexterm"></a> will describe how to get the result value from<a id="id163" class="indexterm"></a> a task. We will go through several scenarios to understand the difference between running a task on a thread pool or on a main thread.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec94"></a>Getting ready</h3></div></div></div><p>To start this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec95"></a>How to do it...</h3></div></div></div><p>To perform <a id="id164" class="indexterm"></a>basic operations with a task, perform the<a id="id165" class="indexterm"></a> following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static Task&lt;int&gt; CreateTask(string name)
{
  return new Task&lt;int&gt;(() =&gt; TaskMethod(name));
}

static int TaskMethod(string name)
{
  WriteLine($"Task {name} is running on a thread id " +
     $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
     $"{CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  return 42;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">TaskMethod("Main Thread Task");
Task&lt;int&gt; task = CreateTask("Task 1");
task.Start();
int result = task.Result;
WriteLine($"Result is: {result}");

task = CreateTask("Task 2");
task.RunSynchronously();
result = task.Result;
WriteLine($"Result is: {result}");

task = CreateTask("Task 3");
WriteLine(task.Status);
task.Start();

while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));â€©} 
      
WriteLine(task.Status);
result = task.Result;
WriteLine($"Result is: {result}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec96"></a>How it works...</h3></div></div></div><p>At first, we <a id="id166" class="indexterm"></a>run <code class="literal">TaskMethod</code> without wrapping it into a task. As a result, it is executed synchronously, providing us with information about the main thread. Obviously, it is not a thread pool thread.</p><p>Then, we<a id="id167" class="indexterm"></a> run <code class="literal">Task 1</code>, starting it with the <code class="literal">Start</code> method and waiting for the result. This task will be placed on a thread pool, and the main thread waits and is blocked until the task returns.</p><p>We do the same with <code class="literal">Task 2</code>, except that we run it using the <code class="literal">RunSynchronously()</code> method. This task will run on the main thread, and we get exactly the same output as in the very first case when we called <code class="literal">TaskMethod</code> synchronously. This is a very useful optimization that allows us to avoid thread pool usage for very short-lived operations.</p><p>We run <code class="literal">Task 3</code> in the same way we did <code class="literal">Task 1</code>, but instead of blocking the main thread, we just spin, printing out the task status until the task is completed. This shows several task statuses, which are <code class="literal">Created</code>, <code class="literal">Running</code>, and <code class="literal">RanToCompletion</code>, respectively.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec41"></a>Combining tasks</h2></div></div><hr /></div><p>This recipe <a id="id168" class="indexterm"></a>will show you how to set up tasks that are dependent on each other. We will learn how to create a task that will run after the parent task is complete. In addition, we will discover a way to save thread usage for very short-lived tasks.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec97"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec98"></a>How to do it...</h3></div></div></div><p>To combine tasks, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the <a id="id169" class="indexterm"></a>following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(seconds));
  return 42 * seconds;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var firstTask = new Task&lt;int&gt;(() =&gt; TaskMethod("First Task", 3));
var secondTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Second Task", 2));

firstTask.ContinueWith(
  t =&gt; WriteLine(
    $"The first answer is {t.Result}. Thread id " +
    $"{CurrentThread.ManagedThreadId}, is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}"),
  TaskContinuationOptions.OnlyOnRanToCompletion);

firstTask.Start();
secondTask.Start();

Sleep(TimeSpan.FromSeconds(4));

Task continuation = secondTask.ContinueWith(
  t =&gt; WriteLine(
    $"The second answer is {t.Result}. Thread id " +
    $"{CurrentThread.ManagedThreadId}, is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}"),
  TaskContinuationOptions.OnlyOnRanToCompletion 
    | TaskContinuationOptions.ExecuteSynchronously);

continuation.GetAwaiter().OnCompleted(
  () =&gt; WriteLine(
    $"Continuation Task Completed! Thread id " +
    $"{CurrentThread.ManagedThreadId}, is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}"));

Sleep(TimeSpan.FromSeconds(2));
WriteLine();

firstTask = new Task&lt;int&gt;(() =&gt;
{
  var innerTask = Task.Factory.StartNew(() =&gt; TaskMethod("Second Task", 5),TaskCreationOptions.AttachedToParent);

  innerTask.ContinueWith(t =&gt; TaskMethod("Third Task", 2),
        TaskContinuationOptions.AttachedToParent);

  return TaskMethod("First Task", 2);
});

firstTask.Start();

while (!firstTask.IsCompleted)
{
  WriteLine(firstTask.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(firstTask.Status);

Sleep(TimeSpan.FromSeconds(10));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec99"></a>How it works...</h3></div></div></div><p>When the <a id="id170" class="indexterm"></a>main program starts, we create two tasks, and for the first task, we set up a <a id="id171" class="indexterm"></a>
<span class="strong"><strong>continuation</strong></span> (a block of code that runs after the antecedent task is complete). Then, we start both tasks and wait for 4 seconds, which is enough for both tasks to be complete. Then, we run another continuation to the second task and try to execute it synchronously by specifying a <code class="literal">TaskContinuationOptions.ExecuteSynchronously</code> option. This is a useful technique when the continuation is very short lived, and it will be faster to run it on the main thread than to put it on a thread pool. We are able to achieve this because the second task is completed by that moment. If we comment out the 4-second <code class="literal">Thread.Sleep</code> method, we will see that this code will be put on a thread pool because we do not have the result from the antecedent task yet.</p><p>Finally, we<a id="id172" class="indexterm"></a> define a continuation for the previous continuation, but in a slightly different manner, using the new <code class="literal">GetAwaiter</code> and <code class="literal">OnCompleted</code> methods. These methods are intended to be used along with C# language asynchronous mechanics. We will cover this topic later in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Using C# 6.0</em></span>.</p><p>The last part of the demo is about the parent-child task relationships. We create a new task, and while running this task, we run a so-called child task by providing a <code class="literal">TaskCreationOptions.AttachedToParent</code> option.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip07"></a>Tip</h3><p>The child task must be created while running a parent task so that it is attached to the parent properly!</p></div><p>This means that the parent task will not be complete until all child tasks finish their work. We are also able to run continuations on those child tasks that provide a <code class="literal">TaskContinuationOptions.AttachedToParent</code> option. These continuation tasks will affect the parent task as well, and it will not be complete until the very last child task ends.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec42"></a>Converting the APM pattern to tasks</h2></div></div><hr /></div><p>In this recipe, we <a id="id173" class="indexterm"></a>will see how to convert an old-fashioned APM API to a task. There are examples of different situations that could take place <a id="id174" class="indexterm"></a>in the process of conversion.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec100"></a>Getting ready</h3></div></div></div><p>To start this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec101"></a>How to do it...</h3></div></div></div><p>To convert the APM pattern to tasks, carry out the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the <a id="id175" class="indexterm"></a>following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">delegate string AsynchronousTask(string threadName);
delegate string IncompatibleAsynchronousTask(out int threadId);

static void Callback(IAsyncResult ar)
{
  WriteLine("Starting a callback...");
  WriteLine($"State passed to a callbak: {ar.AsyncState}");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  WriteLine($"Thread pool worker thread id: {CurrentThread.ManagedThreadId}");
}

static string Test(string threadName)
{
  WriteLine("Starting...");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  CurrentThread.Name = threadName;
  return $"Thread name: {CurrentThread.Name}";
}

static string Test(out int threadId)
{
  WriteLine("Starting...");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  threadId = CurrentThread.ManagedThreadId;
  return $"Thread pool worker thread id was: {threadId}";
}</pre></div></li><li><p>Add the <a id="id176" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">int threadId;
AsynchronousTask d = Test;
IncompatibleAsynchronousTask e = Test;

WriteLine("Option 1");
Task&lt;string&gt; task = Task&lt;string&gt;.Factory.FromAsync(
  d.BeginInvoke("AsyncTaskThread", Callback, 
    "a delegate asynchronous call"), d.EndInvoke);

task.ContinueWith(t =&gt; WriteLine(
    $"Callback is finished, now running a continuation! Result: {t.Result}"));

while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(task.Status);
Sleep(TimeSpan.FromSeconds(1));

WriteLine("----------------------------------------------");
WriteLine();
WriteLine("Option 2");

task = Task&lt;string&gt;.Factory.FromAsync(
  d.BeginInvoke, d.EndInvoke, "AsyncTaskThread", "a delegate asynchronous call");

task.ContinueWith(t =&gt; WriteLine(
    $"Task is completed, now running a continuation! Result: {t.Result}"));
while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(task.Status);
Sleep(TimeSpan.FromSeconds(1));

WriteLine("----------------------------------------------");
WriteLine();
WriteLine("Option 3");

IAsyncResult ar = e.BeginInvoke(out threadId, Callback, "a delegate asynchronous call");
task = Task&lt;string&gt;.Factory.FromAsync(ar, _ =&gt; e.EndInvoke(out threadId, ar));

task.ContinueWith(t =&gt; 
  WriteLine(
        $"Task is completed, now running a continuation! " +
        $"Result: {t.Result}, ThreadId: {threadId}"));

while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(task.Status);

Sleep(TimeSpan.FromSeconds(1));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec102"></a>How it works...</h3></div></div></div><p>Here, we <a id="id177" class="indexterm"></a>define two kinds of delegates; one of them uses the <code class="literal">out</code> parameter and therefore is incompatible with the standard TPL API for converting the APM pattern to tasks. Then, we have three examples of such a conversion.</p><p>The key point<a id="id178" class="indexterm"></a> for converting APM to TPL is the <code class="literal">Task&lt;T&gt;.Factory.FromAsync</code> method, where <code class="literal">T</code> is the asynchronous operation result type. There are several overloads of this method; in the first case, we pass <code class="literal">IAsyncResult</code> and <code class="literal">Func&lt;IAsyncResult, string&gt;</code>, which is a method that accepts the <code class="literal">IAsyncResult</code> implementation and returns a string. Since the first delegate type provides <code class="literal">EndMethod</code>, which is compatible with this signature, we have no problem converting this delegate asynchronous call to a task.</p><p>In the second example, we do almost the same, but use a different <code class="literal">FromAsync</code> method overload, which does not allow specifying a callback that will be executed after the asynchronous delegate call is completed. We are able to replace this with a continuation, but if the callback is important, we can use the first example.</p><p>The last example shows a little trick. This time, <code class="literal">EndMethod</code> of the <code class="literal">IncompatibleAsynchronousTask</code> delegate uses the <code class="literal">out</code> parameter and is not compatible with any <code class="literal">FromAsync</code> method overload. However, it is very easy to wrap the <code class="literal">EndMethod</code> call into a lambda expression that will be suitable for the task factory.</p><p>To see what is going on with the underlying task, we are printing its status while waiting for the asynchronous operation's result. We see that the first task's status is <code class="literal">WaitingForActivation</code>, which means that the task has not actually been started yet by the TPL infrastructure.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec43"></a>Converting the EAP pattern to tasks</h2></div></div><hr /></div><p>This<a id="id179" class="indexterm"></a> recipe will describe how to translate event-based <a id="id180" class="indexterm"></a>asynchronous operations to tasks. In this recipe, you will find a solid pattern that is suitable for every event-based asynchronous API in the .NET Framework class library.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec103"></a>Getting ready</h3></div></div></div><p>To begin this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec104"></a>How to do it...</h3></div></div></div><p>To convert the EAP pattern to tasks, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.ComponentModel;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  Sleep(TimeSpan.FromSeconds(seconds));
  return 42 * seconds;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var tcs = new TaskCompletionSource&lt;int&gt;();

var worker = new BackgroundWorker();
worker.DoWork += (sender, eventArgs) =&gt;
{
  eventArgs.Result = TaskMethod("Background worker", 5);
};

worker.RunWorkerCompleted += (sender, eventArgs) =&gt;
{
  if (eventArgs.Error != null)
  {
    tcs.SetException(eventArgs.Error);
  }
  else if (eventArgs.Cancelled)
  {
    tcs.SetCanceled();
  }
  else
  {
    tcs.SetResult((int)eventArgs.Result);
  }
};

worker.RunWorkerAsync();

int result = tcs.Task.Result;

WriteLine($"Result is: {result}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec105"></a>How it works...</h3></div></div></div><p>This is a<a id="id181" class="indexterm"></a> very simple and elegant example of converting EAP patterns to tasks. The key point is to use the <code class="literal">TaskCompletionSource&lt;T&gt;</code> type, where <code class="literal">T</code> is an asynchronous operation result type.</p><p>It is also important not <a id="id182" class="indexterm"></a>to forget to wrap the <code class="literal">tcs.SetResult</code> method call into the <code class="literal">try/catch</code> block in order to guarantee that the error information is always set to the task completion source object. It is also possible to use the <code class="literal">TrySetResult</code> method instead of <code class="literal">SetResult</code> to make sure that the result has been set successfully.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec44"></a>Implementing a cancelation option</h2></div></div><hr /></div><p>This recipe is about<a id="id183" class="indexterm"></a> implementing the cancelation process for task-based asynchronous operations. You will learn how to use the cancelation token properly for tasks and how to find out whether a task is canceled before it was actually run.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec106"></a>Getting ready</h3></div></div></div><p>To start with this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec107"></a>How to do it...</h3></div></div></div><p>To implement<a id="id184" class="indexterm"></a> a cancelation option for task-based asynchronous operations, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds, CancellationToken token)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  for (int i = 0; i &lt; seconds; i ++)
  {
    Sleep(TimeSpan.FromSeconds(1));
    if (token.IsCancellationRequested) return -1;
  }
  return 42*seconds;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var cts = new CancellationTokenSource();
var longTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 1", 10, cts.Token), cts.Token);
WriteLine(longTask.Status);
cts.Cancel();
WriteLine(longTask.Status);
WriteLine("First task has been cancelled before execution");

cts = new CancellationTokenSource();
longTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 2", 10, cts.Token), cts.Token);
longTask.Start();
for (int i = 0; i &lt; 5; i++ )
{
  Sleep(TimeSpan.FromSeconds(0.5));
  WriteLine(longTask.Status);
}
cts.Cancel();
for (int i = 0; i &lt; 5; i++)
{
  Sleep(TimeSpan.FromSeconds(0.5));
  WriteLine(longTask.Status);
}

WriteLine($"A task has been completed with result {longTask.Result}.");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec108"></a>How it works...</h3></div></div></div><p>This is <a id="id185" class="indexterm"></a>another very simple example of how to implement the cancelation option for a TPL task. You are already familiar with the cancelation token concept we discussed in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Using a Thread Pool</em></span>.</p><p>First, let's look closely at the <code class="literal">longTask</code> creation code. We're providing a cancelation token to the underlying task once and then to the task constructor for the second time. <span class="emphasis"><em>Why do we need to supply this token twice?</em></span></p><p>The answer is that if we cancel the task before it was actually started, its TPL infrastructure is responsible for dealing with the cancelation because our code will not be executed at all. We know that the first task was canceled by getting its status. If we try to call the <code class="literal">Start</code> method on this task, we will get <code class="literal">InvalidOperationException</code>.</p><p>Then, we deal with the cancelation process from our own code. This means that we are now fully responsible for the cancelation process, and after we canceled the task, its status was still <code class="literal">RanToCompletion</code> because from TPL's perspective, the task finished its job normally. It is very important to distinguish these two situations and understand the responsibility difference in each case.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec45"></a>Handling exceptions in tasks</h2></div></div><hr /></div><p>This recipe <a id="id186" class="indexterm"></a>describes the very important topic of handling exceptions in asynchronous tasks. We will go through different aspects of what happens to exceptions thrown from tasks and how to get to their information.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec109"></a>Getting ready</h3></div></div></div><p>To step<a id="id187" class="indexterm"></a> through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe7</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec110"></a>How to do it...</h3></div></div></div><p>To handle exceptions in tasks, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  Sleep(TimeSpan.FromSeconds(seconds));
  throw new Exception("Boom!");
  return 42 * seconds;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task&lt;int&gt; task;
try
{
  task = Task.Run(() =&gt; TaskMethod("Task 1", 2));
  int result = task.Result;
  WriteLine($"Result: {result}");
}
catch (Exception ex)
{
  WriteLine($"Exception caught: {ex}");
}
WriteLine("----------------------------------------------");
WriteLine();

try
{
  task = Task.Run(() =&gt; TaskMethod("Task 2", 2));
  int result = task.GetAwaiter().GetResult();
      WriteLine($"Result: {result}");
}
catch (Exception ex)
{
  WriteLine($"Exception caught: {ex}");
}
WriteLine("----------------------------------------------");
WriteLine();

var t1 = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 3", 3));
var t2 = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 4", 2));
var complexTask = Task.WhenAll(t1, t2);
var exceptionHandler = complexTask.ContinueWith(t =&gt; 
    WriteLine($"Exception caught: {t.Exception}"), 
    TaskContinuationOptions.OnlyOnFaulted
  );
t1.Start();
t2.Start();

Sleep(TimeSpan.FromSeconds(5));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec111"></a>How it works...</h3></div></div></div><p>When the <a id="id188" class="indexterm"></a>program starts, we create a task and try to get the task results<a id="id189" class="indexterm"></a> synchronously. The <code class="literal">Get</code> part of the <code class="literal">Result</code> property makes the current thread wait until the completion of the task and propagates the exception to the current thread. In this case, we easily catch the exception in a catch block, but this exception is a wrapper exception called <code class="literal">AggregateException</code>. In this case, it holds only one exception inside because only one task has thrown this exception, and it is possible to get the underlying exception by accessing the <code class="literal">InnerException</code> property.</p><p>The second example<a id="id190" class="indexterm"></a> is mostly the same, but to access the task result, we use the <code class="literal">GetAwaiter</code> and <code class="literal">GetResult</code> methods. In this case, we do not have a wrapper exception because it is unwrapped by the TPL infrastructure. We have an original exception at once, which is quite comfortable if we have only one underlying task.</p><p>The last <a id="id191" class="indexterm"></a>example shows the situation where we have two task-throwing exceptions. To handle exceptions, we now use a continuation, which is executed only in case the antecedent task finishes with an exception. This behavior is achieved by providing a <code class="literal">TaskContinuationOptions.OnlyOnFaulted</code> option to a continuation. As a result, we have <code class="literal">AggregateException</code> being printed out, and we have two inner exceptions from both the tasks inside it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec112"></a>There's moreâ€¦</h3></div></div></div><p>As tasks may be connected in a very different manner, the resulting <code class="literal">AggregateException</code> exception might contain other aggregate exceptions inside along with the usual exceptions. Those inner aggregate exceptions might themselves contain other aggregate exceptions within them.</p><p>To get rid of those wrappers, we should use the root aggregate exception's <code class="literal">Flatten</code> method. It will return a collection of all the inner exceptions of every child aggregate exception in the hierarchy.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec46"></a>Running tasks in parallel</h2></div></div><hr /></div><p>This recipe <a id="id192" class="indexterm"></a>shows how to handle many asynchronous tasks that are running simultaneously. You will learn how to be notified effectively when all tasks are complete or any of the running tasks have to finish their work.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec113"></a>Getting ready</h3></div></div></div><p>To start this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe8</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec114"></a>How to do it...</h3></div></div></div><p>To run tasks in parallel, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the<a id="id193" class="indexterm"></a> following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  Sleep(TimeSpan.FromSeconds(seconds));
  return 42 * seconds;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var firstTask = new Task&lt;int&gt;(() =&gt; TaskMethod("First Task", 3));
var secondTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Second Task", 2));
var whenAllTask = Task.WhenAll(firstTask, secondTask);

whenAllTask.ContinueWith(t =&gt;
  WriteLine($"The first answer is {t.Result[0]}, the second is {t.Result[1]}"),
  TaskContinuationOptions.OnlyOnRanToCompletion);

firstTask.Start();
secondTask.Start();

Sleep(TimeSpan.FromSeconds(4));

var tasks = new List&lt;Task&lt;int&gt;&gt;();
for (int i = 1; i &lt; 4; i++)
{
  int counter = i;
  var task = new Task&lt;int&gt;(() =&gt; TaskMethod($"Task {counter}", counter));
  tasks.Add(task);
  task.Start();
}

while (tasks.Count &gt; 0)
{
  var completedTask = Task.WhenAny(tasks).Result;
  tasks.Remove(completedTask);
  WriteLine($"A task has been completed with result {completedTask.Result}.");
}

Sleep(TimeSpan.FromSeconds(1));</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec115"></a>How it works...</h3></div></div></div><p>When the<a id="id194" class="indexterm"></a> program starts, we create two tasks, and then, with the help of the <code class="literal">Task.WhenAll</code> method, we create a third task, which will be complete after all initial tasks are complete. The resulting task provides us with an answer array, where the first element holds the first task's result, the second element holds the second result, and so on.</p><p>Then, we create another list of tasks and wait for any of those tasks to be completed with the <code class="literal">Task.WhenAny</code> method. After we have one finished task, we remove it from the list and continue to wait for the other tasks to be complete until the list is empty. This method is useful to get the task completion progress or to use a timeout while running the tasks. For example, we wait for a number of tasks, and one of those tasks is counting a timeout. If this task is completed first, we just cancel all other tasks that are not completed yet.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec47"></a>Tweaking the execution of tasks with TaskScheduler</h2></div></div><hr /></div><p>This <a id="id195" class="indexterm"></a>recipe describes another very important aspect of dealing with tasks, which is a proper way to work with a UI from the asynchronous code. You will learn what a task scheduler is, why it is so important, how it can harm our application, and how to use it to avoid errors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec116"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe9</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec117"></a>How to do it...</h3></div></div></div><p>To tweak task execution with <code class="literal">TaskScheduler</code>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# <span class="strong"><strong>WPF Application</strong></span> project. This time, we will need a UI thread with a message loop, which is not available in console applications.</p></li><li><p>In the <code class="literal">MainWindow.xaml</code> file, add the following markup inside a grid element (that is, between the <code class="literal">&lt;Grid&gt;</code> and <code class="literal">&lt;/Grid&gt;</code> tags):</p><div class="informalexample"><pre class="programlisting">&lt;TextBlock Name="ContentTextBlock"
HorizontalAlignment="Left"
Margin="44,134,0,0"
VerticalAlignment="Top"
Width="425"
Height="40"/&gt;
&lt;Button Content="Sync"
HorizontalAlignment="Left"
Margin="45,190,0,0"
VerticalAlignment="Top"
Width="75"
Click="ButtonSync_Click"/&gt;
&lt;Button Content="Async"
HorizontalAlignment="Left"
Margin="165,190,0,0"
VerticalAlignment="Top"
Width="75"
Click="ButtonAsync_Click"/&gt;
&lt;Button Content="Async OK"
HorizontalAlignment="Left"
Margin="285,190,0,0"
VerticalAlignment="Top"
Width="75"
Click="ButtonAsyncOK_Click"/&gt;</pre></div></li><li><p>In <a id="id196" class="indexterm"></a>the <code class="literal">MainWindow.xaml.cs</code> file, use the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">MainWindow</code> constructor:</p><div class="informalexample"><pre class="programlisting">void ButtonSync_Click(object sender, RoutedEventArgs e)
{
  ContentTextBlock.Text = string.Empty;
  try
  {
    //string result = TaskMethod(
    //  TaskScheduler.FromCurrentSynchronizationContext()).Result;
    string result = TaskMethod().Result;
    ContentTextBlock.Text = result;
  }
  catch (Exception ex)
  {
    ContentTextBlock.Text = ex.InnerException.Message;
  }
}

void ButtonAsync_Click(object sender, RoutedEventArgs e)
{
  ContentTextBlock.Text = string.Empty;
  Mouse.OverrideCursor = Cursors.Wait;
  Task&lt;string&gt; task = TaskMethod();
  task.ContinueWith(t =&gt; 
    {
      ContentTextBlock.Text = t.Exception.InnerException.Message;
      Mouse.OverrideCursor = null;
    }, 
    CancellationToken.None,
    TaskContinuationOptions.OnlyOnFaulted,
    TaskScheduler.FromCurrentSynchronizationContext());
}

void ButtonAsyncOK_Click(object sender, RoutedEventArgs e)
{
  ContentTextBlock.Text = string.Empty;
  Mouse.OverrideCursor = Cursors.Wait;
  Task&lt;string&gt; task = TaskMethod(
    TaskScheduler.FromCurrentSynchronizationContext());

  task.ContinueWith(t =&gt; Mouse.OverrideCursor = null,
    CancellationToken.None,
    TaskContinuationOptions.None,
    TaskScheduler.FromCurrentSynchronizationContext());
}

Task&lt;string&gt; TaskMethod()
{
  return TaskMethod(TaskScheduler.Default);
}

Task&lt;string&gt; TaskMethod(TaskScheduler scheduler)
{
  Task delay = Task.Delay(TimeSpan.FromSeconds(5));

  return delay.ContinueWith(t =&gt;
  {
    string str =
      "Task is running on a thread id " +
      $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
      $"{CurrentThread.IsThreadPoolThread}";

    ContentTextBlock.Text = str;
    return str;
  }, scheduler);
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec118"></a>How it works...</h3></div></div></div><p>Here, we meet <a id="id197" class="indexterm"></a>many new things. First, we created a WPF application instead of a console application. It is necessary because we need a user interface thread with a message loop to demonstrate the different options of running a task asynchronously.</p><p>There is a very important abstraction called <code class="literal">TaskScheduler</code>. This component is actually responsible for how the task will be executed. The default task scheduler puts tasks on a thread pool worker thread. This is the most common scenario; unsurprisingly, it is the default option in TPL. We also know how to run a task synchronously and how to attach them to the parent tasks to run those tasks together. Now, let's see what else we can do with tasks.</p><p>When the program starts, we create a window with three buttons. The first button invokes a synchronous task execution. The code is placed inside the <code class="literal">ButtonSync_Click</code> method. While the task runs, we are not even able to move the application window. The user interface gets totally frozen while the user interface thread is busy running the task and cannot respond to any message loop until the task is complete. This is quite a common bad practice for GUI Windows applications, and we need to find a way to work around this issue.</p><p>The second problem is that we try to access the UI controls from another thread. Graphical User Interface controls have never been designed to be used from multiple threads, and to avoid possible errors, you are not allowed to access these components from a thread other than the one on which it was created. When we try to do that, we get an exception, and the exception message is printed on the main window in 5 seconds.</p><p>To resolve the first problem, we try to run the task asynchronously. This is what the second button does; the code for this is placed inside the <code class="literal">ButtonAsync_Click</code> method. If you run the task in a debugger, you will see that it is placed on a thread pool, and in the end, we will get the same exception. However, the user interface remains responsive all the time the task runs. This is a good thing, but we need to get rid of the exception.</p><p>And we already <a id="id198" class="indexterm"></a>did that! To output the error message, a continuation was provided with the <code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code> option. If this wasn't done, we would not see the error message because we would get the same exception that took place inside the task. This option instructs the TPL infrastructure to put a code inside the continuation on the UI thread and run it asynchronously with the help of the UI thread message loop. This resolves the problem with accessing UI controls from another thread, but still keeps our UI responsive.</p><p>To check whether this is true, we press the last button that runs the code inside the <code class="literal">ButtonAsyncOK_Click</code> method. All that is different is that we provide the UI thread task scheduler to our task. After the task is complete, you will see that it runs on the UI thread in an asynchronous manner. The UI remains responsive, and it is even possible to press another button despite the wait cursor being active.</p><p>However, there are some tricks to use the UI thread in order to run tasks. If we go back to the synchronous task code and uncomment the line with getting the result with the UI thread task scheduler provided, we will never get any result. This is a classical deadlock situation: we are dispatching an operation in the queue of the UI thread, and the UI thread waits for this operation to complete, but as it waits, it cannot run the operation, which will never end (or even start). This will also happen if we call the <code class="literal">Wait</code> method on a task. To avoid deadlock, never use synchronous operations on a task scheduled to the UI thread; just use <code class="literal">ContinueWith</code> or <code class="literal">async</code>/<code class="literal">await</code> from C#.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch05"></a>ChapterÂ 5.Â Using C# 6.0</h2></div></div></div><p>In this chapter, we will look through native asynchronous programming support in the C# 6.0 programming language. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using the <code class="literal">await</code> operator to get asynchronous task results</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">await</code> operator in a lambda expression</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">await</code> operator with consequent asynchronous tasks</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">await</code> operator for the execution of parallel asynchronous tasks</p></li><li style="list-style-type: disc"><p>Handling exceptions in asynchronous operations</p></li><li style="list-style-type: disc"><p>Avoiding the use of the captured synchronization context</p></li><li style="list-style-type: disc"><p>Working around the <code class="literal">async void</code> method</p></li><li style="list-style-type: disc"><p>Designing a custom awaitable type</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">dynamic</code> type with <code class="literal">await</code></p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec48"></a>Introduction</h2></div></div><hr /></div><p>Until now, you learned <a id="id199" class="indexterm"></a>about the Task Parallel Library, the latest asynchronous programming infrastructure from Microsoft. It allows us to design our program in a modular manner, combining different asynchronous operations together.</p><p>Unfortunately, it is still difficult to understand the actual program flow when reading such a program. In a large program, there will be numerous tasks and continuations that depend on each other, continuations that run other continuations, and continuations for exception handling. They are all gathered together in the program code in very different places. Therefore, understanding the sequence of which operation goes first and what happens next becomes a very challenging problem.</p><p>Another issue to watch out for is whether the proper synchronization context is propagated to each asynchronous task that could touch user interface controls. It is only permitted to use these controls from the UI thread; otherwise, we would get a multithreaded access exception.</p><p>Speaking about exceptions, we also have to use separate continuation tasks to handle errors that occur inside antecedent asynchronous operation or operations. This in turn results in complicated error-handling code that is spread through different parts of the code, not logically related to each other.</p><p>To address these issues, the<a id="id200" class="indexterm"></a> authors of C# introduced new language enhancements called <span class="strong"><strong>asynchronous functions </strong></span>along with C# version 5.0. They really make asynchronous programming simple, but at the same time, it is a higher level abstraction over TPL. As we mentioned in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Using the Task Parallel Library</em></span>, abstraction hides important implementation details and makes asynchronous programming easier at the cost of taking away many important things from a programmer. It is very important to understand the concept behind asynchronous functions to create robust and scalable applications.</p><p>To create <a id="id201" class="indexterm"></a>an asynchronous function, you first mark a method with the <code class="literal">async</code> keyword. It is not possible to have the <code class="literal">async</code> property or event accessor methods and constructors without doing this first. The code will look as follows:</p><div class="informalexample"><pre class="programlisting">async Task&lt;string&gt; GetStringAsync()
{
  await Task.Delay(TimeSpan.FromSeconds(2));
  return "Hello, World!";
}</pre></div><p>Another important fact is that asynchronous functions must return the <code class="literal">Task</code> or <code class="literal">Task&lt;T&gt;</code> type. It is possible to have <code class="literal">async void</code> methods, but it is preferable to use the <code class="literal">async Task</code> method instead. The only reasonable option to use <code class="literal">async void</code> functions is when using top-level UI control event handlers in your application.</p><p>Inside a method marked with the <code class="literal">async</code> keyword, you can use the <code class="literal">await</code> operator. This operator works with tasks from TPL and gets the result of the asynchronous operation inside the task. The details will be covered later in the chapter. You cannot use the <code class="literal">await</code> operator outside the <code class="literal">async</code> method; there will be a compilation error. In addition, asynchronous functions should have at least one <code class="literal">await</code> operator inside their code. However, not having an <code class="literal">await</code> operator will lead to just a compilation warning, not an error.</p><p>It is important to note that this method returns immediately after the line with the <code class="literal">await</code> call. In case of a synchronous execution, the executing thread will be blocked for 2 seconds and then return a result. Here, we wait asynchronously while returning a worker thread to a thread pool immediately after executing the <code class="literal">await</code> operator. After 2 seconds, we get the worker thread from a thread pool once again and run the rest of the asynchronous method on it. This allows us to reuse this worker thread to do some other work while these 2 seconds pass, which is extremely important for application scalability. With the help of asynchronous functions, we have a linear program control flow, but it is still asynchronous. This is both very comfortable and very confusing. The recipes in this chapter will help you learn every important aspect of asynchronous functions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>In my experience, there is a common misunderstanding about how programs work if there are two consecutive <code class="literal">await</code> operators in it. Many people think that if we use the await function on one asynchronous operation after another, they run in parallel. However, they actually run sequentially; the second one starts only when the first operation completes. It is very important to remember this, and later in the chapter, we will cover this topic in detail.</p></div><p>There are a number of limitations connected with using <code class="literal">async</code> and <code class="literal">await</code> operators. In C# 5.0, for example, it<a id="id202" class="indexterm"></a> is not possible to mark the console application's <code class="literal">Main</code> method as <code class="literal">async</code>; you cannot have the <code class="literal">await</code> operator inside a <code class="literal">catch</code>, <code class="literal">finally</code>, <code class="literal">lock</code>, or <code class="literal">unsafe</code> block. It is not allowed to have <code class="literal">ref</code> and <code class="literal">out</code> parameters on an asynchronous function. There <a id="id203" class="indexterm"></a>are more subtleties, but these are the major points. In C# 6.0, some of these limitations have been removed; you can use <code class="literal">await</code> inside <code class="literal">catch</code> and <code class="literal">finally</code> blocks due to compiler internal enhancements.</p><p>Asynchronous functions <a id="id204" class="indexterm"></a>are turned into complex program constructs by the C# compiler behind the scenes. I intentionally will not <a id="id205" class="indexterm"></a>describe this in detail; the resulting code is quite similar to another C# construct, called <span class="strong"><strong>iterators</strong></span>, and is implemented as a sort of state machine. Since many developers have started using the <code class="literal">async</code> modifier almost on every method, I would like to emphasize that there is no sense in marking a method <code class="literal">async</code> if it is not intended to be used in an asynchronous or parallel manner. Calling the <code class="literal">async</code> method includes a significant performance hit, and the usual method call is going to be about 40 to 50 times faster as compared to the same method marked with the <code class="literal">async</code> keyword. Please be aware of that.</p><p>In this chapter, you will learn to use the C# <code class="literal">async</code> and <code class="literal">await</code> keywords to work with asynchronous operations. We will cover how to await asynchronous operations sequentially and parallelly. We will discuss how to use <code class="literal">await</code> in lambda expressions, how to handle exceptions, and how to avoid pitfalls when using the <code class="literal">async void</code> methods. To conclude the chapter, we will dive deep into synchronization context propagation and you will learn how to create your own awaitable objects instead of using tasks.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec49"></a>Using the await operator to get asynchronous task results</h2></div></div><hr /></div><p>This recipe walks <a id="id206" class="indexterm"></a>you through the basic scenario of using asynchronous functions. We will compare how<a id="id207" class="indexterm"></a> to get an asynchronous operation result with TPL and with the <code class="literal">await</code> operator.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec119"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec120"></a>How to do it...</h3></div></div></div><p>To use the <code class="literal">await</code> operator in order to get asynchronous task results, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static Task AsynchronyWithTPL()
{
  Task&lt;string&gt; t = GetInfoAsync("Task 1");
  Task t2 = t.ContinueWith(task =&gt; WriteLine(t.Result),
    TaskContinuationOptions.NotOnFaulted);
  Task t3 = t.ContinueWith(task =&gt; WriteLine(t.Exception.InnerException),
    TaskContinuationOptions.OnlyOnFaulted);

  return Task.WhenAny(t2, t3);
}

static async Task AsynchronyWithAwait()
{
  try
  {
    string result = await GetInfoAsync("Task 2");
    WriteLine(result);
  }
  catch (Exception ex)
  {
    WriteLine(ex);
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name)
{
  await Task.Delay(TimeSpan.FromSeconds(2));
  //throw new Exception("Boom!");
  return
     $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." + 
$" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronyWithTPL();
t.Wait();

t = AsynchronyWithAwait();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec121"></a>How it works...</h3></div></div></div><p>When the program<a id="id208" class="indexterm"></a> runs, we run two asynchronous operations. One of them is standard TPL-powered code and the second one uses the new <code class="literal">async</code> and <code class="literal">await</code> C# features. The <code class="literal">AsynchronyWithTPL</code> method starts a task that runs for 2 seconds and then returns a string with information about the worker thread. Then, we define a continuation to print out the asynchronous operation result after the operation is complete and another one to print the exception details in case errors occur. Finally, we return a task representing one of the continuation<a id="id209" class="indexterm"></a> tasks and wait for its completion in the <code class="literal">Main</code> method.</p><p>In the <code class="literal">AsynchronyWithAwait</code> method, we achieve the same result by using <code class="literal">await</code> with the task. It is as if we write just the usual synchronous codeâ€”we get the result from the task, print out the result, and catch an exception if the task is completed with errors. The key difference is that we actually have an asynchronous program. Immediately after using <code class="literal">await</code>, C# creates a task that has a continuation task with all the remaining code after the <code class="literal">await</code> operator and deals with exception propagation as well. Then, we return this task to the <code class="literal">Main</code> method and wait until it gets completed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>Note that depending on the nature of the underlying asynchronous operation and the current synchronization context, the exact means of executing asynchronous code may differ. We will explain this later in the chapter.</p></div><p>Therefore, we can <a id="id210" class="indexterm"></a>see that the first and the second parts of the program are conceptually equivalent, but in the second part the C# compiler does the work of handling asynchronous code implicitly. It is, in fact, even more complicated than the first part, and we will cover the details in the next few recipes of this chapter.</p><p>Remember that it is not recommended to use the <code class="literal">Task.Wait</code> and <code class="literal">Task.Result</code> methods in environments <a id="id211" class="indexterm"></a>such as the Windows GUI or ASP.NET. This could lead to deadlocks if the programmer is not 100% aware of what is really going on in the code. This was illustrated in the <span class="emphasis"><em>Tweaking the execution of tasks with TaskScheduler</em></span> recipe in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Using the Task Parallel Library</em></span>, when we used <code class="literal">Task.Result</code> in the WPF application.</p><p>To test how exception handling works, just uncomment the <code class="literal">throw new Exception</code> line inside the <code class="literal">GetInfoAsync</code> method.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec50"></a>Using the await operator in a lambda expression</h2></div></div><hr /></div><p>This recipe will <a id="id212" class="indexterm"></a>show you how to use <code class="literal">await</code> inside a lambda <a id="id213" class="indexterm"></a>expression. We will write an anonymous method that uses <code class="literal">await</code> and get a result of the method execution asynchronously.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec122"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec123"></a>How to do it...</h3></div></div></div><p>To write an anonymous method that uses <code class="literal">await</code> and get a result of the method execution asynchronously using the <code class="literal">await</code> operator in a lambda expression, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task AsynchronousProcessing()
{
  Func&lt;string, Task&lt;string&gt;&gt; asyncLambda = async name =&gt; {
    await Task.Delay(TimeSpan.FromSeconds(2));
    return
  $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." +
  $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
  };

  string result = await asyncLambda("async lambda");

  WriteLine(result);
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec124"></a>How it works...</h3></div></div></div><p>First, we move out<a id="id214" class="indexterm"></a> the asynchronous function into the <code class="literal">AsynchronousProcessing</code> method, since we cannot use <code class="literal">async</code> with <code class="literal">Main</code>. Then, we<a id="id215" class="indexterm"></a> describe a lambda expression using the <code class="literal">async</code> keyword. As the type of any lambda expression cannot be inferred from lambda itself, we have to specify its type to the C# compiler explicitly. In our case, the type means that our lambda  expression accepts one string parameter and returns a <code class="literal">Task&lt;string&gt;</code> object.</p><p>Then, we define the lambda expression body. One aberration is that the method is defined to return a <code class="literal">Task&lt;string&gt;</code> object, but we actually return a string and get no compilation errors! The C# compiler<a id="id216" class="indexterm"></a> automatically generates a task and returns it for us.</p><p>The last step is to await the<a id="id217" class="indexterm"></a> asynchronous lambda expression execution and print out the result.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec51"></a>Using the await operator with consequent asynchronous tasks</h2></div></div><hr /></div><p>This recipe will show<a id="id218" class="indexterm"></a> you how exactly the <a id="id219" class="indexterm"></a>program flows when we have several consecutive <code class="literal">await</code> methods in the code. You will learn how to read the code with the <code class="literal">await</code> method and understand why the <code class="literal">await</code> call is an asynchronous operation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec125"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec126"></a>How to do it...</h3></div></div></div><p>To understand a program flow in the presence of consecutive <code class="literal">await</code> methods, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static Task AsynchronyWithTPL()
{
  var containerTask = new Task(() =&gt; { 
    Task&lt;string&gt; t = GetInfoAsync("TPL 1");
    t.ContinueWith(task =&gt; {
      WriteLine(t.Result);
      Task&lt;string&gt; t2 = GetInfoAsync("TPL 2");
      t2.ContinueWith(innerTask =&gt; WriteLine(innerTask.Result),
        TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.AttachedToParent);
      t2.ContinueWith(innerTask =&gt; WriteLine(innerTask.Exception.InnerException),
        TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.AttachedToParent);
      },
      TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.AttachedToParent);

    t.ContinueWith(task =&gt; WriteLine(t.Exception.InnerException),
      TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.AttachedToParent);
  });

  containerTask.Start();
  return containerTask;
}

static async Task AsynchronyWithAwait()
{
  try
  {
    string result = await GetInfoAsync("Async 1");
    WriteLine(result);
    result = await GetInfoAsync("Async 2");
    WriteLine(result);
  }
  catch (Exception ex)
  {
    WriteLine(ex);
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name)
{
  WriteLine($"Task {name} started!");
  await Task.Delay(TimeSpan.FromSeconds(2));
  if(name == "TPL 2")
    throw new Exception("Boom!");
  return
  $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." +
  $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronyWithTPL();
t.Wait();

t = AsynchronyWithAwait();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec127"></a>How it works...</h3></div></div></div><p>When the program<a id="id220" class="indexterm"></a> runs, we run two asynchronous operations just as we did in the first recipe. However, this time, we shall start from the <code class="literal">AsynchronyWithAwait</code> method. It still looks like the usual synchronous code; the only difference is the two <code class="literal">await</code> statements. The most important point is that the code is still sequential, and the <code class="literal">Async 2</code> task will start only after the previous one is completed. When we read the code, the program flow is very clear: we see what runs first and what goes after. Then, how is this program asynchronous? Well, first, it is not always asynchronous. If a task is already complete when we use <code class="literal">await</code>, we will get its result synchronously. Otherwise, the common approach when we see an <code class="literal">await</code> statement inside<a id="id221" class="indexterm"></a> the code is to note that at this point, the method will return immediately and the rest of the code will be run in a continuation task. Since we do not block the execution, waiting for the result of an operation, it is an asynchronous call. Instead of calling <code class="literal">t.Wait</code> in the <code class="literal">Main</code> method, we can perform any other task while the code in the <code class="literal">AsynchronyWithAwait</code> method is being executed. However, the main thread must wait until all the asynchronous operations complete, or they will be stopped as they run on background threads.</p><p>The <code class="literal">AsynchronyWithTPL</code> method imitates the same program flow as the <code class="literal">AsynchronyWithAwait</code> method does. We need a container task to handle all the dependent tasks together. Then, we start the main task and add a set of continuations to it. When the task is complete, we print out the result; we then start one more task, which in turn has more continuations to continue work after the second task is complete. To test the exception handling, we throw an exception on purpose when running the second task and get its information printed out. This set of continuations creates the same program flow as in the first method, and when we compare it to the code with the <code class="literal">await</code> methods, we can see that it is much easier to read and understand. The only trick is to remember that asynchrony does not always mean parallel execution.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec52"></a>Using the await operator for the execution of parallel asynchronous tasks</h2></div></div><hr /></div><p>In this recipe, you will<a id="id222" class="indexterm"></a> learn how to use <code class="literal">await</code> to run asynchronous operations in parallel instead of the usual sequential execution.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec128"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you<a id="id223" class="indexterm"></a> will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec129"></a>How to do it...</h3></div></div></div><p>To understand the use of the <code class="literal">await</code> operator for parallel asynchronous task execution, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task AsynchronousProcessing()
{
  Task&lt;string&gt; t1 = GetInfoAsync("Task 1", 3);
  Task&lt;string&gt; t2 = GetInfoAsync("Task 2", 5);

  string[] results = await Task.WhenAll(t1, t2);
  foreach (string result in results)
  {
    WriteLine(result);
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name, int seconds)
{
  await Task.Delay(TimeSpan.FromSeconds(seconds));
  //await Task.Run(() =&gt; 
  //   Thread.Sleep(TimeSpan.FromSeconds(seconds)));
  return
  $"Task {name} is running on a thread id " +
  $"{CurrentThread.ManagedThreadId}. " +
  $"Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec130"></a>How it works...</h3></div></div></div><p>Here, we define two<a id="id224" class="indexterm"></a> asynchronous tasks running for 3 and 5 seconds, respectively. Then, we use a <code class="literal">Task.WhenAll</code> helper method to create another task that will be complete only when all of the underlying tasks get completed. Then, we await the result of this combined task. After 5 seconds, we get all the results, which means that the tasks were running simultaneously.</p><p>However, there is one interesting observation. When you run the program, you might note that both tasks are likely to be served by the same worker thread from a thread pool. How is this possible <a id="id225" class="indexterm"></a>when we have run the tasks in parallel? To make things even more interesting, let's comment out the <code class="literal">await Task.Delay</code> line inside the <code class="literal">GetIntroAsync</code> method and uncomment the <code class="literal">await Task.Run</code> line, and then run the program.</p><p>We will see that in this case, both the tasks will be served by different worker threads. The difference is that <code class="literal">Task.Delay</code> uses a timer under the hood, and the processing goes as follows: we get the worker thread from a thread pool, which awaits the <code class="literal">Task.Delay</code> method to return a result. Then, the <code class="literal">Task.Delay</code> method starts the timer and specifies a piece of code that will be called when the timer counts the number of seconds specified to the <code class="literal">Task.Delay</code> method. Then, we immediately return the worker thread to a thread pool. When the timer event runs, we get any available worker thread from a thread pool once again (which could be the same thread that we used first) and run the code provided to the timer on it.</p><p>When we use the <code class="literal">Task.Run</code> method, we get a worker thread from a thread pool and make it block for a number of seconds, provided to the <code class="literal">Thread.Sleep</code> method. Then, we get a second worker thread and block it as well. In this scenario, we consume two worker threads and they do absolutely nothing, as they are not able to perform any other task while waiting.</p><p>We will talk in detail about the first scenario in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Using Asynchronous I/O</em></span>, where we will discuss a large set of asynchronous operations working with data inputs and outputs. Using the first approach whenever possible is the key to creating scalable server applications.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec53"></a>Handling exceptions in asynchronous operations</h2></div></div><hr /></div><p>This recipe will describe<a id="id226" class="indexterm"></a> how to deal with<a id="id227" class="indexterm"></a> exception handling using asynchronous functions in C#. You will learn how to work with aggregate exceptions in case you use <code class="literal">await</code> with multiple parallel asynchronous operations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec131"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec132"></a>How to do it...</h3></div></div></div><p>To understand handling exceptions in asynchronous operations, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task AsynchronousProcessing()
{
  WriteLine("1. Single exception");

  try
  {
    string result = await GetInfoAsync("Task 1", 2);
    WriteLine(result);
  }
  catch (Exception ex)
  {
    WriteLine($"Exception details: {ex}");
  }

  WriteLine();
  WriteLine("2. Multiple exceptions");

  Task&lt;string&gt; t1 = GetInfoAsync("Task 1", 3);
  Task&lt;string&gt; t2 = GetInfoAsync("Task 2", 2);
  try
  {
    string[] results = await Task.WhenAll(t1, t2);
    WriteLine(results.Length);
  }
  catch (Exception ex)
  {
    WriteLine($"Exception details: {ex}");
  }

  WriteLine();
  WriteLine("3. Multiple exceptions with AggregateException");

  t1 = GetInfoAsync("Task 1", 3);
  t2 = GetInfoAsync("Task 2", 2);
  Task&lt;string[]&gt; t3 = Task.WhenAll(t1, t2);
  try
  {
    string[] results = await t3;
    WriteLine(results.Length);
  }
  catch
  {
    var ae = t3.Exception.Flatten();
    var exceptions = ae.InnerExceptions;
    WriteLine($"Exceptions caught: {exceptions.Count}");
    foreach (var e in exceptions)
    {
      WriteLine($"Exception details: {e}");
      WriteLine();
    }
  }

  WriteLine();
      WriteLine("4. await in catch and finally blocks");

  try
  {
    string result = await GetInfoAsync("Task 1", 2);
    WriteLine(result);
  }
  catch (Exception ex)
  {
    await Task.Delay(TimeSpan.FromSeconds(1));
    WriteLine($"Catch block with await: Exception details: {ex}");
  }
  finally
  {
     await Task.Delay(TimeSpan.FromSeconds(1));
    WriteLine("Finally block");
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name, int seconds)
{
  await Task.Delay(TimeSpan.FromSeconds(seconds));
  throw new Exception($"Boom from {name}!");
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec133"></a>How it works...</h3></div></div></div><p>We run four scenarios<a id="id228" class="indexterm"></a> to illustrate the most common cases of error handling using <code class="literal">async</code> and <code class="literal">await</code> in C#. The first case is very simple and almost identical to the usual synchronous code. We just use the <code class="literal">try</code>/<code class="literal">catch</code> statement and get the exception's details.</p><p>A very common<a id="id229" class="indexterm"></a> mistake is using the same approach when more than one asynchronous operations are being awaited. If we use the <code class="literal">catch</code> block in the same way as we did before, we will get only the first exception from the underlying <code class="literal">AggregateException</code> object.</p><p>To collect all the information, we have to use the awaited tasks' <code class="literal">Exception</code> property. In the third scenario, we flatten the <code class="literal">AggregateException</code> hierarchy and then unwrap all the underlying exceptions from it using the <code class="literal">Flatten</code> method of <code class="literal">AggregateException</code>.</p><p>To illustrate C# 6.0 changes, we use <code class="literal">await</code> inside <code class="literal">catch</code> and <code class="literal">finally</code> blocks of the exception handling code. To verify that it was not possible to use <code class="literal">await</code> inside <code class="literal">catch</code> and <code class="literal">finally</code> blocks in the previous version of C#, you can compile it against C# 5.0 by specifying it in the project properties under the build section advanced settings.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec54"></a>Avoiding the use of the captured synchronization context</h2></div></div><hr /></div><p>This recipe<a id="id230" class="indexterm"></a> discusses the details of the synchronization context behavior when <code class="literal">await</code> is used to get asynchronous operation results. You will learn how and when to turn off the synchronization context flow.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec134"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec135"></a>How to do it...</h3></div></div></div><p>To understand the details of the synchronization context behavior when <code class="literal">await</code> is used and to learn how and when to turn off the synchronization context flow, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add references to the Windows Presentation Foundation Library by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right-click on the <span class="strong"><strong>References</strong></span> folder in the project, and select the <span class="strong"><strong>Add referenceâ€¦</strong></span> menu option.</p></li><li><p>Add references to these libraries: <span class="strong"><strong>PresentationCore</strong></span>, <span class="strong"><strong>PresentationFramework</strong></span>, <span class="strong"><strong>System.Xaml</strong></span>, and <span class="strong"><strong>WindowsBase</strong></span>. You can use the search function in the reference manager dialog as follows:</p></li></ol></div><div class="mediaobject"><img src="graphics/B05292_05_01.jpg" /></div></li><li><p>In the <code class="literal">Program.cs</code> file, add<a id="id231" class="indexterm"></a> the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">private static Label _label;

static async void Click(object sender, EventArgs e)
{
  _label.Content = new TextBlock {Text = "Calculating..."};
  TimeSpan resultWithContext = await Test();
  TimeSpan resultNoContext = await TestNoContext();
  //TimeSpan resultNoContext =
  //   await TestNoContext().ConfigureAwait(false);
  var sb = new StringBuilder();
  sb.AppendLine($"With the context: {resultWithContext}");
  sb.AppendLine($"Without the context: {resultNoContext}");
  sb.AppendLine("Ratio: " +
    $"{resultWithContext.TotalMilliseconds/resultNoContext.TotalMilliseconds:0.00}");
  _label.Content = new TextBlock {Text = sb.ToString()};
}

static async Task&lt;TimeSpan&gt; Test()
{
  const int iterationsNumber = 100000;
  var sw = new Stopwatch();
  sw.Start();
  for (int i = 0; i &lt; iterationsNumber; i++)
  {
    var t = Task.Run(() =&gt; { });
    await t;
  }
  sw.Stop();
  return sw.Elapsed;
}

static async Task&lt;TimeSpan&gt; TestNoContext()
{
  const int iterationsNumber = 100000;
  var sw = new Stopwatch();
  sw.Start();
  for (int i = 0; i &lt; iterationsNumber; i++)
  {
    var t = Task.Run(() =&gt; { });
    await t.ConfigureAwait(
      continueOnCapturedContext: false);
  }
  sw.Stop();
  return sw.Elapsed;
}</pre></div></li><li><p>Replace the <code class="literal">Main</code> method <a id="id232" class="indexterm"></a>with the following code snippet:</p><div class="informalexample"><pre class="programlisting">[STAThread]
static void Main(string[] args)
{
  var app = new Application();
  var win = new Window();
  var panel = new StackPanel();
  var button = new Button();
  _label = new Label();
  _label.FontSize = 32;
  _label.Height = 200;
  button.Height = 100;
  button.FontSize = 32;
  button.Content = new TextBlock {Text = "Start asynchronous operations"};
  button.Click += Click;
  panel.Children.Add(_label);
  panel.Children.Add(button);
  win.Content = panel;
  app.Run(win);

  ReadLine();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec136"></a>How it works...</h3></div></div></div><p>In this example, we studied one of the most important aspects of an asynchronous function's default <a id="id233" class="indexterm"></a>behavior. You already know about task schedulers and synchronization contexts from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Using the Task Parallel Library</em></span>. By default, the <code class="literal">await</code> operator tries to capture synchronization contexts and executes the preceding code on it. As we already know, this helps us write asynchronous code by working with user interface controls. In addition, deadlock situations, such as those that were described in the previous chapter, will not happen when using <code class="literal">await</code>, since we do not block the UI thread while waiting for the result.</p><p>This is reasonable, but let's see what can potentially happen. In this example, we create a Windows Presentation Foundation application programmatically and subscribe to its button-click event. When clicking on the button, we run two asynchronous operations. One of them uses a regular <code class="literal">await</code> operator, while the other uses the <code class="literal">ConfigureAwait</code> method with <code class="literal">false</code> as a parameter value. It explicitly instructs that we should not use captured synchronization contexts to run continuation code on it. Inside each operation, we measure the time they take to complete, and then, we display the respective time and ratios on the main screen.</p><p>As a result, we see that the regular <code class="literal">await</code> operator takes much more time to complete. This is because we post 100,000 continuation tasks on the UI thread, which uses its message loop to asynchronously work with those tasks. In this case, we do not need this code to run on the UI thread, since we do not access the UI components from the asynchronous operation; using <code class="literal">ConfigureAwait</code> with <code class="literal">false</code> will be a much more efficient solution.</p><p>There is one more thing worth noting. Try to run the program by just clicking on the button and waiting for the results. Now, do the same thing again, but this time, click on the button and try to drag the application window from side to side in a random manner. You will note that the code on the captured synchronization context becomes slower! This funny side effect perfectly illustrates how dangerous asynchronous programming is. It is very easy to experience a situation like this, and it would be almost impossible to debug it if you have never experienced such a behavior before.</p><p>To be fair, let's see the <a id="id234" class="indexterm"></a>opposite scenario. In the preceding code snippet, inside the <code class="literal">Click</code> method, uncomment the commented line and comment out the line immediately preceding it. When running the application, we will get a multithreaded control access exception because the code that sets the <code class="literal">Label</code> control text will not be posted on the captured context, but it will be executed on a thread pool worker thread instead.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec55"></a>Working around the async void method</h2></div></div><hr /></div><p>This recipe describes why <code class="literal">async void</code> methods are quite dangerous to use. You will learn in what <a id="id235" class="indexterm"></a>situations it is acceptable to use this method and what to use instead, when possible.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec137"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe7</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec138"></a>How to do it...</h3></div></div></div><p>To learn how to work with the <code class="literal">async void</code> method, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task AsyncTaskWithErrors()
{
  string result = await GetInfoAsync("AsyncTaskException", 2);
  WriteLine(result);
}

static async void AsyncVoidWithErrors()
{
  string result = await GetInfoAsync("AsyncVoidException", 2);
  WriteLine(result);
}

static async Task AsyncTask()
{
  string result = await GetInfoAsync("AsyncTask", 2);
  WriteLine(result);
}

static async void AsyncVoid()
{
  string result = await GetInfoAsync("AsyncVoid", 2);
  WriteLine(result);
}

static async Task&lt;string&gt; GetInfoAsync(string name, int seconds)
{
  await Task.Delay(TimeSpan.FromSeconds(seconds));
  if(name.Contains("Exception"))
    throw new Exception($"Boom from {name}!");
  return
  $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." +
  $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li><p>Add the<a id="id236" class="indexterm"></a> following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsyncTask();
t.Wait();

AsyncVoid();
Sleep(TimeSpan.FromSeconds(3));

t = AsyncTaskWithErrors();
while(!t.IsFaulted)
{
  Sleep(TimeSpan.FromSeconds(1));
}
WriteLine(t.Exception);

//try
//{
//  AsyncVoidWithErrors();
//  Thread.Sleep(TimeSpan.FromSeconds(3));
//}
//catch (Exception ex)
//{
//  Console.WriteLine(ex);
//}

int[] numbers = {1, 2, 3, 4, 5};
Array.ForEach(numbers, async number =&gt; {
  await Task.Delay(TimeSpan.FromSeconds(1));
  if (number == 3) throw new Exception("Boom!");
  WriteLine(number);
});

ReadLine();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec139"></a>How it works...</h3></div></div></div><p>When the program <a id="id237" class="indexterm"></a>starts, we start two asynchronous operations by calling the two methods, <code class="literal">AsyncTask</code> and <code class="literal">AsyncVoid</code>. The first method returns a <code class="literal">Task</code> object, while the other returns nothing since it is declared <code class="literal">async void</code>. They both return immediately since they are asynchronous, but then, the first one can be easily monitored with the returned task status or just by calling the <code class="literal">Wait</code> method on it. The only way to wait for the second method to complete is to literally wait for some time because we have not declared any object that we can use to monitor the state of the asynchronous operation. Of course, it is possible to use some kind of shared state variable and set it from the <code class="literal">async void</code> method while checking it from the <code class="literal">calling</code> method, but it is better to just return a <code class="literal">Task</code> object instead.</p><p>The most dangerous part is exception handling. In case of the <code class="literal">async void</code> method, an exception will be posted to a current synchronization context; in our case, a thread pool. An unhandled exception on a thread pool will terminate the whole process. It is possible to intercept unhandled exceptions using the <code class="literal">AppDomain.UnhandledException</code> event, but there is no way to recover the process from there. To experience this, we should uncomment the <code class="literal">try</code>/<code class="literal">catch</code> block inside the <code class="literal">Main</code> method and then run the program.</p><p>Another fact about using <code class="literal">async void</code> lambda expressions is that they are compatible with the <code class="literal">Action</code> type, which is widely used in the standard .NET Framework class library. It is very easy to forget about exception handling inside this lambda expression, which will crash the program again. To see an example of this, uncomment the second commented-out block inside the <code class="literal">Main</code> method.</p><p>I strongly recommend<a id="id238" class="indexterm"></a> using <code class="literal">async void</code> only in UI event handlers. In all other situations, use the methods that return <code class="literal">Task</code> instead.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec56"></a>Designing a custom awaitable type</h2></div></div><hr /></div><p>This recipe <a id="id239" class="indexterm"></a>shows you how to design a very basic awaitable type that is compatible with the <code class="literal">await</code> operator.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec140"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe8</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec141"></a>How to do it...</h3></div></div></div><p>To design a custom awaitable type, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task AsynchronousProcessing()
{
  var sync = new CustomAwaitable(true);
  string result = await sync;
  WriteLine(result);

  var async = new CustomAwaitable(false);
  result = await async;

  WriteLine(result);
}

class CustomAwaitable
{
  public CustomAwaitable(bool completeSynchronously)
  {
    _completeSynchronously = completeSynchronously;
  }

  public CustomAwaiter GetAwaiter()
  {
    return new CustomAwaiter(_completeSynchronously);
  }

  private readonly bool _completeSynchronously;
}

class CustomAwaiter : INotifyCompletion
{
  private string _result = "Completed synchronously";
  private readonly bool _completeSynchronously;

  public bool IsCompleted =&gt; _completeSynchronously;

  public CustomAwaiter(bool completeSynchronously)
  {
    _completeSynchronously = completeSynchronously;
  }

  public string GetResult()
  {
    return _result;
  }

  public void OnCompleted(Action continuation)
  {
    ThreadPool.QueueUserWorkItem( state =&gt; {
      Sleep(TimeSpan.FromSeconds(1));
      _result = GetInfo();
      continuation?.Invoke();
    });
  }

  private string GetInfo()
  {
    return
    $"Task is running on a thread id {CurrentThread.ManagedThreadId}." +
    $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec142"></a>How it works...</h3></div></div></div><p>To be compatible <a id="id240" class="indexterm"></a>with the <code class="literal">await</code> operator, a type should comply with a number of requirements that are stated in the C# language specification. If you have Visual Studio 2015 installed, you may find the specifications document inside the <code class="literal">C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC#\Specifications\1033</code> folder (assuming you have a 64-bit OS and used the default installation path).</p><p>In paragraph 7.7.7.1, we find a definition of awaitable expressions:</p><p><span class="emphasis"><em>The task of an </em></span><code class="literal">await</code><span class="emphasis"><em> expression is required to be awaitable. An expression </em></span><code class="literal">t</code><span class="emphasis"><em> is awaitable if one of the following holds:</em></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">t</code>
<span class="emphasis"><em> is of compile time type dynamic</em></span></p></li><li style="list-style-type: disc"><p><code class="literal">t</code>
<span class="emphasis"><em> has an accessible instance or extension method called </em></span><code class="literal">GetAwaiter</code><span class="emphasis"><em> with no parameters and no type parameters, and a return type </em></span><code class="literal">A</code><span class="emphasis"><em> for which all of the following hold:</em></span></p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p><code class="literal">A</code><span class="emphasis"><em> implements the interface </em></span><code class="literal">System.Runtime.CompilerServices.INotifyCompletion</code><span class="emphasis"><em> (hereafter known as </em></span><code class="literal">INotifyCompletion</code><span class="emphasis"><em> for brevity).</em></span></p></li><li><p><code class="literal">A</code><span class="emphasis"><em> has an accessible, readable instance property </em></span><code class="literal">IsCompleted</code><span class="emphasis"><em> of type </em></span><code class="literal">bool</code>.</p></li><li><p><code class="literal">A</code><span class="emphasis"><em> has an accessible instance method </em></span><code class="literal">GetResult</code><span class="emphasis"><em> with no parameters and no type parameters</em></span>.</p></li></ol></div></li></ul></div><p>This information is enough to get started. First, we define an awaitable type <code class="literal">CustomAwaitable</code> and implement the <code class="literal">GetAwaiter</code> method. This in turn returns an instance of the <code class="literal">CustomAwaiter</code> type. <code class="literal">CustomAwaiter</code> implements the <code class="literal">INotifyCompletion</code> interface, has the <code class="literal">IsCompleted</code> property of the type <code class="literal">bool</code>, and has the <code class="literal">GetResult</code> method, which returns a <code class="literal">string</code> type. Finally, we write a piece of code that creates two <code class="literal">CustomAwaitable</code> objects and awaits both of them.</p><p>Now, we should understand the way <code class="literal">await</code> expressions are evaluated. This time, the specifications have not been quoted to avoid unnecessary details. Basically, if the <code class="literal">IsCompleted</code> property returns <code class="literal">true</code>, we just call the <code class="literal">GetResult</code> method synchronously. This prevents us from allocating resources for asynchronous task execution if the operation has<a id="id241" class="indexterm"></a> already been completed. We cover this scenario by providing the <code class="literal">completeSynchronously</code> parameter to the constructor method of the <code class="literal">CustomAwaitable</code> object.</p><p>Otherwise, we register a callback action to the <code class="literal">OnCompleted</code> method of <code class="literal">CustomAwaiter</code> and start the asynchronous operation. When it gets completed, it calls the provided callback, which will get the result by calling the <code class="literal">GetResult</code> method on the <code class="literal">CustomAwaiter</code> object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>This implementation has been used for educational purposes only. Whenever you write asynchronous functions, the most natural approach is to use the standard <code class="literal">Task</code> type. You should define your own awaitable type only if you have a solid reason why you cannot use <code class="literal">Task</code> and you know exactly what you are doing.</p></div><p>There are many other topics related to designing custom awaitable types, such as the <code class="literal">ICriticalNotifyCompletion</code> interface implementation and synchronization context propagation. After understanding the basics of how an awaitable type is designed, you will be able to use the C# language specification and other information sources to find out the details you need with ease. But I would like to emphasize that you should just use the <code class="literal">Task</code> type, unless you have a really good reason not to.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec57"></a>Using the dynamic type with await</h2></div></div><hr /></div><p>This recipe <a id="id242" class="indexterm"></a>shows you how to design a very basic type that is <a id="id243" class="indexterm"></a>compatible with the <code class="literal">await</code> operator and the dynamic C# type.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec143"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. You will need Internet access to download the NuGet package. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe9</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec144"></a>How to do it...</h3></div></div></div><p>To learn how to<a id="id244" class="indexterm"></a> use the <code class="literal">dynamic</code> type with <code class="literal">await</code>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add references<a id="id245" class="indexterm"></a> to the <span class="strong"><strong>ImpromptuInterface</strong></span> NuGet package by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right-click on the <span class="strong"><strong>References</strong></span> folder in the project, and select the <span class="strong"><strong>Manage NuGet Packagesâ€¦</strong></span> menu option.</p></li><li><p>Now, add your preferred references to the <span class="strong"><strong>ImpromptuInterface NuGet</strong></span> package. You can use the search function in the <span class="strong"><strong>Manage NuGet Packages</strong></span> dialog as follows:</p></li></ol></div><div class="mediaobject"><img src="graphics/B05292_05_02.jpg" /></div></li><li><p>In the<a id="id246" class="indexterm"></a> <code class="literal">Program.cs</code> file, use the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Dynamic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using ImpromptuInterface;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the<a id="id247" class="indexterm"></a> following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task AsynchronousProcessing()
{
  string result = await GetDynamicAwaitableObject(true);
  WriteLine(result);

  result = await GetDynamicAwaitableObject(false);
  WriteLine(result);
}

static dynamic GetDynamicAwaitableObject(bool completeSynchronously)
{
  dynamic result = new ExpandoObject();
  dynamic awaiter = new ExpandoObject();

  awaiter.Message = "Completed synchronously";
  awaiter.IsCompleted = completeSynchronously;
  awaiter.GetResult = (Func&lt;string&gt;)(() =&gt; awaiter.Message);

  awaiter.OnCompleted = (Action&lt;Action&gt;) ( callback =&gt; 
    ThreadPool.QueueUserWorkItem(state =&gt; {
      Sleep(TimeSpan.FromSeconds(1));
      awaiter.Message = GetInfo();
      callback?.Invoke();
    })
  );

  IAwaiter&lt;string&gt; proxy = Impromptu.ActLike(awaiter);

  result.GetAwaiter = (Func&lt;dynamic&gt;) ( () =&gt; proxy );

  return result;
}

static string GetInfo()
{
  return
    $"Task is running on a thread id {CurrentThread.ManagedThreadId}." +
    $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li><p>Add the<a id="id248" class="indexterm"></a> following code below the <code class="literal">Program</code> class<a id="id249" class="indexterm"></a> definition:</p><div class="informalexample"><pre class="programlisting">public interface IAwaiter&lt;T&gt; : INotifyCompletion
{
    bool IsCompleted { get; }

    T GetResult();
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec145"></a>How it works...</h3></div></div></div><p>Here, we repeat the<a id="id250" class="indexterm"></a> trick from the previous recipe but this time, with the help of dynamic expressions. We can achieve this goal with the help of NuGetâ€”a package manager that contains many useful libraries. This time, we use a library that dynamically creates wrappers, implementing the interfaces we need.</p><p>To start with, we create two instances of the <code class="literal">ExpandoObject</code> type and assign them to dynamic local variables. These variables will be our <code class="literal">awaitable</code> and <code class="literal">awaiter</code> objects. Since an <code class="literal">awaitable</code> object just requires having the <code class="literal">GetAwaiter</code> method, there are no problems with providing it. <code class="literal">ExpandoObject</code> (combined with the <code class="literal">dynamic</code> keyword) allows us to customize<a id="id251" class="indexterm"></a> itself and add properties and methods by assigning corresponding values. It is in fact a dictionary-type collection with keys of the type <code class="literal">string</code> and values of the type <code class="literal">object</code>. If you are familiar with the JavaScript programming language, you might note that this is very similar to JavaScript objects.</p><p>Since <code class="literal">dynamic</code> allows us to skip compile-time checks in C#, <code class="literal">ExpandoObject</code> is written in such a way that if you assign something to a property, it creates a dictionary entry, where the key is the property name and a value is any value that is supplied. When you try to get the property value, it goes into the dictionary and provides the value that is stored in the corresponding dictionary entry. If the value is of the type <code class="literal">Action</code> or <code class="literal">Func</code>, we actually store a delegate, which in turn can be used like a method. Therefore, a combination of the <code class="literal">dynamic</code> type with <code class="literal">ExpandoObject</code> allows us to create an object and dynamically provide it with properties and methods.</p><p>Now, we need to construct our <code class="literal">awaiter</code> and <code class="literal">awaitable</code> objects. Let's start with <code class="literal">awaiter</code>. First, we provide a property called <code class="literal">Message</code> and an initial value to this property. Then, we define the <code class="literal">GetResult</code> method using a <code class="literal">Func&lt;string&gt;</code> type. We assign a lambda expression, which returns the <code class="literal">Message</code> property value. We then implement the <code class="literal">IsCompleted</code> property. If it is set to <code class="literal">true</code>, we can skip the rest of the work and proceed to our <code class="literal">awaitable</code> object that is stored in the <code class="literal">result</code> local variable. We just need to add a method returning the <code class="literal">dynamic</code> object and return our <code class="literal">awaiter</code> object from it. Then, we can use <code class="literal">result</code> as the <code class="literal">await</code> expression; however, it will run synchronously.</p><p>The main challenge is implementing asynchronous processing on our dynamic object. The C# language specifications state that an <code class="literal">awaiter</code> object must implement the <code class="literal">INotifyCompletion</code> or <code class="literal">ICriticalNotifyCompletion</code> interface, which <code class="literal">ExpandoObject</code> does not. And even when we implement the <code class="literal">OnCompleted</code> method dynamically, adding it to the <code class="literal">awaiter</code> object, we will not succeed because our object does not implement<a id="id252" class="indexterm"></a> either of the aforementioned interfaces.</p><p>To work around this<a id="id253" class="indexterm"></a> problem, we use the <code class="literal">ImpromptuInterface</code> library that we obtained from NuGet. It allows us to use the <code class="literal">Impromptu.ActLike</code> method to dynamically create proxy objects that will implement the required interface. If we try to create a proxy implementing the <code class="literal">INotifyCompletion</code> interface, we will still fail because the <code class="literal">proxy</code> object is not dynamic anymore, and this interface has the <code class="literal">OnCompleted</code> method only, but it does not have the <code class="literal">IsCompleted</code> property or the <code class="literal">GetResult</code> method. As the last workaround, we define a generic interface, <code class="literal">IAwaiter&lt;T&gt;</code>, which implements <code class="literal">INotifyCompletion</code> and adds all the required properties and methods. Now, we use it for proxy generation and change the <code class="literal">result</code> object to return a <code class="literal">proxy</code> instead of <code class="literal">awaiter</code> from the <code class="literal">GetAwaiter</code> method. The program now works; we just constructed an <code class="literal">awaitable</code> object that is completely dynamic at runtime.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch06"></a>ChapterÂ 6.Â Using Concurrent Collections</h2></div></div></div><p>In this chapter, we will look through the different data structures for concurrent programming included in the .NET Framework base class library. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using <code class="literal">ConcurrentDictionary</code></p></li><li style="list-style-type: disc"><p>Implementing asynchronous processing using <code class="literal">ConcurrentQueue</code></p></li><li style="list-style-type: disc"><p>Changing the asynchronous processing order with <code class="literal">ConcurrentStack</code></p></li><li style="list-style-type: disc"><p>Creating a scalable crawler with <code class="literal">ConcurrentBag</code></p></li><li style="list-style-type: disc"><p>Generalizing asynchronous processing with <code class="literal">BlockingCollection</code></p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec58"></a>Introduction</h2></div></div><hr /></div><p>Programming requires understanding and knowledge of basic data structures and algorithms. To choose the best-suited data structure for a concurrent situation, a programmer has to know about many things, such as algorithm time, space complexity, and the big O notation. In different, well-known scenarios, we always know which data structures are more efficient.</p><p>For concurrent computations, we need to have appropriate data structures. These data structures have to be scalable, avoid locks when possible, and at the same time provide thread-safe access. .NET Framework, since version 4, has the <code class="literal">System.Collections.Concurrent</code> namespace with several data structures in it. In this chapter, we will cover several data structures and show you very simple examples of how to use them.</p><p>Let's start with <code class="literal">ConcurrentQueue</code>. This collection<a id="id254" class="indexterm"></a> uses atomic <span class="strong"><strong>Compare and Swap</strong></span> (<span class="strong"><strong>CAS</strong></span>) operations, which allow us to safely exchange values of two variables, and <code class="literal">SpinWait</code> to ensure thread safety. It implements a <span class="strong"><strong>First In, First Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) collection, which <a id="id255" class="indexterm"></a>means that the items go out of the queue in the same order in which they were added to the queue. To add an item to a queue, you call the <code class="literal">Enqueue</code> method. The <code class="literal">TryDequeue</code> method tries to take the first item from the<a id="id256" class="indexterm"></a> queue, and the <code class="literal">TryPeek</code> method tries to get the <a id="id257" class="indexterm"></a>first item without<a id="id258" class="indexterm"></a> removing it from the queue.</p><p>The <code class="literal">ConcurrentStack</code> collection is also implemented without using any locks and only with CAS operations. This is<a id="id259" class="indexterm"></a> the <span class="strong"><strong>Last In, First Out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) collection, which means that the most recently added item will be returned first. To add items, you can use the <code class="literal">Push</code> and <code class="literal">PushRange</code> methods; to retrieve, you use <code class="literal">TryPop</code> and <code class="literal">TryPopRange</code>, and to inspect, you can use the <code class="literal">TryPeek</code> method.</p><p>The <code class="literal">ConcurrentBag</code> collection is an unordered collection that supports duplicate items. It is optimized for a scenario where multiple threads partition their work in such a way that each thread produces and consumes its own tasks, dealing with other threads' tasks very rarely (in which case, it uses locks). You add items to a bag using the <code class="literal">Add</code> method; you inspect with <code class="literal">TryPeek</code>, and take items from a bag with the <code class="literal">TryTake</code> method.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>Avoid using the <code class="literal">Count</code> property on the collections mentioned. They are implemented using linked lists, and therefore, <code class="literal">Count</code> is an <code class="literal">O(N)</code> operation. If you need to check whether the collection is empty, use the <code class="literal">IsEmpty</code> property, which is an <code class="literal">O(1)</code> operation.</p></div><p><code class="literal">ConcurrentDictionary</code> is a<a id="id260" class="indexterm"></a> thread-safe dictionary collection implementation. It is lock-free for read operations. However, it requires locking for write operations. The concurrent dictionary uses multiple locks, implementing a fine-grained locking model over the dictionary buckets. The number of locks could be defined using a constructor with the <code class="literal">concurrencyLevel</code> parameter, which means that an estimated number of threads will update the dictionary concurrently.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>Since a concurrent dictionary uses locking, there are a number of operations that require acquiring all the locks inside the dictionary. These operations are: <code class="literal">Count</code>, <code class="literal">IsEmpty</code>, <code class="literal">Keys</code>, <code class="literal">Values</code>, <code class="literal">CopyTo</code>, and <code class="literal">ToArray</code>. Avoid using these operations without need.</p></div><p><code class="literal">BlockingCollection</code> is an advanced wrapper over the <code class="literal">IProducerConsumerCollection</code> generic interface implementation. It has many features that <a id="id261" class="indexterm"></a>are more advanced and is very useful for implementing pipeline scenarios when you have some steps that use the results from processing the previous steps. The <code class="literal">BlockingCollection</code> class supports features such as blocking, bounding inner collections capacity, canceling collection operations, and retrieving values from multiple blocking collections.</p><p>The concurrent algorithms can be very complicated, and covering all the concurrent collectionsâ€”whether more or less advancedâ€”would require writing a separate book. Here, we illustrate only the simplest examples of using concurrent collections.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec59"></a>Using ConcurrentDictionary</h2></div></div><hr /></div><p>This recipe shows<a id="id262" class="indexterm"></a> you a very simple scenario, comparing the performance of a usual dictionary collection with the concurrent dictionary in a single-threaded environment.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec146"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter6\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec147"></a>How to do it...</h3></div></div></div><p>To understand the difference between the performance of a usual dictionary collection and the concurrent dictionary, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">const string Item = "Dictionary item";
const int Iterations = 1000000;
public static string CurrentItem;</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var concurrentDictionary = new ConcurrentDictionary&lt;int, string&gt;();
var dictionary = new Dictionary&lt;int, string&gt;();

var sw = new Stopwatch();

sw.Start();
for (int i = 0; i &lt; Iterations; i++)
{
  lock (dictionary)
  {
    dictionary[i] = Item;
  }
}
sw.Stop();
WriteLine($"Writing to dictionary with a lock: {sw.Elapsed}");

sw.Restart();
for (int i = 0; i &lt; Iterations; i++)
{
  concurrentDictionary[i] = Item;
}
sw.Stop();
WriteLine($"Writing to a concurrent dictionary: {sw.Elapsed}");

sw.Restart();
for (int i = 0; i &lt; Iterations; i++)
{
  lock (dictionary)
  {
    CurrentItem = dictionary[i];
  }
}
sw.Stop();
WriteLine($"Reading from dictionary with a lock: {sw.Elapsed}");

sw.Restart();
for (int i = 0; i &lt; Iterations; i++)
{
  CurrentItem = concurrentDictionary[i];
}
sw.Stop();
WriteLine($"Reading from a concurrent dictionary: {sw.Elapsed}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec148"></a>How it works...</h3></div></div></div><p>When the program<a id="id263" class="indexterm"></a> starts, we create two collections. One of them is a standard dictionary collection, and the other is a new concurrent dictionary. Then, we start adding to them, using a standard dictionary with a lock and measuring the time it takes for one million iterations to complete. Then, we measure the <code class="literal">ConcurrentDictionary</code> collection's performance in the same scenario, and we finally compare the performance of retrieving values from both collections.</p><p>In this very simple scenario, we find that <code class="literal">ConcurrentDictionary</code> is significantly slower on write operations than a usual dictionary with a lock but is faster on retrieval operations. Therefore, if we need many thread-safe reads from a dictionary, the <code class="literal">ConcurrentDictionary</code> collection is the best choice.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>If you need just read-only multithreaded access to the dictionary, it may not be necessary to perform thread-safe reads. In this scenario, it is much better to use just a regular dictionary or the <code class="literal">ReadOnlyDictionary</code> collections.</p></div><p>The <code class="literal">ConcurrentDictionary</code> collection is implemented using the <span class="strong"><strong>fine-grained locking</strong></span> technique, and<a id="id264" class="indexterm"></a> this allows it to scale better on multiple writes than using a regular dictionary with a lock (which is called <span class="strong"><strong>coarse-grained locking</strong></span>). As we saw in this example, when we <a id="id265" class="indexterm"></a>use just one thread, a concurrent dictionary is much slower, but when we scale<a id="id266" class="indexterm"></a> this up to five-six threads (if we have enough CPU cores that could run them simultaneously), the concurrent dictionary will actually perform better.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec60"></a>Implementing asynchronous processing using ConcurrentQueue</h2></div></div><hr /></div><p>This recipe will show<a id="id267" class="indexterm"></a> you an example <a id="id268" class="indexterm"></a>of creating a set of tasks to be processed asynchronously by multiple workers.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec149"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter6\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec150"></a>How to do it...</h3></div></div></div><p>To understand the working of creating a set of tasks to be processed asynchronously by multiple workers, perform the<a id="id269" class="indexterm"></a> following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the <a id="id270" class="indexterm"></a>following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task RunProgram()
{
  var taskQueue = new ConcurrentQueue&lt;CustomTask&gt;();
  var cts = new CancellationTokenSource();

  var taskSource = Task.Run(() =&gt; TaskProducer(taskQueue));

  Task[] processors = new Task[4];
  for (int i = 1; i &lt;= 4; i++)
  {
    string processorId = i.ToString();
    processors[i-1] = Task.Run(
      () =&gt; TaskProcessor(taskQueue, $"Processor {processorId}", cts.Token));
  }

  await taskSource;
  cts.CancelAfter(TimeSpan.FromSeconds(2));

  await Task.WhenAll(processors);
}

static async Task TaskProducer(ConcurrentQueue&lt;CustomTask&gt; queue)
{
  for (int i = 1; i &lt;= 20; i++)
  {
    await Task.Delay(50);
    var workItem = new CustomTask {Id = i};
    queue.Enqueue(workItem);
    WriteLine($"Task {workItem.Id} has been posted");
  }
}

static async Task TaskProcessor(
  ConcurrentQueue&lt;CustomTask&gt; queue, string name, CancellationToken token)
{
  CustomTask workItem;
  bool dequeueSuccesful = false;

  await GetRandomDelay();
  do
  {
    dequeueSuccesful = queue.TryDequeue(out workItem);
    if (dequeueSuccesful)
    {
      WriteLine($"Task {workItem.Id} has been processed by {name}");
    }

    await GetRandomDelay();
  }
  while (!token.IsCancellationRequested);
}

static Task GetRandomDelay()
{
  int delay = new Random(DateTime.Now.Millisecond).Next(1, 500);
  return Task.Delay(delay);
}

class CustomTask
{
  public int Id { get; set; }
}</pre></div></li><li><p>Add the <a id="id271" class="indexterm"></a>following code snippet<a id="id272" class="indexterm"></a> inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = RunProgram();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec151"></a>How it works...</h3></div></div></div><p>When the program<a id="id273" class="indexterm"></a> runs, we create a queue of tasks with an instance of the <code class="literal">ConcurrentQueue</code> collection. Then, we create a cancelation token, which will be used to stop work after we are done posting tasks to the queue. Next, we start a separate worker thread that will post tasks to the tasks queue. This part produces a workload for our asynchronous processing.</p><p>Now, let's define a task-consuming part of the program. We create four workers that will wait a random time, get a task from the task queue, process it, and repeat the whole process until we signal the cancelation token. Finally, we start the task-producing thread, wait for its completion, and then signal the consumers that we've finished work with the cancelation token. The last step will be to wait for all our consumers to complete, to finish processing all tasks.</p><p>We see that we have tasks being processed from start to end, but it is possible that a later task will be processed before an earlier one because we have four workers running independently and the task processing time is not constant. We see that the access to the queue is thread-safe; no work item was taken twice.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec61"></a>Changing asynchronous processing order with ConcurrentStack</h2></div></div><hr /></div><p>This recipe is a slight modification of the previous one. We will, once again, create a set of tasks to be <a id="id274" class="indexterm"></a>processed<a id="id275" class="indexterm"></a> asynchronously by multiple workers, but this time, we implement it with <code class="literal">ConcurrentStack</code> and see the differences.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec152"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter6\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec153"></a>How to do it...</h3></div></div></div><p>To understand the processing of a set of tasks implemented with <code class="literal">ConcurrentStack</code>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the<a id="id276" class="indexterm"></a> following code <a id="id277" class="indexterm"></a>snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task RunProgram()
{
  var taskStack = new ConcurrentStack&lt;CustomTask&gt;();
  var cts = new CancellationTokenSource();

  var taskSource = Task.Run(() =&gt; TaskProducer(taskStack));

  Task[] processors = new Task[4];
  for (int i = 1; i &lt;= 4; i++)
  {
    string processorId = i.ToString();
    processors[i - 1] = Task.Run(
      () =&gt; TaskProcessor(taskStack, $"Processor {processorId}", cts.Token));
  }

  await taskSource;
  cts.CancelAfter(TimeSpan.FromSeconds(2));

  await Task.WhenAll(processors);
}

static async Task TaskProducer(ConcurrentStack&lt;CustomTask&gt; stack)
{
  for (int i = 1; i &lt;= 20; i++)
  {
    await Task.Delay(50);
    var workItem = new CustomTask { Id = i };
    stack.Push(workItem);
    WriteLine($"Task {workItem.Id} has been posted");
  }
}

static async Task TaskProcessor(
  ConcurrentStack&lt;CustomTask&gt; stack, string name, CancellationToken token)
{
  await GetRandomDelay();
  do
  {
    CustomTask workItem;
    bool popSuccesful = stack.TryPop(out workItem);
    if (popSuccesful)
    {
      WriteLine($"Task {workItem.Id} has been processed by {name}");
    }

    await GetRandomDelay();
  }
  while (!token.IsCancellationRequested);
}

static Task GetRandomDelay()
{
  int delay = new Random(DateTime.Now.Millisecond).Next(1, 500);
  return Task.Delay(delay);
}

class CustomTask
{
  public int Id { get; set; }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Task t = RunProgram();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec154"></a>How it works...</h3></div></div></div><p>When the program runs, we now create an instance of the <code class="literal">ConcurrentStack</code> collection. The rest is almost like in the previous recipe, except instead of using the <code class="literal">Push</code> and <code class="literal">TryPop</code> methods<a id="id278" class="indexterm"></a> on the concurrent stack, we use <code class="literal">Enqueue</code> and <code class="literal">TryDequeue</code> on a concurrent queue.</p><p>We now see that the<a id="id279" class="indexterm"></a> task processing order has been changed. The stack is a LIFO collection, and workers process the latter tasks first. In case of a concurrent queue, tasks were processed in almost the same order in which they were added. This means that by depending on the number of workers, we will surely process the task that was created first in a given time frame. In the case of a stack, the tasks that were created earlier will have lower priority and may be not processed until a producer stops giving more tasks to the stack. This behavior is very specific and it is much better to use a queue in this scenario.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec62"></a>Creating a scalable crawler with ConcurrentBag</h2></div></div><hr /></div><p>This recipe shows you<a id="id280" class="indexterm"></a> how to scale workload <a id="id281" class="indexterm"></a>between a number of independent workers that both produce work and process it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec155"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter6\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec156"></a>How to do it...</h3></div></div></div><p>The following steps demonstrate how to scale workload between a number of independent workers that both produce work and process it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static Dictionary&lt;string, string[]&gt; _contentEmulation = new Dictionary&lt;string, string[]&gt;();

static async Task RunProgram()
{
  var bag = new ConcurrentBag&lt;CrawlingTask&gt;();

  string[] urls = {"http://microsoft.com/", "http://google.com/", "http://facebook.com/", "http://twitter.com/"};
    
  var crawlers = new Task[4];
  for (int i = 1; i &lt;= 4; i++)
  {
    string crawlerName = $"Crawler {i}";
    bag.Add(new CrawlingTask { UrlToCrawl = urls[i-1], ProducerName = "root"});
    crawlers[i - 1] = Task.Run(() =&gt; Crawl(bag, crawlerName));
  }

  await Task.WhenAll(crawlers);
}

static async Task Crawl(ConcurrentBag&lt;CrawlingTask&gt; bag, string crawlerName)
{
  CrawlingTask task;
  while (bag.TryTake(out task))
  {
    IEnumerable&lt;string&gt; urls = await GetLinksFromContent(task);
    if (urls != null)
    {
      foreach (var url in urls)
      {
        var t = new CrawlingTask
        {
          UrlToCrawl = url,
          ProducerName = crawlerName
        };

        bag.Add(t);
      }
    }
    WriteLine($"Indexing url {task.UrlToCrawl} posted by " +
       $"{task.ProducerName} is completed by {crawlerName}!");
  }
}

static async Task&lt;IEnumerable&lt;string&gt;&gt; GetLinksFromContent(CrawlingTask task)
{
  await GetRandomDelay();

  if (_contentEmulation.ContainsKey(task.UrlToCrawl)) return _contentEmulation[task.UrlToCrawl];

  return null;
}

static void CreateLinks()
{
  _contentEmulation["http://microsoft.com/"] = new [] { "http://microsoft.com/a.html", "http://microsoft.com/b.html" };
  _contentEmulation["http://microsoft.com/a.html"] = new[] { "http://microsoft.com/c.html", "http://microsoft.com/d.html" };
  _contentEmulation["http://microsoft.com/b.html"] = new[] { "http://microsoft.com/e.html" };

  _contentEmulation["http://google.com/"] = new[] { "http://google.com/a.html", "http://google.com/b.html" };
  _contentEmulation["http://google.com/a.html"] = new[] { "http://google.com/c.html", "http://google.com/d.html" };
  _contentEmulation["http://google.com/b.html"] = new[] { "http://google.com/e.html", "http://google.com/f.html" };
  _contentEmulation["http://google.com/c.html"] = new[] { "http://google.com/h.html", "http://google.com/i.html" };

  _contentEmulation["http://facebook.com/"] = new [] { "http://facebook.com/a.html", "http://facebook.com/b.html" };
  _contentEmulation["http://facebook.com/a.html"] = new[] { "http://facebook.com/c.html", "http://facebook.com/d.html" };
  _contentEmulation["http://facebook.com/b.html"] = new[] { "http://facebook.com/e.html" };

  _contentEmulation["http://twitter.com/"] = new[] { "http://twitter.com/a.html", "http://twitter.com/b.html" };
  _contentEmulation["http://twitter.com/a.html"] = new[] { "http://twitter.com/c.html", "http://twitter.com/d.html" };
  _contentEmulation["http://twitter.com/b.html"] = new[] { "http://twitter.com/e.html" };
  _contentEmulation["http://twitter.com/c.html"] = new[] { "http://twitter.com/f.html", "http://twitter.com/g.html" };
  _contentEmulation["http://twitter.com/d.html"] = new[] { "http://twitter.com/h.html" };
  _contentEmulation["http://twitter.com/e.html"] = new[] { "http://twitter.com/i.html" };
}

static Task GetRandomDelay()
{
  int delay = new Random(DateTime.Now.Millisecond).Next(150, 200);
  return Task.Delay(delay);
}

class CrawlingTask
{
  public string UrlToCrawl { get; set; }

  public string ProducerName { get; set; }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">CreateLinks();
Task t = RunProgram();
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec157"></a>How it works...</h3></div></div></div><p>The program simulates web page indexing with multiple web crawlers. A web crawler is a program that opens<a id="id282" class="indexterm"></a> a web page by its address, indexes the content, tries to visit all the links that this page contains, and indexes these<a id="id283" class="indexterm"></a> linked pages as well. At the beginning, we define a dictionary containing different web-page URLs. This dictionary simulates web pages containing links to other pages. The implementation is very naive; it does not care about indexing the already visited pages, but it is simple and allows us to focus on the concurrent workload.</p><p>Then, we create a concurrent bag, containing crawling tasks. We create four crawlers and provide a different site root URL to each of them. Then, we wait for all crawlers to compete. Now, each crawler starts to index the site URL it was given. We simulate the network I/O process by waiting for some random amount of time; then, if the page contains more URLs, the crawler posts more crawling tasks to the bag. Then, it checks whether there are any tasks left to crawl in the bag. If not, the crawler is complete.</p><p>If we check the output below the first four lines, which are root URLs, we will see that usually, which were root URLs, we will see that usually a task posted by the crawler number <span class="emphasis"><em>N</em></span> is processed by the same crawler. However, the later lines will be different. This happens because internally, <code class="literal">ConcurrentBag</code> is optimized for exactly this scenario where there are multiple threads that both add items and remove them. This is achieved by letting each thread work with its own local queue of items, and thus, we do not need any locks while this queue is occupied. Only when we have no items left in the local queue will we perform some locking and try to <span class="emphasis"><em>steal</em></span> the work from another thread's local queue. This behavior helps to distribute the work between all workers and avoid locking.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec63"></a>Generalizing asynchronous processing with BlockingCollection</h2></div></div><hr /></div><p>This recipe <a id="id284" class="indexterm"></a>will describe how to use <code class="literal">BlockingCollection</code> to simplify implementation of workload asynchronous<a id="id285" class="indexterm"></a> processing.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec158"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter6\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec159"></a>How to do it...</h3></div></div></div><p>To understand how <code class="literal">BlockingCollection</code> simplifies the implementation of workload asynchronous processing, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task RunProgram(IProducerConsumerCollection&lt;CustomTask&gt; collection = null)
{
  var taskCollection = new BlockingCollection&lt;CustomTask&gt;();
  if(collection != null)
    taskCollection= new BlockingCollection&lt;CustomTask&gt;(collection);

  var taskSource = Task.Run(() =&gt; TaskProducer(taskCollection));

  Task[] processors = new Task[4];
  for (int i = 1; i &lt;= 4; i++)
  {
    string processorId = $"Processor {i}";
    processors[i - 1] = Task.Run(
      () =&gt; TaskProcessor(taskCollection, processorId));
  }

  await taskSource;

  await Task.WhenAll(processors);
}

static async Task TaskProducer(BlockingCollection&lt;CustomTask&gt; collection)
{
  for (int i = 1; i &lt;= 20; i++)
  {
    await Task.Delay(20);
    var workItem = new CustomTask { Id = i };
    collection.Add(workItem);
    WriteLine($"Task {workItem.Id} has been posted");
  }
  collection.CompleteAdding();
}

static async Task TaskProcessor(
  BlockingCollection&lt;CustomTask&gt; collection, string name)
{
  await GetRandomDelay();
  foreach (CustomTask item in collection.GetConsumingEnumerable())
  {
    WriteLine($"Task {item.Id} has been processed by {name}");
    await GetRandomDelay();
  }
}

static Task GetRandomDelay()
{
  int delay = new Random(DateTime.Now.Millisecond).Next(1, 500);
  return Task.Delay(delay);
}

class CustomTask
{
  public int Id { get; set; }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Using a Queue inside of BlockingCollection");
WriteLine();
Task t = RunProgram();
t.Wait();

WriteLine();
WriteLine("Using a Stack inside of BlockingCollection");
WriteLine();
t = RunProgram(new ConcurrentStack&lt;CustomTask&gt;());
t.Wait();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec160"></a>How it works...</h3></div></div></div><p>Here, we take exactly the first scenario, but now, we use a <code class="literal">BlockingCollection</code> class that provides <a id="id286" class="indexterm"></a>many useful benefits. First of all, we are able to change the way the tasks are stored inside the blocking <a id="id287" class="indexterm"></a>collection. By default, it uses a <code class="literal">ConcurrentQueue</code> container, but we are able to use any collection that implements the <code class="literal">IProducerConsumerCollection</code> generic interface. To illustrate this, we run the program twice, using <code class="literal">ConcurrentStack</code> as the underlying collection the second time.</p><p>Workers get work items by iterating the <code class="literal">GetConsumingEnumerable</code> method call result on a blocking collection. If there are no items inside the collection, the iterator will just block the worker thread until an item is posted to the collection. The cycle ends when the producer calls the <code class="literal">CompleteAdding</code> method on the collection. It signals that the work is done.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>It is very easy to make a mistake and just iterate <code class="literal">BlockingCollection</code> as it implements <code class="literal">IEnumerable</code> itself. Do not forget to use <code class="literal">GetConsumingEnumerable</code>, or else, you will just iterate a "snapshot" of a collection and get completely unexpected program behavior.</p></div><p>The workload producer inserts the tasks into <code class="literal">BlockingCollection</code> and then calls the <code class="literal">CompleteAdding</code> method, which causes all the workers to get completed. Now, in the program output, we see two result sequences illustrating the difference between the concurrent queue and stack collections.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch07"></a>ChapterÂ 7.Â Using PLINQ</h2></div></div></div><p>In this chapter, we will review different parallel programming paradigms, such as task and data parallelism, and cover the basics of data parallelism and parallel LINQ queries. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using the <code class="literal">Parallel</code> class</p></li><li style="list-style-type: disc"><p>Parallelizing a LINQ query</p></li><li style="list-style-type: disc"><p>Tweaking the parameters of a PLINQ query</p></li><li style="list-style-type: disc"><p>Handling exceptions in a PLINQ query</p></li><li style="list-style-type: disc"><p>Managing data partitioning in a PLINQ query</p></li><li style="list-style-type: disc"><p>Creating a custom aggregator for a PLINQ query</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec64"></a>Introduction</h2></div></div><hr /></div><p>In .NET Framework, there is a subset of libraries that is called Parallel Framework, often referred to as <span class="strong"><strong>Parallel Framework Extensions</strong></span> (<span class="strong"><strong>PFX</strong></span>), which was the name of the very first version of these<a id="id288" class="indexterm"></a> libraries. Parallel Framework was released with .NET Framework 4.0 and consists of three major parts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The Task Parallel Library (TPL)</p></li><li style="list-style-type: disc"><p>Concurrent collections</p></li><li style="list-style-type: disc"><p>Parallel LINQ or PLINQ</p></li></ul></div><p>Until now, you have learned how to run several tasks in parallel and synchronize them with one another. In fact, we partitioned our program into a set of tasks and had different threads running different tasks. This<a id="id289" class="indexterm"></a> approach is called <span class="strong"><strong>task parallelism</strong></span>, and you have only been learning about task parallelism so far.</p><p>Imagine that we have a program that performs some heavy calculations over a big set of data. The easiest way to parallelize this program is to partition this set of data into smaller chunks, run the calculations needed over these chunks of data in parallel, and then aggregate the results of these<a id="id290" class="indexterm"></a> calculations. This programming model is called <span class="strong"><strong>data parallelism</strong></span>.</p><p>Task parallelism has the lowest abstraction level. We define a program as a combination of tasks, explicitly defining how they are combined. A program composed in this way could be very complex and detailed. Parallel operations are defined in different places in this program, and as it grows, the program becomes harder to understand and maintain. This way of making the program parallel is<a id="id291" class="indexterm"></a> called <span class="strong"><strong>unstructured parallelism</strong></span>. It is the price we have to pay if we have complex parallelization logic.</p><p>However, when we have simpler program logic, we can try to offload more parallelization details to the PFX libraries and the C# compiler. For example, we could say, "I would like to run those three methods in parallel, and I do not care how exactly this parallelization happens; let the .NET infrastructure decide the details". This raises the abstraction level as we do not have to provide a detailed description of how exactly we are parallelizing this. This approach<a id="id292" class="indexterm"></a> is referred to as <span class="strong"><strong>structured parallelism</strong></span> since the parallelization is usually a sort of declaration and each case of parallelization is defined in exactly one place in the program.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>There could be an impression that unstructured parallelism is bad practice and structured parallelism should be always used instead. I would like to emphasize that this is not true. Structured parallelism is indeed more maintainable, and preferred when possible, but it is a much less universal approach. In general, there are many situations when we simply are not able to use it, and it is perfectly OK to use TPL task parallelism in an unstructured manner.</p></div><p>TPL has a <code class="literal">Parallel</code> class, which provides APIs for structured parallelism. This is still a part of TPL, but we will review it in this chapter because it is a perfect example of transition from a lower abstraction level to a higher one. When we use the <code class="literal">Parallel</code> class APIs, we do not need to provide the details of how we partition our work. However, we still need to explicitly define how we make one single result from partitioned results.</p><p>PLINQ has the highest abstraction level. It automatically partitions data in to chunks and decides whether we really need to parallelize the query or whether it will be more effective to use usual sequential query processing. Then, the PLINQ infrastructure takes care of combining the partitioned results. There are many options that programmers may tweak to optimize the query and achieve the best possible performance and result.</p><p>In this chapter, we will cover the <code class="literal">Parallel</code> class API usage and many different PLINQ options, such as making a LINQ query parallel, setting up an execution mode and tweaking the parallelism degree of a PLINQ query, dealing with a query item order, and handling PLINQ exceptions. You will also learn how to manage data partitioning for PLINQ queries.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec65"></a>Using the Parallel class</h2></div></div><hr /></div><p>This recipe<a id="id293" class="indexterm"></a> shows you how to use the <code class="literal">Parallel</code> class APIs. You will learn how to invoke methods in parallel, how to perform parallel loops, and tweak parallelization mechanics.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec161"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec162"></a>How to do it...</h3></div></div></div><p>To invoke methods in parallel, perform parallel loops, and tweak parallelization mechanics using the <code class="literal">Parallel</code> class, perform the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static string EmulateProcessing(string taskName)
{
  Sleep(TimeSpan.FromMilliseconds(
    new Random(DateTime.Now.Millisecond).Next(250, 350)));
  WriteLine($"{taskName} task was processed on a " +
                  $"thread id {CurrentThread.ManagedThreadId}");
  return taskName;
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">Parallel.Invoke(
  () =&gt; EmulateProcessing("Task1"),
  () =&gt; EmulateProcessing("Task2"),
  () =&gt; EmulateProcessing("Task3")
);

var cts = new CancellationTokenSource();

var result = Parallel.ForEach(
  Enumerable.Range(1, 30),
  new ParallelOptions
  {
    CancellationToken = cts.Token,
    MaxDegreeOfParallelism = Environment.ProcessorCount,
    TaskScheduler = TaskScheduler.Default
  },
  (i, state) =&gt;
  {
    WriteLine(i);
    if (i == 20)
    {
      state.Break();
      WriteLine($"Loop is stopped: {state.IsStopped}");
    }
  });

WriteLine("---");
WriteLine($"IsCompleted: {result.IsCompleted}");
WriteLine($"Lowest break iteration: {result.LowestBreakIteration}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec163"></a>How it works...</h3></div></div></div><p>This program <a id="id294" class="indexterm"></a>demonstrates different features of the <code class="literal">Parallel</code> class. The <code class="literal">Invoke</code> method allows us to run several actions in parallel without much trouble as compared to defining tasks in TPL. The <code class="literal">Invoke</code> method blocks the other thread until all actions are complete, which is quite a common and convenient scenario.</p><p>The next feature is parallel loops, which are defined with the <code class="literal">For</code> and <code class="literal">ForEach</code> methods. We will look closely at <code class="literal">ForEach</code> since it is very similar to <code class="literal">For</code>. With the <code class="literal">ForEach</code> parallel loop, you can process any <code class="literal">IEnumerable</code> collection in parallel by applying an action delegate to each collection item. We are able to provide several options, customizing parallelization behavior, and get a result that shows whether the loop completed successfully.</p><p>To tweak our parallel loop, we provide an instance of the <code class="literal">ParallelOptions</code> class to the <code class="literal">ForEach</code> method. This allows us to cancel the loop with <code class="literal">CancellationToken</code>, restrict the maximum parallelism degree (how many maximum operations can be run in parallel), and provide a custom <code class="literal">TaskScheduler</code> class to schedule action tasks with it. Actions can accept an additional <code class="literal">ParallelLoopState</code> parameter, which is useful for breaking the loop or for checking what happens with the loop at this moment.</p><p>There are two ways of stopping the parallel loop with this state. We could use either the <code class="literal">Break</code> or <code class="literal">Stop</code> methods. The <code class="literal">Stop</code> method tells the loop to stop processing any more work and sets the <code class="literal">IsStopped</code> property of the parallel loop state to <code class="literal">true</code>. The <code class="literal">Break</code> method stops the<a id="id295" class="indexterm"></a> iterations after it, but the initial ones will continue to work. In that case, the <code class="literal">LowestBreakIteration</code> property of the loop result will contain the number of lowest loop iteration where the <code class="literal">Break</code> method was called.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec66"></a>Parallelizing a LINQ query</h2></div></div><hr /></div><p>This recipe will <a id="id296" class="indexterm"></a>describe how to use PLINQ to make a query parallel and how to go back from a parallel query to sequential processing.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec164"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec165"></a>How to do it...</h3></div></div></div><p>To use PLINQ in order to make a query parallel and to go back from a parallel query to sequential processing, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void PrintInfo(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was printed on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
}

static string EmulateProcessing(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was processed on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
  return typeName;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  return from assembly in AppDomain.CurrentDomain.GetAssemblies()
          from type in assembly.GetExportedTypes()
          where type.Name.StartsWith("Web")
          select type.Name;

}</pre></div></li><li><p>Add the<a id="id297" class="indexterm"></a> following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var sw = new Stopwatch();
sw.Start();
var query = from t in GetTypes()
  select EmulateProcessing(t);

foreach (string typeName in query)
{
  PrintInfo(typeName);
}
sw.Stop();
WriteLine("---");
WriteLine("Sequential LINQ query.");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();
sw.Reset();

sw.Start();
var parallelQuery = from t in GetTypes().AsParallel()
        select EmulateProcessing(t);

foreach (var typeName in parallelQuery)
{
  PrintInfo(typeName);
}
sw.Stop();
WriteLine("---");
WriteLine("Parallel LINQ query. The results are being merged on a single thread");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();
sw.Reset();

sw.Start();
parallelQuery = from t in GetTypes().AsParallel()
        select EmulateProcessing(t);

parallelQuery.ForAll(PrintInfo);

sw.Stop();
WriteLine("---");
WriteLine("Parallel LINQ query. The results are being processed in parallel");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();
sw.Reset();

sw.Start();
query = from t in GetTypes().AsParallel().AsSequential()
    select EmulateProcessing(t);

foreach (string typeName in query)
{
  PrintInfo(typeName);
}

sw.Stop();
WriteLine("---");
WriteLine("Parallel LINQ query, transformed into sequential.");
WriteLine($"Time elapsed: {sw.Elapsed}");
WriteLine("Press ENTER to continue....");
ReadLine();
Clear();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec166"></a>How it works...</h3></div></div></div><p>When the program runs, we create a LINQ query that uses the reflection API to get all types whose names start with <span class="emphasis"><em>Web</em></span> from the assemblies loaded in the current application domain. We emulate delays for processing each item and for printing it with the <code class="literal">EmulateProcessing</code> and <code class="literal">PrintInfo</code> methods. We also use the <code class="literal">Stopwatch</code> class to measure each query's execution time.</p><p>First, we run a <a id="id298" class="indexterm"></a>usual sequential LINQ query. There is no parallelization here, so everything runs on the current thread. The second version of the query uses the <code class="literal">ParallelEnumerable</code> class explicitly. <code class="literal">ParallelEnumerable</code> contains the PLINQ logic implementation and is organized as a number of extension methods to the <code class="literal">IEnumerable</code> collection's functionality. Normally, we do not use this class explicitly; we are using it here to illustrate how PLINQ actually works. The second version runs <code class="literal">EmulateProcessing</code> in parallel; however, by default, the results are merged on a single thread, so the query execution time should be a couple of seconds less than the first version.</p><p>The third version shows how to use the <code class="literal">AsParallel</code> method to run the LINQ query in parallel in a declarative manner. We do not care about implementation details here but just state that we want to run this in parallel. However, the key difference in this version is that we use the <code class="literal">ForAll</code> method to print out the query results. It runs the action to all items in the query on the same thread they were processed in, skipping the results-merging step. It allows us to run <code class="literal">PrintInfo</code> in parallel as well, and this version runs even faster than the previous one.</p><p>The last sample shows how to turn a PLINQ query back to sequential with the <code class="literal">AsSequential</code> method. We can see that this query runs exactly like the first one.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec67"></a>Tweaking the parameters of a PLINQ query</h2></div></div><hr /></div><p>This recipe<a id="id299" class="indexterm"></a> shows how we can manage parallel processing <a id="id300" class="indexterm"></a>options using a PLINQ query and what these options could affect during a query's execution.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec167"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec168"></a>How to do it...</h3></div></div></div><p>To understand how to manage parallel processing options using a PLINQ query and their effects, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the<a id="id301" class="indexterm"></a> following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static string EmulateProcessing(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(
    new Random(DateTime.Now.Millisecond).Next(250,350)));
  WriteLine($"{typeName} type was processed on a thread " +
    $"id {CurrentThread.ManagedThreadId}");
  return typeName;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  return from assembly in AppDomain.CurrentDomain.GetAssemblies()
    from type in assembly.GetExportedTypes()
    where type.Name.StartsWith("Web")
    orderby type.Name.Length
    select type.Name;
}</pre></div></li><li><p>Add the <a id="id302" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var parallelQuery = from t in GetTypes().AsParallel()
        select EmulateProcessing(t);

var cts = new CancellationTokenSource();
cts.CancelAfter(TimeSpan.FromSeconds(3));

try
{
  parallelQuery
    .WithDegreeOfParallelism(Environment.ProcessorCount)
    .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
    .WithMergeOptions(ParallelMergeOptions.Default)
    .WithCancellation(cts.Token)
    .ForAll(WriteLine);
}
catch (OperationCanceledException)
{
  WriteLine("---");
  WriteLine("Operation has been canceled!");
}

WriteLine("---");
WriteLine("Unordered PLINQ query execution");
var unorderedQuery = from i in ParallelEnumerable.Range(1, 30)
       select i;

foreach (var i in unorderedQuery)
{
  WriteLine(i);
}

WriteLine("---");
WriteLine("Ordered PLINQ query execution");
var orderedQuery = from i in ParallelEnumerable.Range(1, 30).AsOrdered()
     select i;

foreach (var i in orderedQuery)
{
  WriteLine(i);
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec169"></a>How it works...</h3></div></div></div><p>The program<a id="id303" class="indexterm"></a> demonstrates different useful PLINQ<a id="id304" class="indexterm"></a> options that programmers can use. We start with creating a PLINQ query, and then we create another query providing PLINQ tweaking.</p><p>Let's start with cancelation first. To be able to cancel a PLINQ query, there is a <code class="literal">WithCancellation</code> method that accepts a cancelation token object. Here, we signal the cancelation token after 3 seconds, which leads to <code class="literal">OperationCanceledException</code> in the query and cancelation of the rest of the work.</p><p>Then, we are able to specify a parallelism degree for the query. It is the exact number of parallel partitions that will be used to execute the query. In the first recipe, we used the <code class="literal">Parallel.ForEach</code> loop, which has the maximum parallelism degree option. It is different because it specifies a maximum partitions value, but there could be fewer partitions if the infrastructure decides that it is better to use less parallelism to save resources and achieve optimal performance.</p><p>Another interesting<a id="id305" class="indexterm"></a> option is overriding the query execution mode with the <a id="id306" class="indexterm"></a>
<code class="literal">WithExecutionMode</code> method. The PLINQ infrastructure can process some queries in sequential mode if it decides that parallelizing the query will only add more overhead and it actually will run slower. Using <code class="literal">WithExecutionMode</code>, we can force the query to run in parallel.</p><p>To tune up query<a id="id307" class="indexterm"></a> result processing, we have the <code class="literal">WithMergeOptions</code> method. The<a id="id308" class="indexterm"></a> default mode is used to buffer a number of results selected by the PLINQ infrastructure before returning them from the query. If the query takes a significant amount of time, it is more reasonable to turn off result buffering to get the results as soon as possible.</p><p>The last option is the <a id="id309" class="indexterm"></a>
<code class="literal">AsOrdered</code> method. It is possible that when we use parallel execution, the item order in the collection is not preserved. Later items in the collection could be processed before earlier ones. To prevent this, we need to call <code class="literal">AsOrdered</code> on a parallel query to explicitly tell the PLINQ infrastructure that we intend to preserve the item order for processing.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec68"></a>Handling exceptions in a PLINQ query</h2></div></div><hr /></div><p>This recipe will <a id="id310" class="indexterm"></a>describe how to handle exceptions in a PLINQ query.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec170"></a>Getting ready</h3></div></div></div><p>To work through this<a id="id311" class="indexterm"></a> recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec171"></a>How to do it...</h3></div></div></div><p>To understand how to handle exceptions in a PLINQ query, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using static System.Console;</pre></div></li><li><p>Add the<a id="id312" class="indexterm"></a> following code snippet inside the<a id="id313" class="indexterm"></a> <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">IEnumerable&lt;int&gt; numbers = Enumerable.Range(-5, 10);

var query = from number in numbers
    select 100 / number;

try
{
  foreach(var n in query)
    WriteLine(n);
}
catch (DivideByZeroException)
{
  WriteLine("Divided by zero!");
}

WriteLine("---");
WriteLine("Sequential LINQ query processing");
WriteLine();

var parallelQuery = from number in numbers.AsParallel()
        select 100 / number;

try
{
  parallelQuery.ForAll(WriteLine);
}
catch (DivideByZeroException)
{
  WriteLine("Divided by zero - usual exception handler!");
}
catch (AggregateException e)
{
  e.Flatten().Handle(ex =&gt;
  {
    if (ex is DivideByZeroException)
    {
      WriteLine("Divided by zero - aggregate exception handler!");
      return true;
    }
          
    return false;
  });
}

WriteLine("---");
WriteLine("Parallel LINQ query processing and results merging");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec172"></a>How it works...</h3></div></div></div><p>First, we run a usual LINQ query over a range of numbers from -5 to 4. When we divide by 0, we get <code class="literal">DivideByZeroException</code>, and we handle it as usual in a <code class="literal">try/catch</code> block.</p><p>However, when <a id="id314" class="indexterm"></a>we use <code class="literal">AsParallel</code>, we get <code class="literal">AggregateException</code> instead because we are now running in parallel, leveraging the task infrastructure behind the scenes. <code class="literal">AggregateException</code> will contain all the exceptions that<a id="id315" class="indexterm"></a> occurred while running the PLINQ query. To handle the inner <code class="literal">DivideByZeroException</code> class, we use the <code class="literal">Flatten</code> and <code class="literal">Handle</code> methods, which were explained in the <span class="emphasis"><em>Handling exceptions in asynchronous operations</em></span> recipe in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Using C# 6.0</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"></a>Note</h3><p>It is very easy to forget that when we handle aggregate exceptions, having more than one inner exception inside is a very common situation. If you forget to handle all of them, the exception will bubble up and the application will stop working.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec69"></a>Managing data partitioning in a PLINQ query</h2></div></div><hr /></div><p>This recipe <a id="id316" class="indexterm"></a>shows you how to create a very basic <a id="id317" class="indexterm"></a>custom partitioning strategy to parallelize a LINQ query in a specific way.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec173"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec174"></a>How to do it...</h3></div></div></div><p>To learn how to <a id="id318" class="indexterm"></a>create a very basic custom partitioning <a id="id319" class="indexterm"></a>strategy to parallelize a LINQ query, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static void PrintInfo(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was printed on a thread " +
$"id {CurrentThread.ManagedThreadId}");
}

static string EmulateProcessing(string typeName)
{
  Sleep(TimeSpan.FromMilliseconds(150));
  WriteLine($"{typeName} type was processed on a thread " +
  $"id { CurrentThread.ManagedThreadId}. Has " +
  $"{(typeName.Length % 2 == 0 ? "even" : "odd")} length.");

  return typeName;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  var types = AppDomain.CurrentDomain
    .GetAssemblies()
    .SelectMany(a =&gt; a.GetExportedTypes());

  return from type in types
    where type.Name.StartsWith("Web")
    select type.Name;
}

public class StringPartitioner : Partitioner&lt;string&gt;
{
  private readonly IEnumerable&lt;string&gt; _data;

  public StringPartitioner(IEnumerable&lt;string&gt; data)
  {
    _data = data;
  }

  public override bool SupportsDynamicPartitions =&gt; false;

  public override IList&lt;IEnumerator&lt;string&gt;&gt;GetPartitions(
int partitionCount)
  {
    var result = new List&lt;IEnumerator&lt;string&gt;&gt;(
partitionCount);

    for (int i = 1; i &lt;= partitionCount; i++)
    {
      result.Add(CreateEnumerator(i, partitionCount));
    }

    return result;
  }

  IEnumerator&lt;string&gt; CreateEnumerator(int partitionNumber, int partitionCount)
  {
    int evenPartitions = partitionCount / 2;
    bool isEven = partitionNumber % 2 == 0;
    int step = isEven ? evenPartitions : 
partitionCount - evenPartitions;

    int startIndex = partitionNumber / 2 +
    partitionNumber % 2;

    var q = _data
      .Where(v =&gt; !(v.Length % 2 == 0 ^ isEven)
|| partitionCount == 1)
      .Skip(startIndex - 1);

    return q
      .Where((x, i) =&gt; i % step == 0)
      .GetEnumerator();

  }
}</pre></div></li><li><p>Add the<a id="id320" class="indexterm"></a> following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var timer = Stopwatch.StartNew();
var partitioner = new StringPartitioner(GetTypes());
var parallelQuery = from t in partitioner.AsParallel()
//      .WithDegreeOfParallelism(1)
      select EmulateProcessing(t);

parallelQuery.ForAll(PrintInfo);
int count = parallelQuery.Count();
timer.Stop();
WriteLine(" ----------------------- ");
WriteLine($"Total items processed: {count}");
WriteLine($"Time elapsesd: {timer.Elapsed}");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec175"></a>How it works...</h3></div></div></div><p>To illustrate that we are able to choose custom partitioning strategies for the PLINQ query, we created a very simple partitioner that processes strings of odd and even lengths in parallel. To<a id="id321" class="indexterm"></a> achieve this, we derive our custom <code class="literal">StringPartitioner</code> class from a standard base class <code class="literal">Partitioner&lt;T&gt;</code> using <code class="literal">string</code> as a type parameter.</p><p>We declare that we only support static partitioning by overriding the <code class="literal">SupportsDynamicPartitions</code> property and setting it to <code class="literal">false</code>. This means that we predefine our partitioning strategy. This is an easy way to partition the initial collection but could be inefficient depending on what data we have inside the collection. For example, in our case, if we had many strings with odd lengths and only one string with even length, one of the threads would have finished early and would not have helped to process odd-length strings. On the other hand, dynamic partitioning means that we partition the initial collection on the fly, balancing the work load between the worker threads.</p><p>Then, we implement the <code class="literal">GetPartitions</code> method, where we define the following logic: if there is only one partition, we simply process everything on it. However, if we have more than one partition, then we process strings with odd length on odd partitions and even-length strings on even-numbered partitions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"></a>Note</h3><p>Please note that we need to create as many partitions as is stated in the <code class="literal">partitionCount</code> parameter, or else we will get the <code class="literal">Partitioner returned a wrong number of partitions</code> error.</p></div><p>Finally, we create an<a id="id322" class="indexterm"></a> instance of our partitioner and perform a PLINQ query with it. We can see that different threads process the odd-length and <a id="id323" class="indexterm"></a>even-length strings. Also, we can experiment with uncommenting the <code class="literal">WithDegreeOfParallelism</code> method and changing its parameter value. In the case of <code class="literal">1</code>, there will be a sequential work items processing, and when increasing the value, we can see that more work gets done in parallel.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec70"></a>Creating a custom aggregator for a PLINQ query</h2></div></div><hr /></div><p>This recipe<a id="id324" class="indexterm"></a> shows you how to create a custom aggregation<a id="id325" class="indexterm"></a> function for a PLINQ query.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec176"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter7\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec177"></a>How to do it...</h3></div></div></div><p>To understand the workings of a custom aggregation function for a PLINQ query, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the<a id="id326" class="indexterm"></a> following code snippet <a id="id327" class="indexterm"></a>below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static ConcurrentDictionary&lt;char, int&gt; AccumulateLettersInformation(
    ConcurrentDictionary&lt;char, int&gt; taskTotal , string item)
{
  foreach (var c in item)
  {
    if (taskTotal.ContainsKey(c))
    {
      taskTotal[c] = taskTotal[c] + 1;
    }
    else
    {
      taskTotal[c] = 1;
    }
  }
  WriteLine($"{item} type was aggregated on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
  return taskTotal;
}

static ConcurrentDictionary&lt;char, int&gt; MergeAccumulators(
    ConcurrentDictionary&lt;char, int&gt; total, ConcurrentDictionary&lt;char, int&gt; taskTotal)
{
  foreach (var key in taskTotal.Keys)
  {
    if (total.ContainsKey(key))
    {
      total[key] = total[key] + taskTotal[key];
    }
    else
    {
      total[key] = taskTotal[key];
    }
  }
  WriteLine("---");
  WriteLine($"Total aggregate value was calculated on a thread " +
          $"id {CurrentThread.ManagedThreadId}");
  return total;
}

static IEnumerable&lt;string&gt; GetTypes()
{
  var types = AppDomain.CurrentDomain
    .GetAssemblies()
    .SelectMany(a =&gt; a.GetExportedTypes());

  return from type in types
         where type.Name.StartsWith("Web")
         select type.Name;
}</pre></div></li><li><p>Add the<a id="id328" class="indexterm"></a> following code snippet inside<a id="id329" class="indexterm"></a> the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var parallelQuery = from t in GetTypes().AsParallel()
                    select t;

var parallelAggregator = parallelQuery.Aggregate(
  () =&gt; new ConcurrentDictionary&lt;char, int&gt;(),
  (taskTotal, item) =&gt; AccumulateLettersInformation(taskTotal, item), 
  (total, taskTotal) =&gt; MergeAccumulators(total, taskTotal),
  total =&gt; total);

WriteLine();
WriteLine("There were the following letters in type names:");
var orderedKeys = from k in parallelAggregator.Keys
          orderby parallelAggregator[k] descending
          select k;

foreach (var c in orderedKeys)
{
  WriteLine($"Letter '{c}' ---- {parallelAggregator[c]} times");
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec178"></a>How it works...</h3></div></div></div><p>Here, we implement custom aggregation mechanics that are able to work with the PLINQ queries. To implement this, we have to understand that since a query is being processed in parallel by several tasks simultaneously, we need to provide mechanics to aggregate each task's result in parallel and then combine those aggregated values into one single result value.</p><p>In this recipe, we wrote an aggregating function that counts letters in a PLINQ query, which returns the <code class="literal">IEnumerable&lt;string&gt;</code> collection. It counts all the letters in each collection item. To illustrate the parallel aggregation process, we print out information about which thread processes each part of the aggregation.</p><p>We aggregate the<a id="id330" class="indexterm"></a> PLINQ query results using the <code class="literal">Aggregate</code> extension method defined in the <code class="literal">ParallelEnumerable</code> class. It accepts four parameters, each of which is a function that performs different parts of the aggregation process. The first one is a factory that constructs the empty initial value of the aggregator. It is also called the seed value.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>Note that the first value provided to the <code class="literal">Aggregate</code> method is actually not an initial seed value for the aggregator function but a factory method that constructs this initial seed value. If you provide just an instance, it will be used in all partitions that run in parallel, which will lead to an incorrect result.</p></div><p>The second<a id="id331" class="indexterm"></a> function aggregates each collection item into the partition aggregation object. We implement this function with the <code class="literal">AccumulateLettersInformation</code> method. It iterates the string and counts the letters inside it. Here, the aggregation objects are different for each query partition running in parallel, which is why we called them <code class="literal">taskTotal</code>.</p><p>The third function is a higher level aggregation function that takes an aggregator object from a partition and merges it into a global aggregator object. We implement it with the <code class="literal">MergeAccumulators</code> method. The last function is a selector function that specifies what exact data we need from the global aggregator object.</p><p>Finally, we print out the aggregation result, ordering it by the letters used most often in the collection items.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch08"></a>ChapterÂ 8.Â Reactive Extensions</h2></div></div></div><p>In this chapter, we will look at another interesting .NET library that helps us create asynchronous<a id="id332" class="indexterm"></a> programs, <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>). We will cover the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Converting a collection to asynchronous <code class="literal">Observable</code></p></li><li style="list-style-type: disc"><p>Writing a custom <code class="literal">Observable</code></p></li><li style="list-style-type: disc"><p>Using the <code class="literal">Subject</code> type</p></li><li style="list-style-type: disc"><p>Creating an <code class="literal">Observable</code> object</p></li><li style="list-style-type: disc"><p>Using LINQ queries against an <code class="literal">Observable</code> collection</p></li><li style="list-style-type: disc"><p>Creating asynchronous operations with Rx</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec71"></a>Introduction</h2></div></div><hr /></div><p>As you have already learned, there are several approaches to creating asynchronous programs in .NET and C#. One of them is event-based asynchronous pattern, which has already been mentioned in the previous chapters. The initial goal of introducing events was to simplify the implementation of the <code class="literal">Observer</code> design pattern. This pattern is common for implementing notifications between objects.</p><p>When we discussed the Task Parallel Library, we noted that the event's main shortcoming was their inability to be effectively composed with each other. The other drawback was that the Event-based Asynchronous Pattern was not supposed to be used to deal with the sequence of notifications. Imagine that we have <code class="literal">IEnumerable&lt;string&gt;</code> that gives us string values. However, when we iterate it, we do not know how much time one iteration will take. It could be slow, and if we use the regular <code class="literal">foreach</code> loop or other synchronous iteration constructs, we will block our thread until we have the next value. This situation is called the <a id="id333" class="indexterm"></a>
<span class="strong"><strong>pull-based</strong></span> approach, when we as a client pull values from the producer.</p><p>The opposite approach is the <span class="strong"><strong>push-based</strong></span> approach, when the producer notifies the client about new values. This allows to offload work to the producer, while the client is free to do anything else in the<a id="id334" class="indexterm"></a> time it waits for another value. Therefore, the goal is to get something like the asynchronous version of <code class="literal">IEnumerable</code>, which produces a sequence of values and notifies the consumer about each item in the sequence, when the sequence is complete or when an exception is thrown.</p><p>.NET Framework starting from version 4.0 contains the definition of the <code class="literal">IObservable&lt;out T&gt;</code> and <code class="literal">IObserver&lt;in T&gt;</code> interfaces that together represent the asynchronous push-based collection and its client. They come from the library called Reactive Extensions (or simply Rx) that was created inside Microsoft to help us effectively compose the sequence of events and all other types of asynchronous programs using observable collections. The interfaces were included in .NET Framework, but their implementations and all other mechanics are still distributed separately in the Rx library.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>Rx globally is<a id="id335" class="indexterm"></a> a cross-platform library. There are libraries for .NET 3.5, Silverlight, and Windows Phone. It is also available in JavaScript, Ruby, and Python. It is also open source; you can find Reactive Extensions' source code for .NET on the CodePlex website and other implementations on GitHub.</p></div><p>The most amazing thing is that the observable collections are compatible with LINQ, and therefore, we are able to use declarative queries to transform and compose those collections in an asynchronous manner. This also makes it possible for us to use the extension methods to add functionalities to the Rx programs in the same way it is used in the usual LINQ providers. Reactive Extensions also supports transition from all asynchronous programming patterns (including the Asynchronous Programming Model, the Event-based Asynchronous Pattern, and the Task Parallel Library) to observable collections, and it supports its own way of running asynchronous operations, which is still quite similar to TPL.</p><p>The Reactive Extensions library is a very powerful and complex instrument, which is worthy of writing a separate book. In this chapter, I would like to review the most useful scenario, that is, how to work with asynchronous event sequences effectively. We will observe key types of the Reactive Extensions framework, learn to create sequences and manipulate them in different ways, and finally, check how we could use Reactive Extensions to run asynchronous operations and manage their options.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec72"></a>Converting a collection to an asynchronous Observable</h2></div></div><hr /></div><p>This recipe walks<a id="id336" class="indexterm"></a> you through the<a id="id337" class="indexterm"></a> process of creating an observable collection from an <code class="literal">Enumerable</code> class and how to process it asynchronously.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec179"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec180"></a>How to do it...</h3></div></div></div><p>To understand how to create an observable collection from an <code class="literal">Enumerable</code> class and process it asynchronously, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right-click on the <span class="strong"><strong>References</strong></span> folder in the project, and select the <span class="strong"><strong>Manage NuGet Packagesâ€¦</strong></span> menu option.</p></li><li><p>Now, add the <span class="strong"><strong>Reactive Extensions - Main Library</strong></span> NuGet package. You can search for <span class="strong"><strong>rx-main</strong></span> in the <span class="strong"><strong>Manage NuGet Packages</strong></span> dialog, as shown in the following screenshot:</p></li></ol></div><div class="mediaobject"><img src="graphics/B05292_08_01.jpg" /></div></li><li><p>In the <a id="id338" class="indexterm"></a>
<code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Reactive.Concurrency;
using System.Reactive.Linq;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the<a id="id339" class="indexterm"></a> following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static IEnumerable&lt;int&gt; EnumerableEventSequence()
{
  for (int i = 0; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(0.5));
    yield return i;
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">foreach (int i in EnumerableEventSequence())
{
  Write(i);
}

WriteLine();
WriteLine("IEnumerable");

IObservable&lt;int&gt; o = EnumerableEventSequence().().ToObservable();
using (IDisposable subscription = o.Subscribe(Write))
{
  WriteLine();
  WriteLine("IObservable");
}

o = EnumerableEventSequence().ToObservable()
    .SubscribeOn(TaskPoolScheduler.Default);
using (IDisposable subscription = o.Subscribe(Write))
{
  WriteLine();
  WriteLine("IObservable async");
  ReadLine();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec181"></a>How it works...</h3></div></div></div><p>Here, we<a id="id340" class="indexterm"></a> simulate a slow enumerable collection<a id="id341" class="indexterm"></a> with the <code class="literal">EnumerableEventSequence</code> method. Then, we iterate it with the usual <code class="literal">foreach</code> cycle, and we can see that it is actually slow; we wait for each iteration to complete.</p><p>We then convert this enumerable collection to Observable with the help of the <code class="literal">ToObservable</code> extension method from the Reactive Extensions library. Next, we subscribe to the updates of this observable collection, providing the <code class="literal">Console.Write</code> method as the action, which will be executed on each update of the collection. As a result, we get exactly the same behavior as before; we wait for each iteration to complete because we use the main thread to subscribe to the updates.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>We wrap the subscription objects into using statements. Although it is not always necessary, disposing off the subscriptions is a good practice that will help you avoid lifetime-related bugs.</p></div><p>To make the program asynchronous, we use the <code class="literal">SubscribeOn</code> method, providing it with the TPL task pool scheduler. This scheduler will place the subscription to the TPL task pool, offloading<a id="id342" class="indexterm"></a> the work from the main thread. This allows us to keep the UI responsive and do something else while the collection<a id="id343" class="indexterm"></a> gets updated. To check this behavior, you could remove the last <code class="literal">Console.ReadLine</code> call from the code. When doing so, we finish our main thread immediately, which forces all background threads (including the TPL task pool worker threads) to end as well, and we will get no output from the asynchronous collection.</p><p>If we are using a UI framework, we have to interact with the UI controls only from within the UI thread. To achieve this, we should use the <code class="literal">ObserveOn</code> method with the corresponding scheduler. For Windows Presentation Foundation, we have the <code class="literal">DispatcherScheduler</code> class and the <code class="literal">ObserveOnDispatcher</code> extension method defined in a separate NuGet package named Rx-XAML or Reactive Extensions XAML support library. For other platforms, there are corresponding separate NuGet packages as well.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec73"></a>Writing custom Observable</h2></div></div><hr /></div><p>This recipe<a id="id344" class="indexterm"></a> will describe how to implement the <code class="literal">IObservable&lt;in T&gt;</code> and <code class="literal">IObserver&lt;out T&gt;</code> interfaces to get the custom Observable sequence and properly consume it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec182"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec183"></a>How to do it...</h3></div></div></div><p>To understand how to implement the <code class="literal">IObservable&lt;in T&gt;</code> and <code class="literal">IObserver&lt;out T&gt;</code> interfaces to get the custom Observable sequence and consume it, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for more details on how to do this.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Reactive.Concurrency;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the<a id="id345" class="indexterm"></a> following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">class CustomObserver : IObserver&lt;int&gt;
{
  public void OnNext(int value)
  {
    WriteLine($"Next value: {value}; Thread Id: {CurrentThread.ManagedThreadId}");
  }

  public void OnError(Exception error)
  {
    WriteLine($"Error: {error.Message}");
  }

  public void OnCompleted()
  {
    WriteLine("Completed");
  }
}

class CustomSequence : IObservable&lt;int&gt;
{
  private readonly IEnumerable&lt;int&gt; _numbers;
 
  public CustomSequence(IEnumerable&lt;int&gt; numbers)
  {
    _numbers = numbers;
  }
  public IDisposable Subscribe(IObserver&lt;int&gt; observer)
  {
    foreach (var number in _numbers)
    {
      observer.OnNext(number);
    }
    observer.OnCompleted();
    return Disposable.Empty;
  }
}</pre></div></li><li><p>Add the<a id="id346" class="indexterm"></a> following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var observer = new CustomObserver();

var goodObservable = new CustomSequence(new[] {1, 2, 3, 4, 5});
var badObservable = new CustomSequence(null);

using (IDisposable subscription = goodObservable.Subscribe(observer))
{
}

using (IDisposable subscription = goodObservable
    .SubscribeOn(TaskPoolScheduler.Default).Subscribe(observer))
{
  Sleep(TimeSpan.FromMilliseconds(100));
  WriteLine("Press ENTER to continue");
  ReadLine();
}

using (IDisposable subscription = badObservable
    .SubscribeOn(TaskPoolScheduler.Default).Subscribe(observer))
{
  Sleep(TimeSpan.FromMilliseconds(100));
  WriteLine("Press ENTER to continue");
  ReadLine();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec184"></a>How it works...</h3></div></div></div><p>Here, we implement our observer first by simply printing out to the console the information about the next item from the observable collection, error, or sequence completion. This is a very simple consumer code and there is nothing special about it.</p><p>The interesting<a id="id347" class="indexterm"></a> part is our observable collection implementation. We accept an enumeration of numbers into a constructor and do not check it for null on purpose. When we have a subscribing observer, we iterate this collection and notify the observer about each item in the enumeration.</p><p>Then, we demonstrate the actual subscription. As we can see, the asynchrony is achieved by calling the <code class="literal">SubscribeOn</code> method, which is an extension method to <code class="literal">IObservable</code> and contains asynchronous subscription logic. We do not care about asynchrony in our observable collection; we use standard implementation from the Reactive Extensions library.</p><p>When we subscribe to the normal observable collection, we just get all the items from it. It is now asynchronous, so we need to wait for some time for the asynchronous operation to complete and only then print the message and wait for the user input.</p><p>Finally, we try to subscribe to the next observable collection, where we are iterating a null enumeration and therefore getting a null reference exception. We see that the exception has been properly handled and the <code class="literal">OnError</code> method was executed to print out the error details.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec74"></a>Using the Subject type family</h2></div></div><hr /></div><p>This recipe<a id="id348" class="indexterm"></a> shows you how to use the <code class="literal">Subject</code> type family from the Reactive Extensions library.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec185"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec186"></a>How to do it...</h3></div></div></div><p>To understand the use of the <code class="literal">Subject</code> type family from the Reactive Extensions library, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for details on how to do this.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Reactive.Subjects;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine($"{obj}")
    , ex =&gt; WriteLine($"Error: {ex.Message}")
    , () =&gt; WriteLine("Completed")
  );
}</pre></div></li><li><p>Add the<a id="id349" class="indexterm"></a> following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">WriteLine("Subject");
var subject = new Subject&lt;string&gt;();

subject.OnNext("A");
using (var subscription = OutputToConsole(subject))
{
  subject.OnNext("B");
  subject.OnNext("C");
  subject.OnNext("D");
  subject.OnCompleted();
  subject.OnNext("Will not be printed out");
}

WriteLine("ReplaySubject");
var replaySubject = new ReplaySubject&lt;string&gt;();

replaySubject.OnNext("A");
using (var subscription = OutputToConsole(replaySubject))
{
  replaySubject.OnNext("B");
  replaySubject.OnNext("C");
  replaySubject.OnNext("D");
  replaySubject.OnCompleted();
}

WriteLine("Buffered ReplaySubject");
var bufferedSubject = new ReplaySubject&lt;string&gt;(2);

bufferedSubject.OnNext("A");
bufferedSubject.OnNext("B");
bufferedSubject.OnNext("C");
using (var subscription = OutputToConsole(bufferedSubject))
{
  bufferedSubject.OnNext("D");
  bufferedSubject.OnCompleted();
}

WriteLine("Time window ReplaySubject");
var timeSubject = new ReplaySubject&lt;string&gt;(TimeSpan.FromMilliseconds(200));

timeSubject.OnNext("A");
Sleep(TimeSpan.FromMilliseconds(100));
timeSubject.OnNext("B");
Sleep(TimeSpan.FromMilliseconds(100));
timeSubject.OnNext("C");
Sleep(TimeSpan.FromMilliseconds(100));
using (var subscription = OutputToConsole(timeSubject))
{
  Sleep(TimeSpan.FromMilliseconds(300));
  timeSubject.OnNext("D");
  timeSubject.OnCompleted();
}

WriteLine("AsyncSubject");
var asyncSubject = new AsyncSubject&lt;string&gt;();

asyncSubject.OnNext("A");
using (var subscription = OutputToConsole(asyncSubject))
{
  asyncSubject.OnNext("B");
  asyncSubject.OnNext("C");
  asyncSubject.OnNext("D");
  asyncSubject.OnCompleted();
}

WriteLine("BehaviorSubject");
var behaviorSubject = new BehaviorSubject&lt;string&gt;("Default");
using (var subscription = OutputToConsole(behaviorSubject))
{
  behaviorSubject.OnNext("B");
  behaviorSubject.OnNext("C");
  behaviorSubject.OnNext("D");
  behaviorSubject.OnCompleted();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec187"></a>How it works...</h3></div></div></div><p>In this program, we look through different variants of the <code class="literal">Subject</code> type family. The <code class="literal">Subject</code> type represents both the <code class="literal">IObservable</code> and <code class="literal">IObserver</code> implementations. This is useful in <a id="id350" class="indexterm"></a>different proxy scenarios when we want to translate events from multiple sources to one stream, or vice versa, to broadcast an event sequence to multiple subscribers. Subjects are also very convenient for experimenting with Reactive Extensions.</p><p>Let's start with the basic <code class="literal">Subject</code> type. It retranslates an event sequence to subscribers as soon as they subscribe to it. In our case, the <code class="literal">A</code> string will not be printed out because the subscription happened after it was transmitted. Besides that, when we call the <code class="literal">OnCompleted</code> or <code class="literal">OnError</code> methods on <code class="literal">Observable</code>, it stops further translation of the event sequence, so the last string will also not be printed out.</p><p>The next type, <code class="literal">ReplaySubject</code>, is quite flexible and allows us to implement three additional scenarios. First, it can cache all the events from the beginning of their broadcasting, and if we subscribe later, we will get all the preceding events first. This behavior is illustrated in the second example. Here, we will have all four strings on the console because the first event will be cached and translated to the latter subscriber.</p><p>Then, we can specify the buffer size and the time window size for <code class="literal">ReplaySubject</code>. In the next example, we set the subject to have a buffer for two events. If more events are broadcasted, only the last two will be retranslated to the subscriber. So here, we will not see the first string because we have <code class="literal">B</code> and <code class="literal">C</code> in the subject buffer when subscribing to it. The same is the case with a time window. We can specify that the <code class="literal">Subject</code> type only caches events that took place less than a certain time ago, discarding the older ones. Therefore, in the fourth example, we will only see the last two events; the older events do not fit into the time window.</p><p>The <code class="literal">AsyncSubject</code> type is something like a <code class="literal">Task</code> type from the TPL globally. It represents a single asynchronous operation. If there are several events published, it waits for the event sequence completion and provides only the last event to the subscriber.</p><p>The <code class="literal">BehaviorSubject</code> type is quite similar to the <code class="literal">ReplaySubject</code> type, but it caches only one value and allows us to specify a default value in case we did not send any notifications. In our last example, we will see all the strings printed out because we provided a<a id="id351" class="indexterm"></a> default value, and all other events take place after the subscription. If we move the <code class="literal">behaviorSubject.OnNext("B");</code> line upwards below the <code class="literal">Default</code> event, it will replace the default value in the output.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec75"></a>Creating an Observable object</h2></div></div><hr /></div><p>This recipe will <a id="id352" class="indexterm"></a>describe different ways to create an <code class="literal">Observable</code> object.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec188"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe could be found at <code class="literal">BookSamples\Chapter8\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec189"></a>How to do it...</h3></div></div></div><p>To understand different ways of creating an <code class="literal">Observable</code> object, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous Observable</em></span> recipe for details on how to do this.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine("{0}", obj)
    , ex =&gt; WriteLine("Error: {0}", ex.Message)
    , () =&gt; WriteLine("Completed")
  );
}</pre></div></li><li><p>Add the <a id="id353" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">IObservable&lt;int&gt; o = Observable.Return(0);
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");
  
o = Observable.Empty&lt;int&gt;();
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

o = Observable.Throw&lt;int&gt;(new Exception());
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

o = Observable.Repeat(42);
using (var sub = OutputToConsole(o.Take(5)));
WriteLine(" ---------------- ");

o = Observable.Range(0, 10);
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

o = Observable.Create&lt;int&gt;(ob =&gt; {
  for (int i = 0; i &lt; 10; i++)
  {
    ob.OnNext(i);
  }
  return Disposable.Empty;
});
using (var sub = OutputToConsole(o)) ;
WriteLine(" ---------------- ");

o = Observable.Generate(
  0 // initial state
  , i =&gt; i &lt; 5 // while this is true we continue the sequence
  , i =&gt; ++i // iteration
  , i =&gt; i*2 // selecting result
);
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

IObservable&lt;long&gt; ol = Observable.Interval(TimeSpan.FromSeconds(1));
using (var sub = OutputToConsole(ol))
{
  Sleep(TimeSpan.FromSeconds(3));
};
WriteLine(" ---------------- ");

ol = Observable.Timer(DateTimeOffset.Now.AddSeconds(2));
using (var sub = OutputToConsole(ol))
{
  Sleep(TimeSpan.FromSeconds(3));
};
WriteLine(" ---------------- ");</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec190"></a>How it works...</h3></div></div></div><p>Here, we walk<a id="id354" class="indexterm"></a> through different scenarios of creating <code class="literal">observable</code> objects. Most of this functionality is provided as static factory methods of the <code class="literal">Observable</code> type. The first two samples show how we can create an <code class="literal">Observable</code> method that produces a single value and one that produces no value. In the next example, we use <code class="literal">Observable.Throw</code> to construct an <code class="literal">Observable</code> class that triggers the <code class="literal">OnError</code> handler of its observers.</p><p>The <code class="literal">Observable.Repeat</code> method represents an endless sequence. There are different overloads of this method; here, we construct an endless sequence by repeating 42 values. Then, we use LINQ's <code class="literal">Take</code> method to take five elements from this sequence. <code class="literal">Observable.Range</code> represents a range of values, pretty much like <code class="literal">Enumerable.Range</code>.</p><p>The <code class="literal">Observable.Create</code> method supports more custom scenarios. There are a lot of overloads that allow us to use cancellation tokens and tasks, but let's look at the simplest one. It accepts a function, which accepts an instance of observer and returns an <code class="literal">IDisposable</code> object representing a subscription. If we had any resources to clean up, we would be able to provide the cleanup logic here, but we just return an empty disposable as we actually do not need it.</p><p>The <code class="literal">Observable.Generate</code> method is another way to create a custom sequence. We must provide an initial value for a sequence and then a predicate that determines whether we should generate more items or complete the sequence. Then, we provide an iteration logic, which increments a counter in our case. The last parameter is a selector function that allows us to customize the results.</p><p>The last two methods deal with timers. <code class="literal">Observable.Interval</code> starts producing timer tick events with the<a id="id355" class="indexterm"></a> <code class="literal">TimeSpan</code> period, and <code class="literal">Observable.Timer</code> specifies the startup time as well.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec76"></a>Using LINQ queries against an observable collection</h2></div></div><hr /></div><p>This recipe shows<a id="id356" class="indexterm"></a> you how to use LINQ to query an<a id="id357" class="indexterm"></a> asynchronous sequence of events.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec191"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec192"></a>How to do it...</h3></div></div></div><p>To understand the use of LINQ queries against the observable collection, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for details on how to do this.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Reactive.Linq;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence, int innerLevel)
{
  string delimiter = innerLevel == 0 
        ? string.Empty 
        : new string('-', innerLevel*3);

  return sequence.Subscribe(
    obj =&gt; WriteLine($"{delimiter}{obj}")
    , ex =&gt; WriteLine($"Error: {ex.Message}")
    , () =&gt; WriteLine($"{delimiter}Completed")
  );
}</pre></div></li><li><p>Add the <a id="id358" class="indexterm"></a>following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">IObservable&lt;long&gt; sequence = Observable.Interval(
    TimeSpan.FromMilliseconds(50)).Take(21);

var evenNumbers = from n in sequence
        where n % 2 == 0
        select n;

var oddNumbers = from n in sequence
        where n % 2 != 0
        select n;

var combine = from n in evenNumbers.Concat(oddNumbers)
      select n;

var nums = (from n in combine
      where n % 5 == 0
      select n)
    .Do(n =&gt; WriteLine($"------Number {n} is processed in Do method"));

using (var sub = OutputToConsole(sequence, 0))
using (var sub2 = OutputToConsole(combine, 1))
using (var sub3 = OutputToConsole(nums, 2))
{
  WriteLine("Press enter to finish the demo");
  ReadLine();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec193"></a>How it works...</h3></div></div></div><p>The ability to use<a id="id359" class="indexterm"></a> LINQ against the <code class="literal">Observable</code> event sequences is the main advantage of the Reactive Extensions framework. There are many different useful scenarios as well; unfortunately, it is impossible to show all of them here. I tried to provide a simple, yet very illustrative example, which does not have many complex details and shows the very essence of how a LINQ query could work when applied to asynchronous observable collections.</p><p>First, we create an <code class="literal">Observable</code> event that generates a sequence of numbers, one number every 50 milliseconds, and we start from the initial value of zero, taking 21 of those events. Then, we compose LINQ queries to this sequence. First, we select only the even numbers from the sequence, and then only the odd numbers. Then, we concatenate these two sequences.</p><p>The final query shows us how to use a very useful method, <code class="literal">Do</code>, which allows us to introduce side effects and, for example, logging each value from the resulting sequence. To run all queries, we<a id="id360" class="indexterm"></a> create nested subscriptions, and because the sequences are initially asynchronous, we have to be very careful about the subscription's lifetime. The outer scope represents a subscription to the timer, and the inner <a id="id361" class="indexterm"></a>subscriptions deal with the combined sequence query and the side effects query, respectively. If we press <span class="emphasis"><em>Enter</em></span> too early, we just unsubscribe from the timer and thus stop the demo.</p><p>When we run the demo, we see the actual process of how different queries interact in real time. We can see that our queries are lazy, and they start running only when we subscribe to their results. The timer event's sequence is printed in the first column. When the even numbers query gets an even number, it prints it out as well using the <code class="literal">---</code> prefix to distinguish this sequence result from the first one. The final query results are printed in the right-hand column.</p><p>When the program runs, we can see that the timer sequence, the even-number sequence, and the side effect sequence run in parallel. Only the concatenation waits until the even-number sequence is complete. If we do not concatenate those sequences, we will have four parallel sequences of events interacting with each other in the most effective way! This shows the real power of Reactive Extensions and could be a good start to learn this library in depth.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec77"></a>Creating asynchronous operations with Rx</h2></div></div><hr /></div><p>This recipe<a id="id362" class="indexterm"></a> shows you how to create an <code class="literal">Observable</code> from<a id="id363" class="indexterm"></a> the asynchronous operations defined in other programming patterns.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec194"></a>Getting ready</h3></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe6</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec195"></a>How to do it...</h3></div></div></div><p>To understand how to create asynchronous operations with Rx, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for details on<a id="id364" class="indexterm"></a> how to do this.</p></li><li><p>In<a id="id365" class="indexterm"></a> the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Reactive;
using System.Reactive.Linq;
using System.Reactive.Threading.Tasks;
using System.Threading.Tasks;
using System.Timers;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task&lt;T&gt; AwaitOnObservable&lt;T&gt;(IObservable&lt;T&gt; observable)
{
  T obj = await observable;
  WriteLine($"{obj}" );
  return obj;
}

static Task&lt;string&gt; LongRunningOperationTaskAsync(string name)
{
  return Task.Run(() =&gt; LongRunningOperation(name));
}

static IObservable&lt;string&gt; LongRunningOperationAsync(string name)
{
  return Observable.Start(() =&gt; LongRunningOperation(name));
}

static string LongRunningOperation(string name)
{
  Sleep(TimeSpan.FromSeconds(1));
  return $"Task {name} is completed. Thread Id {CurrentThread.ManagedThreadId}";
}

static IDisposable OutputToConsole(IObservable&lt;EventPattern&lt;ElapsedEventArgs&gt;&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine($"{obj.EventArgs.SignalTime}")
    , ex =&gt; WriteLine($"Error: {ex.Message}")
    , () =&gt; WriteLine("Completed")
  );
}

static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine("{0}", obj)
    , ex =&gt; WriteLine("Error: {0}", ex.Message)
    , () =&gt; WriteLine("Completed")
  );
}</pre></div></li><li><p>Replace<a id="id366" class="indexterm"></a> the <code class="literal">Main</code> method with the<a id="id367" class="indexterm"></a> following code snippet:</p><div class="informalexample"><pre class="programlisting">delegate string AsyncDelegate(string name);

static void Main(string[] args)
{
IObservable&lt;string&gt; o = LongRunningOperationAsync("Task1");
using (var sub = OutputToConsole(o))
{
  Sleep(TimeSpan.FromSeconds(2));
};
WriteLine(" ---------------- ");

Task&lt;string&gt; t = LongRunningOperationTaskAsync("Task2");
using (var sub = OutputToConsole(t.ToObservable()))
{
  Sleep(TimeSpan.FromSeconds(2));
};
WriteLine(" ---------------- ");

AsyncDelegate asyncMethod = LongRunningOperation;

// marked as obsolete, use tasks instead
Func&lt;string, IObservable&lt;string&gt;&gt; observableFactory = 
  Observable.FromAsyncPattern&lt;string, string&gt;(
        asyncMethod.BeginInvoke, asyncMethod.EndInvoke);

o = observableFactory("Task3");
using (var sub = OutputToConsole(o))
{
  Sleep(TimeSpan.FromSeconds(2));
};
WriteLine(" ---------------- ");

o = observableFactory("Task4");
AwaitOnObservable(o).Wait();
WriteLine(" ---------------- ");

using (var timer = new Timer(1000))
{
  var ot = Observable.
               FromEventPattern&lt;ElapsedEventHandler, ElapsedEventArgs&gt;(
    h =&gt; timer.Elapsed += h,
            h =&gt; timer.Elapsed -= h);
  timer.Start();

  using (var sub = OutputToConsole(ot))
  {
    Sleep(TimeSpan.FromSeconds(5));
  }
  WriteLine(" ---------------- ");
  timer.Stop();
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec196"></a>How it works...</h3></div></div></div><p>This recipe<a id="id368" class="indexterm"></a> shows you how to convert different types<a id="id369" class="indexterm"></a> of asynchronous operations to an <code class="literal">Observable</code> class. The first code snippet uses the <code class="literal">Observable.Start</code> method, which is quite similar to <code class="literal">Task.Run</code> from TPL. It starts an asynchronous operation that gives out a string result and then gets completed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>I would strongly suggest that you use the Task Parallel Library for asynchronous operations. Reactive Extensions supports this scenario as well, but to avoid ambiguity, it is much better to stick with tasks when speaking about separate asynchronous operations and to go with Rx only when we need to work with sequences of events. Another suggestion is to convert every type of separate asynchronous operation to tasks and only then convert a task to an observable class, if you need it.</p></div><p>Then, we do<a id="id370" class="indexterm"></a> the same with tasks and convert a task to an <code class="literal">Observable</code> method by simply calling the <code class="literal">ToObservable</code> extension method. The next code<a id="id371" class="indexterm"></a> snippet is about converting the Asynchronous Programming Model pattern to <code class="literal">Observable</code>. Normally, you would convert APM to a task and then a task to <code class="literal">Observable</code>. However, there is a direct conversion, and this example illustrates how to run an asynchronous delegate and wrap it into an <code class="literal">Observable</code> operation.</p><p>The next part of the code snippet shows that we are able to use the <code class="literal">await</code> operator in an <code class="literal">Observable</code> operation. As we are not able to use the <code class="literal">async</code> modifier on an entry method such as <code class="literal">Main</code>, we introduce a separate method that returns a task and waits for this resulting task to be complete inside the <code class="literal">Main</code> method.</p><p>The last part of this code snippet is the same as the code which converts APM pattern to Observable, but now, we convert the Event-based Asynchronous Pattern directly to an <code class="literal">Observable</code> class. We create a timer and consume its events for 5 seconds. We then dispose the timer to clean up the resources.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>ChapterÂ 9.Â Using Asynchronous I/O</h2></div></div></div><p>In this chapter, we will review asynchronous I/O operations in detail. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Working with files asynchronously</p></li><li style="list-style-type: disc"><p>Writing an asynchronous HTTP server and client</p></li><li style="list-style-type: disc"><p>Working with a database asynchronously</p></li><li style="list-style-type: disc"><p>Calling a WCF service asynchronously</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec78"></a>Introduction</h2></div></div><hr /></div><p>In the previous chapters, we already discussed how important it is to use asynchronous I/O operations properly. Why does it matter so much? To have a solid understanding, let's consider two kinds of applications.</p><p>When we run an <a id="id372" class="indexterm"></a>application on a client, one of the most important things is to have a responsive user interface. This means that no matter what is happening with the application, all user interface elements, such as buttons and progress bars, keep running fast, and the user gets an immediate reaction from the application. This is not easy to achieve! If you try to open the Notepad text editor in Windows and try to load a text document that is several megabytes in size, the application window will be frozen for a significant amount of time because the whole text is being loaded from the disk first, and only then does the program start to process user input.</p><p>This is an extremely important issue, and in this situation, the only solution is to avoid blocking the UI thread at all costs. This in turn means that to prevent the blocking of the UI thread, every UI-related API must allow only asynchronous calls. This is the key reason behind redesigning APIs in the Windows 8 operating system by replacing almost every method with asynchronous analogs. But does it affect the performance if our application uses multiple threads to achieve this goal? Of course, it does! However, we could pay the price considering that we have only one user. It is good to have the application using all the power of the computer to be more effective, as all this power is intended for the single user who runs the application.</p><p>Let's look at the second case, then. If we run the application on a server, we have a completely different situation. We have scalability as a top priority, which means that a single user should consume as little resource as possible. If we start to create many threads for each user, we simply cannot scale well. It is a very complex problem to balance our application resource consumption in an efficient way. For example, in ASP.NET, which is a web application platform from Microsoft, we use a pool of worker threads to serve client requests. This pool has a limited number of worker threads, and we have to minimize the<a id="id373" class="indexterm"></a> use time for each worker thread to achieve scalability. This means that we have to return it to the pool as soon as possible so that it can serve another request. If we start an asynchronous operation that requires computation, we will have a very inefficient workflow. First, we take a worker thread from the thread pool to serve a client request. Then, we take another worker thread and start an asynchronous operation on it. Now, we have two worker threads serving our request, but we really need the first thread to be doing something useful! Unfortunately, the common situation is that we simply wait for the asynchronous operation to complete, and we consume two worker threads instead of one. In this scenario, asynchrony is actually worse than synchronous execution! We do not need to load all the CPU cores as we are already serving many clients and thus are using all the CPU computing power. We do not need to keep the first thread responsive as we have no user interface. Then, why should we use asynchrony in server applications?</p><p>The answer is that we should use asynchrony when there is an asynchronous I/O operation. Today, modern computers usually have a hard disk drive that stores files and a network card that sends and receives data over the network. Both of these devices have their own microcomputers that manage I/O operations on a very low level and signal the operating system about the results. This is again quite a complicated topic; but to keep the concept clear, we could say that there is a way for programmers to start an I/O operation and provide the operating system with code to callback when the operation is completed. Between starting an I/O task and its completion, there is no CPU work involved; it is done in the corresponding disk and network controller microcomputers. This way of executing an I/O task is called an I/O thread; they are implemented using the .NET thread pool and in turn use an infrastructure from the operating system called I/O completion ports.</p><p>In ASP.NET, as soon as an asynchronous I/O operation is started from a worker thread, it can be returned immediately to the thread pool! While the operation is going on, this thread can serve other clients. Finally, when the operation signals completion, the ASP.NET infrastructure gets a free worker thread from the thread pool (which could be different from the one that started the operation), and it finishes the operation.</p><p>All right; we now understand how important I/O threads are for server applications. Unfortunately, it is very hard to check whether any given API uses I/O threads under the hood. The only way<a id="id374" class="indexterm"></a> (besides studying the source code) is simply to know which .NET Framework class library leverages I/O threads. In this chapter, we <a id="id375" class="indexterm"></a>will see how to use some of those APIs. You will learn how to work with files asynchronously, how to use network I/O to create an HTTP server and call the <span class="strong"><strong>Windows Communication Foundation</strong></span> (<span class="strong"><strong>WCF</strong></span>) service, and how to work with an asynchronous API to query a database.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>Another important issue to consider is parallelism. For a number of reasons, an intensive parallel disk operation might have very poor performance. Be aware that parallel I/O operations are often very ineffective, and it might be reasonable to work with I/O sequentially, but in an asynchronous manner.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec79"></a>Working with files asynchronously</h2></div></div><hr /></div><p>This recipe walks us<a id="id376" class="indexterm"></a> through how to create a file and how to read and write data asynchronously.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec197"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec198"></a>How to do it...</h3></div></div></div><p>To understand how to work with files asynchronously, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static System.Console;
using static System.Text.Encoding;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">const int BUFFER_SIZE = 4096;

static async Task ProcessAsynchronousIO()
{
  using (var stream = new FileStream(
    "test1.txt", FileMode.Create, FileAccess.ReadWrite, FileShare.None, BUFFER_SIZE))
  {
    WriteLine($"1. Uses I/O Threads: {stream.IsAsync}");

    byte[] buffer = UTF8.GetBytes(CreateFileContent());
    var writeTask = Task.Factory.FromAsync(
      stream.BeginWrite, stream.EndWrite, buffer, 0, buffer.Length, null);

    await writeTask;
  }

  using (var stream = new FileStream("test2.txt", FileMode.Create, FileAccess.ReadWrite,FileShare.None, BUFFER_SIZE, FileOptions.Asynchronous))
  {
    WriteLine($"2. Uses I/O Threads: {stream.IsAsync}");

    byte[] buffer = UTF8.GetBytes(CreateFileContent());
    var writeTask = Task.Factory.FromAsync(
      stream.BeginWrite, stream.EndWrite, buffer, 0, buffer.Length, null);

    await writeTask;
  }

  using (var stream = File.Create("test3.txt", BUFFER_SIZE, FileOptions.Asynchronous))
  using (var sw = new StreamWriter(stream))
  {
    WriteLine($"3. Uses I/O Threads: {stream.IsAsync}");
    await sw.WriteAsync(CreateFileContent());
  }

  using (var sw = new StreamWriter("test4.txt", true))
  {
    WriteLine($"4. Uses I/O Threads: {((FileStream)sw.BaseStream).IsAsync}");
    await sw.WriteAsync(CreateFileContent());
  }

  WriteLine("Starting parsing files in parallel");

  var readTasks = new Task&lt;long&gt;[4];
  for (int i = 0; i &lt; 4; i++)
  {
    string fileName = $"test{i + 1}.txt";
    readTasks[i] = SumFileContent(fileName);
  }

  long[] sums = await Task.WhenAll(readTasks);

  WriteLine($"Sum in all files: {sums.Sum()}");

  WriteLine("Deleting files...");

  Task[] deleteTasks = new Task[4];
  for (int i = 0; i &lt; 4; i++)
  {
    string fileName = $"test{i + 1}.txt";
    deleteTasks[i] = SimulateAsynchronousDelete(fileName);
  }

  await Task.WhenAll(deleteTasks);

  WriteLine("Deleting complete.");
}

static string CreateFileContent()
{
  var sb = new StringBuilder();
  for (int i = 0; i &lt; 100000; i++)
  {
    sb.Append($"{new Random(i).Next(0, 99999)}");
    sb.AppendLine();
  }
  return sb.ToString();
}

static async Task&lt;long&gt; SumFileContent(string fileName)
{
  using (var stream = new FileStream(fileName, FileMode.Open, FileAccess.Read,FileShare.None, BUFFER_SIZE, FileOptions.Asynchronous))
  using (var sr = new StreamReader(stream))
  {
    long sum = 0;
    while (sr.Peek() &gt; -1)
    {
      string line = await sr.ReadLineAsync();
      sum += long.Parse(line);
    }

    return sum;
  }
}

static Task SimulateAsynchronousDelete(string fileName)
{
  return Task.Run(() =&gt; File.Delete(fileName));
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var t = ProcessAsynchronousIO();
t.GetAwaiter().GetResult();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec199"></a>How it works...</h3></div></div></div><p>When the program runs, we create four files in different ways and fill them up with random data. In the<a id="id377" class="indexterm"></a> first case, we use the <code class="literal">FileStream</code> class and its methods, converting an Asynchronous Programming Model API to a task; in the second case, we do the same, but we provide <code class="literal">FileOptions.Asynchronous</code> to the <code class="literal">FileStream</code> constructor.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>It is very important to use the <code class="literal">FileOptions.Asynchronous</code> option. If we omit this option, we can still work with the file in an asynchronous manner, but this is just an asynchronous delegate invocation on a thread pool! We use the I/O asynchrony with the <code class="literal">FileStream</code> class only if we provide this option (or bool <code class="literal">useAsync</code> in another constructor overload).</p></div><p>The third case uses some simplifying APIs, such as the <code class="literal">File.Create</code> method and the <code class="literal">StreamWriter</code> class. It still uses I/O threads, which we are able to check using the <code class="literal">stream.IsAsync</code> property. The last case illustrates that oversimplifying is also bad. Here, we do not leverage the I/O asynchrony by imitating it with the help of asynchronous delegate invocation.</p><p>Now, we perform parallel asynchronous reading from files, sum up their content, and then sum it with each other. Finally, we<a id="id378" class="indexterm"></a> delete all the files. As there is no asynchronous delete file in any non-Windows store application, we simulate the asynchrony using the <code class="literal">Task.Run</code> factory method.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec80"></a>Writing an asynchronous HTTP server and client</h2></div></div><hr /></div><p>This recipe <a id="id379" class="indexterm"></a>shows you how to create a simple asynchronous HTTP server.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec200"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec201"></a>How to do it...</h3></div></div></div><p>The following steps demonstrate how to create a simple asynchronous HTTP server:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add a reference to the <code class="literal">System.Net.Http</code> framework library.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task GetResponseAsync(string url)
{
  using (var client = new HttpClient())
  {
    HttpResponseMessage responseMessage = await client.GetAsync(url);
    string responseHeaders = responseMessage.Headers.ToString();
    string response = await responseMessage.Content.ReadAsStringAsync();

    WriteLine("Response headers:");
    WriteLine(responseHeaders);
    WriteLine("Response body:");
    WriteLine(response);
  }
}

class AsyncHttpServer
{
  readonly HttpListener _listener;
  const string RESPONSE_TEMPLATE = 
        "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Testpage&lt;/h2&gt;" +
"&lt;h4&gt;Today is: {0}&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;";

  public AsyncHttpServer(int portNumber)
  {
    _listener = new HttpListener();
    _listener.Prefixes.Add($"http://localhost:{portNumber}/");
  }

  public async Task Start()
  {
    _listener.Start();

    while (true)
    {
      var ctx = await _listener.GetContextAsync();
      WriteLine("Client connected...");
      var response = string.Format(RESPONSE_TEMPLATE, DateTime.Now);

      using (var sw = new StreamWriter(ctx.Response.OutputStream))
      {
        await sw.WriteAsync(response);
        await sw.FlushAsync();
      }
    }
  }

  public async Task Stop()
  {
    _listener.Abort();
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var server = new AsyncHttpServer(1234);
var t = Task.Run(() =&gt; server.Start());
WriteLine("Listening on port 1234. Open http://localhost:1234 in your browser.");
WriteLine("Trying to connect:");
WriteLine();

GetResponseAsync("http://localhost:1234").GetAwaiter().GetResult();

WriteLine();
WriteLine("Press Enter to stop the server.");
ReadLine();

server.Stop().GetAwaiter().GetResult();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec202"></a>How it works...</h3></div></div></div><p>Here, we implement a <a id="id380" class="indexterm"></a>very simple web server using the <code class="literal">HttpListener</code> class. There is also a <code class="literal">TcpListener</code> class for the TCP socket I/O operations. We configure our listener to accept connections from any host to the local machine on port <code class="literal">1234</code>. Then, we start the listener in a separate worker thread so that we can control it from the main thread.</p><p>The asynchronous I/O operation happens when we use the <code class="literal">GetContextAsync</code> method. Unfortunately, it does not accept <code class="literal">CancellationToken</code> for cancelation scenarios; so, when we want to stop the server, we just call the <code class="literal">_listener.Abort</code> method, which abandons the connection and stops the server.</p><p>To perform an asynchronous request on this server, we use the <code class="literal">HttpClient</code> class located in the <code class="literal">System.Net.Http</code> assembly and the same namespace. We use the <code class="literal">GetAsync</code> method to issue an asynchronous HTTP <code class="literal">GET</code> request. There are methods for other HTTP requests such as <code class="literal">POST</code>, <code class="literal">DELETE</code>, and <code class="literal">PUT</code> as well. <code class="literal">HttpClient</code> has many other options such as serializing and deserializing an object using different formats, such as XML and JSON, specifying a proxy server address, credentials, and so on.</p><p>When you run the program, you can see that the server has been started up. In the server code, we use the <code class="literal">GetContextAsync</code> method to accept new client connections. This method returns when a new client connects, and we simply output a very basic HTML language with the current date and time to the response. Then, we request the server and print the response headers and content. You can also open your browser and browse to <code class="literal">http://localhost:1234/</code>. Here, you will see the same response displayed in the browser window.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec81"></a>Working with a database asynchronously</h2></div></div><hr /></div><p>This recipe walks<a id="id381" class="indexterm"></a> us through the process of creating a database, populating it with data, and reading data asynchronously.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec203"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec204"></a>How to do it...</h3></div></div></div><p>To understand the process of creating a database, populating it with data, and reading data asynchronously, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task ProcessAsynchronousIO(string dbName)
{
  try
  {
    const string connectionString =
            @"Data Source=(LocalDB)\MSSQLLocalDB;Initial Catalog=master;" +
            "Integrated Security=True";

    string outputFolder = Path.GetDirectoryName(
            Assembly.GetExecutingAssembly().Location);

    string dbFileName = Path.Combine(outputFolder, $"{dbName}.mdf");
    string dbLogFileName = Path.Combine(outputFolder, $"{dbName}_log.ldf");

    string dbConnectionString = 
      @"Data Source=(LocalDB)\MSSQLLocalDB;" +
      $"AttachDBFileName={dbFileName};Integrated Security=True;";

    using (var connection = new SqlConnection(connectionString))
    {
      await connection.OpenAsync();

      if (File.Exists(dbFileName))
      {
        WriteLine("Detaching the database...");

        var detachCommand = new SqlCommand("sp_detach_db", connection);
        detachCommand.CommandType = CommandType.StoredProcedure;
        detachCommand.Parameters.AddWithValue("@dbname", dbName);

        await detachCommand.ExecuteNonQueryAsync();

        WriteLine("The database was detached succesfully.");
        WriteLine("Deleting the database...");

        if(File.Exists(dbLogFileName)) File.Delete(dbLogFileName);
        File.Delete(dbFileName);

        WriteLine("The database was deleted succesfully.");
      }

      WriteLine("Creating the database...");
      string createCommand = 
                $"CREATE DATABASE {dbName} ON (NAME = N'{dbName}', FILENAME = " +
                $"'{dbFileName}')";
      var cmd = new SqlCommand(createCommand, connection);

      await cmd.ExecuteNonQueryAsync();
      WriteLine("The database was created succesfully");
    }

    using (var connection = new SqlConnection(dbConnectionString))
    {
      await connection.OpenAsync();

      var cmd = new SqlCommand("SELECT newid()", connection);
      var result = await cmd.ExecuteScalarAsync();

      WriteLine($"New GUID from DataBase: {result}");

      cmd = new SqlCommand(
@"CREATE TABLE [dbo].[CustomTable]( [ID] [int] IDENTITY(1,1) NOT NULL, " + 
"[Name] [nvarchar](50) NOT NULL, CONSTRAINT [PK_ID] PRIMARY KEY CLUSTERED " + 
" ([ID] ASC) ON [PRIMARY]) ON [PRIMARY]", connection);

            await cmd.ExecuteNonQueryAsync();

      WriteLine("Table was created succesfully.");

      cmd = new SqlCommand(
@"INSERT INTO [dbo].[CustomTable] (Name) VALUES ('John');
INSERT INTO [dbo].[CustomTable] (Name) VALUES ('Peter');
INSERT INTO [dbo].[CustomTable] (Name) VALUES ('James');
INSERT INTO [dbo].[CustomTable] (Name) VALUES ('Eugene');", connection);
      await cmd.ExecuteNonQueryAsync();

      WriteLine("Inserted data succesfully");
      WriteLine("Reading data from table...");

      cmd = new SqlCommand(@"SELECT * FROM [dbo].[CustomTable]", connection);
      using (SqlDataReader reader = await cmd.ExecuteReaderAsync())
      {
        while (await reader.ReadAsync())
        {
          var id = reader.GetFieldValue&lt;int&gt;(0);
          var name = reader.GetFieldValue&lt;string&gt;(1);

          WriteLine("Table row: Id {0}, Name {1}", id, name);
        }
      }
    }
  }
  catch(Exception ex)
  {
    WriteLine("Error: {0}", ex.Message);
  }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">const string dataBaseName = "CustomDatabase";
var t = ProcessAsynchronousIO(dataBaseName);
t.GetAwaiter().GetResult();
Console.WriteLine("Press Enter to exit");
Console.ReadLine();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec205"></a>How it works...</h3></div></div></div><p>This program works <a id="id382" class="indexterm"></a>with software called SQL Server 2014 LocalDb. It is installed with Visual Studio 2015 and should work fine. However, in case of errors, you might want to repair this component from the installation wizard.</p><p>We start with configuring paths to our database files. We place database files in the program-execution folder. There will be two files: one for the database itself and another for the transaction log file. We also configure two connection strings that define how we connect to our databases. The first one is to connect to the LocalDb engine to detach our database; if it already exists, delete and then recreate it. We leverage the I/O asynchrony while opening the connection and while executing the SQL commands using the <code class="literal">OpenAsync</code> and <code class="literal">ExecuteNonQueryAsync</code> methods, respectively.</p><p>After this task is completed, we attach a newly created database. Here, we create a new table and insert some data in it. In addition to the previously mentioned methods, we use <code class="literal">ExecuteScalarAsync</code> to asynchronously get a scalar value from the database engine, and we use the <code class="literal">SqlDataReader.ReadAsync</code> method to read a data row from the database table asynchronously.</p><p>If we had a large table with large binary values in its rows in our database, then we would use the <code class="literal">CommandBehavior.SequentialAcess</code> enumeration to create the data reader and the <code class="literal">GetFieldValueAsync</code> method to get large field values from the reader asynchronously.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec82"></a>Calling a WCF service asynchronously</h2></div></div><hr /></div><p>This recipe will describe how to create a WCF service, how to host it in a console application, how to <a id="id383" class="indexterm"></a>make service metadata available to clients, and how to consume it in an asynchronous way.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec206"></a>Getting ready</h3></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec207"></a>How to do it...</h3></div></div></div><p>To understand how to work with a WCF service, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add references to the <code class="literal">System.ServiceModel</code> library. Right-click on the <code class="literal">References</code> folder in the project and select the <span class="strong"><strong>Add referenceâ€¦</strong></span> menu option. Add references to the <code class="literal">System.ServiceModel</code> library. You can use the search function in the reference manager dialog, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05292_09_01.jpg" /></div></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li><p>Add the <a id="id384" class="indexterm"></a>following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">const string SERVICE_URL = "http://localhost:1234/HelloWorld";

static async Task RunServiceClient()
{
  var endpoint = new EndpointAddress(SERVICE_URL);
  var channel = ChannelFactory&lt;IHelloWorldServiceClient&gt;
        .CreateChannel(new BasicHttpBinding(), endpoint);

  var greeting = await channel.GreetAsync("Eugene");
  WriteLine(greeting);
}

[ServiceContract(Namespace = "Packt", Name = "HelloWorldServiceContract")]
public interface IHelloWorldService
{
  [OperationContract]
  string Greet(string name);
}

[ServiceContract(Namespace = "Packt", Name = "HelloWorldServiceContract")]
public interface IHelloWorldServiceClient
{
  [OperationContract]
  string Greet(string name);

  [OperationContract]
  Task&lt;string&gt; GreetAsync(string name);
}

public class HelloWorldService : IHelloWorldService
{
  public string Greet(string name)
  {
    return $"Greetings, {name}!";
  }
}</pre></div></li><li><p>Add the<a id="id385" class="indexterm"></a> following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">ServiceHost host = null;

try
{
  host = new ServiceHost(typeof (HelloWorldService), new Uri(SERVICE_URL));
  var metadata = host.Description.Behaviors.Find&lt;ServiceMetadataBehavior&gt;() 
        ?? new ServiceMetadataBehavior();

  metadata.HttpGetEnabled = true;
  metadata.MetadataExporter.PolicyVersion = PolicyVersion.Policy15;
  host.Description.Behaviors.Add(metadata);

  host.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, 
        MetadataExchangeBindings.CreateMexHttpBinding(), "mex");

  var endpoint = host.AddServiceEndpoint(typeof (IHelloWorldService),new BasicHttpBinding(), SERVICE_URL);

  host.Faulted += (sender, e) =&gt; WriteLine("Error!");

  host.Open();

  WriteLine("Greeting service is running and listening on:");
  WriteLine($"{endpoint.Address} ({endpoint.Binding.Name})");

  var client = RunServiceClient();
  client.GetAwaiter().GetResult();

  WriteLine("Press Enter to exit");
  ReadLine();
}
catch (Exception ex)
{
  WriteLine($"Error in catch block: {ex}");
}
finally
{
  if (null != host)
  {
    if (host.State == CommunicationState.Faulted)
    {
      host.Abort();
    }
    else
    {
      host.Close();
    }
  }
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec208"></a>How it works...</h3></div></div></div><p>WCF is a framework that allows us to call remote services in different ways. One of them, which was very popular some time ago, was used to call remote<a id="id386" class="indexterm"></a> services via HTTP using an XML-based protocol called the <span class="strong"><strong>Simple Object Access Protocol</strong></span> (<span class="strong"><strong>SOAP)</strong></span>. It is quite common when a server application calls another remote service, and this could be done using I/O threads as well.</p><p>Visual Studio 2015 has<a id="id387" class="indexterm"></a> rich support for WCF services; for example, you can add references to such services with the <span class="strong"><strong>Add Service Reference</strong></span> menu option. You could do this with our service as well because we provide service metadata.</p><p>To create such a service, we need to use a <code class="literal">ServiceHost</code> class that will host our service. We describe what service we will be hosting by providing a service implementation type and the base URI by which the service will be addressed. Then, we configure the metadata endpoint and the service endpoint. Finally, we handle the <code class="literal">Faulted</code> event in case of errors and run the host service.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>Be aware that we need to have administrator privileges to run the service, since it uses HTTP bindings, which in turn use <code class="literal">http.sys</code> and thus require special permissions to be created. You can run Visual Studio under an administrator or run the following command in the elevated command prompt to add the necessary permissions:</p><div class="informalexample"><pre class="programlisting">netsh http add urlacl url=http://+:1234/HelloWorld user=machine\user</pre></div></div><p>To consume this service, we create a client, and here is where the main trick happens. On the server side, we have a service with the usual synchronous method called <code class="literal">Greet</code>. This method is defined in the service contract, <code class="literal">IHelloWorldService</code>. However, if we want to leverage an asynchronous network I/O, we have to call this method asynchronously. We can do that by creating a new service contract with a matching namespace and service name, where we define both the synchronous and task-based asynchronous methods. In spite of the fact that we do not have an asynchronous method definition on the server side, we follow the naming convention, and the WCF infrastructure understands that we want to create an <a id="id388" class="indexterm"></a>asynchronous proxy method.</p><p>Therefore, when we create an <code class="literal">IHelloWorldServiceClient</code> proxy channel, and WCF correctly routes an asynchronous call to the server-side synchronous method, if you leave the application running, you can open the browser and access the service using its URL, that is, <code class="literal">http://localhost:1234/HelloWorld</code>. A service description will be opened, and you can browse to the XML metadata that allows us to add a service reference from Visual Studio 2012. If you try to generate the reference, you will see slightly more complicated code, but it is autogenerated and easy to use.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch10"></a>ChapterÂ 10.Â Parallel Programming Patterns</h2></div></div></div><p>In this chapter, we will review the common problems that a programmer often faces while trying to implement a parallel workflow. You will learn the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Implementing Lazy-evaluated shared states</p></li><li style="list-style-type: disc"><p>Implementing Parallel Pipeline with <code class="literal">BlockingCollection</code></p></li><li style="list-style-type: disc"><p>Implementing Parallel Pipeline with TPL DataFlow</p></li><li style="list-style-type: disc"><p>Implementing Map/Reduce with PLINQ</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec83"></a>Introduction</h2></div></div><hr /></div><p>Patterns in programming means a concrete and standard solution to a given problem. Usually, programming patterns are the result of people gathering experience, analyzing the common problems, and providing solutions to these problems.</p><p>Since parallel programming has existed for quite a long time, there are many different patterns that are used to program parallel applications. There are even special programming languages to make programming of specific parallel algorithms easier. However, this is where things start to become increasingly complicated. In this chapter, I will provide you with a starting point from where you will be able to study parallel programming further. We will review very basic, yet very useful, patterns that are quite helpful for many common situations in parallel programming.</p><p>First, we will be using a<a id="id389" class="indexterm"></a> <span class="strong"><strong>shared-state object</strong></span> from multiple threads. I would like to emphasize that you should avoid it as much as possible. As we discussed in previous chapters, a shared state is really bad when you write parallel algorithms, but on many occasions, it is inevitable. We will find out how to delay the actual computation of an object until it is needed and how to implement different scenarios to achieve thread safety.</p><p>Then, we will show you how<a id="id390" class="indexterm"></a> to create a structured parallel data flow. We will review a concrete case of a producer/consumer pattern, which is called <span class="strong"><strong>Parallel Pipeline</strong></span>. We are going to implement it by just blocking the collection first, and then we will see how <a id="id391" class="indexterm"></a>helpful another library from Microsoft is for parallel programmingâ€”<span class="strong"><strong>TPL DataFlow</strong></span>.</p><p>The last pattern that we will study is <a id="id392" class="indexterm"></a>the <span class="strong"><strong>Map/Reduce</strong></span> pattern. In the modern world, this name could mean very different things. Some people consider Map/Reduce not as a common approach to any problem, but as a concrete implementation for large, distributed cluster computations. We will find out the meaning behind the name of this pattern and review some examples of how it might work in cases of small parallel applications.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec84"></a>Implementing Lazy-evaluated shared states</h2></div></div><hr /></div><p>This recipe shows how to <a id="id393" class="indexterm"></a>program a Lazy-evaluated, thread-safe shared state object.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec209"></a>Getting ready</h3></div></div></div><p>To start this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec210"></a>How to do it...</h3></div></div></div><p>To implement Lazy-evaluated shared states, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static async Task ProcessAsynchronously()
{
  var unsafeState = new UnsafeState();
  Task[] tasks = new Task[4];

  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(unsafeState));
  }
  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var firstState = new DoubleCheckedLocking();
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(firstState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var secondState = new BCLDoubleChecked();
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(secondState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var lazy = new Lazy&lt;ValueToAccess&gt;(Compute);
      var thirdState = new LazyWrapper(lazy);
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(thirdState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

  var fourthState = new BCLThreadSafeFactory();
  for (int i = 0; i &lt; 4; i++)
  {
    tasks[i] = Task.Run(() =&gt; Worker(fourthState));
  }

  await Task.WhenAll(tasks);
  WriteLine(" --------------------------- ");

}

static void Worker(IHasValue state)
{
  WriteLine($"Worker runs on thread id {CurrentThread.ManagedThreadId}");
  WriteLine($"State value: {state.Value.Text}");
}

static ValueToAccess Compute()
{
  WriteLine("The value is being constructed on a thread " +
        $"id {CurrentThread.ManagedThreadId}");
  Sleep(TimeSpan.FromSeconds(1));
  return new ValueToAccess(
            $"Constructed on thread id {CurrentThread.ManagedThreadId}");
}

class ValueToAccess
{
  private readonly string _text; 
  public ValueToAccess(string text)
  {
    _text = text;
  }

  public string Text =&gt; _text;
}

class UnsafeState : IHasValue
{
  private ValueToAccess _value;

  public ValueToAccess Value =&gt;_value ?? (_value = Compute());
}

class DoubleCheckedLocking : IHasValue
{
  private readonly object _syncRoot = new object();
  private volatile ValueToAccess _value;

  public ValueToAccess Value
  {
    get
    {
      if (_value == null)
      {
        lock (_syncRoot)
        {
          if (_value == null) _value = Compute();
        }
      }
      return _value;
    }
  }
}

class BCLDoubleChecked : IHasValue
{
  private object _syncRoot = new object();
  private ValueToAccess _value;
  private bool _initialized;

  public ValueToAccess Value =&gt; LazyInitializer.EnsureInitialized(
    ref _value, ref _initialized, ref _syncRoot, Compute);
}

class BCLThreadSafeFactory : IHasValue
{
  private ValueToAccess _value;

  public ValueToAccess Value =&gt; LazyInitializer.EnsureInitialized(ref _value, Compute);
}

class LazyWrapper : IHasValue
{
  private readonly Lazy&lt;ValueToAccess&gt; _value;

  public LazyWrapper(Lazy&lt;ValueToAccess&gt; value )
  {
    _value = value;
  }

  public ValueToAccess Value =&gt; _value.Value;
}

interface IHasValue
{
  ValueToAccess Value { get; }
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var t = ProcessAsynchronously();
t.GetAwaiter().GetResult();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec211"></a>How it works...</h3></div></div></div><p>The first example shows why it is not safe to use the <code class="literal">UnsafeState</code> object with multiple accessing threads. We<a id="id394" class="indexterm"></a> see that the <code class="literal">Construct</code> method was called several times, and different threads use different values, which is obviously not right. To fix this, we can use a lock when reading the value, and if it is not initialized, create it first. This will work, but using a lock with every read operation is not efficient. To avoid using locks every time, we can use a traditional approach called the <a id="id395" class="indexterm"></a>
<span class="strong"><strong>double-checked locking</strong></span> pattern. We check the value for the first time, and if is not null, we avoid unnecessary locking and just use the shared object. However, if it was not constructed, we use the lock and then check the value for the second time because it could be initialized between our first check and the lock operation. If it is still not initialized, only then do we compute the value. We can clearly see that this approach works with the second exampleâ€”there is only one call to the <code class="literal">Construct</code> method, and the first-called thread defines the shared object state.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>Note that if the Lazy-evaluated object implementation is thread-safe, it does not automatically mean that all its properties are thread-safe as well.</p><p>If you add, for example, an <code class="literal">int</code> public property to the <code class="literal">ValueToAccess</code> object, it will not be thread-safe; you still have to use interlocked constructs or locking to ensure thread safety.</p></div><p>This pattern is very common, and that is why there are several classes in the Base Class Library to help us. First, we <a id="id396" class="indexterm"></a>can use the <code class="literal">LazyInitializer.EnsureInitialized</code> method, which implements the double-checked locking pattern inside. However, the most comfortable option is to use the <code class="literal">Lazy&lt;T&gt;</code> class, which allows us to have thread-safe, Lazy-evaluated, shared state, out of the box. The next two examples show us that they are equivalent to the second one, and the program behaves in the same way. The only difference is that since <code class="literal">LazyInitializer</code> is a static class, we do not have to create a new instance of a class, as we do in the case of <code class="literal">Lazy&lt;T&gt;</code>, and therefore, the performance in the first case can be better in some rare scenarios.</p><p>The last option is to avoid locking at all if we do not care about the <code class="literal">Construct</code> method. If it is thread-safe and has no side effects/serious performance impacts, we can just run it several times but use only the first constructed value. The last example shows the described behavior, and we can achieve this result using another <code class="literal">LazyInitializer.EnsureInitialized</code> method overload.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec85"></a>Implementing Parallel Pipeline with BlockingCollection</h2></div></div><hr /></div><p>This recipe<a id="id397" class="indexterm"></a> will describe how to implement a <a id="id398" class="indexterm"></a>specific scenario of a producer/consumer pattern, which is called Parallel Pipeline, using the standard <code class="literal">BlockingCollection</code> data structure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec212"></a>Getting ready</h3></div></div></div><p>To begin this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec213"></a>How to do it...</h3></div></div></div><p>To understand how to implement Parallel Pipeline using <code class="literal">BlockingCollection</code>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">private const int CollectionsNumber = 4;
private const int Count = 5;

static void CreateInitialValues(BlockingCollection&lt;int&gt;[] sourceArrays, CancellationTokenSource cts)
{
  Parallel.For(0, sourceArrays.Length*Count, (j, state) =&gt;
  {
      if (cts.Token.IsCancellationRequested)
      {
          state.Stop();
      }

      int number = GetRandomNumber(j);
      int k = BlockingCollection&lt;int&gt;.TryAddToAny(sourceArrays, j);
      if (k &gt;= 0)
      {
          WriteLine(
              $"added {j} to source data on thread " +
              $"id {CurrentThread.ManagedThreadId}");
          Sleep(TimeSpan.FromMilliseconds(number));
      }
  });
  foreach (var arr in sourceArrays)
  {
      arr.CompleteAdding();
  }
}

static int GetRandomNumber(int seed)
{
  return new Random(seed).Next(500);
}

class PipelineWorker&lt;TInput, TOutput&gt;
{
  Func&lt;TInput, TOutput&gt; _processor;
  Action&lt;TInput&gt; _outputProcessor;
  BlockingCollection&lt;TInput&gt;[] _input;
  CancellationToken _token;
  Random _rnd;

  public PipelineWorker(
      BlockingCollection&lt;TInput&gt;[] input,
      Func&lt;TInput, TOutput&gt; processor,
      CancellationToken token,
      string name)
  {
    _input = input;
    Output = new BlockingCollection&lt;TOutput&gt;[_input.Length];
    for (int i = 0; i &lt; Output.Length; i++)
      Output[i] = null == input[i] ? null
        : new BlockingCollection&lt;TOutput&gt;(Count);

    _processor = processor;
    _token = token;
    Name = name;
    _rnd = new Random(DateTime.Now.Millisecond);
  }

  public PipelineWorker(
      BlockingCollection&lt;TInput&gt;[] input,
      Action&lt;TInput&gt; renderer,
      CancellationToken token,
      string name)
  {
    _input = input;
    _outputProcessor = renderer;
    _token = token;
    Name = name;
    Output = null;
    _rnd = new Random(DateTime.Now.Millisecond);
    }

  public BlockingCollection&lt;TOutput&gt;[] Output { get; private set; }

  public string Name { get; private set; }

  public void Run()
  {
    WriteLine($"{Name} is running");
    while (!_input.All(bc =&gt; bc.IsCompleted) &amp;&amp; 
      !_token.IsCancellationRequested)
    {
      TInput receivedItem;
      int i = BlockingCollection&lt;TInput&gt;.TryTakeFromAny(
          _input, out receivedItem, 50, _token);
      if (i &gt;= 0)
      {
        if (Output != null)
        {
          TOutput outputItem = _processor(receivedItem);
        BlockingCollection&lt;TOutput&gt;.AddToAny(
            Output, outputItem);
        WriteLine($"{Name} sent {outputItem} to next, on " +
        $"thread id {CurrentThread.ManagedThreadId}");
        Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));
        }
        else
        {
          _outputProcessor(receivedItem);
        }
      }
      else
      {
        Sleep(TimeSpan.FromMilliseconds(50));
      }
    }
    if (Output != null)
    {
      foreach (var bc in Output) bc.CompleteAdding();
    }
  }
}</pre></div></li><li><p>Add the<a id="id399" class="indexterm"></a> following<a id="id400" class="indexterm"></a> code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var cts = new CancellationTokenSource();

Task.Run(() =&gt;
{
  if (ReadKey().KeyChar == 'c') cts.Cancel();
}, 
cts.Token);

var sourceArrays = new BlockingCollection&lt;int&gt;[CollectionsNumber];

for (int i = 0; i &lt; sourceArrays.Length; i++)
{
  sourceArrays[i] = new BlockingCollection&lt;int&gt;(Count);
}

var convertToDecimal = new PipelineWorker&lt;int, decimal&gt;
(
  sourceArrays,
  n =&gt; Convert.ToDecimal(n*100),
  cts.Token,
  "Decimal Converter"
);

var stringifyNumber = new PipelineWorker&lt;decimal, string&gt;
(
  convertToDecimal.Output,
  s =&gt; $"--{s.ToString("C", CultureInfo.GetCultureInfo("en-us"))}--",
  cts.Token,
  "String Formatter"
  );

var outputResultToConsole = new PipelineWorker&lt;string, string&gt;
(
  stringifyNumber.Output,
  s =&gt; WriteLine($"The final result is {s} on thread " +
            $"id {CurrentThread.ManagedThreadId}"),
  cts.Token,
  "Console Output"
  );

try
{
  Parallel.Invoke(
    () =&gt;
    CreateInitialValues(sourceArrays, cts),
    () =&gt; convertToDecimal.Run(),
    () =&gt; stringifyNumber.Run(),
    () =&gt; outputResultToConsole.Run()
  );
}
catch (AggregateException ae)
{
  foreach (var ex in ae.InnerExceptions)
    WriteLine(ex.Message + ex.StackTrace);
}

if (cts.Token.IsCancellationRequested)
{
  WriteLine("Operation has been canceled! Press ENTER to exit.");
}
else
{
  WriteLine("Press ENTER to exit.");
}
ReadLine();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec214"></a>How it works...</h3></div></div></div><p>In the preceding <a id="id401" class="indexterm"></a>example, we implement one of the most common parallel programming scenarios. Imagine that we have some data that has to pass through several computation stages, which takes a significant amount of time. The latter computation requires the results of the former, so we cannot run them in parallel.</p><p>If we had only one<a id="id402" class="indexterm"></a> item to process, there would not be many possibilities to enhance the performance. However, if we run many items through the same set of computation stages, we can use a Parallel Pipeline technique. This means that we do not have to wait until all items pass through the first computation stage to go to the next one. It is enough to have just one item that finishes the stage; we move it to the next stage, and meanwhile, the next item is being by the previous stage, and so on. As a result, we almost have parallel processing shifted by the time required for the first item to pass through the first computation stage.</p><p>Here, we use four collections for each processing stage, illustrating that we can process every stage in parallel as well. The first step that we do is to provide the possibility to cancel the whole process by pressing the <span class="emphasis"><em>C</em></span> key. We create a cancelation token and run a separate task to monitor the <span class="emphasis"><em>C</em></span> key. Then, we define our pipeline. It consists of three main stages. The first stage is where we put the initial numbers on the first four collections that serve as the item source to the latter pipeline. This code is inside the <code class="literal">Parallel.For</code> loop of the <code class="literal">CreateInitialValues</code> method, which in turn is inside the <code class="literal">Parallel.Invoke</code> statement, as we run all the stages in parallel; the initial stage runs in parallel as well.</p><p>The next stage is defining our pipeline elements. The logic is defined inside the <code class="literal">PipelineWorker</code> class. We initialize the worker with the input collection, provide a transformation function, and then run the worker in parallel with the other workers. This way, we define two workers, or filters, because they filter the initial sequence. One of them turns an integer into a decimal value, and the second one turns a decimal to a string. Finally, the last worker just prints every incoming string to the console. In all the places, we provide a running thread ID to see how everything works. Besides this, we added artificial delays, so the item's processing will be more natural, as we really use heavy computations.</p><p>As a result, we see the exact expected behavior. First, some items are created on the initial collections. Then, we see that the first filter starts to process them, and as they are being processed, the second filter starts to work. Finally, the item goes to the last worker that prints it to the console.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec86"></a>Implementing Parallel Pipeline with TPL DataFlow</h2></div></div><hr /></div><p>This recipe shows how<a id="id403" class="indexterm"></a> to implement a Parallel<a id="id404" class="indexterm"></a> Pipeline pattern with the help of the TPL DataFlow library.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec215"></a>Getting ready</h3></div></div></div><p>To start this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec216"></a>How to do it...</h3></div></div></div><p>To understand how to implement Parallel Pipeline with TPL DataFlow, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Add references to the <span class="strong"><strong>Microsoft TPL DataFlow</strong></span> NuGet package. Follow these steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right-click on the <span class="strong"><strong>References</strong></span> folder in the project and select the <span class="strong"><strong>Manage NuGet Packages...</strong></span> menu option.</p></li><li><p>Now, add your preferred references to the <span class="strong"><strong>Microsoft TPL DataFlow</strong></span> NuGet package. You can use the search option in the <span class="strong"><strong>Manage NuGet Packages</strong></span> dialog as follows:</p></li></ol></div><div class="mediaobject"><img src="graphics/B05292_10_01.jpg" /></div></li><li><p>In the<a id="id405" class="indexterm"></a> <code class="literal">Program.cs</code> file, add the <a id="id406" class="indexterm"></a>following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">async static Task ProcessAsynchronously()
{
  var cts = new CancellationTokenSource();
  Random _rnd = new Random(DateTime.Now.Millisecond);

  Task.Run(() =&gt;
  {
    if (ReadKey().KeyChar == 'c')
      cts.Cancel();
  }, cts.Token);

  var inputBlock = new BufferBlock&lt;int&gt;(
    new DataflowBlockOptions { BoundedCapacity = 5, CancellationToken = cts.Token });

  var convertToDecimalBlock = new TransformBlock&lt;int, decimal&gt;(
    n =&gt;
    {
      decimal result = Convert.ToDecimal(n * 100);
      WriteLine($"Decimal Converter sent {result} to the next stage on " +
              $"thread id {CurrentThread.ManagedThreadId}");
      Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));
      return result;
    }
    , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });

  var stringifyBlock = new TransformBlock&lt;decimal, string&gt;(
    n =&gt;
    {
      string result = $"--{n.ToString("C", CultureInfo.GetCultureInfo("en-us"))}--";
      WriteLine($"String Formatter sent {result} to the next stage on thread id {CurrentThread.ManagedThreadId}");
      Sleep(TimeSpan.FromMilliseconds(_rnd.Next(200)));
      return result;
    }
    , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });

  var outputBlock = new ActionBlock&lt;string&gt;(
    s =&gt;
    {
      WriteLine($"The final result is {s} on thread id {CurrentThread.ManagedThreadId}");
    }
    , new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token });

  inputBlock.LinkTo(convertToDecimalBlock, new DataflowLinkOptions { PropagateCompletion = true });
  convertToDecimalBlock.LinkTo(stringifyBlock, new DataflowLinkOptions { PropagateCompletion = true });
  stringifyBlock.LinkTo(outputBlock, new DataflowLinkOptions { PropagateCompletion = true });

  try
  {
    Parallel.For(0, 20, new ParallelOptions { MaxDegreeOfParallelism = 4, CancellationToken = cts.Token }
    , i =&gt;
    {
      WriteLine($"added {i} to source data on thread id {CurrentThread.ManagedThreadId}");
      inputBlock.SendAsync(i).GetAwaiter().GetResult();
    });
    inputBlock.Complete();
    await outputBlock.Completion;
    WriteLine("Press ENTER to exit.");
  }
  catch (OperationCanceledException)
  {
    WriteLine("Operation has been canceled! Press ENTER to exit.");
  }

  ReadLine();
}</pre></div></li><li><p>Add the<a id="id407" class="indexterm"></a> following <a id="id408" class="indexterm"></a>code snippet inside the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var t = ProcessAsynchronously();
t.GetAwaiter().GetResult();</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec217"></a>How it works...</h3></div></div></div><p>In the previous recipe, we implemented a Parallel Pipeline pattern to process items through sequential stages. It is quite a common problem, and one of the proposed ways to program such algorithms is using a TPL DataFlow library from Microsoft. It is distributed via NuGet and is easy to install and use in your application.</p><p>The TPL DataFlow<a id="id409" class="indexterm"></a> library contains different types of blocks that can be connected with each other in different ways and form complicated processes that can be partially parallel and sequential where needed. To see some of the available infrastructure, let's implement the previous scenario with the help of the TPL DataFlow library.</p><p>First, we define the different blocks that will be processing our data. Note that these blocks have different options that can be specified during their construction; they can be very important. For<a id="id410" class="indexterm"></a> example, we pass the cancelation token into every block we define, and when we signal the cancelation, all of them stop working.</p><p>We start our process with <code class="literal">BufferBlock</code>, we bound its capacity to 5 items maximum. This block holds items to pass them to the next blocks in the flow. We restrict it to the five-item capacity, specifying the <code class="literal">BoundedCapacity</code> option value. This means that when there will be five items in this block, it will stop accepting new items until one of the existing items passes to the next blocks.</p><p>The next block type is <code class="literal">TransformBlock</code>. This block is intended for a data transformation step. Here, we define two transformation blocks; one of them creates decimals from integers, and the second one creates a string from a decimal value. We can use the <code class="literal">MaxDegreeOfParallelism</code> option for this block, specifying the maximum simultaneous worker threads.</p><p>The last block is of the <code class="literal">ActionBlock</code> type. This block will run a specified action on every incoming item. We use this block to print our items to the console.</p><p>Now, we link these blocks together with the help of the <code class="literal">LinkTo</code> methods. Here, we have an easy sequential data flow, but it is possible to create schemes that are more complicated. Here, we also provide <code class="literal">DataflowLinkOptions</code> with the <code class="literal">PropagateCompletion</code> property set to <code class="literal">true</code>. This means that when the step is complete, it will automatically propagate its results and exceptions to the next stage. Then, we start adding items to the buffer block in parallel, calling the block's <code class="literal">Complete</code> method, when we finish adding new items. Then, we wait for the last block to get completed. In the case of a cancelation, we handle <code class="literal">OperationCancelledException</code> and cancel the whole process.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec87"></a>Implementing Map/Reduce with PLINQ</h2></div></div><hr /></div><p>This recipe will<a id="id411" class="indexterm"></a> describe how to implement the Map/Reduce pattern while using PLINQ.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec218"></a>Getting ready</h3></div></div></div><p>To begin<a id="id412" class="indexterm"></a> this recipe, you will need to run Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter10\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec219"></a>How to do it...</h3></div></div></div><p>To understand how to implement Map/Reduce with PLINQ, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

using Newtonsoft.Json;

using static System.Console;</pre></div></li><li><p>Add references to the <code class="literal">Newtonsoft.Json</code> NuGet package and the <code class="literal">System.Net.Http</code> assembly.</p></li><li><p>Add the following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">static char[] delimiters = { ' ', ',', ';', ':', '\"', '.' };

async static Task&lt;string&gt; ProcessBookAsync(
    string bookContent, string title, HashSet&lt;string&gt; stopwords)
{
    using (var reader = new StringReader(bookContent))
    {
        var query = reader.EnumLines()
            .AsParallel()
            .SelectMany(line =&gt; line.Split(delimiters))
            .MapReduce(
                word =&gt; new[] { word.ToLower() },
                key =&gt; key,
                g =&gt; new[] { new { Word = g.Key, Count = g.Count() } }
            )
            .ToList();

        var words = query
            .Where(element =&gt;
                !string.IsNullOrWhiteSpace(element.Word)
                &amp;&amp; !stopwords.Contains(element.Word))
            .OrderByDescending(element =&gt; element.Count);
               
        var sb = new StringBuilder();

        sb.AppendLine($"'{title}' book stats");
        sb.AppendLine("Top ten words used in this book: ");
        foreach (var w in words.Take(10))
        {
            sb.AppendLine($"Word: '{w.Word}', times used: '{w.Count}'");
        }

        sb.AppendLine($"Unique Words used: {query.Count()}");

        return sb.ToString();
    }
}

async static Task&lt;string&gt; DownloadBookAsync(string bookUrl)
{
  using (var client = new HttpClient())
  {
      return  await client.GetStringAsync(bookUrl);
  }             
}

async static Task&lt;HashSet&lt;string&gt;&gt; DownloadStopWordsAsync()
{
  string url = 
        "https://raw.githubusercontent.com/6/stopwords/master/stopwords-all.json";

  using (var client = new HttpClient())
  {
      try
      {
          var content = await client.GetStringAsync(url);
          var words =
              JsonConvert.DeserializeObject
                  &lt;Dictionary&lt;string, string[]&gt;&gt;(content);
          return new HashSet&lt;string&gt;(words["en"]);
      }
      catch
      {
          return new HashSet&lt;string&gt;();
      }
              
  }
}</pre></div></li><li><p>Add the<a id="id413" class="indexterm"></a> following code snippet inside<a id="id414" class="indexterm"></a> the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var booksList = new Dictionary&lt;string, string&gt;()
{
    ["Moby Dick; Or, The Whale by Herman Melville"] 
    = "http://www.gutenberg.org/cache/epub/2701/pg2701.txt",

    ["The Adventures of Tom Sawyer by Mark Twain"]
    = "http://www.gutenberg.org/cache/epub/74/pg74.txt",

    ["Treasure Island by Robert Louis Stevenson"]
    = "http://www.gutenberg.org/cache/epub/120/pg120.txt",

    ["The Picture of Dorian Gray by Oscar Wilde"]
    = "http://www.gutenberg.org/cache/epub/174/pg174.txt"
};

HashSet&lt;string&gt; stopwords = DownloadStopWordsAsync().GetAwaiter().GetResult();

var output = new StringBuilder();

Parallel.ForEach(booksList.Keys, key =&gt;
{
    var bookContent = DownloadBookAsync(booksList[key])
        .GetAwaiter().GetResult();

    string result = ProcessBookAsync(bookContent, key, stopwords)
        .GetAwaiter().GetResult();

  output.Append(result);
  output.AppendLine();
});

Write(output.ToString());
ReadLine();</pre></div></li><li><p>Add the<a id="id415" class="indexterm"></a> following code snippet<a id="id416" class="indexterm"></a> after the <code class="literal">Program</code> class definition:</p><div class="informalexample"><pre class="programlisting">static class Extensions
{
  public static ParallelQuery&lt;TResult&gt; MapReduce&lt;TSource, TMapped, TKey, TResult&gt;(
    this ParallelQuery&lt;TSource&gt; source,
    Func&lt;TSource, IEnumerable&lt;TMapped&gt;&gt; map,
    Func&lt;TMapped, TKey&gt; keySelector,
    Func&lt;IGrouping&lt;TKey, TMapped&gt;, IEnumerable&lt;TResult&gt;&gt; reduce)
  {
    return source.SelectMany(map)
    .GroupBy(keySelector)
    .SelectMany(reduce);
  }

    public static IEnumerable&lt;string&gt; EnumLines(this StringReader reader)
    {
        while (true)
        {
            string line = reader.ReadLine();
            if (null == line) yield break;

            yield return line;
        }
    }
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec220"></a>How it works...</h3></div></div></div><p>The <code class="literal">Map</code>/<code class="literal">Reduce</code> functions are another important parallel programming pattern. They are suitable for a small program and large multiserver computations. The meaning of this pattern is that you have two special functions to apply to your data. The first of them is the <code class="literal">Map</code> function. It takes a set of initial data in a key/value list form and produces another key/value sequence, transforming the data to a comfortable format for further processing. Then, we<a id="id417" class="indexterm"></a> use another function, called <code class="literal">Reduce</code>. The <code class="literal">Reduce</code> function takes the result of the <code class="literal">Map</code> function and transforms it to the smallest possible set of data that we actually need. To understand how this algorithm works, let's look through the preceding recipe.</p><p>Here, we are going to analyze four classic books' text. We are going to download the books from the project <a id="id418" class="indexterm"></a>Gutenberg's site (<a class="ulink" href="http://www.gutenberg.org" target="_blank">www.gutenberg.org</a>), which can ask for a captcha if you issue many network requests and thus break the program logic of this sample. If you see<a id="id419" class="indexterm"></a> HTML elements in the program's output, open one of the book URLs in the browser and complete the captcha. The next thing to do is to load a list of English words that we are going to skip when analyzing the text. In this sample, we try to load a JSON-encoded word list from GitHub, and in case of failure, we just get an empty list.</p><p>Now, let's pay attention to our <code class="literal">Map</code>/<code class="literal">Reduce</code> implementation as a PLINQ extension method in the <code class="literal">PLINQExtensions</code> class. We use <code class="literal">SelectMany</code> to transform the initial sequence to the sequence we need by applying the <code class="literal">Map</code> function. This function produces several new elements from one sequence element. Then, we choose how we group the new sequence with the <code class="literal">keySelector</code> function, and we use <code class="literal">GroupBy</code> with this key to produce an intermediate key/value sequence. The last thing we do is apply <code class="literal">Reduce</code> to the resulting grouped sequence to get the result.</p><p>Then, we run all our books processing in parallel. Each processing worker thread outputs the resulting information into a string, and after all workers are complete, we print this information to the console. We do this to avoid concurrent console output, when each worker text overlaps and makes the resulting information unreadable. In each worker process, we split the book text into a text lines sequence, chop each line into word sequences, and apply our <code class="literal">MapReduce</code> function to it. We use the <code class="literal">Map</code> function to transform each word into lowercase and use it as the grouping key. Then, we define the <code class="literal">Reduce</code> function as a transformation of the grouping element into a key value pair, which has the <code class="literal">Word</code> element that contains one unique word found in the text and the <code class="literal">Count</code> element, which has information about how many times this word has been used. The final step is our query materialization with the <code class="literal">ToList</code> method call, since we need to process this query twice. Then, we use our list of stop words to remove common words from our statistics and create a string result with the book's title, top 10 words used in the book, and a unique word's frequency in the book.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch11"></a>ChapterÂ 11.Â There's More</h2></div></div></div><p>In this chapter, we will look through a new programming paradigm in the Windows 10 operating system. Also, you will learn how to run .NET programs on OS X and Linux. You will learn the following recipes in this chapter:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using a timer in a Universal Windows Platform application</p></li><li style="list-style-type: disc"><p>Using WinRT from usual applications</p></li><li style="list-style-type: disc"><p>Using <code class="literal">BackgroundTask</code> in Universal Windows Platform applications</p></li><li style="list-style-type: disc"><p>Running a .NET Core application on OS X</p></li><li style="list-style-type: disc"><p>Running a .NET Core application on Ubuntu Linux</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec88"></a>Introduction</h2></div></div><hr /></div><p>Microsoft released the first public beta build of Windows 8 at the Build conference on September 13, 2011. The new OS tried to address almost every problem that Windows had by introducing features such as a responsive UI suitable for tablet devices with touch, lower power consumption, a new application model, new asynchronous APIs, and tighter security.</p><p>The core of Windows API improvements was a new multiplatform component system, <span class="strong"><strong>WinRT</strong></span>, which is a logic<a id="id420" class="indexterm"></a>al development of COM. With WinRT, a programmer can use native C++ code, C# and .NET, and even JavaScript and HTML to develop applications. Another change is the introduction of a centralized application store, which did not exist on the Windows platform before.</p><p>Being a new application platform, Windows 8 had backward compatibility and allowed us to run the usual Windows applications. This lead to a situation where there were two major classes of applications: the Windows Store applications, where new programs are distributed via the Windows Store, and the usual classic applications that had not changed since the previous version of Windows.</p><p>However, Windows 8 was only the first step toward the new application model. Microsoft got a lot of feedback from the users, and it became clear that Windows Store applications were too different from what people were used to. Besides that, there was a separate smartphone OS, Windows 8 Phone, that had a different application store and a slightly different set of APIs. This made an application developer create two separate applications for desktop and smartphone platforms.</p><p>To improve the situation, the new Windows 10 OS was introduced as a unified platform for all Windows-powered devices. There is a single application store that supports every device family, and now, it is possible to create an application that works on phones, tablets, and desktops. Thus, Windows Store applications are now called Universal Windows Platform applications (UWP apps). This, of course, means a lot of limitations for your applicationâ€”it should not use any platform-specific APIs, and as a programmer, you have to comply with specific rules. The program has to respond in a limited time to start up or to finish, keeping the whole operating system and other applications responsive. To save the battery, your applications are no longer running in the background by default; instead of that, they get suspended and actually stop executing.</p><p>New Windows APIs are asynchronous, and you can only use whitelisted API functions in your application. For example, you are not allowed to create a new <code class="literal">Thread</code> class instance anymore. You have to use a system-managed thread pool instead. A lot of usual APIs cannot be used anymore, and you have to study new ways to achieve the same goals as before.</p><p>But this is not all. Microsoft began to understand that supporting operating systems other than Windows is also important. And now, you can write cross-platform applications using a new subset of .NET that is called .NET Core. Its source can be found on GitHub, and it is supported on platforms such as OS X and Linux. You can use any text editor, but I would suggest you take a look at Visual Studio Codeâ€”a new lightweight, cross-platform code editor, which runs on OS X and Linux and understands the C# syntax well.</p><p>In this chapter, we will see how a Universal Windows Platform application is different from the usual Windows application and how we can use some of the WinRT benefits from the usual applications. We will also go through a simplified scenario of a Universal Windows Platform application with background notifications. You will also learn to run a .NET program on OS X and Linux.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec89"></a>Using a timer in a Universal Windows Platform application</h2></div></div><hr /></div><p>This recipe<a id="id421" class="indexterm"></a> shows you how to <a id="id422" class="indexterm"></a>use a simple timer in Universal Windows Platform applications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec221"></a>Getting ready</h3></div></div></div><p>To go through this recipe, you will need Visual Studio 2015 and the Windows 10 operating system. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe1</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec222"></a>How to do it...</h3></div></div></div><p>To<a id="id423" class="indexterm"></a> understand how to use a timer in a Windows Store application, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual <a id="id424" class="indexterm"></a>Studio 2015. Create a new C# <span class="strong"><strong>Blank App (Universal Windows)</strong></span> project in the <code class="literal">Windows\Universal</code> folder.</p><div class="mediaobject"><img src="graphics/B05292_11_01.jpg" /></div></li><li><p>If you are asked to enable developer mode for Windows 10, you have to enable it in the control panel.</p><div class="mediaobject"><img src="graphics/B05292_11_02.jpg" /></div></li><li><p>Then, confirm<a id="id425" class="indexterm"></a> that you <a id="id426" class="indexterm"></a>are sure you want to turn on developer mode.</p><div class="mediaobject"><img src="graphics/B05292_11_03.jpg" /></div></li><li><p>In the <code class="literal">MainPage.xaml</code> file, add the <code class="literal">Name</code> attribute to the <code class="literal">Grid</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;Grid Name="Grid" Background="{StaticResource  ApplicationPageBackgroundThemeBrush}"&gt;</pre></div></li><li><p>In the <code class="literal">MainPage.xaml.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;</pre></div></li><li><p>Add the<a id="id427" class="indexterm"></a> following code snippet above the <code class="literal">MainPage</code> constructor definition:</p><div class="informalexample"><pre class="programlisting">private readonly DispatcherTimer _timer;
private int _ticks;</pre></div></li><li><p>Replace<a id="id428" class="indexterm"></a> the <code class="literal">MainPage()</code> constructor with the following code snippet:</p><div class="informalexample"><pre class="programlisting">public MainPage()
{
  InitializeComponent();
  _timer = new DispatcherTimer();
  _ticks = 0;
}</pre></div></li><li><p>Add the <code class="literal">OnNavigatedTo()</code> method under the <code class="literal">MainPage</code> constructor definition:</p><div class="informalexample"><pre class="programlisting">protected override void OnNavigatedTo(NavigationEventArgs e)
{
}</pre></div></li><li><p>Add the following code snippet inside the <code class="literal">OnNavigatedTo</code> method:</p><div class="informalexample"><pre class="programlisting">base.OnNavigatedTo(e);Grid.Children.Clear();
var commonPanel = new StackPanel
{
  Orientation = Orientation.Vertical,
  HorizontalAlignment = HorizontalAlignment.Center
};

var buttonPanel = new StackPanel
{
  Orientation = Orientation.Horizontal,
  HorizontalAlignment = HorizontalAlignment.Center
};

var textBlock = new TextBlock
{
  Text = "Sample timer application",
  FontSize = 32,
  HorizontalAlignment = HorizontalAlignment.Center,
  Margin = new Thickness(40)
};

var timerTextBlock = new TextBlock
{
  Text = "0",
  FontSize = 32,
  HorizontalAlignment = HorizontalAlignment.Center,
  Margin = new Thickness(40)
};

var timerStateTextBlock = new TextBlock
{
  Text = "Timer is enabled",
  FontSize = 32,
  HorizontalAlignment = HorizontalAlignment.Center,
  Margin = new Thickness(40)
};

var startButton = new Button { Content = "Start",FontSize = 32};
var stopButton = new Button { Content = "Stop",FontSize = 32};

buttonPanel.Children.Add(startButton);
buttonPanel.Children.Add(stopButton);

commonPanel.Children.Add(textBlock);
commonPanel.Children.Add(timerTextBlock);
commonPanel.Children.Add(timerStateTextBlock);
commonPanel.Children.Add(buttonPanel);

_timer.Interval = TimeSpan.FromSeconds(1);
_timer.Tick += (sender, eventArgs) =&gt;
{
  timerTextBlock.Text = _ticks.ToString(); _ticks++;
};
_timer.Start();

startButton.Click += (sender, eventArgs) =&gt;
{
  timerTextBlock.Text = "0";
  _timer.Start();
  _ticks = 1;
  timerStateTextBlock.Text = "Timer is enabled";
};

stopButton.Click += (sender, eventArgs) =&gt;
{
  _timer.Stop();
  timerStateTextBlock.Text = "Timer is disabled";
};

Grid.Children.Add(commonPanel);</pre></div></li><li><p>Right-click on the project in Visual Studio <span class="strong"><strong>Solution Explorer</strong></span> and choose <span class="strong"><strong>Deploy</strong></span>.</p></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec223"></a>How it works...</h3></div></div></div><p>When the program runs, it <a id="id429" class="indexterm"></a>creates an instance of a <code class="literal">MainPage</code> class. Here, we instantiate <code class="literal">DispatcherTimer</code> in the constructor and initialize the <code class="literal">ticks</code> counter to <code class="literal">0</code>. Then, in the <code class="literal">OnNavigatedTo</code> event handler, we create our UI controls and bind the start and stop buttons to the corresponding lambda expressions, which contain the <code class="literal">start</code> and <code class="literal">stop</code> logics.</p><p>As you can <a id="id430" class="indexterm"></a>see, the <code class="literal">timer</code> event handler works directly with the UI controls. This is okay because <code class="literal">DispatcherTimer</code> is implemented in such a way that the handlers of the <code class="literal">Tick</code> event of <code class="literal">timer</code> are run by the UI thread. However, if you run the program and then switch to something else and then switch to the program after a couple of minutes, you may notice that the seconds counter is far behind the real amount of time that passed. This happens because Universal Windows Platform applications have completely different life cycles.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note29"></a>Note</h3><p>Be aware that Universal Windows Platform applications behave much like the applications on smartphone and tablet platforms. Instead of running in the background, they become suspended after some time, and this means that they are actually frozen until the user switches back to them. You have a limited time to save the current application state before it becomes suspended, and you are able to restore the state when the applications run again.</p></div><p>While this behavior could save power and CPU resources, it creates significant difficulties for program applications that are supposed to do some processing in the background. Windows 10 has a set of special APIs to program such applications. We will go through such a scenario later in this chapter.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec90"></a>Using WinRT from usual applications</h2></div></div><hr /></div><p>This recipe<a id="id431" class="indexterm"></a> shows you how to create a console application that will be able to use the WinRT API.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec224"></a>Getting ready</h3></div></div></div><p>To go through this recipe, you will need Visual Studio 2015 and the Windows 10 operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe2</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec225"></a>How to do it...</h3></div></div></div><p>To understand how to use WinRT from usual applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# console application project.</p></li><li><p>Right-click on the created project in Visual Studio <span class="strong"><strong>Solution Explorer</strong></span> and select the <span class="strong"><strong>Unload Projectâ€¦</strong></span> menu option.</p></li><li><p>Right-click on the unloaded project and select the <span class="strong"><strong>Edit ProjectName.csproj</strong></span> menu option.</p></li><li><p>Add the following XML code below the <code class="literal">&lt;TargetFrameworkVersion&gt;</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;TargetPlatformVersion&gt;10.0&lt;/TargetPlatformVersion&gt;</pre></div></li><li><p>Save the <code class="literal">.csproj</code> file, right-click on the unloaded project in Visual Studio <span class="strong"><strong>Solution Explorer</strong></span>, and select the <span class="strong"><strong>Reload Project</strong></span> menu option.</p></li><li><p>Right-click on the project and select <span class="strong"><strong>Add Reference</strong></span> from the <span class="strong"><strong>Core</strong></span> library under <span class="strong"><strong>Windows</strong></span>. Then, click on the <span class="strong"><strong>Browse</strong></span> button.</p></li><li><p>Navigate to <code class="literal">C:\Program Files (x86)\Windows Kits\10\UnionMetadata</code> and click on <code class="literal">Windows.winmd</code>.</p></li><li><p>Navigate to <code class="literal">C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5</code> and click on the <code class="literal">System.Runtime.WindowsRuntime.dll</code> file.</p></li><li><p>In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Threading.Tasks;
using Windows.Storage;</pre></div></li><li><p>Add the<a id="id432" class="indexterm"></a> following code snippet below the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">async static Task AsynchronousProcessing()
{
  StorageFolder folder = KnownFolders.DocumentsLibrary;

  if (await folder.DoesFileExistAsync("test.txt"))
  {
    var fileToDelete = await folder.GetFileAsync("test.txt");
    await fileToDelete.DeleteAsync(StorageDeleteOption.PermanentDelete);
  }

  var file = await folder.CreateFileAsync("test.txt",CreationCollisionOption.ReplaceExisting);
  using (var stream = await file.OpenAsync(FileAccessMode.ReadWrite))
  using (var writer = new StreamWriter(stream.AsStreamForWrite()))
  {
    await writer.WriteLineAsync("Test content");
    await writer.FlushAsync();
  }

  using (var stream = await file.OpenAsync(FileAccessMode.Read))
  using (var reader = new StreamReader(stream.AsStreamForRead()))
  {
    string content = await reader.ReadToEndAsync();
    Console.WriteLine(content);
  }

  Console.WriteLine("Enumerating Folder Structure:");

  var itemsList = await folder.GetItemsAsync();
  foreach (var item in itemsList)
  {
    if (item is StorageFolder)
    {
      Console.WriteLine("{0} folder", item.Name);
    }
    else
    {
      Console.WriteLine(item.Name);
    }
  }
}</pre></div></li><li><p>Add the following code snippet to the <code class="literal">Main</code> method:</p><div class="informalexample"><pre class="programlisting">var t = AsynchronousProcessing();
t.GetAwaiter().GetResult();
Console.WriteLine();
Console.WriteLine("Press ENTER to continue");
Console.ReadLine();</pre></div></li><li><p>Add the<a id="id433" class="indexterm"></a> following code snippet below the <code class="literal">Program</code> class definition:</p><div class="informalexample"><pre class="programlisting">static class Extensions
{
  public static async Task&lt;bool&gt; DoesFileExistAsync(thisStorageFolder folder, string fileName)
  {
    try
    {
      await folder.GetFileAsync(fileName);
      return true;
    }
    catch (FileNotFoundException)
    {
      return false;
    }
  }
}</pre></div></li><li><p>Run the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec226"></a>How it works...</h3></div></div></div><p>Here, we used quite a tricky way to consume the WinRT API from a common .NET console application. Unfortunately, not all available APIs will work in this scenario, but still, it could be useful to work with movement sensors, GPS location services, and so on.</p><p>To reference WinRT in Visual Studio, we manually edit the <code class="literal">.csproj</code> file, specifying the target platform for the application as Windows 10. Then, we manually reference <code class="literal">Windows.winmd</code> to get access to Windows 10 APIs and <code class="literal">System.Runtime.WindowsRuntime.dll</code> to leverage the <code class="literal">GetAwaiter</code> extension method implementation for WinRT asynchronous operations. This allows us to use <code class="literal">await</code> on WinRT APIs directly. There is a backward conversion as well. When we create a WinRT library, we have to expose the WinRT native <code class="literal">IAsyncOperation</code> interfaces family for asynchronous operations, so they could be consumed from JavaScript and C++ in a language-agnostic manner.</p><p>File operations<a id="id434" class="indexterm"></a> in WinRT are quite self-descriptive; here, we have asynchronous file create and delete operations. Still, file operations in WinRT contain security restrictions, encouraging you to use special Windows folders for your application and not allowing you to work with just any file path on your disk drive.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec91"></a>Using BackgroundTask in Universal Windows Platform applications</h2></div></div><hr /></div><p>This recipe walks<a id="id435" class="indexterm"></a> you through the<a id="id436" class="indexterm"></a> process of creating a background task in a Universal Windows Platform application, which updates the application's live tile on a desktop.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec227"></a>Getting ready</h3></div></div></div><p>To go through this recipe, you will need Visual Studio 2015 and the Windows 10 operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec228"></a>How to do it...</h3></div></div></div><p>To understand how to use <code class="literal">BackgroundTask</code> in Universal Windows Platform applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start Visual Studio 2015. Create a new C# <span class="strong"><strong>Blank App (Universal Windows)</strong></span> project under <code class="literal">Windows\Universal</code> folder. If you need to enable the Windows 10 developer mode, refer to the <span class="emphasis"><em>Using a timer in a Windows Store application</em></span> recipe for detailed instructions.</p></li><li><p>Open the <code class="literal">Package.appxmanifest</code> file. In the <span class="strong"><strong>Declarations</strong></span> tab, add <span class="strong"><strong>Background Tasks</strong></span> to <span class="strong"><strong>Supported Declarations</strong></span>. Under <span class="strong"><strong>Properties</strong></span>, check the supported properties <span class="strong"><strong>System event</strong></span> and <span class="strong"><strong>Timer</strong></span> and set the name of <span class="strong"><strong>Entry point</strong></span> to <code class="literal">YourNamespace.TileSchedulerTask</code>. <code class="literal">YourNamespace</code> should be the namespace of your application.</p><div class="mediaobject"><img src="graphics/B05292_11_04.jpg" /></div></li><li><p>In the <code class="literal">MainPage.xaml</code> file, insert the following XAML code into the <code class="literal">Grid</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;StackPanel Margin="50"&gt;
  &lt;TextBlock Name="Clock"
             Text="HH:mm"
             HorizontalAlignment="Center"
             VerticalAlignment="Center"
             Style="{StaticResource HeaderTextBlockStyle}"/&gt;
&lt;/StackPanel&gt;</pre></div></li><li><p>In the<a id="id437" class="indexterm"></a> <code class="literal">MainPage.xaml.cs</code> file, add<a id="id438" class="indexterm"></a> the following <code class="literal">using</code> directives:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Xml.Linq;
using Windows.ApplicationModel.Background;
using Windows.Data.Xml.Dom;
using Windows.System.UserProfile;
using Windows.UI.Notifications;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;</pre></div></li><li><p>Add the following code snippet above the <code class="literal">MainPage</code> constructor definition:</p><div class="informalexample"><pre class="programlisting">private const string TASK_NAME_USERPRESENT ="TileSchedulerTask_UserPresent";
private const string TASK_NAME_TIMER ="TileSchedulerTask_Timer";

private readonly CultureInfo _cultureInfo;
private readonly DispatcherTimer _timer;</pre></div></li><li><p>Replace the <a id="id439" class="indexterm"></a>
<code class="literal">MainPage</code> constructor with the following code snippet:</p><div class="informalexample"><pre class="programlisting">public MainPage()
{
InitializeComponent();

string language = GlobalizationPreferences.Languages.First();
_cultureInfo = new CultureInfo(language);

_timer = new DispatcherTimer();
_timer.Interval = TimeSpan.FromSeconds(1);
_timer.Tick += (sender, e) =&gt; UpdateClockText();
}</pre></div></li><li><p>Add the<a id="id440" class="indexterm"></a> following code snippet above the <code class="literal">OnNavigatedTo</code> method:</p><div class="informalexample"><pre class="programlisting">private void UpdateClockText()
{
  Clock.Text = DateTime.Now.ToString(_cultureInfo.DateTimeFormat.FullDateTimePattern);
}

private static async void CreateClockTask()
{
  BackgroundAccessStatus result = awaitBackgroundExecutionManager.RequestAccessAsync();
  if (result == BackgroundAccessStatus.AllowedMayUseActiveRealTimeConnectivity ||result == BackgroundAccessStatus.AllowedWithAlwaysOnRealTimeConnectivity)
  {
    TileSchedulerTask.CreateSchedule();

    EnsureUserPresentTask();
    EnsureTimerTask();
  }
}

private static void EnsureUserPresentTask()
{
  foreach (var task in BackgroundTaskRegistration.AllTasks)
    if (task.Value.Name == TASK_NAME_USERPRESENT)
      return;

  var builder = new BackgroundTaskBuilder();
  builder.Name = TASK_NAME_USERPRESENT;
  builder.TaskEntryPoint =(typeof(TileSchedulerTask)).FullName;
  builder.SetTrigger(new SystemTrigger(SystemTriggerType.UserPresent, false));
  builder.Register();
}

private static void EnsureTimerTask()
{
  foreach (var task in BackgroundTaskRegistration.AllTasks)
    if (task.Value.Name == TASK_NAME_TIMER)
      return;

  var builder = new BackgroundTaskBuilder();
  builder.Name = TASK_NAME_TIMER;
  builder.TaskEntryPoint = (typeof(TileSchedulerTask)).FullName;
  builder.SetTrigger(new TimeTrigger(180, false));
  builder.Register();
}</pre></div></li><li><p>Add the<a id="id441" class="indexterm"></a> following code <a id="id442" class="indexterm"></a>snippet to the <code class="literal">OnNavigatedTo</code> method:</p><div class="informalexample"><pre class="programlisting">_timer.Start();
UpdateClockText();
CreateClockTask();</pre></div></li><li><p>Add the following code snippet below the <code class="literal">MainPage</code> class definition:</p><div class="informalexample"><pre class="programlisting">public sealed class TileSchedulerTask : IBackgroundTask
{
  public void Run(IBackgroundTaskInstance taskInstance)
  {
    var deferral = taskInstance.GetDeferral();
    CreateSchedule();
    deferral.Complete();
  }

  public static void CreateSchedule()
  {
    var tileUpdater = TileUpdateManager.CreateTileUpdaterForApplication();
    var plannedUpdated = tileUpdater.GetScheduledTileNotifications();

    DateTime now = DateTime.Now;
    DateTime planTill = now.AddHours(4);

    DateTime updateTime = new DateTime(now.Year, now.Month,now.Day, now.Hour, now.Minute, 0).AddMinutes(1);
    if (plannedUpdated.Count &gt; 0)
      updateTime = plannedUpdated.Select(x =&gt;x.DeliveryTime.DateTime).Union(new[] { updateTime}).Max();
    XmlDocument documentNow = GetTilenotificationXml(now);

    tileUpdater.Update(new TileNotification(documentNow) {ExpirationTime = now.AddMinutes(1) });

    for (var startPlanning = updateTime;startPlanning &lt; planTill; startPlanning =startPlanning.AddMinutes(1))
    {
      Debug.WriteLine(startPlanning);
      Debug.WriteLine(planTill);

      try
      {
        XmlDocument document = GetTilenotificationXml(startPlanning);

        var scheduledNotification = newScheduledTileNotification(document,new DateTimeOffset(startPlanning))
        {
          ExpirationTime = startPlanning.AddMinutes(1)
        };

        tileUpdater.AddToSchedule(scheduledNotification);
      }
      catch (Exception ex)
      {
        Debug.WriteLine("Error: " + ex.Message);
      }
    }
  }

  private static XmlDocument GetTilenotificationXml(DateTime dateTime)
  {
    string language =GlobalizationPreferences.Languages.First();
    var cultureInfo = new CultureInfo(language);

    string shortDate = dateTime.ToString(cultureInfo.DateTimeFormat.ShortTimePattern);
    string longDate = dateTime.ToString(cultureInfo.DateTimeFormat.LongDatePattern);

    var document = XElement.Parse(string.Format(@"&lt;tile&gt;
    &lt;visual&gt;
      &lt;binding template=""TileSquareText02""&gt;
        &lt;text id=""1""&gt;{0}&lt;/text&gt;
        &lt;text id=""2""&gt;{1}&lt;/text&gt;
      &lt;/binding&gt;
      &lt;binding template=""TileWideText01""&gt;
        &lt;text id=""1""&gt;{0}&lt;/text&gt;
        &lt;text id=""2""&gt;{1}&lt;/text&gt;
        &lt;text id=""3""&gt;&lt;/text&gt;
        &lt;text id=""4""&gt;&lt;/text&gt;
      &lt;/binding&gt;  
    &lt;/visual&gt;
  &lt;/tile&gt;", shortDate, longDate));

    return document.ToXmlDocument();
  }
}

public static class DocumentExtensions
{
  public static XmlDocument ToXmlDocument(thisXElement xDocument)
  {
    var xmlDocument = new XmlDocument();
    xmlDocument.LoadXml(xDocument.ToString());
    return xmlDocument;
  }
}</pre></div></li><li><p>Run<a id="id443" class="indexterm"></a> the program.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec229"></a>How it works...</h3></div></div></div><p>The preceding program shows how to create a background time-based task and how to show the updates from this task on a live tile on the Windows 10 start menu. Programming Universal Windows Platform applications is quite a challenging task itselfâ€”you have to care about an application suspending/restoring its state and many other things. Here, we are going to concentrate on our main task, leaving behind the secondary issues.</p><p>Our main goal is<a id="id444" class="indexterm"></a> to run some code when the application itself is not in the foreground. First, we create an implementation of the <code class="literal">IBackgroundTask</code> interface. This is our code, and the <code class="literal">Run</code> method will be called when we get a trigger signal. It is important that if the <code class="literal">Run</code> method contains <a id="id445" class="indexterm"></a>asynchronous code with <code class="literal">await</code> in it, we have to use a special deferral object as shown in the recipe to explicitly specify when we begin and end the <code class="literal">Run</code> method execution. In our case, the method call is synchronous, but to illustrate this requirement, we work with the deferral object.</p><p>Inside our task in the <code class="literal">Run</code> method, we create a set of tile updates each minute for 4 hours and register it in <code class="literal">TileUpdateManager</code> with the help of the <code class="literal">ScheduledTaskNotification</code> class. A tile uses a special XML format to specify exactly how the text should be positioned in it. When we trigger our task from the system, it schedules one-minute tile updates for the next 4 hours. Then, we need to register our background task. We do this twice; one registration provides a <code class="literal">UserPresent</code> trigger, which means that this task will be triggered when a user is logged in. The next trigger is a time trigger, which runs the task once every 3 hours.</p><p>When the program runs, it creates a timer, which runs when the application is in the foreground. At the same time, it tries to register background tasks; to register these tasks, the program needs user permission, and it will show a dialog requesting permissions from the user. Now, we have scheduled live tile updates for the next 4 hours. If we close our application, the live tile will continue to show the new time every minute. In the next 3 hours, the time trigger will run our background task once again, and we will schedule another live tile update.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec92"></a>Running a .NET Core application on OS X</h2></div></div><hr /></div><p>This recipe<a id="id446" class="indexterm"></a> shows how to install a .NET Core application <a id="id447" class="indexterm"></a>on OS X and how to build and run a .NET console application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec230"></a>Getting ready</h3></div></div></div><p>To go through this recipe, you will need a Mac OS X operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe4</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec231"></a>How to do it...</h3></div></div></div><p>To understand how to run .NET Core applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Install .NET <a id="id448" class="indexterm"></a>Core on your OS X machine. You can visit <a class="ulink" href="http://dotnet.github.io/getting-started/" target="_blank">http://dotnet.github.io/getting-started/</a> and follow the installation instructions there. Since .NET Core is in the pre-release stage, the installation and usage scenarios could change before this book is published. Refer to the site instructions in that case.</p></li><li><p>After you have downloaded the <code class="literal">.pkg</code> file, hold the <span class="emphasis"><em>Control</em></span> key while opening it. It will unblock the file and will allow you to install it.</p></li><li><p>After you have installed the package, you will need to install OpenSSL. The easiest way is to install the homebrew package manager first. Open the terminal window and run the following command:</p><div class="informalexample"><pre class="programlisting">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</pre></div></li><li><p>Then, you can install OpenSSL by typing the following in it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>brew install openssl</strong></span>
</pre></div></li><li><p>There is also the small catch that .NET Core at the time of writing needs to increase the open files limit. This can be achieved by typing the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sysctl -w kern.maxfiles=20480</strong></span>
<span class="strong"><strong>sudo sysctl -w kern.maxfilesperproc=18000</strong></span>
<span class="strong"><strong>sudo ulimit -S -n 2048</strong></span>
</pre></div></li><li><p>Now you have installed .NET Core and are ready to go. To create a sample Hello World application, you can create a directory and create an empty application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir HelloWorld</strong></span>
<span class="strong"><strong>cd HelloWorld</strong></span>
<span class="strong"><strong>dotnet new</strong></span>
</pre></div></li><li><p>Let's check whether the default application works. To run the code, we have to restore dependencies and build and run the application. To achieve this, type the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dotnet restore</strong></span>
<span class="strong"><strong>dotnet run</strong></span>
</pre></div></li><li><p>Now, let's try<a id="id449" class="indexterm"></a> to run some asynchronous<a id="id450" class="indexterm"></a> code. In the <code class="literal">Program.cs</code> file, change the code to the following:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
namespace OSXConsoleApplication
{
  class Program
  {
    static void Main(string[] args)
    {
      WriteLine(".NET Core app on OS X");
      RunCodeAsync().GetAwaiter().GetResult();
    }
    static async Task RunCodeAsync()
    {
      try
      {
        string result = await GetInfoAsync("Async 1");
        WriteLine(result);
        result = await GetInfoAsync("Async 2");
        WriteLine(result);
      }
      catch (Exception ex)
      {
        WriteLine(ex);
      }
    }
    static async Task&lt;string&gt; GetInfoAsync(string name)
    {
      WriteLine($"Task {name} started!");
      await Task.Delay(TimeSpan.FromSeconds(2));
      if(name == "Async 2")
        throw new Exception("Boom!");
      return
          $"Task {name} completed successfully!"
// + $"Thread id {System.Threading.Thread.CurrentThread.ManagedThreadId}."
                    ;
    }
  }
}</pre></div></li><li><p>Run the program with the <code class="literal">dotnet run</code> command.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec232"></a>How it works...</h3></div></div></div><p>Here, we download a <code class="literal">.pkg</code> file with the .NET Core installation package from the site and install it. We also<a id="id451" class="indexterm"></a> install the OpenSSL library using the homebrew package manager (which also gets installed). Besides that, we increase the open files limit in OS X to be able to restore .NET Core dependencies.</p><p>Then, we create a<a id="id452" class="indexterm"></a> separate folder for the .NET Core application, create a blank console application, and check whether everything works fine with restoring dependencies and running the code.</p><p>Finally, we create a simple asynchronous code and try to run it. It should run well, showing the messages that the first task completed successfully. The second task caused an exception, which was correctly handled. But if you try to uncomment a line that is intended to show the thread-specific information, the code will not be compiled, since .NET Core has no support for Thread APIs.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec93"></a>Running a .NET Core application on Ubuntu Linux</h2></div></div><hr /></div><p>This recipe shows how<a id="id453" class="indexterm"></a> to install a .NET Core <a id="id454" class="indexterm"></a>application on Ubuntu and how to build and run a .NET console application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec233"></a>Getting ready</h3></div></div></div><p>To go through this recipe, you will need an Ubuntu Linux 14.04 operating system. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter11\Recipe5</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec234"></a>How to do it...</h3></div></div></div><p>To understand how to run .NET Core applications, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Install .NET Core on your Ubuntu machine. You can visit <a class="ulink" href="http://dotnet.github.io/getting-started/" target="_blank">http://dotnet.github.io/getting-started/</a> and follow the installation<a id="id455" class="indexterm"></a> instructions there. Since .NET Core is in the pre-release stage, the installation and usage scenarios could change by the time this book is published. Refer to the site instructions in that case.</p></li><li><p>First, open a terminal window and run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo sh -c 'echo "deb [arch=amd64] http://apt-mo.trafficmanager.net/repos/dotnet/ trusty main" &gt; /etc/apt/sources.list.d/dotnetdev.list'</strong></span>
<span class="strong"><strong>sudo apt-key adv --keyserver apt-mo.trafficmanager.net --recv-keys 417A0893</strong></span>
<span class="strong"><strong>sudo apt-get update</strong></span>
</pre></div></li><li><p>Then, you <a id="id456" class="indexterm"></a>can install .NET Core by typing the following in the terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install dotnet=1.0.0.001331-1</strong></span>
</pre></div></li><li><p>Now, you<a id="id457" class="indexterm"></a> have installed .NET Core and are ready to go. To create a sample Hello World application, you can create a directory and create an empty application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir HelloWorld</strong></span>
<span class="strong"><strong>cd HelloWorld</strong></span>
<span class="strong"><strong>dotnet new</strong></span>
</pre></div></li><li><p>Let's check whether the default application works. To run the code, we have to restore dependencies and build and run the application. To achieve this, type the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dotnet restore</strong></span>
<span class="strong"><strong>dotnet run</strong></span>
</pre></div></li><li><p>Now, let's try to run some asynchronous code. In the <code class="literal">Program.cs</code> file, change the code to the following:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
namespace OSXConsoleApplication
{
  class Program
  {
    static void Main(string[] args)
    {
      WriteLine(".NET Core app on Ubuntu");
      RunCodeAsync().GetAwaiter().GetResult();
    }
    static async Task RunCodeAsync()
    {
      try
      {
        string result = await GetInfoAsync("Async 1");
        WriteLine(result);
        result = await GetInfoAsync("Async 2");
        WriteLine(result);
      }
      catch (Exception ex)
      {
        WriteLine(ex);
      }
    }
    static async Task&lt;string&gt; GetInfoAsync(string name)
    {
      WriteLine($"Task {name} started!");
      await Task.Delay(TimeSpan.FromSeconds(2));
      if(name == "Async 2")
        throw new Exception("Boom!");
      return
          $"Task {name} completed successfully!"
// + $"Thread id {System.Threading.Thread.CurrentThread.ManagedThreadId}."
                    ;
    }
  }
}</pre></div></li><li><p>Run the program with <code class="literal">dotnet run</code> command.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec235"></a>How it works...</h3></div></div></div><p>Here, we start with setting up the apt-get feed that hosts the .NET Core packages that we need. This is<a id="id458" class="indexterm"></a> necessary since at the time of writing, .NET Core for Linux may not have been released. For sure, when the release <a id="id459" class="indexterm"></a>happens, it will get into normal apt-get feeds and you won't have to add custom feeds to it. After completing this, we use apt-get to install the currently working version of .NET Core.</p><p>Then, we create a separate folder for the .NET Core application, create a blank console application, and check whether everything works fine with restoring dependencies and running the code.</p><p>Finally, we create a simple asynchronous code and try to run it. It should run well, showing<a id="id460" class="indexterm"></a> messages that the first task completed <a id="id461" class="indexterm"></a>successfully, and the second task caused an exception, which was correctly handled. But if you try to uncomment a line that is intended to show the thread-specific information, the code will not be compiled, since .NET Core has no support for Thread APIs.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">

    <div id="backindex">
      <h1 class="title">Index</h1>
      <h2>A</h2>
      <ul>
        <li>abstraction layer<ul><li>about / <a href="#ch04lvl1sec38" title="Introduction" class="link">Introduction</a></li></ul></li>
        <li>APM pattern<ul><li>converting, to task / <a href="#ch04lvl1sec42" title="Converting the APM pattern to tasks" class="link">Converting the APM pattern to tasks</a>, <a href="#ch04lvl1sec42" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec42" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>AsOrdered method / <a href="#ch07lvl1sec67" title="How it works..." class="link">How it works...</a></li>
        <li>asynchronous functions<ul><li>about / <a href="#ch05lvl1sec48" title="Introduction" class="link">Introduction</a></li><li>creating / <a href="#ch05lvl1sec48" title="Introduction" class="link">Introduction</a></li></ul></li>
        <li>asynchronous HTTP server and client<ul><li>writing / <a href="#ch09lvl1sec80" title="Writing an asynchronous HTTP server and client" class="link">Writing an asynchronous HTTP server and client</a>, <a href="#ch09lvl1sec80" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>asynchronous I/O operations<ul><li>applications / <a href="#ch09lvl1sec78" title="Introduction" class="link">Introduction</a></li></ul></li>
        <li>asynchronous Observable<ul><li>collection, converting to / <a href="#ch08lvl1sec72" title="Converting a collection to an asynchronous Observable" class="link">Converting a collection to an asynchronous Observable</a>, <a href="#ch08lvl1sec72" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec72" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>asynchronous operation<ul><li>posting, on thread pool / <a href="#ch03lvl1sec32" title="Posting an asynchronous operation on a thread pool" class="link">Posting an asynchronous operation on a thread pool</a>, <a href="#ch03lvl1sec32" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec32" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>asynchronous operations<ul><li>exceptions, handling / <a href="#ch05lvl1sec53" title="Handling exceptions in asynchronous operations" class="link">Handling exceptions in asynchronous operations</a>, <a href="#ch05lvl1sec53" title="How it works..." class="link">How it works...</a></li><li>creating, Rx used / <a href="#ch08lvl1sec77" title="Creating asynchronous operations with Rx" class="link">Creating asynchronous operations with Rx</a>, <a href="#ch08lvl1sec77" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec77" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>asynchronous processing<ul><li>implementing, ConcurrentQueue used / <a href="#ch06lvl1sec60" title="Implementing asynchronous processing using ConcurrentQueue" class="link">Implementing asynchronous processing using ConcurrentQueue</a>, <a href="#ch06lvl1sec60" title="How to do it..." class="link">How to do it...</a>, <a href="#ch06lvl1sec60" title="How it works..." class="link">How it works...</a></li><li>generalizing, BlockingCollection used / <a href="#ch06lvl1sec63" title="Generalizing asynchronous processing with BlockingCollection" class="link">Generalizing asynchronous processing with BlockingCollection</a>, <a href="#ch06lvl1sec63" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>asynchronous processing order<ul><li>changing, ConcurrentStack used / <a href="#ch06lvl1sec61" title="Changing asynchronous processing order with ConcurrentStack" class="link">Changing asynchronous processing order with ConcurrentStack</a>, <a href="#ch06lvl1sec61" title="How to do it..." class="link">How to do it...</a>, <a href="#ch06lvl1sec61" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Asynchronous Programming Model (APM) / <a href="#ch03lvl1sec31" title="Invoking a delegate on a thread pool" class="link">Invoking a delegate on a thread pool</a></li>
        <li>asynchronous task results<ul><li>obtaining, with await operator / <a href="#ch05lvl1sec49" title="Using the await operator to get asynchronous task results" class="link">Using the await operator to get asynchronous task results</a>, <a href="#ch05lvl1sec49" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>async operators<ul><li>disadvantages / <a href="#ch05lvl1sec48" title="Introduction" class="link">Introduction</a></li></ul></li>
        <li>async void method<ul><li>working with / <a href="#ch05lvl1sec55" title="Working around the async void method" class="link">Working around the async void method</a>, <a href="#ch05lvl1sec55" title="How to do it..." class="link">How to do it...</a>, <a href="#ch05lvl1sec55" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>atomic operations<ul><li>about / <a href="#ch02lvl1sec20" title="Introduction" class="link">Introduction</a></li><li>performing / <a href="#ch02lvl1sec21" title="Performing basic atomic operations" class="link">Performing basic atomic operations</a>, <a href="#ch02lvl1sec21" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec21" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>AutoResetEvent construct<ul><li>using / <a href="#ch02lvl1sec24" title="Using the AutoResetEvent construct" class="link">Using the AutoResetEvent construct</a>, <a href="#ch02lvl1sec24" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec24" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>await operator<ul><li>disadvantages / <a href="#ch05lvl1sec48" title="Introduction" class="link">Introduction</a></li><li>used, for obtaining asynchronous task results / <a href="#ch05lvl1sec49" title="Using the await operator to get asynchronous task results" class="link">Using the await operator to get asynchronous task results</a>, <a href="#ch05lvl1sec49" title="How it works..." class="link">How it works...</a></li><li>using, in lambda expression / <a href="#ch05lvl1sec50" title="Using the await operator in a lambda expression" class="link">Using the await operator in a lambda expression</a>, <a href="#ch05lvl1sec50" title="How it works..." class="link">How it works...</a></li><li>using, with consequent asynchronous tasks / <a href="#ch05lvl1sec51" title="Using the await operator with consequent asynchronous tasks" class="link">Using the await operator with consequent asynchronous tasks</a>, <a href="#ch05lvl1sec51" title="How it works..." class="link">How it works...</a></li><li>used, for parallel asynchronous tasks execution / <a href="#ch05lvl1sec52" title="Using the await operator for the execution of parallel asynchronous tasks" class="link">Using the await operator for the execution of parallel asynchronous tasks</a>, <a href="#ch05lvl1sec52" title="How it works..." class="link">How it works...</a></li><li>dynamic type, using with / <a href="#ch05lvl1sec57" title="Using the dynamic type with await" class="link">Using the dynamic type with await</a>, <a href="#ch05lvl1sec57" title="How to do it..." class="link">How to do it...</a>, <a href="#ch05lvl1sec57" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>B</h2>
      <ul>
        <li>BackgroundTask<ul><li>using, in Universal Windows Platform applications / <a href="#ch11lvl1sec91" title="Using BackgroundTask in Universal Windows Platform applications" class="link">Using BackgroundTask in Universal Windows Platform applications</a>, <a href="#ch11lvl1sec91" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec91" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>BackgroundWorker component<ul><li>using / <a href="#ch03lvl1sec37" title="Using the BackgroundWorker component" class="link">Using the BackgroundWorker component</a>, <a href="#ch03lvl1sec37" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec37" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Barrier construct<ul><li>using / <a href="#ch02lvl1sec27" title="Using the Barrier construct" class="link">Using the Barrier construct</a>, <a href="#ch02lvl1sec27" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec27" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>basic operations<ul><li>performing, with task / <a href="#ch04lvl1sec40" title="Performing basic operations with a task" class="link">Performing basic operations with a task</a>, <a href="#ch04lvl1sec40" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec40" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>BlockingCollection<ul><li>about / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li><li>used, for generalizing asynchronous processing / <a href="#ch06lvl1sec63" title="Generalizing asynchronous processing with BlockingCollection" class="link">Generalizing asynchronous processing with BlockingCollection</a>, <a href="#ch06lvl1sec63" title="How it works..." class="link">How it works...</a></li><li>used, for implementing Parallel Pipeline / <a href="#ch10lvl1sec85" title="Implementing Parallel Pipeline with BlockingCollection" class="link">Implementing Parallel Pipeline with BlockingCollection</a>, <a href="#ch10lvl1sec85" title="How to do it..." class="link">How to do it...</a>, <a href="#ch10lvl1sec85" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>C</h2>
      <ul>
        <li>C#<ul><li>thread, creating / <a href="#ch01lvl1sec09" title="Creating a thread in C#" class="link">Creating a thread in C#</a>, <a href="#ch01lvl1sec09" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec09" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>C# lock keyword<ul><li>used, for locking / <a href="#ch01lvl1sec17" title="Locking with a C# lock keyword" class="link">Locking with a C# lock keyword</a>, <a href="#ch01lvl1sec17" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec17" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>callback<ul><li>registering / <a href="#ch03lvl1sec34" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>cancelation option<ul><li>implementing / <a href="#ch04lvl1sec44" title="Implementing a cancelation option" class="link">Implementing a cancelation option</a>, <a href="#ch04lvl1sec44" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec44" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>cancellation option<ul><li>implementing / <a href="#ch03lvl1sec34" title="Implementing a cancellation option" class="link">Implementing a cancellation option</a>, <a href="#ch03lvl1sec34" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec34" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>captured synchronization context<ul><li>use, avoiding / <a href="#ch05lvl1sec54" title="Avoiding the use of the captured synchronization context" class="link">Avoiding the use of the captured synchronization context</a>, <a href="#ch05lvl1sec54" title="How to do it..." class="link">How to do it...</a>, <a href="#ch05lvl1sec54" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>closure mechanics / <a href="#ch03lvl1sec32" title="How it works..." class="link">How it works...</a></li>
        <li>coarse-grained locking / <a href="#ch06lvl1sec59" title="How it works..." class="link">How it works...</a></li>
        <li>collection<ul><li>converting, to asynchronous Observable / <a href="#ch08lvl1sec72" title="Converting a collection to an asynchronous Observable" class="link">Converting a collection to an asynchronous Observable</a>, <a href="#ch08lvl1sec72" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec72" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Common Language Runtime (CLR) / <a href="#ch03lvl1sec30" title="Introduction" class="link">Introduction</a></li>
        <li>Compare and Swap (CAS) / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li>
        <li>ConcurrentBag<ul><li>used, for creating scalable crawler / <a href="#ch06lvl1sec62" title="Creating a scalable crawler with ConcurrentBag" class="link">Creating a scalable crawler with ConcurrentBag</a>, <a href="#ch06lvl1sec62" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>ConcurrentDictionary<ul><li>about / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li><li>using / <a href="#ch06lvl1sec59" title="Using ConcurrentDictionary" class="link">Using ConcurrentDictionary</a>, <a href="#ch06lvl1sec59" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>ConcurrentQueue<ul><li>used, for implementing asynchronous processing / <a href="#ch06lvl1sec60" title="Implementing asynchronous processing using ConcurrentQueue" class="link">Implementing asynchronous processing using ConcurrentQueue</a>, <a href="#ch06lvl1sec60" title="How to do it..." class="link">How to do it...</a></li></ul></li>
        <li>ConcurrentStack<ul><li>used, for changing asynchronous processing order / <a href="#ch06lvl1sec61" title="Changing asynchronous processing order with ConcurrentStack" class="link">Changing asynchronous processing order with ConcurrentStack</a>, <a href="#ch06lvl1sec61" title="How to do it..." class="link">How to do it...</a>, <a href="#ch06lvl1sec61" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>consequent asynchronous tasks<ul><li>await operator, using with / <a href="#ch05lvl1sec51" title="Using the await operator with consequent asynchronous tasks" class="link">Using the await operator with consequent asynchronous tasks</a>, <a href="#ch05lvl1sec51" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>context switch / <a href="#ch02lvl1sec20" title="Introduction" class="link">Introduction</a></li>
        <li>continuation / <a href="#ch04lvl1sec41" title="How it works..." class="link">How it works...</a></li>
        <li>CountDownEvent construct<ul><li>using / <a href="#ch02lvl1sec26" title="Using the CountDownEvent construct" class="link">Using the CountDownEvent construct</a>, <a href="#ch02lvl1sec26" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>custom aggregator<ul><li>creating, for PLINQ query / <a href="#ch07lvl1sec70" title="Creating a custom aggregator for a PLINQ query" class="link">Creating a custom aggregator for a PLINQ query</a>, <a href="#ch07lvl1sec70" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec70" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>custom awaitable type<ul><li>designing / <a href="#ch05lvl1sec56" title="Designing a custom awaitable type" class="link">Designing a custom awaitable type</a>, <a href="#ch05lvl1sec56" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>custom Observable<ul><li>writing / <a href="#ch08lvl1sec73" title="Writing custom Observable" class="link">Writing custom Observable</a>, <a href="#ch08lvl1sec73" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec73" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>D</h2>
      <ul>
        <li>database<ul><li>working with, asynchronously / <a href="#ch09lvl1sec81" title="Working with a database asynchronously" class="link">Working with a database asynchronously</a>, <a href="#ch09lvl1sec81" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>data parallelism / <a href="#ch07lvl1sec64" title="Introduction" class="link">Introduction</a></li>
        <li>data partitioning<ul><li>managing in PLINQ query / <a href="#ch07lvl1sec69" title="Managing data partitioning in a PLINQ query" class="link">Managing data partitioning in a PLINQ query</a>, <a href="#ch07lvl1sec69" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec69" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>degree of parallelism<ul><li>and thread pool / <a href="#ch03lvl1sec33" title="A thread pool and the degree of parallelism" class="link">A thread pool and the degree of parallelism</a>, <a href="#ch03lvl1sec33" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec33" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>delegate<ul><li>about / <a href="#ch03lvl1sec30" title="Introduction" class="link">Introduction</a></li><li>invoking, on thread pool / <a href="#ch03lvl1sec31" title="Invoking a delegate on a thread pool" class="link">Invoking a delegate on a thread pool</a>, <a href="#ch03lvl1sec31" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec31" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>double-checked locking pattern / <a href="#ch10lvl1sec84" title="How it works..." class="link">How it works...</a></li>
        <li>dynamic type<ul><li>using, with await operator / <a href="#ch05lvl1sec57" title="Using the dynamic type with await" class="link">Using the dynamic type with await</a>, <a href="#ch05lvl1sec57" title="How to do it..." class="link">How to do it...</a>, <a href="#ch05lvl1sec57" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>E</h2>
      <ul>
        <li>EAP pattern<ul><li>converting, to task / <a href="#ch04lvl1sec43" title="Converting the EAP pattern to tasks" class="link">Converting the EAP pattern to tasks</a>, <a href="#ch04lvl1sec43" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Enqueue method / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li>
        <li>Event-based Asynchronous Pattern (EAP) / <a href="#ch03lvl1sec37" title="How it works..." class="link">How it works...</a></li>
        <li>event handlers / <a href="#ch03lvl1sec37" title="How it works..." class="link">How it works...</a></li>
        <li>events / <a href="#ch03lvl1sec37" title="How it works..." class="link">How it works...</a></li>
        <li>exception handling, in task<ul><li>about / <a href="#ch04lvl1sec45" title="Getting ready" class="link">Getting ready</a>, <a href="#ch04lvl1sec45" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>exceptions<ul><li>handling / <a href="#ch01lvl1sec19" title="Handling exceptions" class="link">Handling exceptions</a>, <a href="#ch01lvl1sec19" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>exceptions, asynchronous operations<ul><li>handling / <a href="#ch05lvl1sec53" title="Handling exceptions in asynchronous operations" class="link">Handling exceptions in asynchronous operations</a>, <a href="#ch05lvl1sec53" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>exceptions, PLINQ query<ul><li>handling / <a href="#ch07lvl1sec68" title="Getting ready" class="link">Getting ready</a>, <a href="#ch07lvl1sec68" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec68" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>F</h2>
      <ul>
        <li>files<ul><li>working with, asynchronously / <a href="#ch09lvl1sec79" title="Working with files asynchronously" class="link">Working with files asynchronously</a>, <a href="#ch09lvl1sec79" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>fine-grained locking technique / <a href="#ch06lvl1sec59" title="How it works..." class="link">How it works...</a></li>
        <li>First In, First Out (FIFO) / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>G</h2>
      <ul>
        <li>Gutenberg<ul><li>website link / <a href="#ch10lvl1sec87" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>H</h2>
      <ul>
        <li>hybrid constructs / <a href="#ch02lvl1sec20" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>I</h2>
      <ul>
        <li>I/O threads / <a href="#ch03lvl1sec30" title="Introduction" class="link">Introduction</a></li>
        <li>iterators / <a href="#ch05lvl1sec48" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>K</h2>
      <ul>
        <li>kernel-mode constructs / <a href="#ch02lvl1sec20" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>L</h2>
      <ul>
        <li>lambda expression / <a href="#ch03lvl1sec31" title="How it works..." class="link">How it works...</a><ul><li>await operator, using / <a href="#ch05lvl1sec50" title="Using the await operator in a lambda expression" class="link">Using the await operator in a lambda expression</a>, <a href="#ch05lvl1sec50" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Last In, First Out (LIFO) / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li>
        <li>Lazy-evaluated shared states<ul><li>implementing / <a href="#ch10lvl1sec84" title="Implementing Lazy-evaluated shared states" class="link">Implementing Lazy-evaluated shared states</a>, <a href="#ch10lvl1sec84" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>LazyInitializer.EnsureInitialized method / <a href="#ch10lvl1sec84" title="How it works..." class="link">How it works...</a></li>
        <li>LINQ queries<ul><li>using, against observable collection / <a href="#ch08lvl1sec76" title="Using LINQ queries against an observable collection" class="link">Using LINQ queries against an observable collection</a>, <a href="#ch08lvl1sec76" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec76" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>LINQ query<ul><li>parallelizing / <a href="#ch07lvl1sec66" title="Parallelizing a LINQ query" class="link">Parallelizing a LINQ query</a>, <a href="#ch07lvl1sec66" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec66" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>M</h2>
      <ul>
        <li>ManualResetEventSlim construct<ul><li>using / <a href="#ch02lvl1sec25" title="Using the ManualResetEventSlim construct" class="link">Using the ManualResetEventSlim construct</a>, <a href="#ch02lvl1sec25" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec25" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Map/Reduce pattern<ul><li>about / <a href="#ch10lvl1sec83" title="Introduction" class="link">Introduction</a></li><li>implementing, with PLINQ / <a href="#ch10lvl1sec87" title="Implementing Map/Reduce with PLINQ" class="link">Implementing Map/Reduce with PLINQ</a>, <a href="#ch10lvl1sec87" title="How to do it..." class="link">How to do it...</a>, <a href="#ch10lvl1sec87" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>monitor construct<ul><li>locking with / <a href="#ch01lvl1sec18" title="Locking with a Monitor construct" class="link">Locking with a Monitor construct</a>, <a href="#ch01lvl1sec18" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec18" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Mutex construct<ul><li>using / <a href="#ch02lvl1sec22" title="Using the Mutex construct" class="link">Using the Mutex construct</a>, <a href="#ch02lvl1sec22" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>N</h2>
      <ul>
        <li>.NET Core<ul><li>on OS X, installation link / <a href="#ch11lvl1sec92" title="How to do it..." class="link">How to do it...</a></li><li>on Ubuntu machine, installation link / <a href="#ch11lvl1sec93" title="How to do it..." class="link">How to do it...</a></li></ul></li>
        <li>.NET Core application<ul><li>running, on OS X / <a href="#ch11lvl1sec92" title="Running a .NET Core application on OS X" class="link">Running a .NET Core application on OS X</a>, <a href="#ch11lvl1sec92" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec92" title="How it works..." class="link">How it works...</a></li><li>running, on Ubuntu Linux / <a href="#ch11lvl1sec93" title="Running a .NET Core application on Ubuntu Linux" class="link">Running a .NET Core application on Ubuntu Linux</a>, <a href="#ch11lvl1sec93" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec93" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>.NET thread pool / <a href="#ch03lvl1sec30" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>O</h2>
      <ul>
        <li>observable collection<ul><li>LINQ queries, using against / <a href="#ch08lvl1sec76" title="Using LINQ queries against an observable collection" class="link">Using LINQ queries against an observable collection</a>, <a href="#ch08lvl1sec76" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Observable object<ul><li>creating / <a href="#ch08lvl1sec75" title="Creating an Observable object" class="link">Creating an Observable object</a>, <a href="#ch08lvl1sec75" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec75" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>OS X<ul><li>.NET Core application, running / <a href="#ch11lvl1sec92" title="Running a .NET Core application on OS X" class="link">Running a .NET Core application on OS X</a>, <a href="#ch11lvl1sec92" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec92" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>P</h2>
      <ul>
        <li>parallel asynchronous tasks<ul><li>executing, await operator used / <a href="#ch05lvl1sec52" title="Getting ready" class="link">Getting ready</a>, <a href="#ch05lvl1sec52" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Parallel class<ul><li>using / <a href="#ch07lvl1sec65" title="Using the Parallel class" class="link">Using the Parallel class</a>, <a href="#ch07lvl1sec65" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Parallel Framework Extensions (PFX) / <a href="#ch07lvl1sec64" title="Introduction" class="link">Introduction</a></li>
        <li>Parallel Pipeline<ul><li>about / <a href="#ch10lvl1sec83" title="Introduction" class="link">Introduction</a></li><li>implementing, with BlockingCollection / <a href="#ch10lvl1sec85" title="Implementing Parallel Pipeline with BlockingCollection" class="link">Implementing Parallel Pipeline with BlockingCollection</a>, <a href="#ch10lvl1sec85" title="How to do it..." class="link">How to do it...</a>, <a href="#ch10lvl1sec85" title="How it works..." class="link">How it works...</a></li><li>implementing, with TPL DataFlow / <a href="#ch10lvl1sec86" title="Implementing Parallel Pipeline with TPL DataFlow" class="link">Implementing Parallel Pipeline with TPL DataFlow</a>, <a href="#ch10lvl1sec86" title="How to do it..." class="link">How to do it...</a>, <a href="#ch10lvl1sec86" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>parameters<ul><li>passing, to thread / <a href="#ch01lvl1sec16" title="Passing parameters to a thread" class="link">Passing parameters to a thread</a>, <a href="#ch01lvl1sec16" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec16" title="There's moreâ€¦" class="link">There's moreâ€¦</a></li></ul></li>
        <li>parameters, PLINQ query<ul><li>tweaking / <a href="#ch07lvl1sec67" title="Tweaking the parameters of a PLINQ query" class="link">Tweaking the parameters of a PLINQ query</a>, <a href="#ch07lvl1sec67" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec67" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>PLINQ<ul><li>used, for implementing Map/Reduce / <a href="#ch10lvl1sec87" title="Getting ready" class="link">Getting ready</a>, <a href="#ch10lvl1sec87" title="How to do it..." class="link">How to do it...</a>, <a href="#ch10lvl1sec87" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>PLINQ query<ul><li>parameters, tweaking / <a href="#ch07lvl1sec67" title="Tweaking the parameters of a PLINQ query" class="link">Tweaking the parameters of a PLINQ query</a>, <a href="#ch07lvl1sec67" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec67" title="How it works..." class="link">How it works...</a></li><li>exceptions, handling / <a href="#ch07lvl1sec68" title="Handling exceptions in a PLINQ query" class="link">Handling exceptions in a PLINQ query</a>, <a href="#ch07lvl1sec68" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec68" title="How it works..." class="link">How it works...</a></li><li>data partitioning, managing / <a href="#ch07lvl1sec69" title="Managing data partitioning in a PLINQ query" class="link">Managing data partitioning in a PLINQ query</a>, <a href="#ch07lvl1sec69" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec69" title="How it works..." class="link">How it works...</a></li><li>custom aggregator, creating / <a href="#ch07lvl1sec70" title="Creating a custom aggregator for a PLINQ query" class="link">Creating a custom aggregator for a PLINQ query</a>, <a href="#ch07lvl1sec70" title="How to do it..." class="link">How to do it...</a>, <a href="#ch07lvl1sec70" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>pooling / <a href="#ch03lvl1sec30" title="Introduction" class="link">Introduction</a></li>
        <li>pull-based approach / <a href="#ch08lvl1sec71" title="Introduction" class="link">Introduction</a></li>
        <li>push-based approach / <a href="#ch08lvl1sec71" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>R</h2>
      <ul>
        <li>Reactive Extensions (Rx)<ul><li>about / <a href="#ch08lvl1sec71" title="Introduction" class="link">Introduction</a></li><li>used, for creating asynchronous operations / <a href="#ch08lvl1sec77" title="Creating asynchronous operations with Rx" class="link">Creating asynchronous operations with Rx</a>, <a href="#ch08lvl1sec77" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec77" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>ReaderWriterLockSlim construct<ul><li>using / <a href="#ch02lvl1sec28" title="Using the ReaderWriterLockSlim construct" class="link">Using the ReaderWriterLockSlim construct</a>, <a href="#ch02lvl1sec28" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>S</h2>
      <ul>
        <li>scalable crawler<ul><li>creating, ConcurrentBag used / <a href="#ch06lvl1sec62" title="Creating a scalable crawler with ConcurrentBag" class="link">Creating a scalable crawler with ConcurrentBag</a>, <a href="#ch06lvl1sec62" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>SemaphoreSlim construct<ul><li>using / <a href="#ch02lvl1sec23" title="Using the SemaphoreSlim construct" class="link">Using the SemaphoreSlim construct</a>, <a href="#ch02lvl1sec23" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec23" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>shared-state object / <a href="#ch10lvl1sec83" title="Introduction" class="link">Introduction</a></li>
        <li>Simple Object Access Protocol (SOAP) / <a href="#ch09lvl1sec82" title="How it works..." class="link">How it works...</a></li>
        <li>SpinWait construct<ul><li>using / <a href="#ch02lvl1sec29" title="Using the SpinWait construct" class="link">Using the SpinWait construct</a>, <a href="#ch02lvl1sec29" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>structured parallelism / <a href="#ch07lvl1sec64" title="Introduction" class="link">Introduction</a></li>
        <li>Subjects type<ul><li>using / <a href="#ch08lvl1sec74" title="Using the Subject type family" class="link">Using the Subject type family</a>, <a href="#ch08lvl1sec74" title="How to do it..." class="link">How to do it...</a>, <a href="#ch08lvl1sec74" title="How it works..." class="link">How it works...</a></li></ul></li>
      </ul>
      <h2>T</h2>
      <ul>
        <li>task<ul><li>about / <a href="#ch04lvl1sec38" title="Introduction" class="link">Introduction</a></li><li>creating / <a href="#ch04lvl1sec39" title="Creating a task" class="link">Creating a task</a>, <a href="#ch04lvl1sec39" title="How it works..." class="link">How it works...</a></li><li>basic operations, performing with / <a href="#ch04lvl1sec40" title="Performing basic operations with a task" class="link">Performing basic operations with a task</a>, <a href="#ch04lvl1sec40" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec40" title="How it works..." class="link">How it works...</a></li><li>combining / <a href="#ch04lvl1sec41" title="Combining tasks" class="link">Combining tasks</a>, <a href="#ch04lvl1sec41" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec41" title="How it works..." class="link">How it works...</a></li><li>APM pattern, converting to / <a href="#ch04lvl1sec42" title="Converting the APM pattern to tasks" class="link">Converting the APM pattern to tasks</a>, <a href="#ch04lvl1sec42" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec42" title="How it works..." class="link">How it works...</a></li><li>EAP pattern, converting to / <a href="#ch04lvl1sec43" title="Converting the EAP pattern to tasks" class="link">Converting the EAP pattern to tasks</a>, <a href="#ch04lvl1sec43" title="How it works..." class="link">How it works...</a></li><li>exception handling / <a href="#ch04lvl1sec45" title="Handling exceptions in tasks" class="link">Handling exceptions in tasks</a>, <a href="#ch04lvl1sec45" title="How it works..." class="link">How it works...</a></li><li>running, in parallel / <a href="#ch04lvl1sec46" title="Running tasks in parallel" class="link">Running tasks in parallel</a>, <a href="#ch04lvl1sec46" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec46" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>task execution<ul><li>tweaking, with TaskScheduler / <a href="#ch04lvl1sec47" title="Tweaking the execution of tasks with TaskScheduler" class="link">Tweaking the execution of tasks with TaskScheduler</a>, <a href="#ch04lvl1sec47" title="How to do it..." class="link">How to do it...</a>, <a href="#ch04lvl1sec47" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>task parallelism / <a href="#ch07lvl1sec64" title="Introduction" class="link">Introduction</a></li>
        <li>Task Parallel Library / <a href="#ch05lvl1sec48" title="Introduction" class="link">Introduction</a></li>
        <li>Task Parallel Library (TPL) / <a href="#ch03lvl1sec31" title="How it works..." class="link">How it works...</a></li>
        <li>task scheduler / <a href="#ch04lvl1sec39" title="How it works..." class="link">How it works...</a></li>
        <li>thread<ul><li>creating, in C# / <a href="#ch01lvl1sec09" title="Creating a thread in C#" class="link">Creating a thread in C#</a>, <a href="#ch01lvl1sec09" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec09" title="How it works..." class="link">How it works...</a></li><li>pausing / <a href="#ch01lvl1sec10" title="Pausing a thread" class="link">Pausing a thread</a>, <a href="#ch01lvl1sec10" title="How it works..." class="link">How it works...</a></li><li>making, wait / <a href="#ch01lvl1sec11" title="Making a thread wait" class="link">Making a thread wait</a>, <a href="#ch01lvl1sec11" title="How it works..." class="link">How it works...</a></li><li>aborting / <a href="#ch01lvl1sec12" title="Aborting a thread" class="link">Aborting a thread</a>, <a href="#ch01lvl1sec12" title="How it works..." class="link">How it works...</a></li><li>state, determining / <a href="#ch01lvl1sec13" title="Determining a thread state" class="link">Determining a thread state</a>, <a href="#ch01lvl1sec13" title="How it works..." class="link">How it works...</a></li><li>priority / <a href="#ch01lvl1sec14" title="Thread priority" class="link">Thread priority</a>, <a href="#ch01lvl1sec14" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec14" title="How it works..." class="link">How it works...</a></li><li>foreground / <a href="#ch01lvl1sec15" title="Foreground and background threads" class="link">Foreground and background threads</a>, <a href="#ch01lvl1sec15" title="How to do it..." class="link">How to do it...</a></li><li>background / <a href="#ch01lvl1sec15" title="Foreground and background threads" class="link">Foreground and background threads</a>, <a href="#ch01lvl1sec15" title="How it works..." class="link">How it works...</a></li><li>parameters, passing / <a href="#ch01lvl1sec16" title="Passing parameters to a thread" class="link">Passing parameters to a thread</a>, <a href="#ch01lvl1sec16" title="How to do it..." class="link">How to do it...</a>, <a href="#ch01lvl1sec16" title="There's moreâ€¦" class="link">There's moreâ€¦</a></li><li>cancellation option, implementing / <a href="#ch03lvl1sec34" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec34" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>thread pool<ul><li>delegate, invoking / <a href="#ch03lvl1sec31" title="Invoking a delegate on a thread pool" class="link">Invoking a delegate on a thread pool</a>, <a href="#ch03lvl1sec31" title="How it works..." class="link">How it works...</a></li><li>asynchronous operation, posting / <a href="#ch03lvl1sec32" title="Posting an asynchronous operation on a thread pool" class="link">Posting an asynchronous operation on a thread pool</a>, <a href="#ch03lvl1sec32" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec32" title="How it works..." class="link">How it works...</a></li><li>and degree of parallelism / <a href="#ch03lvl1sec33" title="A thread pool and the degree of parallelism" class="link">A thread pool and the degree of parallelism</a>, <a href="#ch03lvl1sec33" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec33" title="How it works..." class="link">How it works...</a></li><li>wait handle, using / <a href="#ch03lvl1sec35" title="Using a wait handle and timeout with a thread pool" class="link">Using a wait handle and timeout with a thread pool</a>, <a href="#ch03lvl1sec35" title="How it works..." class="link">How it works...</a></li><li>timeout, using / <a href="#ch03lvl1sec35" title="Getting ready" class="link">Getting ready</a>, <a href="#ch03lvl1sec35" title="How it works..." class="link">How it works...</a>, <a href="#ch03lvl1sec35" title="There's moreâ€¦" class="link">There's moreâ€¦</a></li></ul></li>
        <li>thread synchronization<ul><li>about / <a href="#ch02lvl1sec20" title="Introduction" class="link">Introduction</a></li><li>Mutex construct / <a href="#ch02lvl1sec22" title="Using the Mutex construct" class="link">Using the Mutex construct</a>, <a href="#ch02lvl1sec22" title="How it works..." class="link">How it works...</a></li><li>SemaphoreSlim construct / <a href="#ch02lvl1sec23" title="Using the SemaphoreSlim construct" class="link">Using the SemaphoreSlim construct</a>, <a href="#ch02lvl1sec23" title="How it works..." class="link">How it works...</a></li><li>AutoResetEvent construct / <a href="#ch02lvl1sec24" title="Using the AutoResetEvent construct" class="link">Using the AutoResetEvent construct</a>, <a href="#ch02lvl1sec24" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec24" title="How it works..." class="link">How it works...</a></li><li>ManualResetEventSlim construct / <a href="#ch02lvl1sec25" title="Using the ManualResetEventSlim construct" class="link">Using the ManualResetEventSlim construct</a>, <a href="#ch02lvl1sec25" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec25" title="There's moreâ€¦" class="link">There's moreâ€¦</a></li><li>CountDownEvent construct / <a href="#ch02lvl1sec26" title="Using the CountDownEvent construct" class="link">Using the CountDownEvent construct</a>, <a href="#ch02lvl1sec26" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec26" title="How it works..." class="link">How it works...</a></li><li>Barrier construct / <a href="#ch02lvl1sec27" title="Using the Barrier construct" class="link">Using the Barrier construct</a>, <a href="#ch02lvl1sec27" title="How it works..." class="link">How it works...</a></li><li>ReaderWriterLockSlim construct / <a href="#ch02lvl1sec28" title="Using the ReaderWriterLockSlim construct" class="link">Using the ReaderWriterLockSlim construct</a>, <a href="#ch02lvl1sec28" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec28" title="How it works..." class="link">How it works...</a></li><li>SpinWait construct / <a href="#ch02lvl1sec29" title="Using the SpinWait construct" class="link">Using the SpinWait construct</a>, <a href="#ch02lvl1sec29" title="How to do it..." class="link">How to do it...</a>, <a href="#ch02lvl1sec29" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>timeout<ul><li>using, with thread pool / <a href="#ch03lvl1sec35" title="Using a wait handle and timeout with a thread pool" class="link">Using a wait handle and timeout with a thread pool</a>, <a href="#ch03lvl1sec35" title="How to do it..." class="link">How to do it...</a>, <a href="#ch03lvl1sec35" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>timer<ul><li>using / <a href="#ch03lvl1sec36" title="Using a timer" class="link">Using a timer</a>, <a href="#ch03lvl1sec36" title="How it works..." class="link">How it works...</a></li><li>using, in Universal Windows Platform application / <a href="#ch11lvl1sec89" title="Using a timer in a Universal Windows Platform application" class="link">Using a timer in a Universal Windows Platform application</a>, <a href="#ch11lvl1sec89" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec89" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>TPL DataFlow<ul><li>about / <a href="#ch10lvl1sec83" title="Introduction" class="link">Introduction</a></li><li>used, for implementing, Parallel Pipeline / <a href="#ch10lvl1sec86" title="Implementing Parallel Pipeline with TPL DataFlow" class="link">Implementing Parallel Pipeline with TPL DataFlow</a>, <a href="#ch10lvl1sec86" title="How to do it..." class="link">How to do it...</a>, <a href="#ch10lvl1sec86" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>TryDequeue method / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li>
        <li>TryPeek method / <a href="#ch06lvl1sec58" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>U</h2>
      <ul>
        <li>Ubuntu Linux<ul><li>.NET Core application, running / <a href="#ch11lvl1sec93" title="Running a .NET Core application on Ubuntu Linux" class="link">Running a .NET Core application on Ubuntu Linux</a>, <a href="#ch11lvl1sec93" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec93" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Universal Windows Platform application<ul><li>timer, using / <a href="#ch11lvl1sec89" title="Using a timer in a Universal Windows Platform application" class="link">Using a timer in a Universal Windows Platform application</a>, <a href="#ch11lvl1sec89" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec89" title="How it works..." class="link">How it works...</a></li><li>BackgroundTask, using / <a href="#ch11lvl1sec91" title="Using BackgroundTask in Universal Windows Platform applications" class="link">Using BackgroundTask in Universal Windows Platform applications</a>, <a href="#ch11lvl1sec91" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec91" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>unstructured parallelism / <a href="#ch07lvl1sec64" title="Introduction" class="link">Introduction</a></li>
        <li>user-mode constructs / <a href="#ch02lvl1sec20" title="Introduction" class="link">Introduction</a></li>
      </ul>
      <h2>W</h2>
      <ul>
        <li>wait handle<ul><li>using, with thread pool / <a href="#ch03lvl1sec35" title="Using a wait handle and timeout with a thread pool" class="link">Using a wait handle and timeout with a thread pool</a>, <a href="#ch03lvl1sec35" title="How it works..." class="link">How it works...</a>, <a href="#ch03lvl1sec35" title="There's moreâ€¦" class="link">There's moreâ€¦</a></li></ul></li>
        <li>Windows Communication (WCF) service<ul><li>about / <a href="#ch09lvl1sec78" title="Introduction" class="link">Introduction</a></li><li>calling, asynchronously / <a href="#ch09lvl1sec82" title="Calling a WCF service asynchronously" class="link">Calling a WCF service asynchronously</a>, <a href="#ch09lvl1sec82" title="How to do it..." class="link">How to do it...</a>, <a href="#ch09lvl1sec82" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>Windows Forms Applications (WPF) / <a href="#ch03lvl1sec37" title="How it works..." class="link">How it works...</a></li>
        <li>WinRT<ul><li>about / <a href="#ch11lvl1sec88" title="Introduction" class="link">Introduction</a></li><li>using, from usual applications / <a href="#ch11lvl1sec90" title="Using WinRT from usual applications" class="link">Using WinRT from usual applications</a>, <a href="#ch11lvl1sec90" title="How to do it..." class="link">How to do it...</a>, <a href="#ch11lvl1sec90" title="How it works..." class="link">How it works...</a></li></ul></li>
        <li>WithExecutionMode method / <a href="#ch07lvl1sec67" title="How it works..." class="link">How it works...</a></li>
        <li>WithMergeOptions method / <a href="#ch07lvl1sec67" title="How it works..." class="link">How it works...</a></li>
        <li>worker thread / <a href="#ch03lvl1sec30" title="Introduction" class="link">Introduction</a></li>
      </ul>
    </div>
  </div></div></div>
</div></div></div></body></html>
