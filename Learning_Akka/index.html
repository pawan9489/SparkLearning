<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"> <!--320-->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

    <link rel="icon" href="../../mapt/images/favicon.ico">

    <link rel="stylesheet" href="../../mapt/css/font-awesome.css">
    <link rel="stylesheet" href="../../mapt/css/google-fonts.css">
    <link rel="stylesheet" href="../../mapt/css/devicon.css">

    <link rel="stylesheet" href="../../mapt/css/bootstrap.css">
    <link rel="stylesheet" href="../../mapt/css/bootstrap-xl.css">
    <link rel="stylesheet" href="../../mapt/css/magnific-popup.css">
    <link rel="stylesheet" href="../../mapt/css/prism.css">
    <link rel="stylesheet" href="../../mapt/css/hljs-github.css">

    <link rel="stylesheet" href="../../mapt/css/mapt.css">
    <link rel="stylesheet" href="../../mapt/css/custom.css">

    <script src="../../mapt/js/jquery.js"></script>
    <script src="../../mapt/js/bootstrap.js"></script>
    <script src="../../mapt/js/jquery.magnific-popup.js"></script>
    <script src="../../mapt/js/highlight.min.js"></script>

    <script src="../../mapt/js/custom.js"></script>
    
    <title>Learning Akka</title>
</head>

<body class="home-body">
    <div id="wrapper">
        <div id="sidebar-wrapper">    
            <ul class="sidebar-nav">
                <div class="list-group" id="sidebar-nav" role="tablist">
                    <li>
                        <a href="../../index.html" class="sidenav-menu-holder back-btn" id="back-link">
                            <span class="sidenav-menu">Book List</span>
                            <span class="pull-left mr5"><i class="fa fa-chevron-left"></i></span>
                        </a>
                    </li>
                    
                    <li class="book-info copyright">
                        <span class="info text-nowrap"><span class="copyleft">&copy;</span><span><strong>RuTracker</strong>.org</span></span>
                    </li>          
                    <li class="book-info copyright">
                        <span class="info text-nowrap">Pub date: <strong>30 Dec 2015</strong></span>
                    </li>         
                    <li class="book-info">
                        <span class="info text-nowrap">Price: â‚¬<strong>32.99</strong></span>
                        <span class="info text-nowrap">ISBN: <strong>9781784393007</strong></span>
                    </li>     
            
                    <li>
                        <a href="graphics/cover.jpg" class="sidenav-menu-holder cover-img">
                            <img src="graphics/cover.jpg" class="cover-image">
                        </a>
                    </li>        
            
                    <div class="book_navigation">
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse1">
                                <div class="section-name">1: Starting Life as an Actor</div>
                            </a>
                        </li>
                        <div id="collapse1" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="1" class="sub-nav">
                                <a href="#ch01">
                                    <div class="section-name">Chapter 1: Starting Life as an Actor</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec08" class="sub-nav">
                                <a href="#ch01lvl1sec08">                    
                                    <div class="section-name">What&#x27;s in this book?</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec09" class="sub-nav">
                                <a href="#ch01lvl1sec09">                    
                                    <div class="section-name">Chapter overview</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec10" class="sub-nav">
                                <a href="#ch01lvl1sec10">                    
                                    <div class="section-name">What is Akka</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec11" class="sub-nav">
                                <a href="#ch01lvl1sec11">                    
                                    <div class="section-name">What we will build</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec12" class="sub-nav">
                                <a href="#ch01lvl1sec12">                    
                                    <div class="section-name">Setting up your environment</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec13" class="sub-nav">
                                <a href="#ch01lvl1sec13">                    
                                    <div class="section-name">Creating your first Akka application setting up the SBT project</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec14" class="sub-nav">
                                <a href="#ch01lvl1sec14">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="1" data-section-id="ch01lvl1sec15" class="sub-nav">
                                <a href="#ch01lvl1sec15">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse2">
                                <div class="section-name">2: Actors and Concurrency</div>
                            </a>
                        </li>
                        <div id="collapse2" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="2" class="sub-nav">
                                <a href="#ch02">
                                    <div class="section-name">Chapter 2: Actors and Concurrency</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec16" class="sub-nav">
                                <a href="#ch02lvl1sec16">                    
                                    <div class="section-name">Reactive system design</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec17" class="sub-nav">
                                <a href="#ch02lvl1sec17">                    
                                    <div class="section-name">The 4 reactive tenets</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec18" class="sub-nav">
                                <a href="#ch02lvl1sec18">                    
                                    <div class="section-name">Anatomy of an Actor</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec19" class="sub-nav">
                                <a href="#ch02lvl1sec19">                    
                                    <div class="section-name">Creating an actor</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec20" class="sub-nav">
                                <a href="#ch02lvl1sec20">                    
                                    <div class="section-name">Promises, futures, and event-driven programming models</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec21" class="sub-nav">
                                <a href="#ch02lvl1sec21">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="2" data-section-id="ch02lvl1sec22" class="sub-nav">
                                <a href="#ch02lvl1sec22">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse3">
                                <div class="section-name">3: Getting the Message Across</div>
                            </a>
                        </li>
                        <div id="collapse3" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="3" class="sub-nav">
                                <a href="#ch03">
                                    <div class="section-name">Chapter 3: Getting the Message Across</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec23" class="sub-nav">
                                <a href="#ch03lvl1sec23">                    
                                    <div class="section-name">Setting the stage with an example problem</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec24" class="sub-nav">
                                <a href="#ch03lvl1sec24">                    
                                    <div class="section-name">Messaging delivery</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec25" class="sub-nav">
                                <a href="#ch03lvl1sec25">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="3" data-section-id="ch03lvl1sec26" class="sub-nav">
                                <a href="#ch03lvl1sec26">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse4">
                                <div class="section-name">4: Actor Lifecycle â€“ Handling State and Failure</div>
                            </a>
                        </li>
                        <div id="collapse4" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="4" class="sub-nav">
                                <a href="#ch04">
                                    <div class="section-name">Chapter 4: Actor Lifecycle â€“ Handling State and Failure</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec27" class="sub-nav">
                                <a href="#ch04lvl1sec27">                    
                                    <div class="section-name">The 8 Fallacies of Distributed Computing</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec28" class="sub-nav">
                                <a href="#ch04lvl1sec28">                    
                                    <div class="section-name">Failure</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec29" class="sub-nav">
                                <a href="#ch04lvl1sec29">                    
                                    <div class="section-name">State</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec30" class="sub-nav">
                                <a href="#ch04lvl1sec30">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="4" data-section-id="ch04lvl1sec31" class="sub-nav">
                                <a href="#ch04lvl1sec31">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse5">
                                <div class="section-name">5: Scaling Up</div>
                            </a>
                        </li>
                        <div id="collapse5" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="5" class="sub-nav">
                                <a href="#ch05">
                                    <div class="section-name">Chapter 5: Scaling Up</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec32" class="sub-nav">
                                <a href="#ch05lvl1sec32">                    
                                    <div class="section-name">Moore&#x27;s law</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec33" class="sub-nav">
                                <a href="#ch05lvl1sec33">                    
                                    <div class="section-name">Multicore architecture as a distribution problem</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec34" class="sub-nav">
                                <a href="#ch05lvl1sec34">                    
                                    <div class="section-name">Choosing Futures or Actors for concurrency</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec35" class="sub-nav">
                                <a href="#ch05lvl1sec35">                    
                                    <div class="section-name">Doing work in parallel</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec36" class="sub-nav">
                                <a href="#ch05lvl1sec36">                    
                                    <div class="section-name">Working with Dispatchers</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec37" class="sub-nav">
                                <a href="#ch05lvl1sec37">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="5" data-section-id="ch05lvl1sec38" class="sub-nav">
                                <a href="#ch05lvl1sec38">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse6">
                                <div class="section-name">6: Successfully Scaling Out â€“ Clustering</div>
                            </a>
                        </li>
                        <div id="collapse6" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="6" class="sub-nav">
                                <a href="#ch06">
                                    <div class="section-name">Chapter 6: Successfully Scaling Out â€“ Clustering</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec39" class="sub-nav">
                                <a href="#ch06lvl1sec39">                    
                                    <div class="section-name">Introducing Akka Cluster</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec40" class="sub-nav">
                                <a href="#ch06lvl1sec40">                    
                                    <div class="section-name">One Giant Monolith or Many Micro Services?</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec41" class="sub-nav">
                                <a href="#ch06lvl1sec41">                    
                                    <div class="section-name">Definition of a Cluster</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec42" class="sub-nav">
                                <a href="#ch06lvl1sec42">                    
                                    <div class="section-name">CAP Theorem</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec43" class="sub-nav">
                                <a href="#ch06lvl1sec43">                    
                                    <div class="section-name">Building Systems with Akka Cluster</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec44" class="sub-nav">
                                <a href="#ch06lvl1sec44">                    
                                    <div class="section-name">Combining Sharding and Replication</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec45" class="sub-nav">
                                <a href="#ch06lvl1sec45">                    
                                    <div class="section-name">Addressing Remote Actors</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec46" class="sub-nav">
                                <a href="#ch06lvl1sec46">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="6" data-section-id="ch06lvl1sec47" class="sub-nav">
                                <a href="#ch06lvl1sec47">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse7">
                                <div class="section-name">7: Handling Mailbox Problems</div>
                            </a>
                        </li>
                        <div id="collapse7" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="7" class="sub-nav">
                                <a href="#ch07">
                                    <div class="section-name">Chapter 7: Handling Mailbox Problems</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec48" class="sub-nav">
                                <a href="#ch07lvl1sec48">                    
                                    <div class="section-name">Overwhelming your weakest link</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec49" class="sub-nav">
                                <a href="#ch07lvl1sec49">                    
                                    <div class="section-name">Resiliency</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec50" class="sub-nav">
                                <a href="#ch07lvl1sec50">                    
                                    <div class="section-name">Staying responsive under load</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec51" class="sub-nav">
                                <a href="#ch07lvl1sec51">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="7" data-section-id="ch07lvl1sec52" class="sub-nav">
                                <a href="#ch07lvl1sec52">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse8">
                                <div class="section-name">8: Testing and Design</div>
                            </a>
                        </li>
                        <div id="collapse8" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="8" class="sub-nav">
                                <a href="#ch08">
                                    <div class="section-name">Chapter 8: Testing and Design</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec53" class="sub-nav">
                                <a href="#ch08lvl1sec53">                    
                                    <div class="section-name">Example problem</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec54" class="sub-nav">
                                <a href="#ch08lvl1sec54">                    
                                    <div class="section-name">Approaching application design</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec55" class="sub-nav">
                                <a href="#ch08lvl1sec55">                    
                                    <div class="section-name">Designing, building, and testing the Domain model</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec56" class="sub-nav">
                                <a href="#ch08lvl1sec56">                    
                                    <div class="section-name">Testing actors</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec57" class="sub-nav">
                                <a href="#ch08lvl1sec57">                    
                                    <div class="section-name">Testing Advice</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec58" class="sub-nav">
                                <a href="#ch08lvl1sec58">                    
                                    <div class="section-name">Homework</div>
                                </a>
                            </li>
                            <li data-chapter="8" data-section-id="ch08lvl1sec59" class="sub-nav">
                                <a href="#ch08lvl1sec59">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapse9">
                                <div class="section-name">9: A Journey&#x27;s End</div>
                            </a>
                        </li>
                        <div id="collapse9" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="9" class="sub-nav">
                                <a href="#ch09">
                                    <div class="section-name">Chapter 9: A Journey&#x27;s End</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec60" class="sub-nav">
                                <a href="#ch09lvl1sec60">                    
                                    <div class="section-name">Other Akka Features and Modules</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec61" class="sub-nav">
                                <a href="#ch09lvl1sec61">                    
                                    <div class="section-name">Deployment Tools</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec62" class="sub-nav">
                                <a href="#ch09lvl1sec62">                    
                                    <div class="section-name">Monitoring Logs and Events</div>
                                </a>
                            </li>
                            <li data-chapter="9" data-section-id="ch09lvl1sec63" class="sub-nav">
                                <a href="#ch09lvl1sec63">                    
                                    <div class="section-name">Summary</div>
                                </a>
                            </li>
                        </div>
                        <li>
                            <a data-toggle="collapse" data-parent="#sidebar-nav" class="sidenav-menu-holder collapsed" href="#collapsebackindex">
                                <div class="section-name">Appendix A: Index</div>
                            </a>
                        </li>
                        <div id="collapsebackindex" class="panel-collapse collapse" role="tabpanel">
                            <li data-chapter="backindex" class="sub-nav">
                                <a href="#backindex">
                                    <div class="section-name">Chapter Appendix A: Index</div>
                                </a>
                            </li>
                        </div>
                    </div>
                </div>
            </ul>
        </div>
        
        <div id="page-content-wrapper" class="book-page">
            <a href="#" id="menu-toggle" class="toggle-nav"><i class="fa fa-bars fa-2x mr5"></i></a>
            
            <a href="#" id="back_to_top" class="back-to-top"><img src="../../mapt/images/kopimi.svg"></a>
            
            <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10">
                <div class="btn-group pull-right mt15 mb30" role="group">
                    <a href="#home" class="btn btn-default">
                        <i class="fa fa-share fa-lg no-text-padding"></i>
                        <span class="hidden-xs ml5">Book Home</span>
                    </a>
                    <button class="btn btn-default" data-nid="21968" id="code-download">
                        <i class="fa fa-file fa-lg"></i>
                        <span class="hidden-xs ml5">Download Code Files</span>
                    </button>
                </div>
            </div>
            <div class="clearfix"></div>
            
            <div id="book-wrapper" class="container-fluid">
                <div class="col-sm-12 col-xl-offset-2 col-xl-8 col-lg-offset-1 col-lg-10" id="home">
                    <h2 class="product-title">Learning Akka</h2>
                    <hr>
                    <div class="row">
                        <div class="col-sm-12">
                            <h5 class="mt10">By Jason Goodwin</h5>
                            <div>
                                <p class="mb20"><b>Build fault tolerant concurrent and distributed applications with Akka</b></p>
                                <a href="#ch01" class="btn btn-info btn-lg pull-right hidden-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <a href="#ch01" class="btn btn-info btn-lg btn-block mt20 mb20 visible-xs">
                                    Start Reading <i class="fa fa-chevron-right ml5"></i>
                                </a>
                                <div class="clearfix"></div>
                                <div class="col-sm-12">
                                    <ul id="myTabs" class="nav nav-tabs nav-justified hidden-xs mt20" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab" data-toggle="tab">
                                                <h5>Info</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab" data-toggle="tab">
                                                <h5>Contents</h5>
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab" data-toggle="tab">
                                                <h5>Author</h5>
                                            </a>
                                        </li>
                                    </ul>
                
                                    <ul id="myTabsMobile" class="nav nav-pills text-center nav-stacked visible-xs mb60" role="tablist">
                                        <li class="active">
                                            <a href="#info" role="tab" id="info-tab-responsive" data-toggle="tab">
                                                Info
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#content" role="tab" id="content-tab-responsive" data-toggle="tab">
                                                Contents
                                            </a>
                                        </li>
                                        <li>
                                            <a href="#author" role="tab" id="author-tab-responsive" data-toggle="tab">
                                                Author
                                            </a>
                                        </li>
                                    </ul>
                
                                    <div id="myTabContent" class="tab-content pt30">
                                    
                                        <div role="tabpanel" class="tab-pane active fade in" id="info">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Features</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Features</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li>Build networked applications that self-heal</li>
                <li>Scale out your applications to handle more traffic faster</li>
                <li>An easy-to-follow guide with a number of examples to ensure you get the best start with Akka</li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Learning</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>Learning</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <ul>
                <li>Use Akka to overcome the challenges of concurrent programming</li>
                <li>Resolve the issues faced in distributed computing with the help of Akka</li>
                <li>Scale applications to serve a high number of concurrent users</li>
                <li>Make your system fault-tolerant with self-healing applications</li>
                <li>Provide a timely response to users with easy concurrency</li>
                <li>Reduce hardware costs by building more efficient multi-user applications</li>
                <li>Maximise network efficiency by scaling it</li>
                </ul>
                                            </div>
                                            <br>
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">About</h5>
                                            </div>
                                            <div class="hidden-xs">
                                                <h5>About</h5>
                                            </div>
                                            <hr>
                                            <div>
                                                <p>Software today has to work with more data, more users, more cores, and more servers than ever. Akka is a distributed computing toolkit that enables developers to build correct concurrent and distributed applications using Java and Scala with ease, applications that scale across servers and respond to failure by self-healing. As well as simplifying development, Akka enables multiple concurrency development patterns with particular support and architecture derived from Erlangâ€™s concept of actors (lightweight concurrent entities). Akka is written in Scala, which has become the programming language of choice for development on the Akka platform.</p>
                <p>Learning Akka aims to be a comprehensive walkthrough of Akka. This book will take you on a journey through all the concepts of Akka that you need in order to get started with concurrent and distributed applications and even build your own.</p>
                <p>Beginning with the concept of Actors, the book will take you through concurrency in Akka. Moving on to networked applications, this book will explain the common pitfalls in these difficult problem areas while teaching you how to use Akka to overcome these problems with ease.</p>
                <p>The book is an easy to follow example-based guide that will strengthen your basic knowledge of Akka and aid you in applying the same to real-world scenarios.</p>
                                            </div>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade in" id="content">
                                            <div class="visible-xs">
                                                <h5 class="mobile-title">Contents</h5>
                                                <hr>
                                            </div>
                                            <ul>
                                                <div>
                                                    <li data-chapter="1">
                                                        <div class="section-name">1: Starting Life as an Actor</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="1" class="chapter-section">
                                                                    <a href="#ch01">        
                                                                        <div class="section-name">Chapter 1: Starting Life as an Actor</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec08" class="chapter-section">
                                                                    <a href="#ch01lvl1sec08">                    
                                                                        <div class="section-name">What&#x27;s in this book?</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec09" class="chapter-section">
                                                                    <a href="#ch01lvl1sec09">                    
                                                                        <div class="section-name">Chapter overview</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec10" class="chapter-section">
                                                                    <a href="#ch01lvl1sec10">                    
                                                                        <div class="section-name">What is Akka</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec11" class="chapter-section">
                                                                    <a href="#ch01lvl1sec11">                    
                                                                        <div class="section-name">What we will build</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec12" class="chapter-section">
                                                                    <a href="#ch01lvl1sec12">                    
                                                                        <div class="section-name">Setting up your environment</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec13" class="chapter-section">
                                                                    <a href="#ch01lvl1sec13">                    
                                                                        <div class="section-name">Creating your first Akka application setting up the SBT project</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec14" class="chapter-section">
                                                                    <a href="#ch01lvl1sec14">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="1" data-section-id="ch01lvl1sec15" class="chapter-section">
                                                                    <a href="#ch01lvl1sec15">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="2">
                                                        <div class="section-name">2: Actors and Concurrency</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="2" class="chapter-section">
                                                                    <a href="#ch02">        
                                                                        <div class="section-name">Chapter 2: Actors and Concurrency</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec16" class="chapter-section">
                                                                    <a href="#ch02lvl1sec16">                    
                                                                        <div class="section-name">Reactive system design</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec17" class="chapter-section">
                                                                    <a href="#ch02lvl1sec17">                    
                                                                        <div class="section-name">The 4 reactive tenets</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec18" class="chapter-section">
                                                                    <a href="#ch02lvl1sec18">                    
                                                                        <div class="section-name">Anatomy of an Actor</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec19" class="chapter-section">
                                                                    <a href="#ch02lvl1sec19">                    
                                                                        <div class="section-name">Creating an actor</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec20" class="chapter-section">
                                                                    <a href="#ch02lvl1sec20">                    
                                                                        <div class="section-name">Promises, futures, and event-driven programming models</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec21" class="chapter-section">
                                                                    <a href="#ch02lvl1sec21">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="2" data-section-id="ch02lvl1sec22" class="chapter-section">
                                                                    <a href="#ch02lvl1sec22">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="3">
                                                        <div class="section-name">3: Getting the Message Across</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="3" class="chapter-section">
                                                                    <a href="#ch03">        
                                                                        <div class="section-name">Chapter 3: Getting the Message Across</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec23" class="chapter-section">
                                                                    <a href="#ch03lvl1sec23">                    
                                                                        <div class="section-name">Setting the stage with an example problem</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec24" class="chapter-section">
                                                                    <a href="#ch03lvl1sec24">                    
                                                                        <div class="section-name">Messaging delivery</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec25" class="chapter-section">
                                                                    <a href="#ch03lvl1sec25">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="3" data-section-id="ch03lvl1sec26" class="chapter-section">
                                                                    <a href="#ch03lvl1sec26">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="4">
                                                        <div class="section-name">4: Actor Lifecycle â€“ Handling State and Failure</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="4" class="chapter-section">
                                                                    <a href="#ch04">        
                                                                        <div class="section-name">Chapter 4: Actor Lifecycle â€“ Handling State and Failure</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec27" class="chapter-section">
                                                                    <a href="#ch04lvl1sec27">                    
                                                                        <div class="section-name">The 8 Fallacies of Distributed Computing</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec28" class="chapter-section">
                                                                    <a href="#ch04lvl1sec28">                    
                                                                        <div class="section-name">Failure</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec29" class="chapter-section">
                                                                    <a href="#ch04lvl1sec29">                    
                                                                        <div class="section-name">State</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec30" class="chapter-section">
                                                                    <a href="#ch04lvl1sec30">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="4" data-section-id="ch04lvl1sec31" class="chapter-section">
                                                                    <a href="#ch04lvl1sec31">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="5">
                                                        <div class="section-name">5: Scaling Up</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="5" class="chapter-section">
                                                                    <a href="#ch05">        
                                                                        <div class="section-name">Chapter 5: Scaling Up</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec32" class="chapter-section">
                                                                    <a href="#ch05lvl1sec32">                    
                                                                        <div class="section-name">Moore&#x27;s law</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec33" class="chapter-section">
                                                                    <a href="#ch05lvl1sec33">                    
                                                                        <div class="section-name">Multicore architecture as a distribution problem</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec34" class="chapter-section">
                                                                    <a href="#ch05lvl1sec34">                    
                                                                        <div class="section-name">Choosing Futures or Actors for concurrency</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec35" class="chapter-section">
                                                                    <a href="#ch05lvl1sec35">                    
                                                                        <div class="section-name">Doing work in parallel</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec36" class="chapter-section">
                                                                    <a href="#ch05lvl1sec36">                    
                                                                        <div class="section-name">Working with Dispatchers</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec37" class="chapter-section">
                                                                    <a href="#ch05lvl1sec37">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="5" data-section-id="ch05lvl1sec38" class="chapter-section">
                                                                    <a href="#ch05lvl1sec38">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="6">
                                                        <div class="section-name">6: Successfully Scaling Out â€“ Clustering</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="6" class="chapter-section">
                                                                    <a href="#ch06">        
                                                                        <div class="section-name">Chapter 6: Successfully Scaling Out â€“ Clustering</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec39" class="chapter-section">
                                                                    <a href="#ch06lvl1sec39">                    
                                                                        <div class="section-name">Introducing Akka Cluster</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec40" class="chapter-section">
                                                                    <a href="#ch06lvl1sec40">                    
                                                                        <div class="section-name">One Giant Monolith or Many Micro Services?</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec41" class="chapter-section">
                                                                    <a href="#ch06lvl1sec41">                    
                                                                        <div class="section-name">Definition of a Cluster</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec42" class="chapter-section">
                                                                    <a href="#ch06lvl1sec42">                    
                                                                        <div class="section-name">CAP Theorem</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec43" class="chapter-section">
                                                                    <a href="#ch06lvl1sec43">                    
                                                                        <div class="section-name">Building Systems with Akka Cluster</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec44" class="chapter-section">
                                                                    <a href="#ch06lvl1sec44">                    
                                                                        <div class="section-name">Combining Sharding and Replication</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec45" class="chapter-section">
                                                                    <a href="#ch06lvl1sec45">                    
                                                                        <div class="section-name">Addressing Remote Actors</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec46" class="chapter-section">
                                                                    <a href="#ch06lvl1sec46">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="6" data-section-id="ch06lvl1sec47" class="chapter-section">
                                                                    <a href="#ch06lvl1sec47">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="7">
                                                        <div class="section-name">7: Handling Mailbox Problems</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="7" class="chapter-section">
                                                                    <a href="#ch07">        
                                                                        <div class="section-name">Chapter 7: Handling Mailbox Problems</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec48" class="chapter-section">
                                                                    <a href="#ch07lvl1sec48">                    
                                                                        <div class="section-name">Overwhelming your weakest link</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec49" class="chapter-section">
                                                                    <a href="#ch07lvl1sec49">                    
                                                                        <div class="section-name">Resiliency</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec50" class="chapter-section">
                                                                    <a href="#ch07lvl1sec50">                    
                                                                        <div class="section-name">Staying responsive under load</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec51" class="chapter-section">
                                                                    <a href="#ch07lvl1sec51">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="7" data-section-id="ch07lvl1sec52" class="chapter-section">
                                                                    <a href="#ch07lvl1sec52">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="8">
                                                        <div class="section-name">8: Testing and Design</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="8" class="chapter-section">
                                                                    <a href="#ch08">        
                                                                        <div class="section-name">Chapter 8: Testing and Design</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec53" class="chapter-section">
                                                                    <a href="#ch08lvl1sec53">                    
                                                                        <div class="section-name">Example problem</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec54" class="chapter-section">
                                                                    <a href="#ch08lvl1sec54">                    
                                                                        <div class="section-name">Approaching application design</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec55" class="chapter-section">
                                                                    <a href="#ch08lvl1sec55">                    
                                                                        <div class="section-name">Designing, building, and testing the Domain model</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec56" class="chapter-section">
                                                                    <a href="#ch08lvl1sec56">                    
                                                                        <div class="section-name">Testing actors</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec57" class="chapter-section">
                                                                    <a href="#ch08lvl1sec57">                    
                                                                        <div class="section-name">Testing Advice</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec58" class="chapter-section">
                                                                    <a href="#ch08lvl1sec58">                    
                                                                        <div class="section-name">Homework</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="8" data-section-id="ch08lvl1sec59" class="chapter-section">
                                                                    <a href="#ch08lvl1sec59">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="9">
                                                        <div class="section-name">9: A Journey&#x27;s End</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="9" class="chapter-section">
                                                                    <a href="#ch09">        
                                                                        <div class="section-name">Chapter 9: A Journey&#x27;s End</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec60" class="chapter-section">
                                                                    <a href="#ch09lvl1sec60">                    
                                                                        <div class="section-name">Other Akka Features and Modules</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec61" class="chapter-section">
                                                                    <a href="#ch09lvl1sec61">                    
                                                                        <div class="section-name">Deployment Tools</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec62" class="chapter-section">
                                                                    <a href="#ch09lvl1sec62">                    
                                                                        <div class="section-name">Monitoring Logs and Events</div>
                                                                    </a>
                                                                </li>
                                                                <li data-chapter="9" data-section-id="ch09lvl1sec63" class="chapter-section">
                                                                    <a href="#ch09lvl1sec63">                    
                                                                        <div class="section-name">Summary</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                                <div>
                                                    <li data-chapter="backindex">
                                                        <div class="section-name">Appendix A: Index</div>
                                                        <div class="panel-collapse" role="tabpanel">
                                                            <ul>
                                                                <li data-chapter="backindex" class="chapter-section">
                                                                    <a href="#backindex">
                                                                        <div class="section-name">Chapter Appendix A: Index</div>
                                                                    </a>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    </li>
                                                </div>
                                            </ul>
                                        </div>
                                        
                                        <div role="tabpanel" class="tab-pane fade" id="author">
                                            <div class="visible-xs">
                                                <h4 class="mobile-title">About the Author</h4>
                                                <hr>
                                            </div>
                                            <p><strong>Jason Goodwin</strong></p>
                                            <div>
                                                <p>Jason Goodwin is a developer who is primarily self-taught. His entrepreneurial spirit led him to study business at school, but he started programming when he was 15 and always had a high level of interest in technology. This interest led his career to take a few major changes away from the business side and back into software development. His journey has led him to working on high-scale distributed systems. He likes to create electronic music in his free time.</p>
                <p>He was first introduced to an Akka project at a Scala/Akka shopâ€”mDialogâ€”that built video ad insertion software for major publishers. The company was acquired by Google eventually. He has also been an influential technologist in introducing Akka to a major Canadian telco to help them serve their customers with more resilient and responsive software. He has experience of teaching Akka and functional and concurrent programming concepts to small teams there. He is currently working via Adecco at Google.</p>
                                            </div>
                                        </div>
                                        
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="next-wrapper">
                        <div class="row ns">
                            <hr />
                            <span class="hidden-xs">
                                <h4 class="pull-left">
                                    <strong>Up Next: </strong><span class="section-title"></span>
                                </h4>
                                <a href="#" class="btn btn-primary pull-right btn-lg">
                                    Next Section
                                </a>
                            </span>
                            <span class="visible-xs">
                                <a href="#" class="btn btn-primary btn-block btn-lg">
                                    Next Section
                                </a>
                            </span>
                        </div>
                        <div class="row ns">
                            <hr>
                        </div>
                    </div>
                </div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch01"></a>ChapterÂ 1.Â Starting Life as an Actor</h2></div></div></div><p>This book is primarily intended for intermediate, to senior-level developers wishing to explore Akka and build fault-tolerant, distributed systems in Scala or modern versions of Java.</p><p>This book has been written for the engineer who is faced with building applications that are fast, stable, and elastic, meaning they can scale to meet thousands or tens of thousands concurrent users. With more users having access to the Internet with faster devices and networks, today, more than ever, we need our applications to be able to handle many concurrent users working with larger datasets and with higher expectations of application stability and performance.</p><p>This book does not assume that you have a deep understanding of concurrency concepts and does try to introduce all of the concepts needed to know how to start a project from scratch, work with concurrency abstractions, and test and build standalone or networked applications using Akka. While this book should give you everything you need in those regards, it's not meant for an absolute beginner and does assume some does assume some programming proficiency.</p><p>Here is a quick overview of what you'll need and what you'll get out of this book.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Requirements:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Intermediate Scala or Java experience</p></li><li style="list-style-type: disc"><p>A computer</p></li><li style="list-style-type: disc"><p>Internet connectivity</p></li></ul></div></li><li style="list-style-type: disc"><p>Recommendations (but you can learn as you go):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If using Java, Java8 lambda exposure</p></li><li style="list-style-type: disc"><p>Git and GitHub experience for assignments</p></li></ul></div></li><li style="list-style-type: disc"><p>What you'll learn:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Learn to build distributed and concurrent application</p></li><li style="list-style-type: disc"><p>Learn techniques for building fault-tolerant systems</p></li><li style="list-style-type: disc"><p>Learn techniques for sharing code between projects and teams</p></li><li style="list-style-type: disc"><p>Learn several concepts and patterns to aid in distributed system design</p></li></ul></div></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec08"></a>What's in this book?</h2></div></div><hr /></div><p>To meet the modern challenges a platform developer may face, this book puts a strong focus not only on Akka but also on distributed and concurrent computing concepts. It is my intention to give you a toolkit to understand the problems you'll face while trying to scale these distributed and concurrent applications.</p><p>These pages are not a re-iteration of the Akka documentation. If you want a desk reference or manual, the 460-page Akka documentation will serve that purpose well. This book is not simply a book about Akka, it is a book about building concurrent and distributed systems with Akka.</p><p>This book will take you on a journey to show you a new way of working with distributed and concurrent applications. This book will arm you with an understanding of the tools, and then will show you how to use them. It will demonstrate how to build clusters of applications that talk to each other over the network and can have new computing nodes added or removed to be able to scale to meet the needs of your users. We'll learn how to do things like building pools of workers to handle huge jobs at scale to show how it's done. We will talk about important theorems and common approaches in distributed systems and show how they affect our design decisions, and we will discuss problems you will encounter related to network reliability and demonstrate how we can build our applications to be resilient to those problems.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec09"></a>Chapter overview</h2></div></div><hr /></div><p>At the heart of Akka is an implementation of the Actor Model, which is a theoretical model of concurrent computation. In this, chapter we will introduce core concepts in Akka by looking at the history of Akka and the actor model. This will give you insight into what Akka is and help you understand what problems it tries to solve. Then, the goals of this book will be introduced with recurring examples that will be used.</p><p>After covering these concepts, the chapter will move into setting up your development environment with the tools you need to start building. We will set up our environment, <a id="id0" class="indexterm"></a>
<span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>), and our first Akka project, including unit testing.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>What is Akka</h2></div></div><hr /></div><p>This section will introduce <a id="id1" class="indexterm"></a>Akka and the actor model. Akka, purportedly named after a mountain in Sweden, is often referred to as a distribution toolkitâ€”a collection of tools that are used to do work across remote computing resources. Akka is a modern implementation of the actor model of concurrency. Akka today could be seen as an evolution of other technologies, borrowing from Erlang's actor model implementation while introducing many new features to aid with building applications that can handle today's high-scale problems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec09"></a>Actor Model origins</h3></div></div></div><p>To better understand<a id="id2" class="indexterm"></a> what Akka is and how it is used, we will take a brief trip through time looking at the Actor model to understand what it is and how it has evolved into a framework for building fault-tolerant distributed systems in Akka today.</p><p>The actor model of concurrency was originally a theoretical model of concurrent computation proposed in a paper called <span class="emphasis"><em>A Universal Modular Actor Formalism for Artificial Intelligence</em></span> in 1973. We will look at the actor model's qualities here to understand its benefits in aiding our ability to reason about concurrent computation while protecting against common pitfalls in shared state.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>What's an Actor anyway?</h3></div></div></div><p>First, let's define what an Actor<a id="id3" class="indexterm"></a> is. In the actor model, an actor is a concurrency primitive; more simply stated, an actor can be thought of as a worker like a process or thread that can do work and take action. It might be helpful to think of an actor as a person in an organization that has a role and responsibility in that organization. Let's say a sushi restaurant. Restaurant staff have to do various pieces of work throughout the day such as preparing dishes for customers.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>Actors and Message passing</h3></div></div></div><p>One of the qualities of an<a id="id4" class="indexterm"></a> object in object oriented languages is that it can be <a id="id5" class="indexterm"></a>can be directly invokedâ€“one object can examine or change another object's fields, or invoke its methods. This is fine if a single thread is doing it, but if multiple threads are trying to read and change values at the same time, then synchronization and locks are needed.</p><p>Actors differ from objects in that they cannot be directly read, changed, and invoked. Instead, Actors can only communicate with the world outside of them through message passing. Message passing simply means that an actor can be sent a message (object in our case) and can, itself, send messages or reply with a message. While you may draw parallels to passing a parameter to a method, and receiving a return value, message passing is fundamentally different because it happens asynchronously. An actor begins processing a message, and replies to the message, on its own terms when it is ready.</p><div class="mediaobject"><img src="graphics/B04006_01_01.jpg" /></div><p>The actor processes messages one at a time, synchronously. The mailbox is essentially a queue of work outstanding for the worker to process. When an actor processes a message, the actor can respond by changing its internal state, creating more actors, or sending more messages to other actors.</p><p>The term <span class="emphasis"><em>Actor System</em></span> is often <a id="id6" class="indexterm"></a>used in implementations to describe a collection of actors and everything related to them including addresses, mailboxes, and configuration.</p><p>To reiterate these key concepts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Actor</strong></span>: A <a id="id7" class="indexterm"></a>worker concurrency primitive, which synchronously processes messages. Actors can hold state, which can change.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Message</strong></span>: A piece of data used <a id="id8" class="indexterm"></a>to communicate with processes (for example, Actors).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Message-passing</strong></span>: A <a id="id9" class="indexterm"></a>software development paradigm where messages are passed to invoke behavior instead of directly invoking the behavior.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mailing address</strong></span>: Where <a id="id10" class="indexterm"></a>messages are sent for an actor to process when the actor is free.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mailbox</strong></span>: The place <a id="id11" class="indexterm"></a>messages are stored until an actor is able to process the message. This can be viewed as a queue of messages.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Actor system</strong></span>: A collection of<a id="id12" class="indexterm"></a> actors, their addresses, mailboxes, and configuration, etc.</p></li></ul></div><p>It might not be obvious yet, but the <a id="id13" class="indexterm"></a>Actor Model is much easier to reason about than imperative object oriented concurrent applications. Taking a real world example and modeling it in an actor system will help to demonstrate this benefit. Consider a sushi restaurant, We have three actors in this example: a customer, a waiter, and the sushi chef.</p><p>Our example starts with the customer telling our waiter their order. The waiter writes it down this onto a piece of paper and places this message in the chef's mailbox (sticks it in the kitchen window). When the chef is free, the chef will pick up the message (order) and start preparing the sushi. The chef will continue to process the message until it's done. When the sushi is prepared, the chef will put this message (plate) in the kitchen window (waiter's mailbox) for the waiter to pick up. The chef can go work on other orders now.</p><p>When the waiter has a free minute, the waiter can pick up the food message from the window and deliver it to the customer's mailbox (for example, the table). When the customer is ready, they will process the message by eating the food.</p><p> </p><div class="mediaobject"><img src="graphics/B04006_01_02.jpg" /></div><p>
</p><p>It's easy to reason about the restaurant<a id="id14" class="indexterm"></a> using the actor model. If you take a moment to imagine more customers coming into the restaurant, you can imagine the waiter taking orders one at a time and handing them off to the chef, the chef processing them, and the waiter delivering food, all concurrently. This is one of the great benefits of the actor model; it's very easy to reason about concurrency when everyone has their own tasks. Modeling real applications with the actor model is not much different than what we have done in this example.</p><p>The next benefit to the actor model is elimination of shared state. Because actors process one message at a time, state can be stored inside an actor safely. If you have not worked on concurrent systems this may be harder to see immediately but we can demonstrate it quite easily. If we try to do two operations that read, modify, and write a value at the same time, then one of the operations will be lost unless we carefully employ synchronization and locking. It's a very easy mistake to make.</p><p>Let's take a look at a non-atomic increment operation called from two threads at the same time, to see what happens when state is shared across threads. We'll have multiple threads read a value from memory, and then write an incremented value back to memory. This is a <span class="emphasis"><em>race condition</em></span> and can be partly solved by ensuring mutually exclusive access to the value in memory. Let's actually demonstrate this with a Scala example:</p><p>If we try to concurrently <a id="id15" class="indexterm"></a>increment an integer 100000 times with multiple threads, there is a good chance that we will lose some writes.</p><div class="informalexample"><pre class="programlisting">import concurrent.Future
import concurrent.ExecutionContext.Implicits.global
var i, j = 0
(1 to 100000).foreach(_ =&gt; Future{i = i + 1})
(1 to 100000).foreach(_ =&gt; j = j + 1)
Thread.sleep(1000)
println(s"${i} ${j}")</pre></div><p>Both <code class="literal">i</code> and <code class="literal">j</code> are incremented 100000 times using this very simple functionâ€”<code class="literal">x = x + 1</code>. <code class="literal">i</code> is incremented from multiple threads concurrently while <code class="literal">j</code> is incremented by only one thread. We wait for a second before printing to ensure all of the updates are done. If you think the output is <code class="literal">100000 100000</code> you are very wrong.</p><div class="mediaobject"><img src="graphics/B04006_01_03.jpg" /></div><p>Shared state is not safe. Values are being read by two threads, and then saved back incremented. Because the same value is read by multiple threads, increment operations are lost along the way. This is a race-condition and is one of the fundamental problems with shared-state concurrency models.</p><p>We can demonstrate what may be happening with the race condition more clearly by reasoning about the reads and write operations:</p><div class="informalexample"><pre class="programlisting">[...]
Thread 2 reads value in memory - value read as 9
Thread 2 writes value in memory - value set to 10 (9 + 1)
Thread 1 reads value in memory - value read as 10
Thread 2 reads value in memory - value read as 10
Thread 1 writes value in memory - value set to 11 (10 + 1) !! LOST INCREMENT !!
Thread 2 writes value in memory - value set to 11 (10 + 1)
Thread 1 reads value in memory - value read as 11
[...]</pre></div><p>For shared state in memory to work correctly, we have to apply locks and synchronization to stop threads from reading and writing from a value at the same time. This introduces complexity and it's hard to reason about it and to ensure it is done right.</p><p>The biggest threat is that<a id="id16" class="indexterm"></a> often your code will appear correct in testing but it will fail intermittently once you have a bunch of concurrent users working on it. The bugs are easily missed because testing often excludes situations with lots of traffic. Dion Almaer once blogged that most Java applications are so rife with concurrency bugs that they only work by accident. Actors help safeguard against these problems by reducing shared state. If you move state inside an actor, access to that state can be limited only to the actor (effectively only one thread can access that state). If you treat all messages as immutable, then you can effectively eliminate shared state in your actor system and build safer applications.</p><p>The concepts in this section represent the core of the actor model. <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> and <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Getting the Message Across</em></span>, will cover concurrency, actors, and message passing in greater detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec01"></a>The Evolution of supervision and fault tolerance in Erlang</h4></div></div></div><p>The actor model evolved over time since its introduction in the aforementioned paper. It was a noted influencer in programming language designs (Scheme for example).</p><p>There was a note-worthy appearance of the actor model when Ericsson produced an implementation in the 80s in the Erlang programming language for use in embedded TELECOM applications. The concept of fault tolerance through supervision was introduced here. Ericsson, using Erlang and the actor model, produced an often cited appliance, the AXD301. The AXD301 managed to achieve a remarkable nine nine's of availability (99.9999999% uptime). That's about 3.1 seconds of downtime in 100 years. The team working on the AXD claimed to have done this through elimination of shared state (as we have covered) and by introducing a fault-tolerance mechanism in Erlang: Supervision.</p><p>Fault-tolerance<a id="id17" class="indexterm"></a> is gained in the actor model through<a id="id18" class="indexterm"></a> supervision. Supervision is more or less moving the responsibility of responding to failure outside of the thing that can fail. Practically speaking, this means that an actor can have other child actors that it is responsible for supervising; it monitors the child actor for failures and can take actions regarding the child actor's lifecycle. When an error is encountered in an actor that is running, the default supervision behavior is to restart (effectively recreate) the actor that encountered the failure. This response to failureâ€”the recreating the component that failsâ€”assumes that if an unexpected error is encountered that it could be a result of bad state, and so throwing away and re-creating the failing piece of the application can restore it to working order. It is possible to write custom responses as supervision strategies so almost any action can be taken to <a id="id19" class="indexterm"></a>restore working order to the application.</p><div class="mediaobject"><img src="graphics/B04006_01_04.jpg" /></div><p>Fault Tolerance<a id="id20" class="indexterm"></a> in relation to distributed systems will be addressed as a general cross-cutting concern throughout the book with an emphasis on fault tolerance in Akka and distributed systems in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Actor Lifecycle â€“ Handling State and Failure</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec02"></a>The Evolution of distribution and location transparency</h4></div></div></div><p>Business today demands<a id="id21" class="indexterm"></a> that the capable engineers be able to design systems that can <a id="id22" class="indexterm"></a>serve traffic to thousands of users concurrently and a single machine is not enough to do that. Further, multi-core processors are becoming more prevalent so distributing across those cores is becoming important to ensure our software can take advantage of the hardware that it runs on.</p><p>Akka takes the actor model and continues to evolve it by introducing an important capability for today's engineers: distribution across the network. Akka presents itself as a toolkit for fault-tolerant distribution. That is, Akka is a tool kit for working across the physical boundaries of servers to scale almost indefinitely while maintaining high availability. In recent releases, many of the features added to Akka are related to solving problems related to networked system. Akka clusters was introduced recently which allows an actor system to span multiple machines transparently, and Akka IO<a id="id23" class="indexterm"></a> and Akka HTTP<a id="id24" class="indexterm"></a> are now in the core libraries to help us interact with other systems more easily. One of Akka's key contributions to the actor model is the concept of location transparencyâ€”that is, an actor's mailing address can actually be a remote location but the location is more or less transparent to the developer so the code produced is more or less identical.</p><p>Akka extends on what Erlang did with the actor model and breaks down the physical barriers of the actor system. Akka adds remoting and location transparency, that is, the mailbox of an actor could suddenly be on a remote machine and Akka would abstract away the transmission of the message over the network.</p><p>More recently, Akka introduced Cluster. Akka Cluster<a id="id25" class="indexterm"></a> uses modern approaches similar to what you might see in distributed systems influenced by the Amazon Dynamo paper such as Dynamo, Cassandra, and Riak. With Cluster, an actor system can exist across multiple machines and nodes will gossip and communicate about state to other members to allow an elastic Akka cluster with no single point of failure. The mechanism is similar to Dynamo style databases <a id="id26" class="indexterm"></a>such as Riak and Cassandra. This is an incredible feature that makes creating elastic, fault-tolerant systems quite simple.</p><p>Typesafe , the company<a id="id27" class="indexterm"></a> that provides technologies like Scala and Akka, are continuing to push forward distributed computing with a plethora of networking tools such as Akka IO and Akka HTTP. Further, Typesafe have been involved in the Reactive Streams proposal and Akka has one of the first implementations for producing non-blocking back-pressure for asynchronous processing.</p><p>We will cover many of these items in detail throughout the course of this book. <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Actor Lifecycle â€“ Handling State and Failure</em></span> and <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Scaling Up</em></span> will cover remoting in greater detail. Cluster will be covered in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Successfully Scaling Out â€“ Clustering</em></span>. Reactive Streams will be covered in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Handling Mailbox Problems</em></span>.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>What we will build</h2></div></div><hr /></div><p>We will produce two<a id="id28" class="indexterm"></a> primary services throughout the book and recommend that you follow along. There is a homework section at the end of every chapter that will give you exercises to help put the material to useâ€” complete the activities before you head on to the next chapter. Post them up to GitHub if you want to share your progress or have a good open-source idea.</p><p>We can define two main pieces of software we will focus on developing in the book. One example will be used to demonstrate how to handle state and distribution and the other will be used to demonstrate how to get work done.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Example 1 â€“ handling distributed state</h3></div></div></div><p>We're going to look at how we would build a scalable distributed in memory database that we will store data in from the other example. To be clear, we will build a highly available key value store similar to Redis or memcached. The database that you build will handle all of the concurrency, clustering, and distribution concerns needed for this to really work. Many of the skills you build will be in learning how to separate and distribute the data and load for our database in a cluster so we can take advantage of the hardware, and scale out to utilize multiple machines, you'll get a real taste of the design challenges and common solutions in real world situations. We're also going to look at how to build a client library to interact with our Akka-based database so anyone on the JVM can use it. It is highly recommended that you build a database like this for yourself, put it on GitHub, and show it off on your resume.</p><p>If it sounds like a lot of workâ€”good news, this will all actually be fairly simple to do using the Akka toolkit. We will take you from zero to hero in no time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>Example 2 â€“ getting lots of work done</h3></div></div></div><p>For an example of doing<a id="id29" class="indexterm"></a> lots of work at scale in this book, we will produce an article reading an API that will take a blog or news article, rip out the main text body, and store it in our database for later consumption. </p><p>For a use case, imagine a mobile device will have a reader on it requesting articles from popular RSS feeds from our service and presenting the main body text in a nice reader experience that can reflow the text to fit the display. Our service will do the extraction of that body text from major RSS feeds so the user has a nice fast experience on the device and never has to wait. If you want to see a real example of this on a device, check out Flipboard for iOS: it is a great example of what a consumer of our service might look like.</p><div class="mediaobject"><img src="graphics/B04006_01_05.jpg" /></div><p>Now that we've covered <a id="id30" class="indexterm"></a>the content that is in this book, let's get started by setting up your environment, and building an actor!</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec12"></a>Setting up your environment</h2></div></div><hr /></div><p>Before we really dig into Akka, we're<a id="id31" class="indexterm"></a> going to cover setting up your environment and scaffolding a project. You can refer back to this section in later chapters of the book as we will create a few projects along the way.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>Choosing a language</h3></div></div></div><p>The Scala and Java APIs<a id="id32" class="indexterm"></a> are more or less 1 to 1 for Scala and Java so use whichever language you are comfortable with. If you know both languages, Scala certainly has a more idiomatic API but both are very serviceable choices. An Actor built in Java is accessible from Scala through the Scala actor API and visa versa so there is no need to decide which to build on immediately; do whatever will get you to where you are going faster. Right now your focus is on learning Akka, not a language. You'll be able to pick up the other <a id="id33" class="indexterm"></a>API later without much effort once you know Akka.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>Installing Java â€“ Oracle JDK8</h3></div></div></div><p>This book will forego all older<a id="id34" class="indexterm"></a> versions of Java and focus only on Java8. If you are a Java developer but not familiar with Java8 features, you should take some time to familiarize yourself with lambdas and the stream API as covered in this <a id="id35" class="indexterm"></a>tutorial: <a class="ulink" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" target="_blank">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html</a>
</p><p>You'll see lambdas are used heavily in this book. you will benefit from taking the time to get acquainted.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec03"></a>Installing on Windows</h4></div></div></div><p>Download <a id="id36" class="indexterm"></a>and <a id="id37" class="indexterm"></a>install the <a id="id38" class="indexterm"></a>Windows<a id="id39" class="indexterm"></a> JDK8 installer (dmg) from Oracle: <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>.</p><p>Follow the instructions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec04"></a>Installing on OS X</h4></div></div></div><p>Download <a id="id40" class="indexterm"></a>and <a id="id41" class="indexterm"></a>install the <a id="id42" class="indexterm"></a>OS X <a id="id43" class="indexterm"></a>JDK8 installer (dmg) from Oracle:  <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>.</p><p>Follow the instructions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec05"></a>Installing on Linux or Unix (Universal instructions)</h4></div></div></div><p>There are a couple<a id="id44" class="indexterm"></a> approaches that can be used for Nix installations. You can <a id="id45" class="indexterm"></a>use the Universal installer, or try to use a package manager like Yum for <span class="strong"><strong>Red Hat Enterprise Linux</strong></span> (<span class="strong"><strong>RHEL</strong></span>)<a id="id46" class="indexterm"></a> based<a id="id47" class="indexterm"></a> distributions or Apt-Get for Debian-based <a id="id48" class="indexterm"></a>distribution. Instructions <a id="id49" class="indexterm"></a>for the package manager<a id="id50" class="indexterm"></a> can vary from distribution to distribution but instructions can be found via Google if desired.</p><p>The Universal installer<a id="id51" class="indexterm"></a> will work on all systems so will be covered here. This is<a id="id52" class="indexterm"></a> the most basic installation you can get away with. It will<a id="id53" class="indexterm"></a> install the JDK and enable it for your current user but will not<a id="id54" class="indexterm"></a> change your system. If you want to change your system's JDK/JRE you can follow the install instructions for your particular distribution. This <a id="id55" class="indexterm"></a>would be suitable for servers or desktop environments. If <a id="id56" class="indexterm"></a>you're working on a desktop environment, you can see if there are instructions for your particular distribution if you want it available for other users as the default JDK/JRE.</p><p>Download the Linux <code class="literal">tar.gz</code> JDK distribution<a id="id57" class="indexterm"></a> from Oracle: <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>.</p><p>It will likely be in a file named something like <code class="literal">jdk-8u31-linux-x64.tar.gz</code> Decompress the <code class="literal">tar.gz</code> file in an appropriate location such as <code class="literal">/opt</code>:</p><p>
<code class="literal">sudo cp jdk-8u31-linux-x64.tar.gz /opt cd /opt sudo tar -xvf jdk-8u31-linux-x64.tar.gz</code>
</p><p>You'll want to set your user's Java home to the Java8 folder:</p><p>
<code class="literal">echo 'export JAVA_HOME=/opt/jdk1.8.031' &gt;&gt; ~/.profile</code>
</p><p>Also ensure that Java bin is on the path:</p><p>
<code class="literal">echo 'export PATH=$PATH:/opt/jdk1.8.031' &gt;&gt; ~/.profile</code>
</p><p>Now your IDE and Sbt/Activator can use the JDK to build and run apps we build.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec16"></a>Ensuring Java is configured in your environment</h3></div></div></div><p>Regardless of the OS <a id="id58" class="indexterm"></a>you're on, you'll want to ensure that <code class="literal">JAVA_HOME</code> is set and also that the Java binary is on the path. You shouldn't need to do this unless you use the universal installer but you should validate in a new terminal that <code class="literal">JAVA_HOME</code> is set in the environment, and that the JDK bin folder is on the path. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec17"></a>Installing Scala</h3></div></div></div><p>If you're using <a id="id59" class="indexterm"></a>Scala, then <a id="id60" class="indexterm"></a>you'll want to have Scala and the REPL installed on your system. At the time of writing, the current Scala version (2.11) compiles to Java 1.6 byte-code so we can assume you do not need to install JDK8. There is talk of future versions of Scala requiring JDK8 so this may change.</p><p>Scala does not need to be installed on its own. Typesafe Activator contains Scala and all of the tools we will need to work with it; we will install next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec18"></a>Installing Typesafe Activator</h3></div></div></div><p>Typesafe Activator<a id="id61" class="indexterm"></a> installation is a bundle that contains Scala, Akka, Play, <span class="strong"><strong>Simple Build Tool</strong></span> (<span class="strong"><strong>SBT</strong></span>) <a id="id62" class="indexterm"></a>and some extra<a id="id63" class="indexterm"></a> features such as project scaffolding and templates.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec06"></a>Windows</h4></div></div></div><p>Download <a id="id64" class="indexterm"></a>Typesafe Activator<a id="id65" class="indexterm"></a> from <a id="id66" class="indexterm"></a>Typesafeâ€”<a class="ulink" href="http://www.typesafe.com/â€¨get-started" target="_blank">http://www.typesafe.com/get-started</a>.</p><p>Run the installer<a id="id67" class="indexterm"></a> and follow the onscreen instructions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec07"></a>Linux/Unix/OS X</h4></div></div></div><p>Download<a id="id68" class="indexterm"></a> Typesafe<a id="id69" class="indexterm"></a> Activator from Typesafe:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://www.typesafe.com/activator/download" target="_blank">http://www.typesafe.com/activator/download</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://www.typesafe.com/get-started" target="_blank">http://www.typesafe.com/get-started</a>
</p></li></ul></div><p>Unzip the file in an appropriate<a id="id70" class="indexterm"></a> location such as <code class="literal">/opt cd /opt sudo unzip typesafe-activator-1.2.12.zip.</code>
</p><p>Make the Activator <a id="id71" class="indexterm"></a>executable: <code class="literal">sudo chmod 755 /opt/activator-1.2.12/activator</code>
</p><p>Add the Activator to your <a id="id72" class="indexterm"></a>path: <code class="literal">echo 'export PATH=$PATH:/opt/activator-1.2.12'</code>
</p><p>Log out and back<a id="id73" class="indexterm"></a> in. Ensure you can run the following on the command line: </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activator --version</strong></span>
</pre></div><p>That should display text similar to this: sbt launcher version 0.13.5</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec08"></a>OS X</h4></div></div></div><p>Activator can either be <a id="id74" class="indexterm"></a>installed with Linux <a id="id75" class="indexterm"></a>or using <code class="literal">brew</code>. This section will cover the <a id="id76" class="indexterm"></a>brew installation:</p><p>Open a terminal.</p><p>Place the following in your terminal (copied from <a class="ulink" href="http://brew.sh" target="_blank">http://brew.sh</a>). This will install the Homebrew OS X Package manager.</p><div class="informalexample"><pre class="programlisting">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</pre></div><p>Finally, place the following<a id="id77" class="indexterm"></a> in your terminal and <a id="id78" class="indexterm"></a>press <span class="emphasis"><em>Enter</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>brew install typesafe-activator</strong></span>
</pre></div><p>Check that the Activator is<a id="id79" class="indexterm"></a> available on the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activator --version</strong></span>
</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec19"></a>Creating a new project</h3></div></div></div><p>We will use the Activator to quickly<a id="id80" class="indexterm"></a> scaffold projects in this book. We can generate a project from any number of templates. We will only use the basic Java and Scala templates in this book. Feel free to explore other options. Typesafe has many user-submitted Activator templates that will demonstrate various technologies and approaches used together.</p><p>To create a new Activator template, in a terminal/command prompt, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activator new</strong></span>
</pre></div><p>You will see the following.</p><p>Choose from these featured templates or enter a template name:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>minimal-akka-java-seed</p></li><li style="list-style-type: disc"><p>minimal-akka-scala-seed</p></li><li style="list-style-type: disc"><p>minimal-java</p></li><li style="list-style-type: disc"><p>minimal-scala</p></li><li style="list-style-type: disc"><p>play-java</p></li><li style="list-style-type: disc"><p>play-scala</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip02"></a>Tip</h3><p>You can hit <span class="emphasis"><em>Tab</em></span> to view a list of all templates.</p></div><p>Select the minimal-scala or minimal-java project depending on your language preference. You will be prompted to name your application next, call it <code class="literal">akkademy-db</code>.</p><p>Enter a name for your application (just press <span class="emphasis"><em>Enter</em></span> for minimal-scala) &gt; <code class="literal">akkademy-db</code>.
</p><p>To confirm that the project and your environment are set up correctly, change into the folder and run <code class="literal">activator test</code>.
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd akkademy-db activator test</strong></span>
</pre></div><p>You will see output indicating that the project compiled and the test ran. If there are any problems, you may have to head to stack-overflow and sort out your environment before proceeding.</p><p>You will see the <a id="id81" class="indexterm"></a>following success message if all went well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[info] Passed: Total 1, Failed 0, Errors 0, Passed 1 [success] Total time: 3 s, completed 22-Jan-2015 9:44:21 PM</strong></span>
</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>Installing an IDE</h3></div></div></div><p>We have our environment set up and<a id="id82" class="indexterm"></a> running now and we can actually start to work on the code. If you want to use a simple text editor, feel free to skip this section. Emacs or Sublime are good choices for text editors and have syntax highlighting and integrations that can provide autocomplete. If you want to get an IDE up and running, we'll cover setting up Eclipse, and IntelliJ here.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec09"></a>Install IntelliJ CE</h4></div></div></div><p>If you choose to use an<a id="id83" class="indexterm"></a> IDE, IntelliJ is the recommended IDE. If you're using another IDE, I <a id="id84" class="indexterm"></a>still strongly recommend you attempt to use IntelliJ. While writing this book, I've worked with many Java developers who transitioned to working with SBT projects and almost all of them switched to IntelliJ and never looked back.</p><p>IntelliJ now has built-in SBT support, which makes it a fast IDE to use for your Akka projects; setting up and configuring of the IDE is virtually non-existentâ€”it will just work with the technology we will use in this book.</p><p>Steps for getting the project up and running:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Download and install IntelliJ CE (free).</p></li><li><p>After installing choose to open a project. Select the <code class="literal">akkademy-db</code> folder.</p></li><li><p>Select Java 1.8 if you're using Java (or if Scala 2.12 requires it). You can use Java 6 or 7 if using Scala 2.11. Turn on the Auto Import feature. Hit okay.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec10"></a>Eclipse</h4></div></div></div><p>If using Eclipse, it is recommended that you <a id="id85" class="indexterm"></a>download Scala-Ide, which contains all of the required plugins to work with our sbt/Akka projects in either Java or Scala. Even if you're only using Java, you may find you want to inspect some Scala along the way.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec01"></a>Installing Eclipse (Scala-Ide)</h5></div></div></div><p>Download Scala-Ide<a id="id86" class="indexterm"></a> from <a class="ulink" href="http://scala-ide.org" target="_blank">http://scala-ide.org</a> which is a packaged <a id="id87" class="indexterm"></a>version of Eclipse with sbt and Scala plugins integrated.</p><p>Unzip the file that is<a id="id88" class="indexterm"></a> downloaded. You can move the unzipped folder to another location if desired such as <code class="literal">/opt (linux)</code> or <code class="literal">~/Applications (OSX)</code>.</p><p>Run the Eclipse binary. Choose a workspace folder or select the default.</p><p>Check that the Java JDK is correctly selected in <code class="literal">Preferences: Java | Compiler</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec02"></a>Preparing the project for Eclipse</h5></div></div></div><p>In order to open the project in <a id="id89" class="indexterm"></a>eclipse, we must first generate an Eclipse project.</p><p>First we must add the eclipse<a id="id90" class="indexterm"></a> sbt plugin to our environment. Open your global sbt plugins file (create it if it's not there), is located in <code class="literal">~/.sbt/{version}/plugins/plugins.sbt</code> where version is the sbt version. It is 0.13 at the time of writing, so <code class="literal">~/.sbt/0.13/plugins/plugins.sbt</code>
</p><p>Include the following in the file, ensuring there is a blank line between each line in the file if there are multiple lines.</p><div class="informalexample"><pre class="programlisting">addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "3.0.0")</pre></div><p>You may want to ensure this is current by checking the<a id="id91" class="indexterm"></a> sbteclipse GitHub project: <a class="ulink" href="https://github.com/typesafehub/sbteclipse/" target="_blank">https://github.com/typesafehub/sbteclipse/</a>
</p><p>Once you have the plugin installed, you need to generate the eclipse project: <a class="ulink" href="https://github.com/typesafehub/sbteclipse/" target="_blank">https://github.com/typesafehub/sbteclipse/</a> </p><p>In the terminal, navigate <a id="id92" class="indexterm"></a>to the project we created earlier (<code class="literal">akkademy-db</code>). In the root of the project, run Activator eclipsify to generate the eclipse project structure.</p><p>You will see the following success message if all went well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[info] Successfully created Eclipse project files for project(s): [info] akkademy-db</strong></span>
</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec03"></a>Importing the project into Eclipse</h5></div></div></div><p>In <a id="id93" class="indexterm"></a>Eclipse, select<a id="id94" class="indexterm"></a> <span class="strong"><strong>File | Import</strong></span>.</p><p>Choose<span class="strong"><strong> General | Existing Projects into Workspace</strong></span>.</p><div class="mediaobject"><img src="graphics/B04006_01_06.jpg" /></div><p>Select the<a id="id95" class="indexterm"></a> folder<a id="id96" class="indexterm"></a> and click <span class="strong"><strong>Next</strong></span>.</p><div class="mediaobject"><img src="graphics/B04006_01_07.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"></a>Tip</h3><p>Note if you<a id="id97" class="indexterm"></a> change <code class="literal">build.sbt</code> you will need to re-generate the<a id="id98" class="indexterm"></a> project and may need to re-import it.</p></div></div></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec13"></a>Creating your first Akka application â€“ setting up the SBT project</h2></div></div><hr /></div><p>Now that we have covered <a id="id99" class="indexterm"></a>setting up your environment and how to create a project, we<a id="id100" class="indexterm"></a> can proceed with creating some actor code in Akka, and then look at how to validate that code. We will be using<a id="id101" class="indexterm"></a> <span class="strong"><strong>simple build tool</strong></span>(<span class="strong"><strong>SBT</strong></span>), which is the preferred build tool for Scala projects and is also the build tool that Play Framework and Activator use under the hood. It's not complex and we will use it only for managing dependencies and building a testing and running applications, so it should not be an obstacle to learning Akka.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>Adding Akka to build.sbt</h3></div></div></div><p>We will now open the<a id="id102" class="indexterm"></a> application (either Java or Scala) in our favorite IDE. The<a id="id103" class="indexterm"></a> scaffolding Activator created is not for an Akka project, so we will need to add the Akka dependencies first. We will add both the Akka core Akka module (akka-actor) and the Akka test-kit, which contains tools to more easily allow us to test the actors.</p><p>In the <code class="literal">build.sbt</code> file, you will see something roughly like this for a Scala project. Note the dependencies are actually Maven dependencies. Any Maven dependencies can easily be added, as we'll cover shortly. The Java and Scala projects will be more or less identical; however the Java project will have a Junit dependency instead of Scalatest:</p><div class="informalexample"><pre class="programlisting">name := """akkademy-db-java"""
version := "1.0"
scalaVersion := "2.11.1"
libraryDependencies ++= Seq( "com.typesafe.akka" %% "akka-actor" % "2.3.6", "com.typesafe.akka" %% "akka-testkit" % "2.3.6" % "test", "junit"             % "junit"           % "4.11"  % "test", "com.novocode"      % "junit-interface" % "0.10"  % "test" )</pre></div><p>To Include Akka, we need to add a new dependency.</p><p>Your dependencies should look something like this for Java:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq( "com.typesafe.akka" % "akka-actor_2.11" % "2.3.6", "junit"             % "junit"           % "4.11"  % "test", "com.novocode"      % "junit-interface" % "0.10"  % "test" )</pre></div><p>And something like this for Scala:</p><div class="informalexample"><pre class="programlisting">name := """akkademy-db-scala"""
version := "1.0"
scalaVersion := "2.11.1"
libraryDependencies ++= Seq( "com.typesafe.akka" %% "akka-actor" % "2.3.3", "com.typesafe.akka" %% "akka-testkit" % "2.3.6" % "test", "org.scalatest" %% "scalatest" % "2.1.6" % "test"
)</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec11"></a>A note on getting the right Scala version with %%</h4></div></div></div><p>As Scala does not have binary<a id="id104" class="indexterm"></a> compatibility across major versions, libraries will often be built and published across several versions of Scala. To have SBT try to resolve the dependency built for the correct Scala version for your project, you can change the dependency declared in the <code class="literal">build.sbt</code> file to use two % symbols after the group ID instead of specifying the Scala version in the artifact id.</p><p>For example, in a Scala 2.11 project, these two dependencies are equivalents as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  "com.typesafe.akka" % "akka-actor_2.11" % "2.3.3"
  "com.typesafe.akka" %% "akka-actor" % "2.3.3"</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec12"></a>Adding other Dependencies from Maven Central</h4></div></div></div><p>Any Maven <a id="id105" class="indexterm"></a>dependencies can be added hereâ€”for <a id="id106" class="indexterm"></a>example from <a class="ulink" href="http://www.mvnrepository.com" target="_blank">http://www.mvnrepository.com</a>. You can see on this link that for any artifact there is an sbt tab that will give you the line to add for the dependency.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>Creating your first Actor</h3></div></div></div><p>In this section, we will create an<a id="id107" class="indexterm"></a> actor that receives a message and updates its internal state by storing the values from the message into a map. This is the humble beginnings of our distributed database.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec13"></a>Making the Message first</h4></div></div></div><p>We're going to <a id="id108" class="indexterm"></a>begin our in-memory database with a <code class="literal">SetRequest</code> message that will store a key (String) and a value (any Object) in memory. You can think of it as a combination of both an insert and an update in one, or like the <code class="literal">set</code> operation on a Map.</p><p>Remember, our actor has to get the message from his mailbox and check what the instruction is in that message. We use the class/type of the message to determine what the instruction is. The contents of that message type describe the exact details of how to fulfill the contract of the API; in this case we will describe the key as a String and the value as an Object inside the message so that we know what to store.</p><p>Messages should always be immutable in order to avoid strange and unexpected behavior, primarily by ensuring you and your team don't do unsafe things across execution contexts/threads. Remember also that these messages may not be simply destined for a local actor but for so another machine. If possible, mark everything <code class="literal">val</code> (Scala) or <code class="literal">final</code> (Java) and use immutable collections and types such as those found in Google Guava (Java) or the Scala Standard Library.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec04"></a>Java</h5></div></div></div><p>Here is our Set message <a id="id109" class="indexterm"></a>in Java as an immutable object. This is a fairly standard approach to immutable objects in Java. It will be a familiar sight to any skilled Java developer; you should generally prefer immutability in all of your code.</p><div class="informalexample"><pre class="programlisting">package com.akkademy.messages;
public class SetRequest { private final String key; private final Object value;public Set(String key, Object value) { 
 this.key = key;
 this.value = value;
 }
    public String getKey() { return key; }    public Object getValue() { return value;
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec05"></a>Scala</h5></div></div></div><p>In Scala we have a much more succinct way of<a id="id110" class="indexterm"></a> defining immutable messagesâ€”the case class. The case class lets us create an immutable message; values can only be set once in the constructor and then are read from the fields:</p><div class="informalexample"><pre class="programlisting">package com.akkademy.messages case class SetRequest(key: String, value: Object)</pre></div><p>That's it for the messages.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec14"></a>Defining Actor response to the Message</h4></div></div></div><p>Now that we have<a id="id111" class="indexterm"></a> the message created, we can create the actor and describe the behavior that the actor will take in response to our message. In our very early example here, we are going to do two things:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Log the message.</p></li><li><p>Store the contents of any Set message for later retrieval.</p></li></ol></div><p>We will build on the example in future chapters to let us retrieve stored messages so that this actor can be used as a thread-safe caching abstraction (and eventually a full-on distributed key-value store).</p><p>We'll have a look at the Java8 actor first.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec06"></a>Java â€“ AkkademyDb.java</h5></div></div></div><p>The following <a id="id112" class="indexterm"></a>code denotes Actor response to the message in Java:</p><div class="informalexample"><pre class="programlisting">package com.akkademy;
import akka.actor.AbstractActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;
import akka.japi.pf.ReceiveBuilder;
import com.akkademy.message.SetRequest;
import java.util.HashMap;
import java.util.Map;
public class AkkademyDb extends AbstractActor { protected final LoggingAdapter log = Logging.getLogger(context().system(), this); protected final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); 
    private AkkademyDb(){ receive(ReceiveBuilder.match(SetRequest.class, message -&gt; { log.info("Received set request â€“ key: {} value: {}", message.getKey(), message.getValue()); map.put(message.getKey(), message.getValue()); }).matchAny(o -&gt; log.info("received unknown message {}", o)).build()
        );
    }
}</pre></div><p>The actor is a Java class that extends <code class="literal">AbstractActor</code> (a Java8 Akka Actor API). We create the logger and the map in the class as protected members so we can access them in test cases later in the chapter.</p><p>In the constructor we call receive. The receive method takes a <code class="literal">ReceiveBuilder</code> which has several methods that we call chained together to produce the final <code class="literal">ReceiveBuilder</code>. With this, we describe how the actor should behave in response to different message types. We define two behaviors here and we will look at them one at a time.</p><p>First, we define the behavior to respond to any <code class="literal">SetRequest</code> messages with:</p><div class="informalexample"><pre class="programlisting">match(SetRequest.class, message -&gt; { log.info("Received Set request: {}", message); map.put(message.getKey(), message.getValue()); }).</pre></div><p>The <code class="literal">ReceiveBuilder</code> match method in the Java8 API is somewhat similar to a case statement except that we can match on class types. More formally, this is pattern matching.</p><p>The match method call, then, says: if the message is of type <code class="literal">SetRequest.class</code>, take that message, log it, and put a new record in the map using the key and value of that Set message.</p><p>Second, we define a<a id="id113" class="indexterm"></a> catch-all to simply log any unknown message.</p><div class="informalexample"><pre class="programlisting">matchAny(o -&gt; log.info("received unknown message"))</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec07"></a>Scala â€“ AkkademyDb.scala</h5></div></div></div><p>Scala is a natural <a id="id114" class="indexterm"></a>fit as the language has pattern matching as a first-class language construct. We'll have a look at the Scala equivalent code now:</p><div class="informalexample"><pre class="programlisting">package com.akkademy
import akka.actor.Actor
import akka.event.Logging
import scala.collection.mutable.HashMap
import com.akkademy.messages.SetRequest
class AkkademyDb extends Actor {
  val map = new HashMap[String, Object]
  val log = Logging(context.system, this) override def receive = { case SetRequest(key, value) =&gt; { log.info("received SetRequest - key: {} value: {}", key, value) map.put(key, value) } case o =&gt; log.info("received unknown message: {}", o);
  }
}</pre></div><p>In the Scala API, we mix in the Actor trait, define the map and logger as we did in Java, and then implement the receive method. The receive method on the Actor super-type returns the Receive which, in the Akka source, is defined as a partial function as follows:</p><div class="informalexample"><pre class="programlisting">type Receive = scala.PartialFunction[scala.Any, scala.Unit]</pre></div><p>We define the behavior for the response to the <code class="literal">SetRequest</code> message using pattern matching to produce the partial function. We can extract the key and the value variables for clearer code using pattern matching semantics:</p><div class="informalexample"><pre class="programlisting">case SetRequest(key, value)</pre></div><p>The behavior is to simply log the request, and then to set the key/value in the map.</p><div class="informalexample"><pre class="programlisting">    case SetRequest(key, value) =&gt; { log.info("received SetRequest - key: {} value: {}", key, value)
      map.put(key, value)
    }</pre></div><p>Finally, we add a <a id="id115" class="indexterm"></a>catch-all case to simply log unknown messages:</p><div class="informalexample"><pre class="programlisting">    case o =&gt; log.info("received unknown message: {}", o);</pre></div><p>That's it for the actor. Now we have to validate we did everything correctly.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"></a>Validating the code with unit tests</h3></div></div></div><p>While books<a id="id116" class="indexterm"></a> covering frameworks may print to the console or create <a id="id117" class="indexterm"></a>web pages that are suitable evidence that our code is working, we're going to be using unit tests to validate code and to demonstrate its use. Library code and services often don't have an API that is easy to interact with or to otherwise to observe, testing is generally how these components are validated in almost every project. This is an important skill for any serious developer to have under their belt.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec15"></a>Akka Testkit</h4></div></div></div><p>Akka provides a<a id="id118" class="indexterm"></a> test kit that provides almost anything you would ever need to test your actor code. We included the test kit dependencies earlier when we set up our project. For reference, the SBT dependency to place in <code class="literal">build.sbt </code>is as follows:</p><div class="informalexample"><pre class="programlisting">  "com.typesafe.akka" %% "akka-testkit" % "2.3.6" % "test"</pre></div><p>We're going to use the <code class="literal">TestActorRef</code> generic here from the testkit instead of a normal <code class="literal">ActorRef</code> (which we will look at in the next chapter). The <code class="literal">TestActorRef</code> does two things: it makes the actor's API synchronous so we don't need to think about concurrency in our tests, and it gives us access to the underlying Actor object.</p><p>To be clear, Akka hides the actual Actor (<code class="literal">AkkademyDb</code>) and instead gives a reference to the actor that you send messages to. This encapsulates the actor to enforce message passing as nobody can access the actual object instance.</p><p>Next we will look at the source code, and then explain it line by line.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec08"></a>Java</h5></div></div></div><p>This is the source code<a id="id119" class="indexterm"></a> for Akka toolkit:</p><div class="informalexample"><pre class="programlisting">package com.akkademy;
import static org.junit.Assert.assertEquals;
import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.testkit.TestActorRef;
import com.akkademy.messages.SetRequest;
import org.junit.Test;
public class AkkademyDbTest { ActorSystem system = ActorSystem.create(); 
    @Test
    public void itShouldPlaceKeyValueFromSetMessageIntoMap() { TestActorRef&lt;AkkademyDb&gt; actorRef = TestActorRef.create(system, Props.create(AkkademyDb.class)); actorRef.tell(new SetRequest("key", "value"),ActorRef.noSender());
        AkkademyDb akkademyDb = actorRef.underlyingActor(); assertEquals(akkademyDb.map.get("key"), "value");}
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec09"></a>Scala</h5></div></div></div><p>The following source code represents<a id="id120" class="indexterm"></a> interaction with the actor:</p><div class="informalexample"><pre class="programlisting">package com.akkademy
import akka.util.Timeout
import org.scalatest.{BeforeAndAfterEach, FunSpecLike, Matchers}
import akka.actor.ActorSystem
import com.akkademy.messages.SetRequest
import akka.testkit.TestActorRef
import scala.concurrent.duration. class AkkademyDbSpec extends FunSpecLike with Matchers with BeforeAndAfterEach {implicit val system = ActorSystem()
  describe("akkademyDb") { describe("given SetRequest"){ it("should place key/value into map"){ val actorRef = TestActorRef(new AkkademyDb) actorRef ! SetRequest("key", "value")
        val akkademyDb = actorRef.underlyingActorakkademyDb.map.get("key") should equal(Some("value"))
      }
    }
  }
}</pre></div><p>This is the first time we are looking at interacting with an actor so there is some new code and behavior, some of it is test-specific and some related to interacting with the actor.</p><p>We've described an Actor System as a place where actors and their addresses reside, the first thing we need to do before creating the actor is to get a reference to an actor system. We create one as a field in the test:</p><div class="informalexample"><pre class="programlisting">//Java
ActorSystem system = ActorSystem.create();
//Scala
implicit val system = ActorSystem()</pre></div><p>After creating the actor system, we can now create our actor in the actor system. As mentioned, we're going to use Akka Testkit to create a <code class="literal">TestActorRef</code> which has a synchronous API, and lets us get at the underlying actor. We create the actor in our actor system here:</p><div class="informalexample"><pre class="programlisting">//Java
TestActorRef&lt;AkkademyDb&gt; actorRef = TestActorRef.create(system, Props.create(AkkademyDb.class));
//Scala
val actorRef = TestActorRef(new AkkademyDb)</pre></div><p>We call the Akka Testkit <code class="literal">TestActorRef</code> create method, passing in the actor system we created (it is implicitly passed in Scala) and a reference to the class. We will look at actor creation in further chapters. Actor instances are hidden away so the act of creating an actor in our actor system returns an <code class="literal">ActorRef</code> (in this case, a <code class="literal">TestActorRef</code>) that we can send messages to. The system and class reference is enough for Akka to create this simple actor in our actor system so we have successfully created our first actor.</p><p>We communicate with an actor via message-passing. We place a message into an actor's mailbox with 'tell' or '!' in Scala, which is still read as 'tell'. We define that there is nobody to respond to for this message as a parameter of the <code class="literal">tell</code> method in Java. In Scala, outside of an actor, this is implicit.</p><div class="informalexample"><pre class="programlisting">//Java
actorRef.tell(new SetRequest("key", "value"), ActorRef.noSender());
//Scala
actorRef ! SetRequest("key", "value")</pre></div><p>Because we are using <code class="literal">TestActorRef</code>, the call to tell will not continue until the request is processed. This is fine for a look at our first actor but it's important to note that this example does not expose the asynchronous nature of the Actor's API. This is not the usual behavior; tell is an asynchronous operation that returns immediately in normal usage.</p><p>Finally, we need to ensure that the behavior is correct by asserting that the actor placed the value into its map. To do this, we get the reference to the underlying Actor instance, and inspect the map by calling <code class="literal">get("key")</code> and ensuring the value is there.</p><div class="informalexample"><pre class="programlisting">//Java
AkkademyDb akkademyDb = actorRef.underlyingActor();
assertEquals(akkademyDb.map.get("key"), "value");
//Scala
val akkademyDb = actorRef.underlyingActor
akkademyDb.map.get("key") should equal(Some("value"))</pre></div><p>That's it for the creation <a id="id121" class="indexterm"></a>of our first simple test case. This basic pattern can be built on for unit testing Actors synchronously. As we go through the book, we will look at more extensive unit-testing examples as well as asynchronous integration testing of our actors.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec24"></a>Running the test</h3></div></div></div><p>We're almost there! Now that we've built our <a id="id122" class="indexterm"></a>tests, we can go to the command line and run 'activator' to start the activator cli. Next we can run 'clean' to tidy up any garbage and then 'test' which will fire off the tests. To do this in one step, we can run activator clean test.</p><p>You should see something like the following for the Java Junit test:</p><div class="informalexample"><pre class="programlisting">[INFO] [01/12/2015 23:09:24.893] [pool-7-thread-1] [akka://default/user/$$a] Received Set request: Set{key='key', value=value}
[info] Passed: Total 1, Failed 0, Errors 0, Passed 1
<span class="strong"><strong>[</strong></span>success] Total time: 7 s, completed 12-Jan-2015 11:09:25 PM</pre></div><p>And if you're using Scala, then scala-test will give you a bit nicer output:</p><div class="informalexample"><pre class="programlisting">[info] AkkademyDbSpec:
[info] akkademyDb
[info] - should place key/value from Set message into map
[info] Run completed in 1 second, 990 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.</pre></div><p>The output will tell you some information about how many tests were run, how many tests failed, and, if there are any errors, it will indicate where the failures occurred so that you can investigate. Once you have a test in place on a behavior, you can be confident that any changes or refactorings you apply did not break the behavior.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>Homework</h2></div></div><hr /></div><p>To ensure you have a good grasp on the content, an assignment will be given at the end of each chapter:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Place the Akka documentation in your Bookmark bar. Also place <span class="emphasis"><em>Hacker News</em></span> there and read it every day.</p></li><li style="list-style-type: disc"><p>Come up with an idea for a service you want to build and provide on the Internet. Preferably the service should involve processing some input and storing it or returning it.</p></li><li style="list-style-type: disc"><p>Create a repository in GitHub for your project. Check your project into GitHub. If you've never worked with Git or GitHub, now is a good time as the source from this book is available there! You can use it to post and display the work you do in this book. Tag your README with <code class="literal">LEARNINGAKKAJG</code> so others can search for your project on GitHub to see what you've done.</p></li><li style="list-style-type: disc"><p>Create an actor. Have the actor store the last string that it was sent.</p></li><li style="list-style-type: disc"><p>Write a unit test to confirm the actor will receive a message correctly.</p></li><li style="list-style-type: disc"><p>Write a unit test to confirm the actor behaves correctly if it is sent two messages.</p></li><li style="list-style-type: disc"><p>Push your project to GitHub.</p></li><li style="list-style-type: disc"><p>Check out the book source code from <a class="ulink" href="http://www.github.com/jasongoodwin/learning-akka" target="_blank">http://www.github.com/jasongoodwin/learning-akka</a>
</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec15"></a>Summary</h2></div></div><hr /></div><p>We have officially started our journey into building a scalable and distributed applications using Akka. In this chapter, we looked at a brief history of the actor model to understand what Akka is and where it came from. We also learned how to set-up an sbt project for our Akka code. We set up our environment to work with sbt projects and created an actor. Then, we tested the behavior of our actor with a unit test</p><p>In the following few chapters, our example application will really start to take shape as we expand it with a client and distribute it across cores and processes.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch02"></a>ChapterÂ 2.Â Actors and Concurrency</h2></div></div></div><p>This chapter will focus on preparing you for the rest of this book by ensuring that you have the necessary background in working with concurrent and asynchronous code. This chapter is incredibly important to get down before you proceed. If you are very comfortable working with Scala futures, Play promises, or Java8 completable futures, you may skim through this chapter. If you have experience with Guava or Spring Listenable Futures, you'll want to learn the differences in the APIs presented here. If you have never worked with a monadic future, you'll want to take your time here.</p><p>The chapter will cover the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The anatomy of, creation of, and communication with an actor</p></li><li style="list-style-type: disc"><p>The tools and knowledge necessary to deal with asynchronous responses from the Actor API</p></li><li style="list-style-type: disc"><p>Working with Futuresâ€”place-holders of results that will be available in the future that can succeed or fail</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec16"></a>Reactive system design</h2></div></div><hr /></div><p>A<a id="id123" class="indexterm"></a> book on Akka would not be complete without a description of the term "Reactive". If you look at books being published or the names of new libraries and frameworks, you may see the word "Reactive" in quite a few of the titles. Akka is also called a <a id="id124" class="indexterm"></a>
<span class="strong"><strong>Reactive platform</strong></span> or more specifically part of the Typesafe Reactive platform. In this context, the term has become more popular, partially thanks to the <a id="id125" class="indexterm"></a>Reactive Manifesto, which is a document that attempts to distill the qualities required for a web application to successfully grow while meeting the demands of users today.</p><p>At this point, the word is practically a piece of developer pop-culture. Of course, then, there are a few out there that may grumble when they hear the word. </p><p>This section will briefly introduce the four tenets of the Reactive Manifesto. These are the <a id="id126" class="indexterm"></a>qualities that we will strive for in our applications so that they will scale and be resilient to failure. We will refer back to these qualities throughout this book. The Reactive Manifesto<a id="id127" class="indexterm"></a> can be found at <a class="ulink" href="http://www.reactivemanifesto.org/" target="_blank">http://www.reactivemanifesto.org/</a>.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>The 4 reactive tenets</h2></div></div><hr /></div><p>The reactive <a id="id128" class="indexterm"></a>manifesto includes four tenets or design goalsâ€”responsiveness, elasticity, resiliency, and event-driven design. The four tenets are outlined in the following with examples of their application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec25"></a>Responsive</h3></div></div></div><p>Our applications should <a id="id129" class="indexterm"></a>respond to requests as fast as possible.</p><p>If we have a choice between getting data in a serial manner or in parallel, we should always choose to get the data in parallel in order to get a response back to a user faster. Requests for unrelated data can be made at the same time. When requesting unrelated non-dependent pieces of data, we should evaluate if it's possible to make those requests at the same time.</p><p>If there is a potential error situation, we should return a notification of the problem to the user immediately rather than having them wait for the timeout.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec26"></a>Elastic</h3></div></div></div><p>Our applications should be able to <a id="id130" class="indexterm"></a>scale under varying workload (especially achieved by adding more computing resources). In order to achieve elasticity, our systems should aim to eliminate bottlenecks.</p><p>If we have our in-memory database running on a virtual machine, adding a second machine node could split the queries across the two servers, doubling potential throughput. Adding additional nodes should allow performance to scale in a near-linear manner.</p><p>Adding a second in-memory database node could double memory capacity by splitting the data and moving half of it to the new node. Adding nodes should expand capacity in a near-linear manner.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec27"></a>Resilient</h3></div></div></div><p>Our <a id="id131" class="indexterm"></a>applications should expect faults to occur and react to them gracefully. If a component of the system fails, it should not cause a lack of availability for requests that do not touch that component. Failure is inevitableâ€”that impact should be isolated to the component that fails. If possible, failure of a component should not cause any impact in behavior by employing replication and redundancy in critical <a id="id132" class="indexterm"></a>components and data.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec28"></a>Event-driven/message-driven</h3></div></div></div><p>Using messages instead of<a id="id133" class="indexterm"></a> method invocation prescribes a way in which we can meet the other three reactive tenets. Message-driven systems move the control over how, when, and where requests are responded, which allows routing and load balancing of the responding component.</p><p>An asynchronous message-driven system can more efficiently utilize a system's resources as it only consumes resources like threads when they are actually needed. Messages can be delivered to remote machines as well (location transparency). As messages are queued and delivered outside an actor, it's possible to self-heal a failing system via supervision.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec29"></a>Reactive Tenet Correlation</h3></div></div></div><p>The following figure shows <a id="id134" class="indexterm"></a>Reactive Tenet Correlation:</p><div class="mediaobject"><img src="graphics/B04006_02_01.jpg" /></div><p>Reactive tenets are not completely independent of one another. Often an approach that is used to meet one of the reactive tenets will aid a system in meeting others. For example, if we note that one of our services is behaving slowly, we may stop sending requests to that service for a short period of time to let it recover while giving users an error message immediately. This improves resiliency of our system by reducing risk of a slow service crashing under load, and also improves the responsiveness of our system by indicating to a user that <a id="id135" class="indexterm"></a>there is an issue right away.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Anatomy of an Actor</h2></div></div><hr /></div><p>Before we move into a more <a id="id136" class="indexterm"></a>relevant example, we'll cover the most basic features of an Actor to understand the basic structure and methods. To demonstrate the simplest case possible, for this example we'll build a simple actor that receives a Stringâ€”"Ping"â€”and gives a responseâ€”"Pong".</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec30"></a>Java Actor API</h3></div></div></div><p>We'll look at the <a id="id137" class="indexterm"></a>Java implementation first. The Java and Scala APIs are <a id="id138" class="indexterm"></a>different enough that they each need their own introduction.</p><div class="informalexample"><pre class="programlisting">public class JavaPongActor extends AbstractActor { public PartialFunction receive() { return ReceiveBuilder. matchEquals("Ping", s -&gt;  sender().tell("Pong", ActorRef.noSender())). matchAny(x -&gt; sender().tell( new Status.Failure(new Exception("unknown message")), self() )).                 build(); }
}</pre></div><p>The preceding code shows the Java <code class="literal">actorAPI</code>. We'll look at this example in detail.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">AbstractActor</code>: First, we extend <code class="literal">AbstractActor</code> class This is a Java8-specific API that is meant to take advantage of the Java8 lambda features. There is another base Actor API that can be used for Java if you look at the documentationâ€”<code class="literal">UntypedActor</code>. The <code class="literal">UntypedActor</code> is an older model for working, which we won't cover in this book. In that API, you get an object and must use <code class="literal">if</code> statements to match on the object. We will focus on the Java8 specific API as it is more expressive, presenting a way to pattern-match using lambdas.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Receive</code>
<span class="strong"><strong>:</strong></span> The <code class="literal">AbstractActor</code> class has a method that must be implemented or invoked via the constructor, which is the receive method. It returns a <code class="literal">PartialFunction</code>, which is from the Scala API. In Java, we don't have any native way of building a Scala <code class="literal">PartialFunction</code> (a function that does not match all potential inputs), so Akka gives us a Builder abstraction for producing the <code class="literal">PartialFunction</code> called <code class="literal">ReceiveBuilder</code> and that we use to produce the return value. Don't worry, you won't need to understand Scala <code class="literal">PartialFunctions</code> to use Akka!</p></li><li style="list-style-type: disc"><p>
<code class="literal">ReceiveBuilder</code>: We <a id="id139" class="indexterm"></a>call <code class="literal">ReceiveBuilder</code> methods, stringing together match cases as needed to describe the response to each type of message we need to handle, and then call <code class="literal">build()</code> to produce the <code class="literal">PartialFunction</code> that we need to return.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Match</code>: There <a id="id140" class="indexterm"></a>are a few <code class="literal">match</code> functions in the receive builder that are worth noting. We'll show examples of how to match on ping with each:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">match(class, function)</code>: This describes behavior to apply to any unmatched class instance.</p><div class="informalexample"><pre class="programlisting">match(String.class, s -&gt; {if(s.equals("Ping")) respondToPing(s);})</pre></div></li><li style="list-style-type: disc"><p>
<code class="literal">match(class, predicate, function)</code>: This describes behavior to apply to a message if it is the type of the class and the predicate function is true.</p><div class="informalexample"><pre class="programlisting">match(String.class, s -&gt; s.equals("Ping"), s -&gt; respondToPing(s))</pre></div></li><li style="list-style-type: disc"><p>
<code class="literal">matchEquals(object, function)</code>: This describes behavior to apply if the call to equals is true for the object supplied.</p><div class="informalexample"><pre class="programlisting">matchEquals("Ping", s -&gt; respondToPing(s))</pre></div></li><li style="list-style-type: disc"><p>
<code class="literal">matchAny(function)</code>: This matches any unmatched messages. It's generally a good practice to respond with a failure, or at least log in to aid in troubleshooting during development.</p><p>The <code class="literal">match</code> function will pattern-match from top to bottom, so you can describe specific and then general cases:</p><div class="informalexample"><pre class="programlisting">ReceiveBuilder
    .matchEquals("Ping", s -&gt; System.out.println("It's Ping: " + s))
    .match(String.class, s -&gt; System.out.println("It's a string: "
+ s)) .matchAny(x -&gt; System.out.println("It's something else: " +
x))
    .build</pre></div></li></ul></div></li><li style="list-style-type: disc"><p>
<code class="literal">Reply to sender()</code>: Calling<a id="id141" class="indexterm"></a> the <code class="literal">sender()</code> method will allow us to reply to the message. This could be an actor or this could potentially respond to an ask from outside an actor system. The first case is pretty straightforwardâ€”the message will go back into the sending actor's inbox. The second case we'll look at in more detail later.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Tell()</code>: <code class="literal">sender()</code> function<code class="literal"> </code>gives us an <code class="literal">ActorRef</code>. In the example, we call <code class="literal">tell()</code>; providing<a id="id142" class="indexterm"></a> the sender. <code class="literal">tell()</code> is the most basic one-way message pattern. The first argument is the message we want to place in the sender's mailbox. The second argument is the sender that actor will see.</p><p>Similar to what we did in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span> we describe behavior for messages of the String class. We're using a different match method hereâ€”we include a predicate for the second argument as we need to check that the string equals Ping. We then describe the behaviorâ€”we send a message back to the <code class="literal">sender()</code> with <code class="literal">tell().</code> We send back the String Pong. The <code class="literal">tell</code> method in Java requires the sender of the message to be identifiedâ€”<code class="literal">ActorRef.noSender()</code> is used to indicate there is no reply addresses.</p></li><li style="list-style-type: disc"><p>Replies with <code class="literal">akka.actor.Status.Failure</code>: To report an error back to the sender, we need to send them a message. If an exception is thrown in the actor, it will trigger the supervisor to be notified (covered in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Getting the Message Across</em></span>), but, in any case, if we want to notify of a failure, we need to send back a failure to the sender. If there is a placeholder 'future' for a response, then this will cause the future to fail. We'll cover this shortly.</p></li></ul></div><p>This covers the basics of the Java <code class="literal">AbstractActor</code> API. We'll look at the Scala API next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec31"></a>Scala Actor API</h3></div></div></div><p>The following code <a id="id143" class="indexterm"></a>shows a Scala actor:</p><div class="informalexample"><pre class="programlisting">//Scala
class ScalaPongActor extends Actor { override def receive: Receive = { case "Ping" =&gt; sender() ! "Pong" case _ =&gt; sender() ! Status.Failure(new Exception("unknown message"))
  }
}</pre></div><p>We'll look at the actor in detail now:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Actor</code>: To <a id="id144" class="indexterm"></a>define an actor, we extend the Actor base class. This is the basic Scala actor API. It's simple and a natural fit for Scala's language features.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Receive</code>: Override the receive method in the Actor and return a <code class="literal">PartialFunction</code>. Note that Receive is the return type on the receive methodâ€”it's just a type definition for <code class="literal">scala.</code> <code class="literal">PartialFunction</code>[<code class="literal">scala.Any</code>, <code class="literal">scala.Unit</code>]. If you're not too familiar with <code class="literal">PartialFunctions</code> in the Scala API, not to worryâ€”you just need to build some pattern matching cases that return Unit and know that you're free to make your statements non-exhaustive. If you want to see what's going on under the hood with the receive method, you can play with <code class="literal">scala.PartialFunction</code> on the REPL:</p><div class="informalexample"><pre class="programlisting">scala&gt; val pf: PartialFunction[Any, Unit] = { case _: String =&gt; println("Got a String") } pf: PartialFunction[Any,Unit] = &lt;function1&gt;  scala&gt; pf("hey") Got a String</pre></div></li><li style="list-style-type: disc"><p>
<code class="literal">Reply to sender</code>: In the example actor code, we then access the sender <code class="literal">ActorRef</code> via the <code class="literal">sender()</code> method. We can reply to the sender by sending it a message. We send back a "Pong" in this case.</p></li><li style="list-style-type: disc"><p>
<code class="literal">tell method (!)</code>: We send the message to the sender with the tell method that is invoked via the <code class="literal">!</code> method. You'll note if you read the Java section that the sender must be specified, but here we are omitting any reference to a sender as it's implicit. The tell method <code class="literal">!</code> has an implicit <code class="literal">ActorRef</code> parameter in the method signature. It defaults to <code class="literal">noSender</code> if you're using tell from somewhere outside an actor. The following is the method signature:</p><div class="informalexample"><pre class="programlisting">def !(message: Any)(implicit sender: ActorRef = Actor.noSender): Unit</pre></div></li></ul></div><p>The Actor has an implicit sender value through <code class="literal">self</code>, which is used in the actor, so tell will always provide self as the sender.</p><div class="informalexample"><pre class="programlisting">implicit final val self = context.self</pre></div><p>The sender is implicit so we never have to worry about it, but it's helpful to understand where the values are coming from while comparing the Java and Scala APIs.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Reply with akka.actor.Status.Failure</strong></span>: The last piece to note is the reply with <code class="literal">akka.actor</code>. <code class="literal">Status.Failure</code> in the case of an unknown message. The actor will never reply with a failureâ€”even if the actor itself failsâ€”so you will always need to ensure you send back a failure if you want to notify anyone who is asking that there was an issue. Sending back a failure will cause a placeholder future to be marked as a failure.</p></li></ul></div><p>We'll look at<a id="id145" class="indexterm"></a> the specifics of getting a reply from an actor shortlyâ€”first we <a id="id146" class="indexterm"></a>need to be able to create an actor.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Creating an actor</h2></div></div><hr /></div><p>Actors are not accessed<a id="id147" class="indexterm"></a> like ordinary objects. You never get an instance of an actor. You do not call methods on actors or directly change their stateâ€”you pass them messages. You do not access members of the actorâ€”you request information about its state through message-passing. Using message-passing instead of method invocation enforces encapsulation. Alan Kay, who originally described Object-Oriented programming, actually included message-passing as one of the definitions of object-oriented programming. I'm sure Alan Kay looks at what OO has turned into and shakes his head some days.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">Â </td><td width="80%" valign="top"><p><span class="emphasis"><em>I made up the term 'object-oriented', and I can tell you I didn't have C++ in mind</em></span></p></td><td width="10%" valign="top">Â </td></tr><tr><td width="10%" valign="top">Â </td><td colspan="2" align="right" valign="top">--<span class="attribution"><span class="emphasis"><em>Alan Kay, OOPSLA '97</em></span></span></td></tr></table></div><p>Using a message-based approach allows us to encapsulate the instance of an actor quite completely. If we only communicate through messages, then there is never any need to access the actor instance. We only need a mechanism to send the actor messages and to get responses.</p><p>In Akka, this reference to an actor is called an <code class="literal">ActorRef</code>. The <code class="literal">ActorRef</code> is an un-typed reference that encapsulates the actor behind a layer of abstraction and gives us the mechanisms to interact with the actor.</p><p>We've covered the fact that the actor system is where actors exist. It may be obvious that this is also where we create actors and obtain references to them. The <code class="literal">actorOf</code> method will produce a new actor and return a reference to it:</p><div class="informalexample"><pre class="programlisting">//Java
ActorRef actor = actorSystem.actorOf(Props.create(JavaPongActor.class));
//Scala
val actor: ActorRef =
actorSystem.actorOf(Props(classOf[ScalaPongActor]))</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>Note here that we don't actually create the actorâ€”we don't, for example, call <code class="literal">actorOf</code>(new <code class="literal">PongActor</code>).</p></div><p>The actors are<a id="id148" class="indexterm"></a> encapsulatedâ€”they should not be accessible. We never want to be able to access the Actor's state from our code. The creation pattern used ensures this; we'll now look at this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec32"></a>Props</h3></div></div></div><p>To ensure we encapsulate the actor instance and never gain access to an instance of it, we pass in a Props<a id="id149" class="indexterm"></a> instance with all of the constructor <code class="literal">args</code>. Props lets us pass in the class, and a variable lengle list of arguments:</p><div class="informalexample"><pre class="programlisting">//Java
Props.create(PongActor.class, arg1, arg2, argn);
//Scala
Props(classOf[PongActor], arg1, arg2, argn)</pre></div><p>If the actor takes constructor arguments, it's recommended that the props is created via a factory method. If we wanted our <span class="emphasis"><em>Pong</em></span> actor to respond with a message other than <span class="emphasis"><em>Pong</em></span>, we might take that as a constructor arg. We can create a factory method to produce the Props instance like so:</p><div class="informalexample"><pre class="programlisting">//Java
public static Props props(String response) { return Props.create(this.class, response); }
//Scala
object ScalaPongActor { def props(response: String): Props = { Props(classOf[ScalaPongActor], response) }
}</pre></div><p>Then we would create the actor using the props factory method:</p><div class="informalexample"><pre class="programlisting">//Java
ActorRef actor = actorSystem.actorOf(JavaPongActor.props("PongFoo"));
//Scala
val actor: ActorRef = actorSystem.actorOf(ScalaPongActor props "PongFoo")</pre></div><p>Creating the props factory method isn't required but moves the concern of creating the Props object into one place so that any changes to the actor's constructor can be isolated to avoid making breaking changes as the code changes over time.</p><p>
<code class="literal">actorOf</code> creates<a id="id150" class="indexterm"></a> an actor and gives you an <code class="literal">ActorRef</code> for the newly created actor. There is another way to get a reference to an Actorâ€”<code class="literal">actorSelection</code>.</p><p>To understand <code class="literal">actorSelection</code>, we first need to look at actor paths. Each actor is created with a path that you can see at <code class="literal">ActorRef.path</code>. It might look something like the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">akka://default/user/BruceWillis</code>
</p></li></ul></div><p>It's a URI and it can even reference a remote actor with the <code class="literal">akka.tcp</code> protocol:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">akka.tcp://my-sys@remotehost:5678/user/CharlieChaplin</code>
</p></li></ul></div><p>Note that the preceding path states <code class="literal">akka.tcp</code> as the protocol and specifies the host and port of the remote actor system. If we know the path of an Actor, we can use <code class="literal">actorSelection </code>to get a referenceâ€”an <code class="literal">ActorSelection</code>â€”for that Actor, even if it is on a remote machine:</p><div class="informalexample"><pre class="programlisting">ActorSelection selection = system.actorSelection("akka.tcp://actorSystem@host.jason-goodwin.com:5678/user/KeanuReeves");</pre></div><p>The <code class="literal">ActorSelection</code> here is a reference to a remote actorâ€”we can use the <code class="literal">ActorSelection</code> like the <code class="literal">ActorRef</code> to communicate over the network. This demonstrates how easy it is to send messages over the wire, and is an example of Akka's location transparency in action. We're able to change an application to communicate with remote services merely by configuring where an actor is located.</p><p>To recap this section, we can create an Actor and gain a reference to it by calling <code class="literal">system.actorOf</code> and pass it a Props instance with the list of <code class="literal">args</code>. We can also give the actor a name by passing that into the <code class="literal">actorOf</code> method. Finally, we can look up an existing actor, even on a remote system, by using <code class="literal">actorSelection</code>.</p><p>Next we'll begin to look at how to write asynchronous and event-driven code.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Promises, futures, and event-driven programming models</h2></div></div><hr /></div><p>Before moving on to working <a id="id151" class="indexterm"></a>with more complex Actor-based applications, we need to understand some basic abstractions for working in an event-driven programming modelâ€”Promises<a id="id152" class="indexterm"></a> and <a id="id153" class="indexterm"></a>Futures. In <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span> we saw how to send a message to an actor and have it invoke some behavior in response to that event. But, what if we need to get some output from the actor in response to that message? Let's say we need to get a record from our in-memory key-value store?</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec33"></a>Blocking versus event-driven APIs</h3></div></div></div><p>Blocking code is familiar to almost<a id="id154" class="indexterm"></a> any developer. It's where we start <a id="id155" class="indexterm"></a>when we begin with IO. When we make a call to a synchronous API, the calling method does not return immediatelyâ€”the application waits for execution to complete. For example, if you make an HTTP request, you'll get back a response object once the request is completed. Code that waits for IO to complete is called blocking as a thread sits and waitsâ€”it is blocked from doing any other work until the IO is complete. We can demonstrate blocking code by showing a query using <a id="id156" class="indexterm"></a>
<span class="strong"><strong>Java Database Connectivity</strong></span> (<span class="strong"><strong>JDBC</strong></span>):</p><div class="informalexample"><pre class="programlisting">      stmt = conn.createStatement();
      String sql = "select name from users where id='123'";
      ResultSet rs = stmt.executeQuery(sql);
      rs.next()
      String name  = rs.getString("name");</pre></div><p>Here we retrieve a user's name from a database using JDBC. The code looks very simple but there are hidden effects that make this simple code less readable:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Latency</strong></span>: It takes time to go over the network to get the result.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Failure</strong></span>: The request can fail if, for example, the remote service is unavailable. An exception might be thrown for any number of reasons.</p></li></ul></div><p>When we call <code class="literal">executeQuery</code>, the thread that is executing this code has to wait for the database query to complete. In a web application, where many users may be making concurrent requests, the finite limit of the thread pool can be reached. There are a limited number of threads in that thread pool, and if all of them are waiting on IO, then you can't put any more traffic through the server even if you have free compute resources as there are no threads available to use those resources. If you've done any performance tuning on blocking Servlet-based web applications, you may have witnessed the limitations of <code class="literal">threadpool</code>. Usually the CPU will be under-utilized when the server is at capacity because all of the threads are just waiting.</p><p>This is potentially because the <code class="literal">threadpool</code> is exhausted, or it may also be because the system is spending time loading and unloading the context of threads that need the free CPU time instead of actually doing work on the CPU. Similarly, there are a limited number of threads in the <code class="literal">threadpool</code>. So, if all of the threads are waiting, the next calls that come into the server cannot be handled until a thread is freed, causing latency to grow.</p><p>So you might ask why we don't simply use an unlimited <code class="literal">threadpool</code> (create one new thread for every request). Creating a thread has a cost and maintaining many active threads has a cost. When using many threads on a core, the operating system has to context-switch between threads in order to ensure all of the threads are getting CPU time. The CPU has to unload and store the current thread's state, and then load in another thread's context that is waiting for CPU time. If there are 1,000 threads actively working, you can imagine that this may represent a lot of overhead in loading and unloading contexts.</p><p>To summarize, there are a <a id="id157" class="indexterm"></a>few problems with using many threads to <a id="id158" class="indexterm"></a>handle blocking IO:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Code does not obviously express failure in the response type</p></li><li style="list-style-type: disc"><p>Code does not obviously express latency in the response type</p></li><li style="list-style-type: disc"><p>Blocking models have throughput limitations due to fixed <code class="literal">threadpool</code> sizes</p></li><li style="list-style-type: disc"><p>Creating and using many threads has a performance overhead due to context-switching</p></li></ul></div><p>A non-blocking asynchronous event-driven system can run with only a handful of threads and will not block those threads, only using them when computation is needed. This gives the system better responsiveness at scale and can allow better system resource utilization. Depending on the implementation, there can also be a benefit in making effects such as failure and latency more clearly defined in the types, as we'll see soon.</p><p>The downside is that it can take a bit of time to understand how to write code using event-driven paradigms. We'll look at an example of each model to better understand how the two design approaches work.</p><p>First, we'll look at a very simple call to a database using blocking IO.</p><div class="informalexample"><pre class="programlisting">//Java
String username = getUsernameFromDatabase(userId); System.out.println(username);
//Scala
val username = getUsernameFromDatabase(userId)
println(username)</pre></div><p>The method is invoked and the thread continues into the method, returning once there is a result.</p><p>If you were debugging, you could step into the method with the thread and see each line of the method <code class="literal">getUsernameFromDatabase</code> method called. Once the actual IO is executed, the thread will sleep until the result comes back. Then the thread returns the method, and jumps back out of the method and continues to print the result.</p><div class="mediaobject"><img src="graphics/B04006_02_02.jpg" /></div><p>The event-driven <a id="id159" class="indexterm"></a>equivalent will look different because <a id="id160" class="indexterm"></a>we have to describe what happens when the completion event occurs, and that code is executed in a different context. To turn our example above into an event-driven equivalent, the code needs to express the print statement as something that happens when the result comes back from the database. It can take some time to adjust to this model, but you only have to learn it once.</p><p>To move to an event-driven model, we have to express the result in code differently. We have to use placeholders for values that will eventually be thereâ€”a future. The printing of the result is registered as something to do when the completion event occurs. We register some code that we to be invoked when the value the placeholder represents becomes available. The term "event-driven" describes the way that we express code to execute on certain events:</p><div class="informalexample"><pre class="programlisting">//Java
CompletableFuture&lt;String&gt; usernameFuture = getUsernameFromDatabaseAsync(userId);
usernameFuture.thenRun(username -&gt;
    //executed somewhere else
    System.out.println(username)
);
//Scala val future = getUsernameFromDatabaseAsync(userId)
future.onComplete(username =&gt;
  //executed somewhere else
  println(username)
)</pre></div><p>From the thread's perspective, the code will call the method and go into the method, and then return with a Future/Completable Future almost immediately. The result is only a placeholder of the value that will eventually be there.</p><p>We won't look at the method invocation itself in too much detailâ€”you should understand that the method will return immediately and the database call and result will happen somewhere else, on another thread. There is an <code class="literal">ExecutionContext</code> that represents the threads where the other work is done, which we'll look at later in this book. (In Akka, you'll see a dispatcher in the <code class="literal">ActorSystem</code>, which is an <code class="literal">ExecutionContext</code> implementation.)</p><p>Note, there is<a id="id161" class="indexterm"></a> a critical difference if you're trying to debug <a id="id162" class="indexterm"></a>async codeâ€”you won't see all of the details of the call to the database on the invoking thread, so you can't step through the database call from the invoking thread using a debugger like you can in a blocking model. Similarly, if you look at a stack trace from a failure, you may not necessarily see the original calling codeâ€”you'll see references to another stack where the code is being run.</p><p>After the method returns the future, we only have the promise of a value that will eventually be there. We don't want to make the thread wait for the result, but we want to take some action when the result becomes available (print it to the console). The way we do work in an event-driven system is to describe the code to run when an event happens. In an actor, we describe the behavior to use when a message is received. Similarly, with a future, we describe the behavior to execute when the future's value becomes available. The methods on a future to register code to run on the successful completion event successfully with then Run (Java8) or on Complete (Scala).</p><div class="mediaobject"><img src="graphics/B04006_02_03.jpg" /></div><p>It's important to highlight againâ€”the print statement will not run on the thread that registers the event. It will run somewhere else, on another thread via the <code class="literal">ExecutionContext</code>. Futures are always created with <code class="literal">ExecutionContext</code>, so you can choose where to run them.</p><p>All of the variables<a id="id163" class="indexterm"></a> in scope are available to the lambda<a id="id164" class="indexterm"></a> registered. Methods, however, should be invoked with special care, or simply should not be invoked within the closures, as they won't be invoked in the same lexical scope. We'll look at this gotcha in the next chapter.</p><p>Note that futures can fail and should always be bounded by a timeout (required in the Scala API) so they will not hang around forever and will always finishâ€”either successfully or with failure. We'll take a closer look at handling futures now.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec16"></a>Skills check-point</h4></div></div></div><p>Scala developers should be<a id="id165" class="indexterm"></a> familiar with using higher order functions/lambdas. It would be helpful for the developer to have some familiarity with the option or try types to ensure the material is fast to understand.</p><p>If you're using Java8, it's a good time to check in and see if you're comfortable reading the code examples so far. If you're unclear on the use of lambdas, you should take the time now to go through the <a id="id166" class="indexterm"></a>Oracle Java8 lambda primer, which can be found at <a class="ulink" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html" target="_blank">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html</a>.</p><p>You should get some experience working with them by exploring the Stream API and the Optional type. The Optional type is helpful to learn as it's semantically similar in its use to <code class="literal">CompletableFuture</code>.</p><p>Understanding the following material will be easier if you have some experience to relate the material to first.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec34"></a>Having an Actor respond via a future</h3></div></div></div><p>We looked at a <a id="id167" class="indexterm"></a>hypothetical example of an asynchronous <a id="id168" class="indexterm"></a>database call, where the result of a call to the database completes a future. We'll introduce a real example now by communicating with the example actors that we built earlier in this chapterâ€”the <code class="literal">PongActor</code>. We'll have a way of communicating with actors from outside the actor system after this so that we can use Akka to build the core of an application or library and use it from plain Java or Scala code.</p><p>While the test case here does introduce the asynchronous API, the test cases are still blocking by awaiting the result. This is useful in demonstrating another way of handling Akka in your test cases. We need the test cases to block because, if we don't wait for the result, the test case will always return immediately and, hence, will always pass.</p><p>You should build<a id="id169" class="indexterm"></a> these test cases and use them to explore the future <a id="id170" class="indexterm"></a>API introduced in the next section to understand it well. By building these examples, you'll always have a sandbox you can return to if you need to further examine how futures work. They are included in the source code for this book as well.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec17"></a>Java example</h4></div></div></div><p>We'll cover the Java8 examples<a id="id171" class="indexterm"></a> first. Akka is built in Scala, and, generally, the Scala and Java APIs are one to one. There is a notable exception and that is that all asynchronous methods that return a future will return the Scala <code class="literal">scala.concurrent.Future</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec10"></a>Working with Scala futures</h5></div></div></div><p>For the <a id="id172" class="indexterm"></a>Java examples, we need a way to handle Scala futuresâ€”in this <a id="id173" class="indexterm"></a>book, we'll convert them to the Java8 <code class="literal">CompletableFuture</code>.</p><p>The Play Promise API is also a good choice if you're building a Play application. I personally prefer the semantics used in the Play Promise API over the Java8 <code class="literal">CompletableFuture</code> API, but the Java8 API may be more readable for those not accustomed to working with asynchronous code yet. It's recommended if your code may be placed into a library that you use the Java8 <code class="literal">CompletableFuture</code> so you do not have a dependency on Play in your code outside the controller.</p><p>To start, we need to add this dependency from the Scala team to your <code class="literal">build.sbt</code> to be able to convert between Scala and Java8 Futures:</p><div class="informalexample"><pre class="programlisting">"org.scala-lang.modules" %% "scala-java8-compat" % "0.6.0"</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec11"></a>Test case</h5></div></div></div><p>The following is the complete<a id="id174" class="indexterm"></a> test case. Next, we'll look at each element of the APIs in detail:</p><div class="informalexample"><pre class="programlisting">package pong;
//[...imports] import static scala.compat.java8.FutureConverters.*;
public class PongActorTest { ActorSystem system = ActorSystem.create(); ActorRef actorRef = system.actorOf(Props.create(JavaPongActor.class)); @Test
    public void shouldReplyToPingWithPong() throws Exception { Future sFuture = ask(actorRef, "Ping", 1000); final CompletionStage&lt;String&gt; cs = toJava(sFuture); final CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs; assert(jFuture.get(1000, TimeUnit.MILLISECONDS).equals("Pong")); }
    @Test(expected = ExecutionException.class) public void shouldReplyToUnknownMessageWithFailure() throws Exception { Future sFuture = ask(actorRef, "unknown", 1000); final CompletionStage&lt;String&gt; cs = toJava(sFuture); final CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs; jFuture.get(1000, TimeUnit.MILLISECONDS); }
}</pre></div><p>Our Pong Actor <a id="id175" class="indexterm"></a>test has a test for both the success case and failure case.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec12"></a>Actor creation</h5></div></div></div><p>We begin by <a id="id176" class="indexterm"></a>creating an <code class="literal">ActorSystem</code>, and then an actor in that actor system with <code class="literal">actorOf</code>, as previously covered:</p><div class="informalexample"><pre class="programlisting">ActorSystem system = ActorSystem.create();
ActorRef actorRef = 
system.actorOf(Props.create(JavaPongActor.class));</pre></div><p>Now, we ask the actor for a response to a message:</p><div class="informalexample"><pre class="programlisting">final Future sFuture = ask(actorRef, "Ping", 1000);</pre></div><p>This is fairly straightforwardâ€”we call the ask method, passing:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The actor ref to send the message to</p></li><li style="list-style-type: disc"><p>The message we want to send the actor</p></li><li style="list-style-type: disc"><p>The timeout for the futureâ€”how long to wait for a result before considering it a failure</p></li></ul></div><p>This gives us back the placeholder of the response we'll get in the futureâ€”a Scala Future. In the actor code, the actor will send a message back to <code class="literal">sender()</code>, which we will receive as the response to this future.</p><p>We can't use the Scala Future from Java8, but we can convert it with the library we imported earlier:</p><div class="informalexample"><pre class="programlisting">final CompletionStage&lt;String&gt; cs = toJava(sFuture); final CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs;</pre></div><p>We first convert the Scala future with <code class="literal">scala.compat.java8.FutureConverters.toJava</code>,<code class="literal"> </code>which gives us a <code class="literal">CompletionStage</code>. The <code class="literal">CompletionStage</code> is the interface for the <code class="literal">CompletableFuture</code>â€”specifically it is a read-only interface. In this case, we cast the future to gain access to the get method. You won't need to cast the <code class="literal">CompletionStage</code> outside of test cases.</p><p>Note that we're <a id="id177" class="indexterm"></a>placing a String type on the future. Actors are untyped and return an Object, so you may find the unchecked casting a little iffy. Certainly, some care is needed when talking to Actors from outside of the <code class="literal">ActorSystem</code> in this regard. We know that the Actor will always return a String on this message, though, so it's a safe assertion that the type of the future is a String.</p><p>Finally, we call the <code class="literal">get()</code> method to block the thread in the tests and get the result. In the failure test, the get method will throw an exceptionâ€”it will throw the <code class="literal">akka.status.Failure</code> message's exception, which is sent from the actor.</p><p>You now have an example of a successful and failing future to experiment with!</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec18"></a>Scala example</h4></div></div></div><p>Next, we'll cover the Scala example<a id="id178" class="indexterm"></a>. Akka gives Scala futures, so the test is a bit simpler.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec13"></a>Test case</h5></div></div></div><p>The following is the complete Scala <a id="id179" class="indexterm"></a>test case. Next, we'll cover the test in detail:</p><div class="informalexample"><pre class="programlisting">package pong
//[...imports]
import akka.pattern.ask import scala.concurrent.duration._ 
class ScalaAskExamplesTest extends FunSpecLike with Matchers { val system = ActorSystem() implicit val timeout = Timeout(5 seconds) val pongActor = system.actorOf(Props(classOf[ScalaPongActor])) describe("Pong actor") { it("should respond with Pong") { val future = pongActor ? "Ping" //uses the implicit timeout val result = Await.result(future.mapTo[String], 1 second) assert(result == "Pong") }it("should fail on unknown message") { val future = pongActor ? "unknown" intercept[Exception]{ Await.result(future.mapTo[String], 1 second)
      }
    }
  }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec14"></a>Actor creation</h5></div></div></div><p>We begin by creating an <code class="literal">ActorSystem</code> and then creating an actor in that actor system with <code class="literal">actorOf</code>, as <a id="id180" class="indexterm"></a>previously covered.</p><p>We also create an implicit <code class="literal">Timeout</code> for the future creation (note that the import of <code class="literal">scala.concurrent.duration</code> is needed for the duration passed in to the Timeout):</p><div class="informalexample"><pre class="programlisting">  implicit val system = ActorSystem()
  implicit val timeout = Timeout(5 seconds)
  val pongActor = system.actorOf(Props(classOf[ScalaPongActor]))</pre></div><p>Now, we ask the actor for a response to a message:</p><div class="informalexample"><pre class="programlisting">val future = pongActor ? "Ping"</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip05"></a>Tip</h3><p>We need to import <code class="literal">akka.pattern.ask</code> for this to work.</p></div><p>The call to ask references:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The actor ref to send the message to <code class="literal">pongActor</code>
</p></li><li style="list-style-type: disc"><p>The message we want to send the actor</p></li><li style="list-style-type: disc"><p>Implicitly, the timeout for the futureâ€”how long to wait for a result before considering it a failure</p></li></ul></div><p>This gives us back a placeholderâ€”a Futureâ€”that represents the actor's reply. In the actor code, the actor will send a message back to <code class="literal">sender()</code>, which we will receive as the response to this future.</p><p>Finally, we want to block the test until we have the result available. We use <code class="literal">Await.result</code> on the future with a timeout value:</p><div class="informalexample"><pre class="programlisting">val result = Await.result(future.mapTo[String], 1 second)</pre></div><p>The Actor is untyped, so we get back a <code class="literal">Future[AnyRef].</code> We call <code class="literal">future.mapTo[String]</code> to change the future's type to the expected type of the result.</p><p>You can build on this example nowâ€”play around with the Future API as we continue through the next sections of this chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec19"></a>Blocking threads in tests</h4></div></div></div><p>Asking an actor<a id="id181" class="indexterm"></a> for a response demonstrates how to talk to an actor <a id="id182" class="indexterm"></a>from outside the actor system by getting a response via a future. In this test case, we sleep/block the test thread by calling get <code class="literal">Await.result</code> in order to get the result out of the future synchronously.</p><p>This is fine in test casesâ€”it's actually necessary or the test will complete before the result is availableâ€”however, blocking is a bad practice anywhere other than in test cases. You should only have non-blocking code outside of the test context.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip06"></a>Tip</h3><p>Don't sleep or block outside tests.</p></div><p>In tests, the preferred way to block with the Java8 completable future is to call the get() method on the Future. The get() method will block the thread until the result is available:</p><div class="informalexample"><pre class="programlisting">jFuture.get().equals("Pong")</pre></div><p>While <code class="literal">get()</code> will sleep forever if you don't specify a timeout, the Scala future requires a timeout (specified in the ask method), so the future will fail if the timeout is violated.</p><p>Getting the result from the Scala Future can be accomplished by using <code class="literal">scala.concurrent.Await.result</code>:</p><div class="informalexample"><pre class="programlisting">import scala.concurrent.duration._ val result: String = Await.result(future.mapTo[String], 1 second)</pre></div><p>Here the timeout is requiredâ€”it's redundant as the ask method has already placed a timeout on the future.</p><p>In both the Java and Scala examples, if the future fails, blocking will result in the exception that the future failed with being thrown. The Java8 <code class="literal">CompletableFuture</code> will throw an <code class="literal">ExecutionException</code> caused by the <code class="literal">Throwable</code> the future fails with. The Scala API will throw the actual <code class="literal">Throwable</code>. (Scala has no checked exceptions, so the API can do thisâ€”Java throws an unchecked exception type here.)</p><p>You now have an example of a future that you can work with and mechanisms to build test cases to examine the results. We will begin to cover the future APIs in depth now as they are crucial to understand when working with asynchronous code. It is highly recommended you explore the future API inside these test cases. To save some typing, the examples are available in the <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> code bundle available online.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec35"></a>Understanding futures and promises</h3></div></div></div><p>Modern futures make two effects <a id="id183" class="indexterm"></a>implicit: failure and latency. To see how we can move from blocking<a id="id184" class="indexterm"></a> IO to non-blocking IO, we must learn some abstractions that express handling with failure and latency in different ways. It may seem difficult at first, but most developers find they take to the paradigm once they begin to understand it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec20"></a>Future â€“ expressing failure and latency in types</h4></div></div></div><p>An asynchronous API, such<a id="id185" class="indexterm"></a> as the ask pattern, will return one of the<a id="id186" class="indexterm"></a> placeholder future types mentioned previously. We can try to demonstrate how the code becomes clearer by looking at different ways in which we can work with our <code class="literal">PongActor</code> in the test case. It's very strongly advised that you do follow along in this section with the test case we built previously.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec15"></a>Preparing for the Java example</h5></div></div></div><p>First, for the <a id="id187" class="indexterm"></a>Java8 examples, we'll simplify the ask by placing it into a method to eliminate duplication. This now looks like a real asynchronous API:</p><div class="informalexample"><pre class="programlisting">public CompletionStage&lt;String&gt; askPong(String message){ Future sFuture = ask(actorRef, "Ping", 1000); CompletionStage&lt;String&gt; cs = toJava(sFuture); return cs;
}</pre></div><p>Then we'll build simple test cases:</p><div class="informalexample"><pre class="programlisting">@Test public void printToConsole() throws Exception { 
    askPong("Ping").
        thenAccept(x -&gt; System.out.println("replied with: " + x)); 
    Thread.sleep(100); 
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec16"></a>Preparing for Scala examples</h5></div></div></div><p>We'll start by<a id="id188" class="indexterm"></a> defining a simple method to remove any redundancy and make the examples a bit easier to read:</p><div class="informalexample"><pre class="programlisting">def askPong(message: String): Future[String] = (pongActor ? message).mapTo[String]</pre></div><p>We're going to look at asynchronous work running on multiple threads, so you'll need to import an implicit <code class="literal">ExecutionContext</code> now.</p><p>We can make a test case like the following to play around in:</p><div class="informalexample"><pre class="programlisting">describe("FutureExamples"){
  import scala.concurrent.ExecutionContext.Implicits.global
  it("should print to console"){
    (pongActor ? "Ping").onSuccess({
      case x: String =&gt; println("replied with: " + x)     })
    Thread.sleep(100) }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec17"></a>Note on sleeping</h5></div></div></div><p>This test doesn't yet make any <a id="id189" class="indexterm"></a>assertions, but shows a test with real asynchronous behavior now. This test isn't helpful, but we can see if it works by looking for the effects (we expect to print to the console in this case). If you want events to occur asynchronously, you may occasionally need to sleep tests. As with blocking, sleeping is OK in tests but should never be done in real code.</p><p>While these tests don't actually test anything, they're useful for experimenting to see the effects occur asynchronously. We'll look at how to make assertions in asynchronous code after taking some time to understand futures.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec18"></a>Anatomy of a future</h5></div></div></div><p>A <code class="literal">Future[T]/CompletableFuture&lt;T&gt;</code> can either be successful with a value of type <code class="literal">T</code> or a failure of <a id="id190" class="indexterm"></a>type <code class="literal">Throwable</code>. We'll look at how to handle each caseâ€”success and failureâ€”and how to transform the future's value to be able to do useful things with the result.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec19"></a>Handling success cases</h5></div></div></div><p>As we saw in <a id="id191" class="indexterm"></a>our test, the <code class="literal">PongActor</code> will reply with "Pong" if it <a id="id192" class="indexterm"></a>receives "Ping." We'll work with this example to demonstrate different ways we can interact with the future.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec01"></a>Executing code with the result</h6></div></div></div><p>Sometimes we <a id="id193" class="indexterm"></a>need to simply "do something" with the result. Maybe we want to log the event or maybe we want to send a response over the network. We can "register" events  to occur once the result becomes available.</p><p>As demonstrated, we can use <code class="literal">thenAccept</code> to consume the value in Java8:</p><div class="informalexample"><pre class="programlisting">askPong("Ping").thenAccept(x -&gt; System.out.println("replied with: " + x));</pre></div><p>And, in Scala, we can use onSuccess:</p><div class="informalexample"><pre class="programlisting">(pongActor ? "Ping").onSuccess(){ case x: String =&gt; println("replied with: " + x) })</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip07"></a>Tip</h3><p>Note that <code class="literal">onSuccess</code> takes a partial function, so it fits well with the Akka untyped <a id="id194" class="indexterm"></a>responsesâ€”pattern matching takes care of determining the type of the result.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec02"></a>Transforming the result</h6></div></div></div><p>The most common use<a id="id195" class="indexterm"></a> case is the need to transform a response asynchronously before doing something with it. For example, we may need to get data from a database and then transform that into an HTTP response to give back to a client.</p><p>Transformation of a value is done with map in most APIs, as it is with Scala's Future:</p><div class="informalexample"><pre class="programlisting">askPong("Ping").map(x =&gt; x.charAt(0))</pre></div><p>In Java8, we call <code class="literal">thenApply:</code>
</p><div class="informalexample"><pre class="programlisting">askPong("Ping").thenApply(x -&gt; x.charAt(0))</pre></div><p>These will give you back new Futures of type <code class="literal">Char</code>. You can transform the result and then pass the modified future on to other methods for further processing.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec03"></a>Transforming the result asynchronously</h6></div></div></div><p>If we need to make an asynchronous call, and then make another asynchronous call with the result of the first, it could start to look a little bit messy: </p><div class="informalexample"><pre class="programlisting">//Java CompletionStage&lt;CompletionStage&lt;String&gt;&gt; futureFuture = askPong("Ping").thenApply(x -&gt; askPong(x)); //Scala val futureFuture: Future[Future[String]] = askPong("Ping").map(x =&gt; { askPong(x) })</pre></div><p>Very often you'll need to make an asynchronous call, and then make another asynchronous call as we have done in this example. However, right now, our result is buried inside a future inside another future! This is very difficult to work withâ€”what we want to do instead is to flatten that out so the result is inside of a single future, we want a <code class="literal">Future[String]/CompletionStage[String]</code>.</p><p>There are ways to compose our futures to make these chained asynchronous operations. using <code class="literal">thenCompose</code> in Java:</p><div class="informalexample"><pre class="programlisting">CompletionStage&lt;String&gt; cs = askPong("Ping").thenCompose(x -&gt; askPong("Ping"));

Orpredictably, flatMap in Scala:

val f: Future[String] = askPong("Ping").flatMap(x =&gt; askPong("Ping"))</pre></div><p>Once the first "Ping" is responded to, then we send a second "Ping" and return the response as the value of the future.</p><p>Note you can<a id="id196" class="indexterm"></a> continue to string together asynchronous computation like this. This is a very powerful way of handling pipelines of data processing. You can make a call to a remote service and then make a call to a second service with the result.</p><p>A failure on either call will cause the entire future to fail. We'll look at failure cases next.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec20"></a>Handling failure cases</h5></div></div></div><p>Failures can <a id="id197" class="indexterm"></a>occur and we need to handle those failures as well. Failures<a id="id198" class="indexterm"></a> always have a cause represented by a <code class="literal">Throwable</code>. Similar to the success cases, there are methods that allow us to handle the failure or even recover from it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec04"></a>Executing code in the failure case</h6></div></div></div><p>Very often you <a id="id199" class="indexterm"></a>will want to do something with a failure. The most basic case is to log something in the case of failure.</p><p>In Scala, there is a simple way to do thisâ€”<code class="literal">onFailure</code>. This method accepts a partial function accepting a <code class="literal">Throwable</code>:</p><div class="informalexample"><pre class="programlisting">    askPong("causeError").onFailure{ case e: Exception =&gt; println("Got exception") } }</pre></div><p>Unfortunately, in Java8, there is no consumer-based method for failure, so we will introduce <code class="literal">handle()</code> here for this case:</p><div class="informalexample"><pre class="programlisting">askPong("cause error").handle((x, t) -&gt; { if(t!=null){System.out.println("Error: " + t); } return null; });</pre></div><p>Handle takes a <code class="literal">BiFunction</code> that transforms either the success or failure case. The function in handle will provide you with either the successful result or the <code class="literal">Throwable</code>, so we have to check to see if the <code class="literal">Throwable</code> is present (only the result or the <code class="literal">Throwable</code> will be not null). If the <code class="literal">Throwable</code> is present, then we log the statement. We have to return a value on the function, so we simply return null as we're not doing anything with the value in the failure case.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec05"></a>Recovering from failure</h6></div></div></div><p>Often we want <a id="id200" class="indexterm"></a>to use a value if there is an error. If you want to recover from failure, you transform the future to have a successful value.</p><p>In Java, we can use exceptionally to take the <code class="literal">Throwable</code> and transform it into a usable value:</p><div class="informalexample"><pre class="programlisting">        CompletionStage&lt;String&gt; cs = askPong("cause error").exceptionally(t -&gt; { return "default"; });</pre></div><p>In Scala, there is a recover method that is the equivalent. Again, this takes a <code class="literal">PartialFunction</code>, so we can pattern match on the exception type:</p><div class="informalexample"><pre class="programlisting">      val f = askPong("causeError").recover{ case t: Exception =&gt; "default" }</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec06"></a>Recovering from failure asynchronously</h6></div></div></div><p>Often we'll need to recover from <a id="id201" class="indexterm"></a>failure with another asynchronous operation. A few use cases could be:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Retrying a failed operation</p></li><li style="list-style-type: disc"><p>A cold hit to a cache requires making an operation to another service</p></li></ul></div><p>We'll demonstrate a retry as follows:</p><div class="informalexample"><pre class="programlisting">askPong("cause error")
        .handle( (pong, ex) -&gt; ex == null 
                ? CompletableFuture.completedFuture(pong) 
                : askPong("Ping")
        ).thenCompose(x -&gt; x);</pre></div><p>We have to do this in two steps. First, we check if the exception is not null and return either a future of the result or the new retry future. Then we call <code class="literal">thenCompose</code> to <code class="literal">flatten</code> the <code class="literal">CompletionState[CompletionStage[String]]</code>. </p><p>In Scala, <code class="literal">recoverWith</code> is the function we want to invokeâ€”this is like <code class="literal">flatMap</code> for the error case, so is considerably more readable and succinct than the Java equivalent:</p><div class="informalexample"><pre class="programlisting">askPong("causeError").recoverWith({ case t: Exception =&gt; askPong("Ping") })</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec21"></a>Composing futures</h5></div></div></div><p>Often we'll have<a id="id202" class="indexterm"></a> multiple operations we need to do and maybe we'll want to do them in different places in the codebase. Each call to the methods covered returns a new future that can have additional operations applied to it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec07"></a>Chaining operations together</h6></div></div></div><p>We've covered the <a id="id203" class="indexterm"></a>basics of working with futures. One of the benefits of working with latency and failure in a functional style is that it's easy to compose together multiple operations without having to handle exceptions along the way. We can focus on the happy path and then collect errors at the end of the chain of operations.</p><p>Each of the methods that transforms a value covered returns a new future that can then be dealt with and chained into more operations.</p><p>Putting it all together, we may have several operations and then one recovery function at the end to deal with any errors that may have occurred. It's possible to combine these functions (aka combinators) in any order you can dream up to accomplish the work you need to get done.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">askPong("Ping").
    thenCompose(x -&gt; askPong("Ping" + x)).
    handle((x, t) -&gt; { if(t != null){ return "default"; }else{ return x; } });</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">val f = askPong("Ping").
  flatMap(x =&gt; askPong("Ping" + x)).
  recover({ case Exception =&gt; "There was an error" })</pre></div><p>In these examples, we get a future, then call <code class="literal">thenCompose</code>/<code class="literal">flatMap</code> to asynchronously make a call when the first completes, and then, in the case of an error, we recover with a String value to ensure the future is successful.</p><p>Any failure along the way becomes the failure at the end of the chain. This leaves us with an elegant pipeline of operations where exceptions are handled at the end regardless of which operation caused the failure. We can focus on describing the happy path without extraneous error checking throughout the pipeline. At the end, failure as an effect is described separately.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec08"></a>Combining futures</h6></div></div></div><p>You'll often have<a id="id204" class="indexterm"></a> multiple futures executing that you need to get access to. There are facilities for handling these cases as well. In Java, the <code class="literal">thenCombine</code> method on <code class="literal">CompletableFuture</code> will let you access the values of two futures once they are available:</p><div class="informalexample"><pre class="programlisting">askPong("Ping").
    thenCombine(askPong("Ping"), (a,b) -&gt; { return a + b; //"PongPong" });</pre></div><p>In Scala, for comprehensions offer an alternative syntax for composing together several futures. We're able to extract the results of two futures and handle them together like we would with any other collection. (Note that this is syntactic sugar for <code class="literal">flatMap</code>â€”I prefer this notation over <code class="literal">flatMap</code>.):</p><div class="informalexample"><pre class="programlisting">val f1 = Future{4} val f2 = Future{5} val futureAddition: Future[Int] = for( res1 &lt;- f1; res2 &lt;- f2 ) yield res1 + res2</pre></div><p>These examples yield simple mechanisms for handling multiple futures of varying types. In this way, we can parallelize work, making multiple requests at the same time to get responses back to users faster. This use of parallelization can help us improve system responsiveness.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec09"></a>Dealing with lists of futures</h6></div></div></div><p>If you have a collection<a id="id205" class="indexterm"></a> and you execute an asynchronous method on each element, you'll end up with a list of Futures.</p><p>For example, in Scala, if we take a list of messages, and ask the Pong actor to reply to each method, we end up with a list of futures like the following:</p><div class="informalexample"><pre class="programlisting">val listOfFutures = List[Future[String]] = List("Pong", "Pong", "failed").map(x =&gt; askPong(x))</pre></div><p>If you try to work with that, you'll see it's not easy. What we want is to get at the list of resultsâ€”really, we want to flip the types so the <code class="literal">List[Future]</code> becomes <code class="literal">Future[List]</code>. This is a job for sequence, which is a member of Future:</p><div class="informalexample"><pre class="programlisting">val futureOfList: Future[List[String]] = Future.sequence(listOfFutures)</pre></div><p>Now we have a usable type. If we call map on <code class="literal">futureOfList</code>, for example, we get a <code class="literal">List[String]</code>, which is what we want to work with. There is a problem here though. The future generated by sequence will fail if any of the futures in the list fail. We can recover each future before sequencing if we want to get any successful values instead of failing everything:</p><div class="informalexample"><pre class="programlisting">Future.sequence(listOfFutures.map(future =&gt; future.recover{case Exception =&gt; ""}))</pre></div><p>There is no<a id="id206" class="indexterm"></a> equivalent in the Java8 core library, but there are gists around that cover the functionality for sequencing futures in the same manner.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch02lvl5sec10"></a>Future cheat-sheet</h6></div></div></div><p>The following is a <a id="id207" class="indexterm"></a>small chart outlining the basic operations covered:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Operation</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Scala Future</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Java CompletableFuture</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>Transform Value</p>
</td><td style="" align="left" valign="top">
<p>.map(x =&gt; y)</p>
</td><td style="" align="left" valign="top">
<p>.thenApply(x -&gt; y)</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Transform Value Async</p>
</td><td style="" align="left" valign="top">
<p>.flatMap(x =&gt; futureOfY)</p>
</td><td style="" align="left" valign="top">
<p>.thenCompose(x -&gt; futureOfY)</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Return Value if Error</p>
</td><td style="" align="left" valign="top">
<p>.recover(t =&gt; y)</p>
</td><td style="" align="left" valign="top">
<p>.exceptionally(t -&gt; y)</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Return Value Async if Error</p>
</td><td style="" align="left" valign="top">
<p>.recoverWith(t =&gt; futureOfY)</p>
</td><td style="" align="left" valign="top">
<p>.handle(t,x -&gt; futureOfY).thenCompose(x-&gt;x)</p>
</td></tr></tbody></table></div><p>This section gives a good overview of the future and promises APIs. It's necessary to understand this abstraction, so it's recommended that you work with some asynchronous code and futures to get a better grasp on this. In the next section, we will introduce how to interact with actors by getting futures backâ€”you should take some time to practice this to see how to handle multiple future results to ensure you have a good foundation to build on.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec22"></a>Composing a Distributed System â€“ AkkademyDb and client</h5></div></div></div><p>The purpose of this <a id="id208" class="indexterm"></a>book is to teach you how to build distributed applications, so we're going to put everything we've covered in this chapter together into a small distributed application. While the code is fairly simple, this example is a bit advanced in its structure in that it jumps right in to showing you how two remote systems can use Akka to talk, but I think it's important to see the power of Akka right away to keep you interested in the material. If you get a taste for what Akka can do for you now, you'll want to keep going through the remaining chapters.</p><p>We'll be building a client and a serviceâ€”our databaseâ€”and then a database client to talk to it. In order to send messages over the wire between the client and service, we need to share messages between the projects.</p><p>We could put the messages<a id="id209" class="indexterm"></a> in their own project, but to keep the examples shorter, we'll put the messages in the server project and import the server project (and, hence, the messages) into the client project.</p><div class="mediaobject"><img src="graphics/B04006_02_04.jpg" /></div><p>We'll start by extending the server project from the first chapter and producing all of the messages we want the database to expose. Then we'll implement the features for those messages in the database.</p><p>After building these basic operations, we'll produce a <code class="literal">main()</code> to make the store runnable. We'll start the application by producing an <code class="literal">ActorSystem</code> and the Actor in the <code class="literal">ActorSystem</code>, creating our first Akka "micro-service."</p><p>To consume the service and demonstrate how we can get futures from our remote actors, we'll create the database client to use the service. We'll expose the service in the client by returning futures. At this point, we'll have built a usable key-value datastore, much like redis, and a remote client to consume it.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec36"></a>Preparing the DB and messages</h3></div></div></div><p>We want to <a id="id210" class="indexterm"></a>expose a<a id="id211" class="indexterm"></a> few messages to start with.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Get message: Return a key if it exists</p></li><li style="list-style-type: disc"><p>Key Not Found exception: If a key isn't found, return this failure</p></li><li style="list-style-type: disc"><p>Set message: Sets a value and reply with a status</p></li></ul></div><p>In the server, we'll implement these messages, their behavior, and a main so that the datastore can run. Note, we'll use the project from <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span>, adding features <a id="id212" class="indexterm"></a>introduced in this chapter such as replying and replying with<a id="id213" class="indexterm"></a> failure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec21"></a>The messages</h4></div></div></div><p>As we'll be using remoting to send<a id="id214" class="indexterm"></a> messages between separate networked applications, we need all of the messages to be serializable so that Akka can turn them into representations of the objects as they transfer over the networks between the applications. We'll implement <code class="literal">SetRequest</code>, <code class="literal">GetRequest</code>, and <code class="literal">KeyNotFoundException</code>.</p><p>The Java messages:</p><div class="informalexample"><pre class="programlisting">public class SetRequest implements Serializable { public final String key; public final Object value;
    public SetRequest(String key, Object value) { this.key = key; this.value = value; }
}
public class GetRequest implements Serializable { public final String key;
    public GetRequest(String key) { this.key = key; } } public class KeyNotFoundException extends Exception implements Serializable { public final String key; public KeyNotFoundException(String key) { this.key = key; }
}</pre></div><p>The Scala messages:</p><div class="informalexample"><pre class="programlisting">case class SetRequest(key: String, value: Object) case class GetRequest(key: String) case class KeyNotFoundException(key: String) extends Exception</pre></div><p>These are simple objects. We omit the Java getter as the message is immutable anywayâ€”you can include one if you like.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip08"></a>Tip</h3><p>Messages should always be immutable.</p></div><p>(The Scala case class is serializable.)</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec22"></a>Implementing the DB functionality</h4></div></div></div><p>We've covered how to reply to<a id="id215" class="indexterm"></a> messages with <code class="literal">sender() tell/!</code>. We also covered how to reply with <code class="literal">Status.Failure</code>(<code class="literal">Exception</code>). We'll implement replies to all messages and we'll also add failure responses if the <code class="literal">GetRequest</code> encounters a miss in the key/value store.</p><p>The Java code's receive statements:</p><div class="informalexample"><pre class="programlisting">        receive(ReceiveBuilder. match(SetRequest.class, message -&gt; { log.info("Received Set request: {}", message); map.put(message.key, message.value); sender().tell(new Status.Success(message.key), self()); }). match(GetRequest.class, message -&gt; { log.info("Received Get request: {}", message);
                            String value = map.get(message.key); Object response = (value != null) ? value : new Status.Failure(new KeyNotFoundException(message.key)); sender().tell(response, self()); }). matchAny(o -&gt; sender().tell(new Status.Failure(new ClassNotFoundException()), self()) ).build() );</pre></div><p>The Scala code's <code class="literal">receive</code> method:</p><div class="informalexample"><pre class="programlisting">  override def receive = { case SetRequest(key, value) =&gt; log.info("received SetRequest - key: {} value: {}", key, value)
      map.put(key, value) sender() ! Status.Success case GetRequest(key) =&gt; log.info("received GetRequest - key: {}", key) val response: Option[String] = map.get(key) response match{ case Some(x) =&gt; sender() ! x case None =&gt; sender() ! Status.Failure(new KeyNotFoundException(key)) }
    case o =&gt; Status.Failure(new ClassNotFoundException) }</pre></div><p>These are both roughly equivalent, languages aside. If the actor receives a <code class="literal">SetRequest</code>, the actor stores the value in the map. The behavior has been updated from the first chapter to send back a Success message. For the <code class="literal">GetRequest</code>, the actor tries to retrieve the value from the map. If it's found, it sends back the value. If it's not found, the actor sends back a Failure containing the <code class="literal">KeyNotFoundException</code>. Finally, we've changed the behavior for unknown messages to reply with a failureâ€”we stuck a <code class="literal">ClassNotFound</code> exception in, but <a id="id216" class="indexterm"></a>you could make a custom one for greater clarity.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec23"></a>Enabling remoting</h4></div></div></div><p>We need to enable remote access<a id="id217" class="indexterm"></a> to the actor from a remote application over <a id="id218" class="indexterm"></a>the network. This is a trivial task fortunately. We need to add the remoting dependency to the <code class="literal">build.sbt</code> file:</p><div class="informalexample"><pre class="programlisting">"com.typesafe.akka" %% "akka-remote" % "2.3.6"</pre></div><p>Then we simply add configuration to enable remote access to our actor. Add a new file in the <code class="literal">src/main/resources</code> file called <code class="literal">application.conf</code> and put the following configuration in the file with the interface and port to listen on. The <code class="literal">application.conf</code> file is recognized by Akka. It is a <code class="literal">typesafe-config HOCON</code> file, which is a JSON like format that is quite usable relative to other configuration formatsâ€”you'll see the configuration file referenced in the Akka documentation often and I personally find the HOCON format is quite a nice alternative to properties files if more than a few properties are needed. Note that properties files are usable as well if desired simply by naming the file <code class="literal">application.properties</code> and using the properties format (for example, <code class="literal">keypath.key=value</code>).Here is the application.conf::</p><div class="informalexample"><pre class="programlisting">akka { actor { provider = "akka.remote.RemoteActorRefProvider" } remote { enabled-transports = ["akka.remote.netty.tcp"] netty.tcp { hostname = "127.0.0.1" port = 2552 } }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec24"></a>Main</h4></div></div></div><p>Finally, for the datastore, we need to add <a id="id219" class="indexterm"></a>a main<a id="id220" class="indexterm"></a> method to start the actor system and create the actor.</p><p>In Java, we'll add a class: <code class="literal">com.akkademy.Main</code>:</p><div class="informalexample"><pre class="programlisting">public class Main { public static void main(String... args) { ActorSystem system = ActorSystem.create("akkademy"); system.actorOf(Props.create(AkkademyDb.class), "akkademy-db"); } }</pre></div><p>In Scala, we can put a Main object in the <code class="literal">com.akkademy.AkkademyDb.scala</code> file:</p><div class="informalexample"><pre class="programlisting">object Main extends App { val system = ActorSystem("akkademy") system.actorOf(Props[AkkademyDb], name = "akkademy-db") }</pre></div><p>We simply <a id="id221" class="indexterm"></a>need to create an <code class="literal">ActorSystem</code>, and<a id="id222" class="indexterm"></a> then create the actor in it. Note we give the actor a nameâ€”<code class="literal">akkademy-db</code>â€”we use a name to be able to easily look up the actor in the client, and also to ease debugging as Akka will log the Actor's name in error scenarios.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec25"></a>Publishing the messages</h4></div></div></div><p>We need to publish the <a id="id223" class="indexterm"></a>messages locally now so that we can use them in the client project. To publish to Nexus or Artifactory, we would set up the repository information in the <code class="literal">build.sbt</code>, but we'll simply publish them locally.</p><p>We need to add an organization and version to the <code class="literal">build.sbt</code> file like the following:</p><div class="informalexample"><pre class="programlisting">name := "akkademy-db"
organization := "com.akkademy-db"
version := "0.0.1-SNAPSHOT"</pre></div><p>'-SNAPSHOT' indicates that the version is unstable and can change. As we will probably republish the server, we should add this tag to the version. If we were to release the code, then we would remove the '-SNAPSHOT' tag from the version to indicate that it will not (and cannot) change again.</p><p>Lastly, we need to exclude the <code class="literal">application.conf</code> file so that the client doesn't try to start a remote server. Again, it's better to put the messages in a standalone libraryâ€”we're cutting corners for brevity. Put this in your <code class="literal">build.sbt</code> file to exclude the application.conf when publishing:</p><div class="informalexample"><pre class="programlisting">mappings in (Compile, packageBin) ~= { _.filterNot { case (_, name) =&gt;
  Seq("application.conf").contains(name)
}}</pre></div><p>If we put the messages in a separate library (and you certainly can), we wouldn't have needed to exclude the configuration from the build. We're done with the build configuration. From the command line, in the root of our project, we simply run the activator <code class="literal">publish-local</code> target to publish the project:</p><div class="informalexample"><pre class="programlisting">$activator publish-local</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec26"></a>Starting the DB</h4></div></div></div><p>We're going to build the client<a id="id224" class="indexterm"></a> next, and to demonstrate integration, we're going to write some integration tests, so we need the server to be running. We can start the database now:</p><div class="informalexample"><pre class="programlisting">$activator run</pre></div><p>Akka will log that it is listening for remote connections and tells us the address (which we will use shortly in the client):</p><div class="informalexample"><pre class="programlisting">[Remoting] Remoting now listens on addresses: [akka.tcp://akkademy@127.0.0.1:2552]</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec37"></a>Producing the client</h3></div></div></div><p>We've published <a id="id225" class="indexterm"></a>our messages, and have the key-value store running. We're ready to wrap up our first distributed application by consuming the service with a client.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec27"></a>Scaffolding the project</h4></div></div></div><p>The first thing we need<a id="id226" class="indexterm"></a> to do is create a project for the client and have it import the server project for the messages. We'll scaffold the project as we did in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span> â€”you can review the material if needed. Run activator-new and choose minimal-java or minimal-akka project. Call the project <code class="literal">akkademy-db-client</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec28"></a>Modifying build.sbt</h4></div></div></div><p>We need to add the dependency<a id="id227" class="indexterm"></a> for our project into the <code class="literal">build.sbt</code> file. In the new project, add the following dependencies for our messages in <code class="literal">build.sbt</code>:</p><div class="informalexample"><pre class="programlisting">"com.akkademy-db"   %% "akkademy-db"     % "0.0.1-SNAPSHOT"</pre></div><p>Apart from the testing frameworks included in the scaffolding, this dependency includes the dependencies we need to get going with the Scala project.</p><p>In the Java project, we need to also add the scala-java8-compat library to be able to convert the futures the actor will produce:</p><div class="informalexample"><pre class="programlisting">"org.scala-lang.modules" %% "scala-java8-compat" % "0.6.0"</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec29"></a>Building the client</h4></div></div></div><p>In this section, we'll <a id="id228" class="indexterm"></a>build the client to connect to the remote actor, and then implement methods for the <code class="literal">SetRequest</code> and <code class="literal">GetRequest</code> messages.</p><p>First, the Java code can be placed in <code class="literal">com.akkademy.JClient</code>:</p><div class="informalexample"><pre class="programlisting">public class JClient { private final ActorSystem system = ActorSystem.create("LocalSystem"); private final ActorSelection remoteDb; 
    public JClient(String remoteAddress){ remoteDb = system.actorSelection("akka.tcp://akkademy@" + remoteAddress + "/user/akkademy-db"); }
    public CompletionStage set(String key, Object value) { return toJava(ask(remoteDb, new SetRequest(key, value), 2000));}
    public CompletionStage&lt;Object&gt; get(String key){ return toJava(ask(remoteDb, new GetRequest(key), 2000)); }
}</pre></div><p>The Scala code can be placed in <code class="literal">com.akkademy.SClient</code>:</p><div class="informalexample"><pre class="programlisting">class SClient(remoteAddress: String){ private implicit val timeout = Timeout(2 seconds) private implicit val system = ActorSystem("LocalSystem") private val remoteDb = system.actorSelection(s"akka.tcp://akkademy@$remoteAddress/user/akkademy-db") def set(key: String, value: Object) = { remoteDb ? SetRequest(key, value) }
  def get(key: String) = { remoteDb ? GetRequest(key) }
}</pre></div><p>The code is fairly simple. First, we create a local <code class="literal">ActorSystem</code>, and then get a reference to the remote actor at the address provided in the constructor. Next, we create a method for each of the behaviorsâ€”get and set. We ask the actor using the messages we imported into our project, and then we return the future. Note we're using an arbitrary timeout value in the asks. Ideally, the timeout should be configurable.</p><p>For the Java code, we convert the <code class="literal">scala.concurrent.Future</code> to <code class="literal">CompletionStage</code> and return that. This gives us a better Java API for the consumer of our library to work with.</p><p>Next, to test that it all fits together, we'll write a small test case.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec30"></a>Testing</h4></div></div></div><p>We need to make sure the <code class="literal">db</code> is running as these are <a id="id229" class="indexterm"></a>integration tests. Here we'll simply create and then retrieve a record from the remote database.</p><p>The Java example:</p><div class="informalexample"><pre class="programlisting">public class JClientIntegrationTest { JClient client = new JClient("127.0.0.1:2552");
    @Test
    public void itShouldSetRecord() throws Exception { client.set("123", 123); Integer result = (Integer) ((CompletableFuture) client.get("123")).get(); assert(result == 123); }
}</pre></div><p>And the Scala example:</p><div class="informalexample"><pre class="programlisting">class SClientIntegrationSpec extends FunSpecLike with Matchers { val client = new SClient("127.0.0.1:2552")
  describe("akkademyDbClient") { it("should set a value"){ client.set("123", new Integer(123)) val futureResult = client.get("123") val result = Await.result(futureResult, 10 seconds) result should equal(123) }
  }
}</pre></div><p>This takes the knowledge we gained about working with Futures to be able to test our API. We use Awaits/get as it's just a test case, but we now have definitive proof that building distributed applications is feasible with Akka. And we're only on <a class="link" href="#" linkend="ch02">Chapter2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span>
</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Homework</h2></div></div><hr /></div><p>Doing the homework is very important in this chapter as it covers the core skill set needed. The example had fairly simple code, but was a touch advanced in introducing remotingâ€”in the next few chapters we will only work on local Actor systems, so the examples will be simpler. Running the example outlined here will give some insight into exactly what problems Akka tries to solve, though, so I would recommend you take a few minutes to study them. This chapterâ€”in particular the future APIâ€”is the foundation for everything that follows. We need to have a solid base to build on in the topics covered in this chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec38"></a>General learning</h3></div></div></div><p>Here are some tasks you should complete to ensure you understand how to work with the information presented in this chapter.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Build a small service that has an actor that reverses a string. Have it fail if an unknown message type is sent.</p></li><li style="list-style-type: disc"><p>Build a service for the actor that exposes the functionality through a plain Java/ScalaAPI, returning a future.</p></li><li style="list-style-type: disc"><p>Build test cases for success and failure cases.</p></li><li style="list-style-type: disc"><p>Write a test that will send a list of strings to the actor, and validate all of the results. You should use sequenceâ€”a Java8 sequence implementation can be found at <a class="ulink" href="http://www.nurkiewicz.com/2013/05/java-8-completablefuture-in-action.html" target="_blank">http://www.nurkiewicz.com/2013/05/java-8-completablefuture-in-action.html</a>.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec39"></a>Project homework</h3></div></div></div><p>Expand on the example code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Add an atomic <code class="literal">SetIfNotExists</code> and Delete messages to the <code class="literal">Akkademy DB</code> App.</p></li><li style="list-style-type: disc"><p>If you need some <code class="literal">sbt</code> experience, move the messages to their own project and publish it.</p></li><li style="list-style-type: disc"><p>Complete Tests for the Clientâ€”we don't have tests for the failure cases such as getting a missing message. You should complete this.</p></li><li style="list-style-type: disc"><p>Start building your own project.</p></li><li style="list-style-type: disc"><p>Build an actor that delivers some piece of functionality from your projectâ€”have the actor reply to messages with the work done.</p></li><li style="list-style-type: disc"><p>Write unit tests to cover success and failure cases it by asking the actor.</p></li></ul></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Summary</h2></div></div><hr /></div><p>This chapter laid down the foundation for building applications with Akka. All of the prerequisites are now covered for us to begin doing real work with distributed applications. We looked in depth at actor codeâ€”creating an instance of an actor, looking up an actor, responding to a message in an actor, getting a response from an actors from outside the <code class="literal">ActorSystem</code>â€”and working with futures.</p><p>We have enough knowledge now to give our asynchronous event-driven Akka applications to the rest of the worldâ€”we can build libraries and services with Akka and expose them with the core Scala and Java8 future APIs. This is what we will be doing in the next chapter.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch03"></a>ChapterÂ 3.Â Getting the Message Across</h2></div></div></div><p>In this chapter, we will cover all of the details of message delivery mechanisms in Akka. We'll look at different messaging patternsâ€”different ways in which we can get messages between Actors to get work done. We'll look at scheduling message delivery as wellâ€”a way of delaying or repeating delivery of messages. We'll cover how these messaging patterns can be used to compose Actors together to get work done in this chapter.</p><p>To demonstrate all the ways in which we can get messages between Actors, a new example service will be introduced as a consumer of <code class="literal">Akkademy-DB</code> as wellâ€”a simple article parsing component.</p><p>This chapter will cover some of the essential mechanics around handling Messages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Making Messages Immutable</p></li><li style="list-style-type: disc"><p>Asking an Actor for a Reply</p></li><li style="list-style-type: disc"><p>Forwarding Messages</p></li><li style="list-style-type: disc"><p>Piping Futures</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec23"></a>Setting the stage with an example problem</h2></div></div><hr /></div><p>Imagine you are on <a id="id230" class="indexterm"></a>a team asked to create a mobile news reader. Someone<a id="id231" class="indexterm"></a> will produce the application that runs on the device. It will comb RSS feeds from major news sites, presenting the new articles on the feeds to the user. When the user selects an article that they would like to read, they will be shown a simple representation of the text optimized for consumption on a mobile device.</p><p>You need to produce a service that will accept the URL of an article and will return back the article's body text. It should contain only the body text and no HTML tags. Because many people will be reading new articles, it should cache all parsed articles so that they can be returned quickly to the user. The articles should be cached in an Akkademy-DB instance running on another machine.</p><p>Requirement Overview:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Expose<a id="id232" class="indexterm"></a> an HTTP Endpoint that accepts the<a id="id233" class="indexterm"></a> URL of an article</p></li><li style="list-style-type: disc"><p>Return the main body of text from the article</p></li><li style="list-style-type: disc"><p>Cache the article in <code class="literal">Akkademy DB</code>
</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec40"></a>Sketching the project</h3></div></div></div><p>We will use Activator again to create another <a id="id234" class="indexterm"></a>project. Refer to <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Starting Life as an Actor</em></span> if you need more details.</p><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Runâ€”<code class="literal">Activator run</code>
</p></li><li><p>Select a <code class="literal">minimal-java</code> or <code class="literal">minimal-scala</code> project.</p></li><li><p>Call the <code class="literal">akkademaid</code> project.</p></li><li><p>Add the <code class="literal">akkademy-db</code> and <code class="literal">boilerpipe</code> dependencies to <code class="literal">build.sbt</code>:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq( 
"com.syncthemall" % "boilerpipe" % "1.2.2", 
"com.akkademy-db" %% "akkademy-db-scala" % "0.0.1-SNAPSHOT", 
"com.syncthemail" % "boilerpipe" % "1.2.2"
)</pre></div></li></ol></div><p>
<code class="literal">Akkademy-DB</code> is added as a dependency for Akka and the messages needed to communicate with it. We add the <code class="literal">boilerpipe</code> Java library to help with our requirement of getting the body text from a web page. Test frameworks will be included in <code class="literal">build.sbt</code> by default.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec31"></a>Core functionality</h4></div></div></div><p>The <code class="literal">boilerpipe</code> library<a id="id235" class="indexterm"></a> takes care of the article parsing for us. We simply need to call <code class="literal">ArticleExtractor.getInstance.getText(input) </code>where input is a Stream or String.</p><p>We'll revisit the example and <code class="literal">Akkademy-DB</code>
as we work through different approaches to solving the problem.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec24"></a>Messaging delivery</h2></div></div><hr /></div><p>In this next section, we're <a id="id236" class="indexterm"></a>going to look at ways of getting messages to an Actor. We're going to cover core messaging patterns, and we'll also introduce scheduling along the way.</p><p>There are four core Actor <a id="id237" class="indexterm"></a>messaging patterns: tell, ask, forward, and pipe. We have looked at <code class="literal">tell</code> and <code class="literal">ask</code> where the sender is not an Actor. We will introduce all message <a id="id238" class="indexterm"></a>passing concepts here from the perspective of an Actor sending messages to another Actor:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Ask</strong></span>: Send a <a id="id239" class="indexterm"></a>message to an Actor, and get a <a id="id240" class="indexterm"></a>response back via a future. When the Actor replies, it completes the future. No messages are sent to the sender's mailbox</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Tell</strong></span>: Send <a id="id241" class="indexterm"></a>a message to an Actor. Any <a id="id242" class="indexterm"></a>replies to <code class="literal">sender()</code> are sent back to the sending Actor</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Forward</strong></span>: Take a<a id="id243" class="indexterm"></a> message that has been <a id="id244" class="indexterm"></a>received and send it to another Actor. Any replies to <code class="literal">sender()</code> are delivered back to the sender of the original message</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Pipe</strong></span>: This is <a id="id245" class="indexterm"></a>used to send the result of a future <a id="id246" class="indexterm"></a>back to <code class="literal">sender()</code> or another Actor. If using Ask or handling a future, using Pipe is the correct way to reply with the result of the future</p></li></ul></div><p>We'll cover these patterns and the basic principles of messages in Akka in the following section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec41"></a>Messages should be immutable</h3></div></div></div><p>As mentioned earlier, messages should be<a id="id247" class="indexterm"></a> immutable. Because Akka is built on the JVM, where Java and Scala have mutable types, it's possible to send mutable messages but you may lose many of the advantages Akka gives in eliminating shared state. By having messages that are mutable, you introduce the risk that a developer may one day start mutating messages in ways that can break the application. It's certainly possible to use mutable messages safely by not changing state, but it's better to use immutable messages to ensure that no errors are introduced in future changes.</p><p>There are two ways in which messages can be mutableâ€”references and types. I saw Jamie Allen present recently and he demonstrated a matrix of mutable references and types in relation to a message like so:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>References</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Mutable Type</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Immutable Type</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>Mutable Reference</p>
</td><td style="" align="left" valign="top">
<p><span class="inlinemediaobject"><img src="graphics/B04006_03_50.jpg" /></span><span class="inlinemediaobject"><img src="graphics/B04006_03_50.jpg" /></span></p>
</td><td style="" align="left" valign="top">
<div class="mediaobject"><img src="graphics/B04006_03_50.jpg" /></div>
</td></tr><tr><td style="" align="left" valign="top">
<p>Immutable Reference</p>
</td><td style="" align="left" valign="top">
<div class="mediaobject"><img src="graphics/B04006_03_50.jpg" /></div>
</td><td style="" align="left" valign="top">
<div class="mediaobject"><img src="graphics/B04006_03_500.jpg" /></div>
</td></tr></tbody></table></div><p>If both your references and types are mutable, then that's the worst case scenario. The following is an example:</p><div class="informalexample"><pre class="programlisting">public class Message{
public StringBuffer mutableBuffer;
public Message(StringBuffer: mutableBuffer){
this.mutableBuffer = mutableBuffer;
}
}
class Message(var mutableBuffer: StringBuffer = new StringBuffer);</pre></div><p>Here, both the objects <a id="id248" class="indexterm"></a>are referenced, and the object's state can also change, which is the worst case in our grid.</p><p>Variables referenced in the message (for example, fields) can either be mutable or immutable. In Scala, field members marked <code class="literal">val</code> are immutable references and field members marked <code class="literal">var</code> are mutableâ€”the reference can be changed to point to a new object/primitive. In Java, members marked with final are immutable references and those without are mutable. All fields in messages should be of the immutable variety. The field members should be passed in via constructor arguments to be able to fulfill the immutability contract.</p><p>We can demonstrate how the references can change:</p><div class="informalexample"><pre class="programlisting">Messagemessage=newMessage(newStringBuffer("original"));
message.mutableBuffer=newStringBuffer("new");

valmessage=newMessage(newStringBuffer("original"))
message.mutableBuffer=newStringBuffer("new")</pre></div><p>Here we create a new message, and then we change the <code class="literal">StringBuffer</code> reference to point to a new <code class="literal">StringBuffer</code>. The message is created with <code class="literal">StringBuffer</code>(<code class="literal">original</code>) but is mutated to <code class="literal">StringBuffer</code>(<code class="literal">new</code>). This shows how the message can be changed because of the change in its reference.</p><div class="mediaobject"><img src="graphics/B04006_03_01.jpg" /></div><p>We want to eliminate the possibility of someone changing the reference in the message, so we need to make the references <code class="literal">val</code>/<code class="literal">final</code>. The following is an example of immutable references in the<a id="id249" class="indexterm"></a> message, improving on our previous example:</p><div class="informalexample"><pre class="programlisting">public class Message {
public final StringBuffer mutableBuffer;
Message(StringBuffer mutableBuffer) {
                this.mutableBuffer = mutableBuffer;
        }
	}</pre></div><p>In Scala, if no access modifiers are supplied in the declaration, the field reference will be an immutable <code class="literal">val</code>. In Java, we use the final modifier to make the reference immutable. Now we can't change the <code class="literal">mutableBuffer</code> reference to point at a new objectâ€”we can be sure the message will always point toward the same <code class="literal">StringBuffer</code>. There is still a problem with this thoughâ€”we can change the <code class="literal">StringBuffer</code> object itself as it is a mutable type. We can append new characters to a reference. If multiple Actors have a reference to that message, then it's possible that concurrency errors can occur. The following is an example of us changing the <code class="literal">StringBuffer</code>:</p><div class="informalexample"><pre class="programlisting">Message message = new Message(new StringBuffer())
message.mutableBuffer.append("appended");
val message = new Message(StringBuffer("original"))
message.mutableBuffer.append("appended")</pre></div><p>This demonstrates that even though the message's <code class="literal">mutableBuffer</code> reference is immutable, the <code class="literal">StringBuffer</code> in memory can still be modified as it is a mutable type as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_02.jpg" /></div><p>For a message to truly be immutable, it needs to have both immutable references and use immutable types. String is an immutable type, so we can make this message immutable by using String instead of <code class="literal">StringBuffer</code>. An example of the ideal immutable message is as follows:</p><div class="informalexample"><pre class="programlisting">public class ImmutableMessage{
    public final String immutableType;
public ImmutableMessage(String immutableType) {
    this.immutableType = immutableType;
    }
}
class ImmutableMessage(immutableType: String)</pre></div><p>Now we cannot <a id="id250" class="indexterm"></a>change the message in any wayâ€”it's thread safe and can be sent across threads or machines without any risk of that message changing in any way in its life:</p><div class="informalexample"><pre class="programlisting">new ImmutableMessage("can't be changed");</pre></div><p>There is one more improvement we can makeâ€”use a case class instead of a class in Scala. Case classes are preferred as they give useful members like a default <code class="literal">toString()</code> and <code class="literal">copy()</code> method. They can be serialized for use in Akka remoting as well. In Java, we will often declare our messages as Serializable as well in case we want to send them over the wire:</p><div class="informalexample"><pre class="programlisting">public class ImmutableMessage implements Serializable {
public final String string;
public ImmutableMessage(String string) {
this.string = string;
}
}
case class ImmutableMessage(String: String)</pre></div><p>Understanding immutability is essential not only in Akka messages but also in safe and concurrent computing in general. Any time data is to be shared between threads, therefore, aim for immutability first. Now that we know how to make immutable messages, we can look at how to compose actors together with various messaging patterns.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec42"></a>Ask message pattern</h3></div></div></div><p>The <a id="id251" class="indexterm"></a>Ask pattern <a id="id252" class="indexterm"></a>produces a future that represents the reply from an Actor. This is often used to talk to Actors from plain objects outside of an Actor system. We looked at Ask, we get a future back that represents the response, but it may not be obvious exactly how Akka knows which message fulfills the future.</p><p>When you ask an Actor, Akka actually creates a temporary Actor in the Actor system. The <code class="literal">sender()</code> reference that the Actor replies to becomes this temporary Actor. When an Actor replies to the message it receives from an ask, this temporary Actor completes the future with the response as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_03.jpg" /></div><p>Akka knows which message fulfills the future because the <code class="literal">sender()</code> reference becomes that temporary Actor's path. It's important to know this so we can compose together multiple Actors and ensure we're replying to the correct place to fulfill any asks.</p><p>Asks always require a timeout be defined and if the ask is not replied to, then the future will fail with the timeout. The <code class="literal">ask/?</code> method requires a timeout to be supplied to itâ€”either a long one in milliseconds or an <code class="literal">akka.util.Timeout</code>, which offers some more expressive descriptions of time.</p><p>In Java, you can Ask with a <code class="literal">Timeout</code> constructed with a <code class="literal">TimeUnit</code> like the following:</p><div class="informalexample"><pre class="programlisting">static import akka.pattern.Patterns.ask; Timeout timeout = new akka.util.Timeout(1,
java.util.concurrent.TimeUnit.SECONDS);
Future future = ask(actor, message, timeout);</pre></div><p>In Scala, you can use <code class="literal">scala.concurrent.duration</code> for defining a timeout with the attractive scala duration<a id="id253" class="indexterm"></a> <span class="strong"><strong>Domain Specific Languages</strong></span>(<span class="strong"><strong>DSL</strong></span>), which <a id="id254" class="indexterm"></a>lets you describe a duration as, for example, 1 second. In Scala, the timeout supplied to the ask is implicit, which helps to simplify the ask semantics to a concise statement:</p><div class="informalexample"><pre class="programlisting">actorRef ? message</pre></div><p>For example, with the timeout and imports, your code would look like the following:</p><div class="informalexample"><pre class="programlisting">import scala.concurrent.duration._
import akka.pattern.ask
implicit val timeout = akka.util.Timeout(1 second)
val future = actorRef ? "message"</pre></div><p>We'll look at an <a id="id255" class="indexterm"></a>example of a design using ask to demonstrate how we can compose together asks. Because Ask gives Futures, this is essentially composing together Futures that the Actors produce with Ask.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec32"></a>Designing with Ask</h4></div></div></div><p>We'll demonstrate our <a id="id256" class="indexterm"></a>example application <a id="id257" class="indexterm"></a>design using the Ask pattern first. This is the most naive approach. The example we'll show here is for the article parse service using ask that will check the cache, and, if the parsed article is not in the cache, it will ask an <code class="literal">HttpClientActor </code>and then have the result parsed by an <code class="literal">ArtcileParserActor</code>. After retrieving the results, it will attempt to cache the article and then return the article to the user as shown the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_04.jpg" /></div><p>This is a useful <a id="id258" class="indexterm"></a>example to look<a id="id259" class="indexterm"></a> at but it's not an optimal design. This is very much how we would have done this using a synchronous API, so it's a good starting point to build on. We'll examine some code before proceeding.</p><p>For brevity, we'll omit the Actor code except for the service Actor. The full code examples are in the GitHub examples in the folder in this chapter. For the context of reading the code, each of the Actors sends back either a failure or a successâ€”a String representing the article (raw or parsed).</p><p>The following is the Scala source:</p><div class="informalexample"><pre class="programlisting">packagecom.akkademy.askdemo
class AskDemoArticleParser(cacheActorPath: String, httpClientActorPath: String, acticleParserActorPath: String,implicit val timeout: Timeout
) 
extends Actor {
  val cacheActor = context.actorSelection(cacheActorPath)
  val httpClientActor = context.actorSelection(httpClientActorPath)
  val articleParserActor = context.actorSelection(acticleParserActorpath)
  import scala.concurrent.ExecutionContext.Implicits.global

  override def receive: Receive = {
    case ParseArticle(uri) =&gt;
      val senderRef = sender() //sender ref needed for closure

      val cacheResult = cacheActor ? GetRequest(uri) //ask cache actor

      val result = cacheResult.recoverWith { //if request fails, then ask the articleParseActor
        case _: Exception =&gt;
          val fRawResult = httpClientActor ? uri

          fRawResult flatMap {
            case HttpResponse(rawArticle) =&gt;
              articleParserActor ? ParseHtmlArticle(uri, rawArticle)
            case x =&gt;
              Future.failed(new Exception("unknown response"))
          }
      }
                 
      result onComplete { //could use Pipe (covered later)
        case scala.util.Success(x: String) =&gt;
          println("cached result!")
          senderRef ! x //cached result
        case scala.util.Success(x: ArticleBody) =&gt;
          cacheActor ! SetRequest(uri, x.body)
          senderRef ! x
        case scala.util.Failure(t) =&gt;
          senderRef ! akka.actor.Status.Failure(t)
        case x =&gt;
          println("unknown message! " + x)
      }
  }
}</pre></div><p>The following<a id="id260" class="indexterm"></a> is the equivalent Java8 <a id="id261" class="indexterm"></a>code:</p><div class="informalexample"><pre class="programlisting">public class AskDemoArticleParser extends AbstractActor {

    private final ActorSelection cacheActor;
    private final ActorSelection httpClientActor;
    private final ActorSelection artcileParseActor;
    private final Timeout timeout;

    public AskDemoArticleParser(String cacheActorPath, String httpClientActorPath, String artcileParseActorPath, Timeout timeout) {
        this.cacheActor = context().actorSelection(cacheActorPath);
        this.httpClientActor = context().actorSelection(httpClientActorPath);
        this.artcileParseActor = context().actorSelection(artcileParseActorPath);
        this.timeout = timeout;
    }

public PartialFunction receive() {
        return ReceiveBuilder.
                match(ParseArticle.class, msg -&gt; {
                    final CompletionStage cacheResult = toJava(ask(cacheActor, new GetRequest(msg.url), timeout));
                    final CompletionStage result = cacheResult.handle((x, t) -&gt; {
                        return (x != null)
                                ? CompletableFuture.completedFuture(x)
                                : toJava(ask(httpClientActor, msg.url, timeout)).
                                thenCompose(rawArticle -&gt; toJava(
                                                ask(artcileParseActor,
                                                        new ParseHtmlArticle(msg.url,
                                                                ((HttpResponse) rawArticle).body), timeout))
                                );
                    }).thenCompose(x -&gt; x);

                    final ActorRef senderRef = sender();
                    result.handle((x,t) -&gt; {
                        if(x != null){
                            if(x instanceof ArticleBody){
                                String body = ((ArticleBody) x).body; //parsed article
                                cacheActor.tell(body, self()); //cache it
                                senderRef.tell(body, self()); //reply
                            } else if(x instanceof String) //cached article
                                senderRef.tell(x, self());
                        } else if( x == null )
                            senderRef.tell(new akka.actor.Status.Failure((Throwable)t), self());
                        return null;
                    });

                }).build();
    }
}</pre></div><p>Both the Scala and<a id="id262" class="indexterm"></a> Java8 examples have <a id="id263" class="indexterm"></a>the same functionalityâ€”the Actor constructor takes strings with the Actor paths and looks up each of the Actors with <code class="literal">actorSelection</code> as we have done previously. Injecting the paths are dependencies. This lets us configure where our actors are. For example, the cached <code class="literal">b</code> would be local in test and on a remote machine in production.</p><p>Once we receive a message, we try to get a cached article. If the <code class="literal">cacheResult</code> misses or fails for any reason, we compose together two more asks in a recover/exceptionally block:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Ask the HTTP client Actor for the raw article</p></li><li style="list-style-type: disc"><p>Ask the article parser to parse the raw article from the HTTP Actor</p></li></ul></div><p>If the cache request fails, we don't care what the issue is with the cache resultâ€”we can still give the user a result if the cache is offline for example. We would, however, log the unexpected error or capture the cause of the error in a metric.</p><p>Finally, we register what to do when we have the result or error at the end of processingâ€”we either send back the success or send a failure with the cause of the error.</p><p>The use of ask is a simple solution, but there are a few "gotchas" and issues to look out for when using ask as the primary message patterns in Actors. Ask is a good place to start with for building simple solutions, but it can sometimes be better to design with tell as we'll look at shortly. Let's look at a few of the elements of using ask that we need to be aware of.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec33"></a>Callbacks execute in another execution context</h4></div></div></div><p>Note that in the <a id="id264" class="indexterm"></a>preceding example, a local <code class="literal">ActorRef </code>variable is created to store the <code class="literal">sender()</code>method's result. This is very important: this is necessary here and you will no doubt bump into this at least once when you start working with Akka. Because the lambdas are executed somewhere else, in another execution context on another thread, the <code class="literal">sender()</code>method will return an unexpected value when the code block in the lambda is running. This is a non-obvious issue to beginners. In older Scala Akka examples, <code class="literal">sender()</code> was often written without the brackets. It's recommended that <code class="literal">sender()</code>always be expressed with the brackets in Scala as it does not have referential transparency (it doesn't return the same value every time it's called)â€” it's clearer that this is a method call when you add the brackets. In order for the correct <code class="literal">ActorRef</code> to be referred to, <code class="literal">sender()</code>must be called in the main thread and the reference stored into a variable. That variable will correctly be passed into the lambda's closure when it is executed. There is a better way to handle the reply called Pipe, which we'll look at shortly, but this is an<a id="id265" class="indexterm"></a> important quality of closures to understand.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec34"></a>Timeouts are required</h4></div></div></div><p>Note that the example<a id="id266" class="indexterm"></a> uses a single timeout and passes it to several asks. You cannot ask an Actor for a reply without creating a bounded timeout. If the Actor that is asked does not reply to the future before the timeout ends, the future will be failed.</p><p>Selecting the correct timeout value can be difficult without real data from production systems under load. Setting the timeout too low will cause failures to be reported for operations that would have succeeded. Setting the timeout too high will force users to wait too long when operations might have failed due to anomalies. To set timeouts, you'll want to have statistics on the operations in production. You can't control the performance of systems you depend on, so it can be difficult to get this correct.</p><p>Because every ask requires a timeout, if Actors are asking Actors that are asking Actors, it's not easy to enforce a single timeout. If an error occurs at some point, it's possible you'll see several timeouts in your logs, which can make debugging quite difficult as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_05.jpg" /></div><p>In the preceding image, it's possible that the 2-second timeout causes the future to fail, even if all of the code is working correctly and all systems are responding.</p><p>It may seem like a good idea to place a large timeout to avoid errors from occurring. Placing arbitrary and large timeouts should be considered an anti-pattern as it violates the responsive tenet of <a id="id267" class="indexterm"></a>reactive design we try to adhere to when building our applications. A 30-second timeout offers very little value in reality as a user waiting for data has likely given up by the time the timeout has occurred. In most use cases, if your users legitimately need to wait for more than 10 seconds for an operation, it's possible your users won't be using your software for long. Obviously, there are exceptions, but studies from Microsoft and Google have shown that user behavior is impacted negatively if they have to wait for more than 2 seconds for a page to appear in web applications.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec35"></a>Timeout stacktraces aren't useful</h4></div></div></div><p>Each ask you use has a<a id="id268" class="indexterm"></a> timeout. In our example, the operation spans multiple asks, so there are multiple places where timeouts can occur. The ask timeouts will throw exceptions from Akka's scheduler thread rather than a thread local to the Actor, so you won't be able to tell from printing the <code class="literal">AskTimeoutExceptions</code> stacktrace specifically which ask operation timed out. It can be difficult to debug an application when all you have is an exception like the following:</p><div class="informalexample"><pre class="programlisting">akka.pattern.AskTimeoutException: Ask timed out on [Actor[akka://system/user/actor#778114812]] after [2000 ms]
        at akka.pattern.PromiseActorRef$$anonfun$1.apply$mcV$sp(AskSupport.scala:335)
        at akka.actor.Scheduler$$anon$7.run(Scheduler.scala:117)</pre></div><p>One more thing to watch out for is if your actor throws an unexpected exception and doesn't reply with the failure. It may appear that the error occurred due to the timeout, but the cause might be elsewhere.</p><p>The lesson here is that when using ask, you should always reply to messages with failures when errors are encountered in your code. If an Actor throws an exception, the Actor will not reply with a message. In an Actor, you're responsible for implementing all message handling behaviorâ€”if an actor expects a reply, Akka will not implicitly handle any replies for youâ€”you must always reply to messages yourself when a reply is expected.</p><p>Ask is a pattern built on top of Akkaâ€”it's a useful helper, but there is no mechanism in Akka to automatically reply to messages or fail Futures generated by the Ask pattern. The Ask pattern creates a Scala Promise and a temporary (extra) Actor to receive a reply that it uses to fulfill the Promise. There is no mechanism to make the temporary Actor aware of an exception encountered in another Actor, so if you don't reply to the temporary Actor the Ask creates, it will not fulfill the Promise, and the timeout will fail the corresponding Future as in the following figure:</p><div class="mediaobject"><img src="graphics/B04006_03_06.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec36"></a>Ask has overhead</h4></div></div></div><p>The ask pattern may seem simple<a id="id269" class="indexterm"></a> but it has some <code class="literal">hidden</code> overhead. First, Ask causes Akka to create a new temporary Actor in the<code class="literal">/temp</code> path. That Actor awaits the response from the Actor that receives the Ask message. Next, there is also the overhead of the future. Ask creates a future that the temporary Actor completes. It's not a huge overhead, but it is worth considering if your ask operations occur with extremely high frequency. Ask can be simpler, but there are more efficient solutions using only tell where performance matters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec37"></a>Complexity of Actors and Ask</h4></div></div></div><p>If you're simply asking your<a id="id270" class="indexterm"></a> Actors, and they don't contain state, then you may be better off using Futures alone. In the preceding examples Actors are used as an asynchronous API by invoking them with ask. We could replace the Actors with methods that give back Futures and our code would be equivalent and simpler to read.</p><p>For quite a while, I was of the opinion that it's better to not use Actors if you don't have either:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>State and concurrency; or</p></li><li style="list-style-type: disc"><p>Distribution</p></li></ul></div><p>If you aren't using Akka for remoting or you aren't using Akka for concurrent access to state by encapsulating state in Actors, then it may not be obvious what the benefits are compared to stateless classes that are asynchronous and non-blocking.</p><p>However, I believe this<a id="id271" class="indexterm"></a> is because I was writing Actor code with poor designs. It is true that if you have no state, an asynchronous API is simpler than using Ask with Actors. However, if you are designing with the "Tell Don't Ask" principle, then you can have code that is simpler, better performing, and can be easier to debug when using Actors. We'll look at tell next.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec43"></a>Tell</h3></div></div></div><p>Tell<a id="id272" class="indexterm"></a> is the simplest messaging patternâ€”however, it can take some time to learn<a id="id273" class="indexterm"></a> how to use it best, which is why it is being presented here after Ask. It is often viewed as a "fire and forget" message delivery mechanism as no sender is specified; however, request/reply style messaging can be completed with tell when a little ingenuity is applied.</p><div class="mediaobject"><img src="graphics/B04006_03_07.jpg" /></div><p>Tell is a method of the <code class="literal">ActorRef</code>/<code class="literal">ActorSelection </code>classes. It can take a reply to as an argument as well which becomes <code class="literal">sender()</code>in the Actor that receives the Message. By default, in Scala, the sender is implicitly defined as the Actor that sent the message. If there is no senderâ€”for example, invoking ask from outside of an Actorâ€”then the response address default is no mailbox (called <code class="literal">DeadLetters</code>).</p><p>In Java, there are no implicits or default values, so you have to supply the sender. If you don't want to supply any specific sender to reply to, you should use the following convention:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Use <code class="literal">self()</code> if sending from an actor:</p><div class="informalexample"><pre class="programlisting">actor.tell(message, self());</pre></div></li><li style="list-style-type: disc"><p>Use <code class="literal">noSender</code> if sending from outside of the actor system:</p><div class="informalexample"><pre class="programlisting">actor.tell("message", akka.actor.ActorRef.noSender());</pre></div></li><li style="list-style-type: disc"><p>As covered in Scala, this is all default/implicit, so you get this for free implicitly with the simple syntax:</p><div class="informalexample"><pre class="programlisting">actor ! "message"</pre></div></li></ul></div><p>This is the <a id="id274" class="indexterm"></a>expected behavior with tellâ€”the reply reference should <a id="id275" class="indexterm"></a>be the Actor sending the message or it should be none if it's not an Actor sending the message. However, using a different sender can be quite important when using tellâ€”we can actually eliminate asks through some creative use of reply addresses and storing state in Actors, as we'll see soon:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec38"></a>Designing with Tell</h4></div></div></div><p>It may seem odd to have<a id="id276" class="indexterm"></a> put ask before tell, as, theoretically, tell is a much simpler message delivery mechanism. In building applications, it may seem natural to ask several Actors and compose the Futures similar to what we did in the ask design example. We covered several of the problems with ask, as well as the timeouts and overhead associated with it, so there is motivation to look at other solutions. We can do better by using tell.</p><p>Tell is often viewed as a fire-and-forget messaging pattern, but when designing, changing how you think about objects and actors and how they interact can yield better designs. If you're coming from Scala, you might find your designs become simpler if you store a bit of state in Actors and if you create some temporary Actors to handle certain tasks. This is counter-intuitive for the functional programmer who avoids state. Object-oriented languages were originally message-driven and so we can get a few hints about the lessons learned in design by reviewing some of the good practices from <code class="literal">SmallTalk</code> culture.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec23"></a>Handling replies with Tell </h5></div></div></div><p>Because the sender reference is available to send back a message, it's easy to reply to a message. However, to handle a reply, we need to have the ability to recall which message the Actor is replying to. If we store some state in the Actor about messages that it expects a response to, then we can effectively "ask" an Actor without the pitfalls of ask described earlier.</p><p>For a very simple example of designing with tell, we can store some context in an Actor with a map with a key and send the key in the message. Then, when a message comes back with that key, we can restore that context and complete handling the message. This allows us to use semantics similar to ask without the overhead of ask.</p><div class="mediaobject"><img src="graphics/B04006_03_08.jpg" /></div><p>This may seem like a lot of <a id="id277" class="indexterm"></a>overhead when you can use ask, but if you're trying to compose together many Actors, it removes the timeouts and extra Actor creation that ask incurs. This lets us control where the timeout occurs.</p><p>Because there is no timeout with tell, we generally want to produce our own timeout at some point in time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec24"></a>Scheduling a Tell Timeout</h5></div></div></div><p>We'll introduce the scheduler here as a minor element. The scheduler is capable of repeating messages at an interval; however, it is most commonly used as a way of deferring a tell. For example, if an Actor wants to send itself a "check-for-timeout" message after 3 seconds, the scheduler is the mechanism that can be used to accomplish that.</p><p>Very often in our Actors, we expect some event to occur before a certain period of time elapses, and if that event has not occurred, then we want to fail in some manner. The scheduler can be used to schedule such an event (for example, a timeout). The following is an example of sending an Actor a timeout message after 3 seconds:</p><div class="informalexample"><pre class="programlisting">//Java
context().system().scheduler().scheduleOnce(Duration.create(3, TimeUnit.SECONDS), actor, "timeout");

//Scala
context.system.scheduler.scheduleOnce(3 seconds, actor, "timeout")</pre></div><p>We'll see how this comes into play shortly.</p><p>Tell Don't Askâ€“<span class="emphasis"><em>Procedural code gets information then makes decisions. Object-oriented code tells objects to do things</em></span>â€”Alec Sharp, SmallTalk by Example.</p><p>The OO designers who worked in <code class="literal">SmallTalk</code> delivered a very important principle in Object-oriented design, which translates quite well into the Actor paradigmâ€”Tell, Don't Ask.</p><p>This is saying that<a id="id278" class="indexterm"></a> messages should be commands and that your Actors should be combinations of state and behavior instead of invocations of proceduresâ€”just like good object-oriented design. When you're designing, I'd recommend you take that a step farther and consider avoiding ask between Actors to see what your designs look like. This is a heuristic, so evaluate your designs, and the costs and benefits. You'll often find tell will produce simpler, leaner flows.</p><p>Tell Don't Ask is actually more of an object-oriented design heuristic, but given some of the pitfalls of the ask pattern covered, we may want consider this rule of thumb in designing with Actors as well. Ask can be simple, so evaluate it when working with Akka, but be aware of the alternative solutions as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec25"></a>Avoiding Ask with an Anonymous Actor</h5></div></div></div><p>If you're invoking tell from outside of an Actor in plain objects, there is no immediately obvious way to receive and handle a response apart from ask. As we've looked at, between Actors, you can handle a response by capturing some state specific to the current message in an Actor (for example, an ID). There is another option for handling a reply as wellâ€”by using a new temporary Actor, we can describe the response to a single message.</p><p>We'll cover using tell instead of ask in an example. In this example, we'll create a temporary Actor to handle the response to a message. Note that this is very similar to how Akka handles ask under the hoodâ€”it creates a temporary Actor to handle the response sent to the sender to complete the future.</p><p>We'll demonstrate the receive block only (Java and then Scala):</p><div class="informalexample"><pre class="programlisting">//Java
public PartialFunction receive() {
        return ReceiveBuilder.
                match(ParseArticle.class, msg -&gt; {
                    ActorRef extraActor = buildExtraActor(sender(), msg.url);
                    cacheActor.tell(new GetRequest(msg.url), extraActor);
                    httpClientActor.tell(msg.url, extraActor);
                    context().system().scheduler().scheduleOnce(timeout.duration(),
                            extraActor, "timeout", context().system().dispatcher(), ActorRef.noSender());
                }).build();
    }

//Scala
  override def receive: Receive = {
    case msg @ ParseArticle(uri) =&gt;

      val extraActor = buildExtraActor(sender(), uri)

      cacheActor.tell(GetRequest(uri), extraActor)
      httpClientActor.tell("test", extraActor)

      context.system.scheduler.scheduleOnce(timeout.duration, extraActor, "timeout")
  }</pre></div><p>This looks a bit simpler because we're not composing any Futures, but there is an extra actor that is created in the <code class="literal">buildExtraActor</code> method.</p><p>We'll demonstrate<a id="id279" class="indexterm"></a> the <code class="literal">buildExtraActor</code> method in a moment, but we'll walk through this first. The block gets the <code class="literal">ParseArticle</code> message and begins by creating the <code class="literal">extraActor</code>. The term extra is a term attributed to Jamie Allen in his book <span class="emphasis"><em>Effective Akka</em></span> from <span class="emphasis"><em>O'Reilly</em></span> publications where he demonstrates a similar pattern which he refers to as the Extra Pattern.</p><p>After creating the <code class="literal">extraActor</code>, the receive block continues to send three messages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Send a message to the cache actor requesting the cached article that causes a String to be sent back to the sender. Here, sender is supplied to the tell as the <code class="literal">extraActor</code>
</p></li><li style="list-style-type: disc"><p>Send a message to the <code class="literal">httpClientActor</code> requesting the raw article that causes an <code class="literal">HttpResponse </code>to be sent to the <code class="literal">extraActor</code>
</p></li><li style="list-style-type: disc"><p>Schedule a <code class="literal">timeout</code> message to be sent to the <code class="literal">extraActor</code>
</p></li></ul></div><p>This is different than the ask example because we don't wait for the cache to respond in this particular example. It's possible to compose the requests in the extra Actor's behavior, but for simplicity, here we'll send them both off and have the extra Actor respond to whichever message is received first.</p><p>The <code class="literal">extraActor</code> is an anonymous Actor that describes the response to the three possible messages above:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If it gets a response from the cache, respond with that to the <code class="literal">originalSender</code>
</p></li><li style="list-style-type: disc"><p>If it gets an HTTP response, send that to the <code class="literal">ArticleParser </code>to parse and have the article parser reply back with the <code class="literal">ArticleBody</code>
</p></li><li style="list-style-type: disc"><p>If it gets an <code class="literal">ArticleBody</code>, the <code class="literal">HttpResponse </code>has been parsed, so we want to cache the result and reply to the <code class="literal">originalSender</code>
</p></li><li style="list-style-type: disc"><p>If it gets a timeout, send a failure back to the <code class="literal">originalSender</code>
</p></li></ul></div><p>The <code class="literal">extraActor</code> describes the response to the three messages, including how to get the raw HTML article and then how to parse it. By putting all of this behavior into a single anonymous Actor, which can only handle one of each type of the messages, we can describe the response <a id="id280" class="indexterm"></a>to the behavior in each case.</p><div class="mediaobject"><img src="graphics/B04006_03_09.jpg" /></div><p>Here is the code for the factory method for the extra Actor:</p><div class="informalexample"><pre class="programlisting">//Java
private ActorRef buildExtraActor(ActorRef senderRef, String uri){

        class MyActor extends AbstractActor {
            public MyActor() {
            receive(ReceiveBuilder
                        .matchEquals(String.class, x -&gt; x.equals("timeout"), x -&gt; { //if we get timeout, then fail
                            senderRef.tell(new Status.Failure(new TimeoutException("timeout!")), self());
                            context().stop(self());
                        })
                        .match(HttpResponse.class, httpResponse -&gt; { //If we get the cache response first, then we handle it and shut down.
                            //The cache response will come back before the HTTP response so we never parse in this case.
                            artcileParseActor.tell(new ParseHtmlArticle(uri, httpResponse.body), self());
                        })
                        .match(String.class, body -&gt; { //If we get the cache response first, then we handle it and shut down.
                            //The cache response will come back before the HTTP response so we never parse in this case.
                            senderRef.tell(body, self());
                            context().stop(self());
                        })
                        .match(ArticleBody.class, articleBody -&gt; {//If we get the parsed article back, then we've just parsed it
                            cacheActor.tell(new SetRequest(articleBody.uri, articleBody.body), self());
                            senderRef.tell(articleBody.body, self());
                            context().stop(self());
                        })
                        .matchAny(t -&gt; { //We can get a cache miss
                            System.out.println("ignoring msg: " + t.getClass());
                        })
                        .build());
            }
        }

        return context().actorOf(Props.create(MyActor.class, () -&gt; new MyActor()));
    }

//Scala
  private def buildExtraActor(senderRef: ActorRef, uri: String): ActorRef = {
    return context.actorOf(Props(new Actor{
      override def receive = {
        case "timeout" =&gt; //if we get timeout, then fail
          senderRef ! Failure(new TimeoutException("timeout!"))
          context.stop(self)

        case HttpResponse(body) =&gt; //If we get the http response first, we pass it to be parsed.
          articleParserActor ! ParseHtmlArticle(uri, body)

        case body: String =&gt; //If we get the cache response first, then we handle it and shut down.
          //The cache response will come back before the HTTP response so we never parse in this case.
          senderRef ! body
          context.stop(self)

        case ArticleBody(uri, body) =&gt; //If we get the parsed article back, then we've just parsed it
          cacheActor ! SetRequest(uri, body) //Cache it as we just parsed it
          senderRef ! body
          context.stop(self)

        case t =&gt; //We can get a cache miss
          println("ignoring msg: " + t.getClass)
      }
    }))
  }</pre></div><p>Note that there are <a id="id281" class="indexterm"></a>three possible outcomes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The cache responds with the body</p></li><li style="list-style-type: disc"><p>The http article comes back, is parsed and then cached</p></li><li style="list-style-type: disc"><p>Neither of these events occur before the timeout message</p></li></ul></div><p>All three of these outcomes cause the <code class="literal">extraActor</code> to be stopped by executing <code class="literal">context().stop(self());</code> this Actor is short lived, thenâ€”it will not live more than 3 seconds.</p><p>There is the case where the cache fails and the article comes backâ€”this is a special case because we need to parse the article still, so we send this message to the article parser and then handle the response.</p><p>This looks like a bit more code, and it is, but it's actually lighter than the ask example believe it or not:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The ask example causes a future to be created for each ask</p></li><li style="list-style-type: disc"><p>The ask example causes a temporary Actor to be created for each ask</p></li></ul></div><p>Our example has no Futures and only one extra Actor. It's also simpler to analyze errors:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The ask example has three separate timeouts that can fail</p></li></ul></div><p>Our example has only one timeout which we control - the timeout is either encountered or else the success case occurs. In this approach, we can also log any state in the temporary Actor when the timeout is encountered to understand exactly what occurred. Future timeouts are not very helpful in comparison.</p><p>At the expense of a bit more code than the ask example, we're taking control over the behavior instead of relying on Akka's ask implementation details, and in turn, we're able to construct the solution to fit the exact use case. I've worked in teams that prefer simple terse code so which solution you choose â€“ tell or ask â€“ will be up to you and your team to decide. Explore both and understand their pros and cons. For any performance critical areas of your code, tell can be more performant.</p><p>A good exercise here would be to change the extra Actor code only request or only parse the article if the cache request fails to return a result. Don't be afraid to keep state in the extra Actor to understand where it is in its lifecycle.</p><p>This demonstrates<a id="id282" class="indexterm"></a> how a design can be changed from composing asks to a design that avoids ask completely by using an extra Actor to deal with responses and control the flow of messages between Actors. There are no panaceas, but you should try to evaluate a few different designs when building and see which works best in your use case.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec39"></a>Forward</h4></div></div></div><p>While tell semantically<a id="id283" class="indexterm"></a> sends a message to another Actor with the reply <a id="id284" class="indexterm"></a>address being the current Actor, forward is much like the case in forwarding mailâ€”the original sender stays the same but there is a new recipient.</p><p>Where tell lets you specify the reply address and it is implicit that the Actor that sends the message, forward delivers a message with the reply address equal to sender.</p><div class="mediaobject"><img src="graphics/B04006_03_10.jpg" /></div><p>This is useful where a message received will be delegated to another actor to fulfill, and the product of that Actor is needed by the original requester.</p><p>The intermediate Actor hands off the message, or possibly a new one, but the original sender is passed with the new message. An example use case could be getting a history from a bank account. There may be one History Actor who then delegates the request for account history to either a <code class="literal">ChequingAccount </code>or <code class="literal">CreditCardAccount </code>Actor. The message requesting the account history would be forwarded to the more specific Actor to complete.</p><p>There is nothing special about forward, and you can accomplish the same thing with <code class="literal">ActorRef.tell</code> (message, sender) by supplying the sender. It is semantically clearer to use forward where it makes sense (especially in Scala where the <code class="literal">!</code> method is generally used):</p><div class="informalexample"><pre class="programlisting">//Java
actor.forward(result, getContext());

//Scala
actor forward message</pre></div><p>Note that the <a id="id285" class="indexterm"></a>context<a id="id286" class="indexterm"></a> is implicit in Scala.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec40"></a>Pipe</h4></div></div></div><p>Very often you will <a id="id287" class="indexterm"></a>have a future in your Actor that you want to send <a id="id288" class="indexterm"></a>back to the sender. We've covered that <code class="literal">sender()</code> is a method, so you have to store a reference to sender when using callbacks in Futures:</p><div class="informalexample"><pre class="programlisting">//Java
final ActorRef senderRef = sender();
future.map(x -&gt; {senderRef.tell(x, ActorRef.noSender()}));

//Scala
val senderRef = sender();
future.map(x =&gt; senderRef ! ActorRef.noSender);</pre></div><p>Callbacks registered on a future, such as map in this example, will execute in another thread, so they don't have access to the correct value from <code class="literal">sender()</code>. It's very unclear why the sender is stored and it is hard to understand code like this. It likely won't make sense to anyone who hasn't encountered this issue on their own. Quite possibly, as you read this, you may wonder why you don't just call <code class="literal">sender()</code> in the lambda. Try it out and you'll see unexpected results as <code class="literal">sender()</code> returns something different when it's called from the lambda.</p><p>We can skirt around this entire confusing mess by using the Pipe pattern. Pipe will take the result of a future and reply to the sender with the result of the future, whether success or failure, which is exactly what we want:</p><div class="informalexample"><pre class="programlisting">//Java
pipe(future, system.dispatcher()).to(sender());

//Scala
future pipeTo sender()
pipe(future) to sender()</pre></div><p>Again, pipe takes the result of the future and pipes it to the Actor <code class="literal">ref</code> provided. In these examples, we show <code class="literal">sender(),</code> and because <code class="literal">sender()</code> is executed on the current thread, it all behaves as expected without doing anything strange like storing a reference in a variable. Much better!</p><p>If this is at all unclear, trust <a id="id289" class="indexterm"></a>me you will run into this problem sooner or later and<a id="id290" class="indexterm"></a> ask yourself what is wrong once you start seeing dead-letter messages in your logs. Once you've gone through this once, you can pat yourself on the back and welcome yourself to the async club. This is an important lesson and you will learn it as you work with the APIs, especially when using ask.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Homework</h2></div></div><hr /></div><p>A short recap on what was discussed in the chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec44"></a>General learning</h3></div></div></div><p>Before looking at the supplied source on GitHub, take the examples in this chapter and try building them.</p><p>Using Ask designs, produce some Actors that do work and a cache for the results:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Improve upon the design using pipe.</p></li><li style="list-style-type: disc"><p>Using Tell Don't Ask Principles, eliminate asks, and do the same work.</p></li><li style="list-style-type: disc"><p>Try to use Tell Don't Ask principles to compose requests to multiple Actors from the extra Actor.</p></li></ul></div><p>You'll likely need an anonymous Actor:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In the previous design, schedule a timeout.</p></li><li style="list-style-type: disc"><p>Do the preceding but with the caching actor set up as a remote Actor.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec45"></a>Project homework</h3></div></div></div><p>You'll have the ability to handle many types of data flows now.</p><p>Pick one piece of functionality and try implementing with ask:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Try changing the behavior to avoid asking.</p></li><li style="list-style-type: disc"><p>Was the design better or worse? Hit the forums such as <a class="ulink" href="http://www.codereview.stackexchange.com" target="_blank">http://www.codereview.stackexchange.com</a> and discuss!</p></li></ul></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec26"></a>Summary</h2></div></div><hr /></div><p>This chapter covered relatively basic messaging concepts in Akka but has given enough heuristics to help you grow into a competent designer overtime.</p><p>You should now have a basic understanding of the messaging patterns:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Ask</p></li><li style="list-style-type: disc"><p>Tell</p></li><li style="list-style-type: disc"><p>Forward</p></li><li style="list-style-type: disc"><p>Pipe</p></li></ul></div><p>Some of the more advanced pieces that have been included, include how Ask works, and a few of the pitfalls you might encounter when using Ask, how to simplify working with Futures with Pipe, and how to simplify redirecting messages with Forward. In the next chapter, we'll look at different ways we can handle state in Actors.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch04"></a>ChapterÂ 4.Â Actor Lifecycle â€“ Handling State and Failure</h2></div></div></div><p>In this chapter, we're going to cover the actor's life cycleâ€”what happens when an actor encounters an exceptional state and how we can change its state to modify its behavior. We've looked at fault tolerance as a reactive tenet and covered how to store state in an actorâ€”we're going to expand on those topics here.</p><p>Before we get into failure and state, we're going to introduce what is known as The Fallacies of Distributed Computingâ€”a list of common misconceptions that developers hold about systems communicating over the network.</p><p>This chapter will cover the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The Fallacies of Distributed Computing</p></li><li style="list-style-type: disc"><p>What happens to an actor when it fails</p></li><li style="list-style-type: disc"><p>How an Actor can be supervised to handle failure</p></li><li style="list-style-type: disc"><p>How an Actor can change behavior with <code class="literal">become()</code> and as Finite State Machines</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec27"></a>The 8 Fallacies of Distributed Computing</h2></div></div><hr /></div><p>Before we look at the examples, we'll have a quick look at the Fallacies of Distributed Computing. The Fallacies of <a id="id291" class="indexterm"></a>Distributed Computing are a set of incorrect<a id="id292" class="indexterm"></a> assumptions that a team from Sun Microsystems asserted inexperienced developers make about systems working over a network. Let us have a look at the eight fallacies in detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec460"></a>The network is reliable</h3></div></div></div><p>The fallacy we hear is<a id="id293" class="indexterm"></a> most often cited, and that seems to come into play the most in systems today, is that the network is reliable. It is not. It's easy to think of a remote system in the same way we would think of a local oneâ€”Akka further helps us with this false assumption through location transparency by raising the level of abstraction when talking over the networkâ€”and we interact with remote actors exactly as we would with local ones.</p><p>We can reason that a service may be up or down, but what really constitutes a service being available? Even if a service is running, traffic has to be able to make it to the service. If you have two servers on a small network, it's very easy to think that they will be connected and talking successfully all of the time. But something will eventually fail between them. A router can crash and restart, the power can fail, someone can unplug the wrong cable in the datacenter, and so on. When you start to scale up, and you're talking about a thousand or ten thousand servers, the chance of things being unavailable become more common and more likely. In <a id="id294" class="indexterm"></a>
<span class="strong"><strong>Amazon Web Server</strong></span> (<span class="strong"><strong>AWS</strong></span>), it's actually extremely common for temporary<a id="id295" class="indexterm"></a> network failures to occur. In the system we are working on today, in AWS, we see disconnects and periods of network failure daily.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec46"></a>Latency is zero</h3></div></div></div><p>It takes time for messages to<a id="id296" class="indexterm"></a> travel over the network and it takes time for responses to come back. A remote Actor will incur a lot more latency overhead than one in local memory. Before any data begins to be sent over the network, there are several things that happen.</p><p>Hostnames are resolved to IPs (via DNS), IP addresses are resolved to their receiver's MAC address (via ARP), a TCP connection is established by a handshake, and then data starts to move. Data transferred over TCP is sent in sequenced packets, which receive an acknowledgment back. With this complexity, you can imagine that making a request to Google search takes some time just to leave your machine and to get to Google.</p><p>Given the overhead of network communication, we can make an assumption that it is better to make less calls with larger messages than it is to make more requests with smaller messages. To put this into practice in our example database, we may want to add a feature to send multiple <code class="literal">SetRequests</code> or multiple <code class="literal">GetRequests</code> in a single message.</p><p>Remember that testing with components in memory on your local machine is fine in development, but you always need to consider the latency that the network introduces and the impact that it has on the user's experience. This refers back to one of the reactive tenets: responsiveness. It's not only real-time systems that this is important forâ€”the responsiveness of web applications is just as important as it is in first-person shooters and stock-trading systems.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>Bandwidth is infinite</h3></div></div></div><p>Bandwidth is increasing <a id="id297" class="indexterm"></a>quite steadily in our networking technology today, so this is a bit less of a concern. Still, we don't want to send more over the network than we have to. A network has a capacity as well, which must be considered. The more traffic on a network, the more that communication is impacted by the noise. Also, the more you have to move over the network, the longer it will take.</p><p>For latency, we discussed how our database should handle multiple <code class="literal">SetRequests</code> and <code class="literal">GetRequests</code> in a single message to eliminate the number of requests made over the network. For bandwidth, we strive to reduce the size of the messages sent over the network. Gzip is often used in HTTP communication to reduce how much data is sent on each request. In large-scale distributed systems, compression algorithms that are easy on CPU (fast) are often used such as Snappy and LZO (for example, Cassandra uses LZO for intra-node communication).</p><p>For our database to take this fallacy's consideration into effect, we would want to reduce the size of the messages by using compression. Compression isn't freeâ€”it has a cost on CPU resources. There are some specialized algorithms that focus on performance rather than compression ratioâ€”we could use one of these, such as Snappy, to deflate the serialized messages before they are sent to the remote actor and then inflate them again before de-serializing them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>The network is secure</h3></div></div></div><p>It's easy to <a id="id298" class="indexterm"></a>forget that the networks we operate on are not secure.</p><p>In a public space like a shared Wi-Fi network, any HTTP traffic can be intercepted and read with minimal technical knowledge. The MySpace sign-on page used to be sent over un-encrypted HTTP, so it was very common for people to sit in cafes on Wi-Fi and steal your credentials. Even HTTPS can be intercepted and read via a Man-In-The-Middle attack using ARP Spoofingâ€”you'll get a certificate error still, so humans are the weak point in the system.</p><p>Just remember people can always read what you're sending on the network, so you need to ensure that if it's sensitive information in transit, it's protected with secure encryption such as AES-256 and that the keys are handled very carefully.</p><p>To apply this to our database, we'd want to allow encrypted communications to occur and we would want to validate the identity of the sender.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec49"></a>Network topology doesn't change</h3></div></div></div><p>When you build an <a id="id299" class="indexterm"></a>application and deploy it into your company's infrastructure or on the cloud, today your IPs looks one way but it is out of your control. Depending on specific IPs asserts that the network will never change. This problem is exacerbated when you move to the cloud, where stopping and starting your machine means it gets a new IP.</p><p>You can work to reduce this impact by using DNS or service registries built with technologies like Zookeeper, but it's important to assume your network will change.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec50"></a>There is one administrator</h3></div></div></div><p>I've been in trusted positions <a id="id300" class="indexterm"></a>with access to production systems for major brands on a few occasionsâ€”often because I needed to do work in them. You, as the developer, may not realize how many people will walk in and out of your network and machines. It's possible you work with an external datacenter or in cloud infrastructureâ€”remember people can leave the company and different disciplines require multiple people access the box, and so on.</p><p>Why would you care? The other day I deployed some software in test and immediately found it was broken after the application started. I was not aware that someone had logged into the system and changed some configuration. While managing your software, you should try to eliminate as many touch points as you canâ€”especially around configuration. Not everyone will have the tools or the understanding of the impacts that changes can incur. A simple change to one component can have unexpected outcomes for other systems.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec51"></a>Transport cost is zero</h3></div></div></div><p>There are costs in<a id="id301" class="indexterm"></a> pushing data down to the transport layer. There is a resource cost in serialization of data, compression of that data, pushing it to TCP buffers, and to establish connections. No chatter over the network is free.</p><p>Both in networks and in cloud infrastructure, there is an actual money cost to use the network as well. There is a cost in maintenance in infrastructure, and there is a cost incurred in use in the cloud.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec52"></a>The network is homogeneous</h3></div></div></div><p>In your <a id="id302" class="indexterm"></a>mind, imagine a network. It has communications coming into a firewall from the Internet, which is forwarded to a load balancer. That traffic is then forwarded to your application running on a<a id="id303" class="indexterm"></a> <span class="strong"><strong>Virtual Machine</strong></span> (<span class="strong"><strong>VM</strong></span>). Now imagine you build and deploy the exact same application in another environment.</p><p>Is the second network the same? Likely, every last component is different. Your firewall might be from Cisco or it might be a home router. Your load balancer might be from F5 or it might be a copy of nginx running on a VM. Your application may be running on an IBM P595 or it may be running on a VMare ESXi host. The VM might be running Ubuntu for an OS or it might be running IBM AIX Unix.</p><p>Does the load <a id="id304" class="indexterm"></a>balancer round robin or does it sticky sessions? Does the load balancer even support sticky sessions? These are all important questions to ask. I've seen an application deployed into production where a load balancer in an early cloud provider didn't support sticky sessions. A stateful application was deployed without state replication. This was unplanned for as we assumed the network was homogeneous; we assumed all load balancers were the sameâ€”they do NOT all have the same feature sets.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec28"></a>Failure</h2></div></div><hr /></div><p>The first fallacy of <a id="id305" class="indexterm"></a>distributed computing is that the network is reliable. It is not. It can and will fail. So all of our code has to correctly assume things will fail: that the network will glitch; that a message will drop.</p><p>Remember the Reactive Manifesto? One of the tenets is that we <span class="emphasis"><em>React to Failure</em></span>. That is, we have to assume error cases will be encountered. A secondary benefit of using Akka is fault tolerance. In this section, we will take a good look at how Akka helps us handle failure.</p><p>For the example in this section, we will look at different ways we can react to failure with our database.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec53"></a>Isolating failure</h3></div></div></div><p>Before we look at how <a id="id306" class="indexterm"></a>Akka responds to failure, we'll look at some strategies we should generally try to adhere to in our distributed applications: isolation of failures.</p><p>If every component was a ticking time bomb, you would want to ensure that if one exploded, it didn't blow up, causing a chain reaction with other components going down in the explosion. You might say, then, that we want to isolate the failure or compartmentalize the component that can fail.</p><p>I think a better analogy is bulk-heading, which I first saw used as an example in <span class="emphasis"><em>Reactive Design Patterns</em></span> by Jamie Allen and Roland Khun. Ships and planes are often compartmentalized in their hullsâ€”they have many individual vertical walls in the body of the ship. If there is a breach of the hull, only that one compartment is compromised, so even if a ship hits a rock or ice, it may stay afloat as all of the other compartments will not fill with water. This is an excellent example of how we want to design our systems to respond to failure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec41"></a>Redundancy</h4></div></div></div><p>One of the ways we<a id="id307" class="indexterm"></a> can keep a system up in the face of failure is to make components redundant and ensuring that there is no single point of failure. If we have a service, there are a few ways in which we can design the service for high availability with redundancy.</p><p>One example is by using a broker. A broker<a id="id308" class="indexterm"></a> is often used to allow new service nodes to come online or to allow a service node to go offline without taking down the system. Services will connect to the broker and pick up messages from the queue and process them. JMS or RabbitMQ might be examples of a broker. Databases can be used to broker messages. Note that a single broker is itself a single point of failure and can also be a bottleneck. We'll look at clustering services without a broker later in this book.</p><div class="mediaobject"><img src="graphics/B04006_04_01.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec54"></a>Supervision</h3></div></div></div><p>Erlang introduced fault<a id="id309" class="indexterm"></a> tolerance into the Actor Model through a concept known as supervision. At its core, the idea is to separate the response to failure from the thing that can fail and to organize things that can fail into hierarchies that can be managed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec42"></a>Supervision hierarchies</h4></div></div></div><p>Supervision is described in terms of <a id="id310" class="indexterm"></a>Actor hierarchiesâ€”when Actors are created, they are created as children of another actor that supervises them. The actor hierarchies are shown as path structures and the hierarchies can be thought of much like folders in a filesystem.</p><p>At the very top of the actor hierarchy is the root Actor at <code class="literal">/</code>. There is then an actor called the guardian whose path is <code class="literal">/user</code>. Any actor created with <code class="literal">actorSystem.actorOf()</code> function will be created as a child of this guardian actor <code class="literal">(/user/yourActor</code>).</p><p>If you create an actor from inside of an actor, you can create the actor as a child of the actor by calling <code class="literal">context().actorOf</code>, which would make this actor in the next leaf of the tree <code class="literal">(/user/yourActor/newChild</code>)</p><p>There are other actor <a id="id311" class="indexterm"></a>hierarchies under the root as well. Supporting system actors go under the system guardian at <code class="literal">/system.</code> There is a temporary actor hierarchy under <code class="literal">/temp</code> where actors that complete futures go. You won't need to worry about these too muchâ€”they are mostly transparent to the developer as used by Akka's internals.</p><p>Remember the sushi restaurant example? Assuming that the restaurant has an owner who oversees a manager and a manager who oversees the line staff (chefs and waiters), then, we may have a hierarchy that looks like the following:</p><div class="mediaobject"><img src="graphics/B04006_04_02.jpg" /></div><p>Each actor that <a id="id312" class="indexterm"></a>oversees other actors can then define its supervision strategy. We will look at supervision strategies next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec43"></a>Supervision strategies and the drunken sushi chef</h4></div></div></div><p>To understand <a id="id313" class="indexterm"></a>supervision <a id="id314" class="indexterm"></a>strategies, we'll look at an example. We have a sushi chef who likes to drink a lot. His drinking often gets himself in trouble, and his manager has to take action. There are a few different actions the manager can take. We'll look at each in the following.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Resume</strong></span>: The actor will continue with the next message</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Stop</strong></span>: Will stop the actor and take no further action</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Restart</strong></span>: Will create a new actor to replace the old one</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Escalate</strong></span>: Will pass the exception up to the next supervisor</p></li></ul></div><p>To demonstrate these, imagine our sushi chef actor has to make sushi. He is very skilled and to celebrate his beautiful dishes, he takes a drink every time he makes a plate. The waiting staff pile up menu chits for the sushi chef to fill and he keeps making sushi and drinking. If the sushi chef works all day, eventually he will get into a bad state (to put it lightly).</p><p>If the actor makes a mistakeâ€”if he cuts his finger or drops a plateâ€”this is probably acceptable. The actor will be told to <code class="literal">resume()</code> in this case.</p><p>If the chef gets tired and makes an error indicating he may need to take a break, then the supervisor may tell the actor to stop processing messages and let the actor take a break. It's often up to the supervisor to take necessary actions in this case, for example, the supervisor would need to tell the actor when to go back to work.</p><p>Once the sushi<a id="id315" class="indexterm"></a> chef is drunk, he makes a really bad looking plate and<a id="id316" class="indexterm"></a> starts hitting on some customers. The managerâ€”who is the supervisor of the chefâ€”responds to the exception. The manager declares the chef drunk and sends him home for the day. The supervisor calls in another chef who picks up the next ticket and continues with the orders. Retiring the old chef and bringing on a new one is the equivalent to restart.</p><p>This next chef is young and can't handle his liquor. He gets particularly intoxicated and knocks over a candle and sets fire to the place. The manager can't handle the errorâ€”the roaring flame can't be fixed by sending this chef home drunk and putting another chef in the burning kitchen! The manager calls his supervisorâ€”the ownerâ€”who tells him to shut down the restaurant and call the police immediately. This is escalate, where the manager's boss (the owner) makes the decision. If an throwable is escalated through the hierarchy to the guardian, then the application will shutdown.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec44"></a>Defining supervisor strategies</h4></div></div></div><p>Actors have a default <a id="id317" class="indexterm"></a>supervisor strategy. If an actor is supervised without changing the supervision strategy, the behavior will roughly be the same as in the drunken chef example:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Exception in a running actor: <code class="literal">restart()</code>
</p></li><li style="list-style-type: disc"><p>Error in a running actor: <code class="literal">escalate()</code>
</p></li><li style="list-style-type: disc"><p>Exception in an actor during initialization: <code class="literal">stop()</code>
</p></li></ul></div><p>There is one other case defined in the default behaviorâ€”<code class="literal">ActorKilledException</code>. If an actor is killed, its supervisor will receive an <code class="literal">ActorKilledException</code>â€”the behavior when receiving this exception is to <code class="literal">stop()</code>.</p><p>Remember that <code class="literal">/system</code> path? All of the supervision events actually happen in actors over thereâ€”the exception events are not your normal messagesâ€”it's important to understand this if you're trying to reason about message delivery order.</p><p>We'll look at how <a id="id318" class="indexterm"></a>we would define the manager's supervision strategy if we wanted to describe the behavior.</p><p>In Java:</p><p>Following code denotes manager's supervision strategy in Java:</p><div class="informalexample"><pre class="programlisting">@Override
    public akka.actor.SupervisorStrategy supervisorStrategy() {
        return new OneForOneStrategy(5, Duration.create("1 minute"), akka.japi.pf.DeciderBuilder. match(BrokenPlateException.class, e -&gt; SupervisorStrategy.resume()). match(DrunkenFoolException.class, e -&gt; SupervisorStrategy.restart()). match(RestaurantFireError.class, e -&gt; SupervisorStrategy.escalate()). match(TiredChefException.class, e -&gt; SupervisorStrategy.stop()). matchAny(e -&gt; SupervisorStrategy.escalate()). build() );
    }</pre></div><p>We override the <code class="literal">supervisorStrategy</code> method in an actor returning a new strategy (<code class="literal">OneForOneStrategy</code>, which we'll look at more closely shortly.) In Java8, we use a <code class="literal">DeciderBuilder</code> to create a Scala <code class="literal">PartialFunction</code> for the strategy similar to how we use the <code class="literal">ReceiveBuilder</code> for the <code class="literal">PartialFunction</code> for the receive block. While Java lacks the pattern matching semantics that Scala has for producing Scala <code class="literal">PartialFunctions</code>, the <code class="literal">DeciderBuilder</code> alleviates this, giving us a nice API for pattern matching in Java8. We describe each case outlined in the scenarios in our Sushi restaurant example and we also include a <code class="literal">matchAny</code> case at the endâ€”if an unknown <code class="literal">Throwable</code> is received, we have the manager call his boss.</p><p>Scala has pattern matching so it needs less boilerplate to express the same:</p><div class="informalexample"><pre class="programlisting">override def supervisorStrategy = { OneForOneStrategy(){ case BrokenPlateException =&gt; Resume case DrunkenFoolException =&gt; Restart case RestaurantFireError =&gt;Escalate case TiredChefException =&gt; Stop case _ =&gt; Escalate } }</pre></div><p>In the Scala <a id="id319" class="indexterm"></a>example, we override the <code class="literal">supervisorStrategy</code> method of the actor again, and then define a <code class="literal">PartialFunction</code> matching on Throwables and returning Directives. Here we describe all of the scenarios outlined in the example and any unknown cases, we escalate.</p><p>In both Scala and Java, we describe how to handle each of the different <code class="literal">Throwable</code> cases if they are thrown by the actor: if the chef breaks a plate, we tell them to resume the next plate; if a chef is a drunken fool, we tell them to go home and bring on a new chef; if the chef lights the restaurant on fire, we have the manager call his boss; if the chef is tired, we tell him to take a break.</p><p>Note that the default behavior is generally suitableâ€”if a running actor throws an exception, we will restart the actor, and if it throws an error, we will escalate and stop the application. If your actor can throw exceptions in the constructor, however, this will cause the <code class="literal">ActorInitializationException</code>, which causes the Actor to stop. Special care must be taken in these cases as your application will not resume.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec45"></a>Actor lifecycle</h4></div></div></div><p>We introduced restart, which is<a id="id320" class="indexterm"></a> like sending a worker home and replacing him with a new one. We'll look at what happens through the actor's lifecycle now.</p><p>There are a few methods/hooks that are called through an actor's lifecycle, which you can override as needed.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">preStart()</code>: After constructor</p></li><li style="list-style-type: disc"><p>
<code class="literal">postStop():</code> Before restart</p></li><li style="list-style-type: disc"><p>
<code class="literal">preRestart(reason,message)</code>: Calls <code class="literal">postStop</code> by default</p></li><li style="list-style-type: disc"><p>
<code class="literal">postRestart()</code>: Calls <code class="literal">preStart</code> by default</p></li></ul></div><p>The order of events in an Actor's lifecycle is as given in the following image:</p><div class="mediaobject"><img src="graphics/B04006_04_03.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip09"></a>Tip</h3><p>Note that the <code class="literal">preRestart</code> and <code class="literal">postRestart</code> are only called on restart. And they are called instead of the <code class="literal">preStart</code> and <code class="literal">postStop</code> methods but by default call <code class="literal">preStart</code> and <code class="literal">postStop</code>. This lets you decide whether you want to call the <code class="literal">preStart</code> and <code class="literal">postStop</code> methods only once (when an actor starts or stops) or every time an actor restarts.</p></div><p>This can be very<a id="id321" class="indexterm"></a> helpful when designing. Imagine a chat application where each user is represented by an actor that sends messages to an actor representing the chat. When a user joins the room, an actor starts and sends a message so that the list of users in the room can be updated. When an actor stops, it sends another message so that the user can be removed from the list of users displayed as currently active in the chat. With the default implementation, if the actor encounters an exception and restarts, it will unpublish and republish the user in the chat window. We can override <code class="literal">preRestart</code> and <code class="literal">postRestart</code> so that the user will only add itself to the list and remove itself from the list when the user actually joins and leaves the chat.</p><div class="mediaobject"><img src="graphics/B04006_04_04.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec461"></a>Messages in restart, stop</h4></div></div></div><p>It's important to<a id="id322" class="indexterm"></a> understand what happens to a message when an <a id="id323" class="indexterm"></a>exception is encountered and to take an appropriate position depending on your application. Supervision strategies can be defined to retry failed messages any number of times before raising the exception to the supervision strategy. You can also time bound the failures so that you can retry up to 10 times or retry for 1 minuteâ€”whichever comes first:</p><div class="informalexample"><pre class="programlisting">new OneForOneStrategy(2, Duration.create("1 minute"), PartialFunction) OneForOneStrategy( maxNrOfRetries = 2) { case _: IOException  Restart })</pre></div><p>Once a message raises an exception, it will be dropped. It will not be tried againâ€”the Supervisor will execute the supervision strategy, and in the case of resume or restart, the next message will be processed.</p><p>In the case of a worker queue, you likely want to retry the job a few times and then have it fail completely.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec47"></a>Terminating or killing an Actor</h4></div></div></div><p>Actors can be stopped in a few <a id="id324" class="indexterm"></a>different ways. You can stop an actor by doing <a id="id325" class="indexterm"></a>any of the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Call <code class="literal">ActorSystem.stop</code>(<code class="literal">actorRef</code>)</p></li><li style="list-style-type: disc"><p>Call <code class="literal">ActorContext.stop</code>(<code class="literal">actorRef</code>)</p></li><li style="list-style-type: disc"><p>Send a <code class="literal">PoisonPill</code> message to the actor, which will stop the actor when processed.</p></li><li style="list-style-type: disc"><p>Send a Kill message to the actor, which will stop the actor when processed.</p></li></ul></div><p>Calling <code class="literal">context.stop</code> or <code class="literal">system.stop</code> will cause the actor to stop immediately. <code class="literal">PoisonPill</code> <a id="id326" class="indexterm"></a>will cause the actor to stop when the message is processed. By <a id="id327" class="indexterm"></a>contrast, Kill will not stop the actor directly, but will cause the actor to throw an <code class="literal">ActorKilledException </code>which is handled by the supervision behaviorâ€”you can decide how you want to respond in those cases.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec48"></a>Lifecycle monitoring and DeathWatch</h4></div></div></div><p>Supervision describes <a id="id328" class="indexterm"></a>a mechanism for responding to a child <a id="id329" class="indexterm"></a>actor's statesâ€”it's also possible for an actor to monitor any other actor. Calling <code class="literal">context.watch</code>(<code class="literal">actorRef</code>) will register an actor for monitoring another actor for termination and calling <code class="literal">context.unwatch</code>(<code class="literal">actorRef</code>) will unregister. If the watched actor stops, a <code class="literal">Terminated</code>(<code class="literal">ActorRef</code>) message will be sent to the watcher.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec49"></a>Safely restarting</h4></div></div></div><p>When we build reactive systems, we design them anticipating failure. We need to ensure our systems respond to failure correctly. One of the mistakes that I've seen out in the wild is to initialize an actor's state after it has started without handling the failure case. If you send an actor some initialization messages, with information that is important to its state, you have to be very careful because that information may be be lost in a restart.</p><p>Let's demonstrate: Imagine if we make a database client actor with no arguments, and then we tell the actor where to connect. This doesn't seem unreasonableâ€”very often in Java, we set fields in objects after creating them. We also know that Actors can safely store state, so nothing seems wrong with this scenario yet:</p><div class="informalexample"><pre class="programlisting">ActorRef db = system.actorOf(DbActor.props()); db ! Connect(host = "10.0.8.14", port = "9001"); val actor = createActor(DbActor.props); actor.tell(new Connect("10.0.8.14", "9001");</pre></div><p>Now we have an actor, and, once it processes that first message, it's initialized and connected to a remote database.</p><p>We send messages to the actor for a bit, and then the actor encounters an exception caused by network reliability. The actor will restart at this point. When the actor restarts, it will call <code class="literal">preRestart()</code>, and then the original actor will stop. All of the state in that actor will go away with it. Then a new object is created for the Actor. That actor's constructor will run, then <code class="literal">postRestart</code> will be called, and then the actor will be up and running.</p><p>That Connect message is now lost. You can write some extra code to handle this scenario. You could write a supervision strategy or use Akka's lifecycle monitoring (<code class="literal">DeathWatch</code>) to respond to these failure conditions. But, the point is, for this simple initialization message, you have to handle this case now and risk making an error in handling the client. A much better implementation is to pass the initialization information into the constructor of the actor via Props:</p><div class="informalexample"><pre class="programlisting">ActorRef db = system.actorOf(DbActor.props(host = "10.0.8.14", port = "9001")); val actor = createActor(DbActor.props("10.0.8.14", "9001"));</pre></div><p>This seems betterâ€”the actor now gets all of the information in its constructor and it connects automatically. If we start sending the actor messages and it restarts, it will recover correctly because it has the connection information in its constructor arguments..` But, if the actor encounters an exception during initialization, perhaps trying to connect to the remote database, then the default supervision behavior is to stop. So, we have a scenario where the actor can restart safely if running, but, if it can't initialize, we have to write extra code in supervision behavior to handle the scenario where the actor can't connect to the database on startup.</p><p>It is common to have an actor send itself an initialization message and to have it handle changing its state while running, instead of potentially failing during initialization. To do this, on <code class="literal">postStart</code>, an actor might send itself a Connect message:</p><div class="informalexample"><pre class="programlisting">public void postStart(){ self().ask(new Connect(), null); } override def postStart = self ! Connect</pre></div><p>Now that actor can only fail when it's running, and it will restart successfully, continuing to try to connect to the database until it's available.</p><p>If you're paying attention, you might reason that you could have the actor send itself the <code class="literal">Connect(host, port)</code> message on the <code class="literal">preRestart</code> event. If the actor were to drop that message for any reason, maybe because its mailbox was full or because a restart caused it to be dropped, then that Connect message could be lostâ€”it's simpler and safer to use the constructor for an actor that is critical to the actor's functioning.</p><p>This is a quick and dirty look at building an actor that will just continually retry its connection.</p><p>It's important to note that there are some missing details and problems with this still. The first is that we have no way to handle the messages the actor will receive before it connects. And the second is that the mailbox will be flooded if the actor can't connect for a large period of time.</p><p>We'll cover handing state in this chapter. Mailbox problems are covered in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Handling Mailbox Problems</em></span>.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec29"></a>State</h2></div></div><hr /></div><p>We have looked at how it is <a id="id330" class="indexterm"></a>safe to store state in an Actorâ€”how Actors give us a lock-free way to deal with state in concurrency. We're going to look at how an actor can change its behavior in the face of different states now.</p><p>There are a few mechanisms you can use to change behavior in an actor:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Conditionals based on an Actor's state</p></li><li style="list-style-type: disc"><p>Hotswap: <code class="literal">become()</code> and <code class="literal">unbecome()</code>
</p></li><li style="list-style-type: disc"><p>Finite State Machine (FSM)</p></li></ul></div><p>We'll look at each after introducing the example that builds on our key-value datastore example.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec55"></a>Online/Offline state</h3></div></div></div><p>Let's revisit the first<a id="id331" class="indexterm"></a> fallacy of distributed computing. Not only is the network <a id="id332" class="indexterm"></a>not reliable, but the components that we try to talk<a id="id333" class="indexterm"></a> to over the network could be down. We want our application to handle<a id="id334" class="indexterm"></a> network misses gracefully without dropping too many messages.</p><p>To continue to develop our database example, we'll improve the remote client so that it deals with network partitions such as temporary failure of network components or database service restarts as gracefully as possible in the case of a client-server model.</p><p>What we looked at in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> was an example where we had a remote key-value datastore, which we connected to from a client. We did an <code class="literal">actorSelection</code> to get a reference to the remote actor and then started sending it messages. What if the database isn't ready when we start our application? Or, what if the database goes offline for a moment?</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec50"></a>Transitioning state</h4></div></div></div><p>One of the most common<a id="id335" class="indexterm"></a> examples I have seen of the use of state is to determine if a service is online or offline. We examined this in the section on failure, and looking at what happens to actors when they restart. We'll continue with the example of a database client actor connecting to a remote database.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec51"></a>Stashing messages between states</h4></div></div></div><p>If the bartender <a id="id336" class="indexterm"></a>at<a id="id337" class="indexterm"></a> our sushi restaurant gets a request to pour a beer while the keg is being changed, he won't be able to take care of that order. But he will be able to at a later point in time, once the new keg is ready. The bartender won't simply throw away the order because the keg isn't readyâ€”he will set aside the order for a minute and process other orders that he is able to (like pouring more sake for the chef). Once the keg is ready, then he'll put any beer orders back in his queue to process.</p><p>Similar to this <a id="id338" class="indexterm"></a>example, it's very common for an Actor to be in a state where it can't process certain messages. If the database client is offline, it isn't <a id="id339" class="indexterm"></a>going to be able to handle any messages until it is online. We could have the client connection continue to restart until it connects, in which case it will drop every message it encounters until it's able to connect successfully. Or we could have the client set the messages it cannot handle aside while waiting for the client to enter a connected state.</p><p>Akka has a mechanism called <code class="literal">stash</code> to do this. Stashing messages puts the message off to the side in a separate queue that it cannot currently handle:</p><div class="informalexample"><pre class="programlisting">if(cantHandleMessage){ stash(); }else{ handleMessage(message); }</pre></div><p>Unstash puts the messages that were set aside back into the mailbox queue for the actor to handle.</p><div class="informalexample"><pre class="programlisting">changeStateToOnline(); unstash();

To use stash in Java, your Actor will extend AbstractActorWithStash:
class RemoteActorProxy extends AbstractActorWithStash { [...] }
To use stash in Scala, you mix in the stash trait:
class RemoteActorProxy extends Actor with Stash { [...] }</pre></div><p>We'll use this mechanism now to demonstrate how to make a client switch between online and offline states.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>NOTE that <code class="literal">stash()</code> and <code class="literal">unstash()</code> can be handy when you expect state to change quickly, but states where messages are stashed should always be time-bound or else you risk flooding your mailboxes.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec56"></a>Conditional statements</h3></div></div></div><p>The most naive approach is<a id="id340" class="indexterm"></a> to store state in the actor and then have a conditional statement decide what behavior the actor should take.</p><p>You can store a Boolean to say if you're connected to the database, and if you're connected, try to handle the message. If you're not, you can fail.</p><p>The following is a Java example of storing state and handling behavior with conditional statements:</p><div class="informalexample"><pre class="programlisting">private Boolean online = false; public PartialFunction receive() { return RecieveBuilder. match(GetRequest.class, x -&gt; { if(online) { processMessage(x); } else { stash(); } }). match(Connected.class, x -&gt; { online = true; unstash(); ). match(Disconnected.class, x -&gt; online = false). build(); 
Here is the Scala equivalent to storing state and changing behavior with conditionals:
 var online = false def receive = { case x: GetRequest =&gt; if(online) processMessage(x) else stash() case _: Connected =&gt; online = true unstash() case _: Disconnected =&gt; online = false }</pre></div><p>This conditional statement is the most basic way to express different behavior based on state stored in an actor. We store a Boolean called <code class="literal">online</code> that represents if the actor is connected or not. If the actor is connected, it processes the message. If it is not connected, it stashes the messages, as covered previously. If it receives a Connected message, then it changes its state to be online and unstashes all of the messages. Because of the use of <code class="literal">stash</code>/<code class="literal">unstash</code>, once it comes online, the actor will then process any messages it stashed.</p><p>It's very common for an actor to store state and behave differently depending on that state. Using conditionals is a very procedural approach to dealing with behavior and state. Fortunately, Akka<a id="id341" class="indexterm"></a> gives us a couple of better options.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec57"></a>Hotswap: Become/Unbecome</h3></div></div></div><p>The code with <a id="id342" class="indexterm"></a>conditionals was not very pretty. It certainly was not very <a id="id343" class="indexterm"></a>declarative. Akka gives us <code class="literal">become()</code> and <code class="literal">unbecome()</code> to manage behavior that can improve the clarity of the code considerably. In the actor's <code class="literal">context()</code>, there are a two methods:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">become(PartialFunction behavior)</code>: This changes the actor's behavior from the behavior defined in the receive block to a new <code class="literal">PartialFunction</code>.</p></li><li style="list-style-type: disc"><p>
<code class="literal">unbecome()</code>: This reverts the actor's behavior back to the default behavior.</p></li></ul></div><p>Let's look at how using this mechanism can improve our previous example:</p><div class="informalexample"><pre class="programlisting">public PartialFunction receive() { return RecieveBuilder. match(GetRequest.class, x -&gt; stash()). match(Connected.class, x -&gt; { context().become(online); unstash(); }). build(); } final private PartialFunction&lt;Object, BoxedUnit&gt; online(final ActorRef another) { return RecieveBuilder. match(GetRequest.class, x -&gt; processMessage(x)). build(); }</pre></div><p>Here is the Scala equivalent:</p><div class="informalexample"><pre class="programlisting">  def receive = { case x: GetRequest =&gt; stash() case _: Connected =&gt; become(online) unstash() } def online: Receive = { case x: GetRequest =&gt; processMessage(x) case _: Disconnected =&gt; unbecome() }</pre></div><p>This has better readability than conditional statements. Each state's behavior is described in its own <code class="literal">PartialFunction</code> where pattern matching and behavior are described. This lets us read the behavior of the actor in its different states independently.</p><p>The actor starts in the offline state where it will stash messages it is not able to respond to <code class="literal">(GetRequest)</code>. Those messages get set aside until the <code class="literal">Connected</code> message is received. Once the Connected message is received, then the actor calls become to change its behavior to the online state described in the online method. At this time, the actor also calls <code class="literal">unstash</code> to put the messages set aside, back into the queue. Now all of the messages will be processed with the new behavior.</p><p>If the actor receives a <code class="literal">Disconnected</code> message, then it calls <code class="literal">unbecome</code>, which will revert the actor to its default behavior. Note that any number of receive blocks can be defined and swapped between. Hotswap can handle mostly any behavior changes that might need to be handled in an actor as it changes behavior. This is a nice easy abstraction for producing readable actors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec52"></a>Stash leaks</h4></div></div></div><p>The examples covered so far <a id="id344" class="indexterm"></a>using stash have a problemâ€”if the connect message takes too long to be received, or is not received, then messages will continually be stashed until the application runs out of memory or the mailbox starts dropping messages (mailboxes are covered further in a later chapter). Wherever using <code class="literal">stash()</code>, it's a good idea to put a boundary on how much time can pass or how many messages can be received before taking action.</p><p>The most basic way to do this is to schedule a timeout message to be sent to the actor after a certain period of time.</p><p>We can schedule one message in the actor's constructor or <code class="literal">postStart </code>hook, and then when it is received, check that the actor is connected. If it's not connected, then the actor can escalate the problem and have the supervisor take action:</p><div class="informalexample"><pre class="programlisting">system.scheduler().scheduleOnce(Duration.create(1000, TimeUnit.MILLISECONDS), self(), CheckConnected, system.dispatcher(), null);</pre></div><p>If the actor receives the message and it is online, it will be ignored. If the actor receives the message and it is not online, then it will throw an exception:</p><div class="informalexample"><pre class="programlisting"> .match(CheckConnected.class, msg -&gt; throw new ConnectTimeoutException())
case _: CheckConnected =&gt; throw new ConnectTimeoutException</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec53"></a>Finite State Machines (FSM)</h4></div></div></div><p>There is another tool for handling state in <a id="id345" class="indexterm"></a>actors: <span class="strong"><strong>Finite State Machine </strong></span>(<span class="strong"><strong>FSM</strong></span>). Much like hotswap, FSMs have state and behavior that changes based on state. FSM is a bit heavier of an abstraction than hotswap and requires more code and types to get up and running, so hotswap will usually be a simpler and more readable option.</p><p>We have a good example for connected/disconnected to use in the clientâ€”we'll keep that in place for the basic client and look for other ways we can improve the client/server communication.</p><p>The Fallacies of Distributed Computing were introduced earlier in this chapter. One of the points is that there is a cost in latency for every request and response over the network (fallacy: latency is zero). Because there is a cost to every request and response, reducing the number of times messages are sent and responded to can cut down on total time spent waiting. To improve our client and server behavior, we can reduce how many messages are sent over the network by combining them into a smaller number of requests.</p><p>Using traditional request/response protocols, an application will make a request over the network and then wait for the response to continue processing messages. In an application where we need to read multiple records from a database, the typical flow may look something like the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>
<span class="strong"><strong>Client</strong></span>: Send <code class="literal">GetRequest(user)</code> over network.</p></li><li><p>
<span class="strong"><strong>Server</strong></span>: Reply to client with user data.</p></li><li><p>
<span class="strong"><strong>Client</strong></span>: Wait for <code class="literal">Success</code> response.</p></li><li><p>
<span class="strong"><strong>Client</strong></span>: Send <code class="literal">GetRequest</code>(article) to server.</p></li><li><p>
<span class="strong"><strong>Server</strong></span>: Reply to client with article data.</p></li><li><p>
<span class="strong"><strong>Client</strong></span>: Wait for Success response.</p></li><li><p>
<span class="strong"><strong>Client</strong></span>: Return Success response to create user profile request</p></li></ol></div><p>The time taken for a signal to be sent plus the acknowledgment to be received is called <a id="id346" class="indexterm"></a>
<span class="strong"><strong>Round-trip Delay Time</strong></span> (<span class="strong"><strong>RTD</strong></span> or <span class="strong"><strong>RTT</strong></span>). One of the Reactive Tenets is to be responsive to our users, so we want to eliminate the amount of time we spend waiting for messages to travel over the network.</p><p>One way we can improve our datastore API is to allow the datastore to accept a list. This would let us send multiple operations in a single request:</p><div class="informalexample"><pre class="programlisting">ask(remoteActorSelection, Arrays.asList( new SetRequest(id, user, sender), new SetRequest("profile-" + id, profile, sender)), timeout); remoteActorSelection ? List( SetRequest(id, user, sender), SetRequest("profile-"+id, profile, sender) )</pre></div><p>Note that on the preceding snippet showing the list, we've included a sender in the messages to allow us to complete futures or reply to Actors.</p><p>Trying to create a single list in an application request could prove to be inconvenient to the users of our library. We can improve the client API to handle this concern.</p><p>We'll create an actor <a id="id347" class="indexterm"></a>to use in our datastore client that sends messages to a remote database actor once several messages have accumulated or once a <code class="literal">Flush</code> message is received. By doing this, we put the concern of gathering and sending messages in one actor to adhere to single responsibility principle. (Note that this example is similar to the one in the Akka documentation for FSMâ€”you can see the documentation if you need a quick reference or want to see a different implementation.)</p><p>The FSM types have two parameters: State and Container. We'll look at defining those and then we'll look at building the FSM.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec54"></a>Defining states</h4></div></div></div><p>The FSM <a id="id348" class="indexterm"></a>describes its state a bit differently than other actors we have looked at.</p><p>For our FSMs, we will improve on the hotswap example to store messages in the actor instead of stashing them:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Disconnected</strong></span>: Not online and no messages are queued</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Disconnected and Pending</strong></span>: Not online and messages are queued</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Connected</strong></span>: Online and no messages are queued</p></li><li style="list-style-type: disc"><p>C<span class="strong"><strong>onnected and Pending</strong></span>: Online and Messages are Pending</p></li></ul></div><p>We use an <code class="literal">enum</code> in Java for the states:</p><div class="informalexample"><pre class="programlisting">enum State{ DISCONNECTED, CONNECTED, CONNECTED_AND_PENDING, }</pre></div><p>In Scala, we can use case objects instead:</p><div class="informalexample"><pre class="programlisting">sealed trait State case object Disconnected extends State case object Connected extends State case object ConnectedAndPending extends State</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec55"></a>Defining the state container</h4></div></div></div><p>We've described the states, now <a id="id349" class="indexterm"></a>we need to define the state container for the actor. The state container is where we will store the messages. The FSM allows us to define the state container and change it between states, so our use case maps quite nicely to the FSM as we'll change the state container when we change between states.</p><p>For our state container, we'll store a list of requests to be processed on a flush event:</p><div class="informalexample"><pre class="programlisting">public class EventQueue extends LinkedList&lt;Request&gt; {}</pre></div><p>In Scala, we'll use a type definition for this purpose:</p><div class="informalexample"><pre class="programlisting">object StateContainerTypes { type RequestQueue = List[Request] }
public class Flush {}
case object Flush</pre></div><p>Now we're ready to build the actor's behavior.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec56"></a>Defining behavior in FSMs</h4></div></div></div><p>First, FSMs <a id="id350" class="indexterm"></a>must extend the base traits.</p><p>In Java8, we <a id="id351" class="indexterm"></a>extend <code class="literal">akka.actor.AbstractFSM&lt;S, D&gt;</code>
</p><div class="informalexample"><pre class="programlisting">public class BunchingAkkademyClient extends AbstractFSM&lt;State, RequestQueue&gt;{ {//init block } }</pre></div><p>Note that we create an init blockâ€”we describe the behavior in this init block.</p><p>In Scala, we extend <code class="literal">akka.actor.FSM[S, D]</code>:</p><div class="informalexample"><pre class="programlisting">class BunchingAkkademyClient extends FSM[State, RequestQueue]{ }</pre></div><p>In the actors, we can now use the FSM API to describe the behavior in different states. First, we call the <code class="literal">startWith</code> method to describe how the actor starts:</p><div class="informalexample"><pre class="programlisting">{ startWith(DISCONNECTED, null); }
  startWith(Disconnected, null) //scala needs no init block!</pre></div><p>Then we describe how different messages are responded to in different states and how the state changes depending on the message. There are a few ways to describe the behavior. The one that you'll be most comfortable with is calling <code class="literal">when</code> (S state, <code class="literal">PartialFunction pf</code>). We can build the behavior for each case by calling the <code class="literal">when</code> statement several times.</p><p>In Java, we can build a partial function again using tools that Akka gives us similar to the <code class="literal">ReceiveBuilder</code>.</p><p>We'll describe each of the<a id="id352" class="indexterm"></a> states and the response to<a id="id353" class="indexterm"></a> Flush, Connected, and Request messages:</p><div class="informalexample"><pre class="programlisting">        when(DISCONNECTED, matchEvent(FlushMsg.class, (msg, container) -&gt; stay()) .event(GetRequest.class, (msg, container) -&gt; { container.add(msg); return stay(); }).event(Tcp.Connected.class, (msg, container) -&gt; { if(container.getFirst() == null){ return goTo(CONNECTED); }else{ return goTo(CONNECTED_AND_PENDING); } })); when(CONNECTED, matchEvent(FlushMsg.class, (msg, container) -&gt; stay()) .event(GetRequest.class, (msg, container) -&gt; { container.add(msg); return goTo(CONNECTED_AND_PENDING); })); when(CONNECTED_AND_PENDING, matchEvent(FlushMsg.class, (msg, container) -&gt; { container = new EventQueue(); return stay(); }) .event(GetRequest.class, (msg, container) -&gt; { container.add(msg); return goTo(CONNECTED_AND_PENDING); })); 
         scala.PartialFunction pf = ReceiveBuilder.match(String.class, x -&gt; System.out.println(x)).build(); when(CONNECTED, pf);</pre></div><p>And for Scala, we use pattern matching to describe the <code class="literal">PartialFunction</code> in each state with <code class="literal">when</code>(state):</p><div class="informalexample"><pre class="programlisting">  when(Disconnected){ case (_: Connected, container: RequestQueue) =&gt; if (container.headOption.isEmpty) goto(Connected) else goto(ConnectedAndPending) case (x: GetRequest, container: RequestQueue) =&gt; stay using(container :+ x) } when (Connected) { case (x: GetRequest, container: RequestQueue) =&gt; goto(ConnectedAndPending) using(container :+ x) } when (ConnectedAndPending) { case (Flush, container) =&gt; remoteDb ! container; container = Nil goto(Connected) case (x: GetRequest, container: RequestQueue) =&gt; stay using(container :+ x) }</pre></div><p>In Both the Java and Scala examples, we describe the three states. The <code class="literal">Disconnected</code> state will store messages or go online. It will ignore messages other than <code class="literal">Connected</code> or <code class="literal">GetRequest</code>.</p><p>In the <code class="literal">Connected</code> state, we<a id="id354" class="indexterm"></a> only care about messages<a id="id355" class="indexterm"></a> that make us transition to the <code class="literal">ConnectedAndPending</code> state.</p><p>Finally, the <code class="literal">ConnectedAndPending</code> state can either flush or add a request to the container. In Scala, the container is an immutable type, so we pass a new container through the state changes.</p><p>Note that we ignore messages in some states or process them in others. We'll ignore the Flush command if there are no messages to flush, but we'll process it and move back to the <code class="literal">Connected</code> state with no pending messages after a flush.</p><p>The actor has to return a description of states that it either stays in or moves to in the FSM, which means that, compared to hotswap, the FSM requires a more descriptive actor. There is some boilerplate to using FSM, but it can produce clearer actor code in some cases. It's possible to use either hotswap or FSM for actor with different behavior in states. You can evaluate which will produce more usable code for your use case. FSM is another tool in your toolbeltâ€”in many cases, hotswap will be enough and simpler, but FSMs might have maintainability benefits in some cases.</p><p>The last thing we do in the block is call <code class="literal">initialize()</code>:</p><div class="informalexample"><pre class="programlisting">initialize();</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec58"></a>Using restarts to transition through states</h3></div></div></div><p>Note that the <a id="id356" class="indexterm"></a>actor does not have any disconnect message or behavior. If we encounter an exception in our actor's state, the easiest way to transition back to disconnected is to simply throw an exception and have the actor restart. Very often this will be the simplest and most reliable way to respond to an exceptional case. Once your actor is running, do not be afraid to restart your actors! You know that the piece of the actor system that is encountering the problem will simply be recreated. The Akka team's blog is called "Let IT Crash" because of the attitude that Akka takes to the reliability of our software. If an exception is thrown, Akka takes care of it for us by recreating the piece of our software that fails.</p><p>The best way to handle understanding if the actor is connected is to get a message from the remote actor every couple of seconds. This is called a "heartbeat." We could build a heartbeat that checks that the actor is responding, and, if it is not, then we could restart the actor and log the exception. In our FSM example, if we restarted after a couple of missed heartbeats, the actor would dump any pending messages, which, while it would drop them, would mean that the application wouldn't leak too much memory. When the remote database finally becomes available, then the application will resume behavior as normal.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec30"></a>Homework</h2></div></div><hr /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Take the <code class="literal">Akkademy DB</code> from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> and implement a Connected Messageâ€”Have the client send a Ping and respond with Connected</p></li><li style="list-style-type: disc"><p>Returning from the previous chapter, Instead of Ping and Connected messages, use Akka's Identify message using the preStart hook to determine if the remote actor is available. (See documentation.) Use this to acquire an ActorRef for a remote actor and use this instead of the ActorSelection.</p></li><li style="list-style-type: disc"><p>Continuing to use Identity and an ActorRef, implement a connected state in the client using hotswap.</p></li><li style="list-style-type: disc"><p>Every 2 seconds with the Identity message. Have the client restart if it misses 2 response</p></li><li style="list-style-type: disc"><p>Instead of sending a ping and receiving a response, is it possible to have the client subscribe to a heartbeat message that is sent every two seconds?</p></li><li style="list-style-type: disc"><p>Update the client to bunch messages using FSM. Do you think hotswap or FSM is more appropriate for this?</p></li><li style="list-style-type: disc"><p>Implement supervision to have the actor log any restarts it encounters (such as two missed heartbeats)</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Summary</h2></div></div><hr /></div><p>We looked at the Fallacies of Distributed Computing to better understand some of the characteristics that the network has and which will affect our application's reliability and performance.</p><p>Because our actors can encounter problemsâ€”both in the network and in their internal stateâ€”we examined how actors move through their lifecycle. We looked at how supervision can be used to build responses to failures and to customize how actors respond when starting, stopping, and restarting.</p><p>We also covered different ways in which an actor's behavior can change depending on its state. We covered how Hotswap and FSM can improve the readability of an actor that does have behavior that changes through state instead of simply using conditionals.</p><p>At this point, we can build resilient applications that react to errors and can clearly describe behavior in response to state.</p><p>In the next chapter, we will cover scaling up an application to better utilize the hardware it is running on.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch05"></a>ChapterÂ 5.Â Scaling Up</h2></div></div></div><p>Scaling up refers to making better use of hardware from a single machine. Akka can help us scale up more easily to make better use of our hardware, with very little effort. In fact, generally, to efficiently utilize your hardware, you will not need to do much, but it's important to understand a few basic techniques.</p><p>We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The emergence of multicore computing</p></li><li style="list-style-type: disc"><p>Utilizing multiple cores with futures</p></li><li style="list-style-type: disc"><p>Utilizing multiple cores with routers and actors</p></li><li style="list-style-type: disc"><p>Utilizing dispatchers to isolate performance risk</p></li></ul></div><p>Note that while this chapter does talk about using Akka for distribution problems, it will only cover a single application running on a single node and will not look at how to utilize multiple servers to scale your application. However, the next chapter will cover scaling out, utilizing multiple machines, and will look at how to build clusters of applications that communicate over the network using Akka.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec32"></a>Moore's law</h2></div></div><hr /></div><p>Moore's law <a id="id357" class="indexterm"></a>states that, every 18 months or so, transistors per square inch in integrated circuits double. This used to be correlated to CPU clock speed doubling every couple of years, but CPU clock speeds are no longer increasing at the same rate that they once were.</p><p>What we see today is that processors in environmentsâ€”for example, servers, computers, and phonesâ€”are hitting the market with more and more CPUs and cores. My phone has 6 cores, my workstation at work has 12 virtual cores via a Xeon CPU, and the VMs in AWS can have up to 40 virtual cores. These changes in consumer and server hardware mean that we need to design our software differentlyâ€”if your application runs on a single thread on an 8 core PC, you'll only be able to utilize one core effectively. Our applications need to be able to utilize these resourcesâ€”if we're running an application on a single thread, then we're only able to use one of those cores. Today, as software engineers, we need to write concurrent software to be able to take advantage of the hardware our software runs on.</p><p>The term "scaling up" means that, when we provide additional resources to a single systemâ€”such as<a id="id358" class="indexterm"></a> additional CPU cores or memoryâ€”the application will utilize them. If we have a single server and we give an application more resources, it should be able to utilize those resources running. In cloud services, if we need it to serve more traffic, we might replace the instance with a larger one with more cores. Assuming our application can utilize the resources, we have scaled up our application. (Conversely, when we say scaling out, we mean that we are adding resources to a system by adding more machines or VMs instead of just using bigger machines or bigger VMs.)</p><p>Given that most environments we deploy our code to today are going to have several virtual CPUs available, we need to change how we think about writing code to utilize the hardware effectively. It is your duty as a modern engineer to be able to tackle these problems safely and effectively. Given that we are getting more cores instead of more processing speed on a core, we need to design our applications to utilize multiple cores by handling multiple streams of work in parallel.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec33"></a>Multicore architecture as a distribution problem</h2></div></div><hr /></div><p>Utilizing multiple cores <a id="id359" class="indexterm"></a>in an application can seem like a difficult problem to approach. Traditional thread-based abstractions were very difficult to get right. When threads share access to mutable state, it's easy to build in race conditions that don't present themselves until you've deployed and are running your app at scale. Tim Sweeny has said before that, in a concurrent world, imperative is the wrong default. Fortunately, for us today we have different abstractions that we can use to utilize all of those cores available to us, and they're much easier to build correct concurrent software on than thread abstractions using synchronization and locking.</p><p>It turns out that utilizing multicore architecture can be looked at as a distribution problemâ€”we want to take some work and run it somewhere else, either on another CPU or another machine. When working with actors in Akka, the differences between scaling up and scaling out can begin to blur. We can start to ignore the differences between another machine or another core, and instead only think about the problem as sending a message to an actor. We want to send some work somewhere else to be done, and then, at some point in time, we'll receive a response to the request. Looking at scaling up is a great way to begin to understand how you might eventually scale outâ€”if you can do work across 8 cores with Actors, doing work across 8 machines is a small step from there.</p><p>The focus of this chapter is on specifically utilizing multiple cores rather than utilizing multiple machines, so we'll highlight the details in that context. The primary mechanism for utilizing multiple cores is parallelismâ€”our applications must do multiple things at the same time. Essentially, we want to separate work into discrete pieces and run the work in different places at the same time to utilize all of the cores that are available.</p><p>There are two<a id="id360" class="indexterm"></a> abstractions in Akka that you can use to do work in parallel across cores: Futures and Actors. We'll look at both of these abstractions in relation to doing heavy computation in parallel at this point. We will still look at how we can better utilize our hardware using both of these abstractions. We'll also talk about when one might be better to use than the other in this context.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec34"></a>Choosing Futures or Actors for concurrency</h2></div></div><hr /></div><p>Both Actors and Futures<a id="id361" class="indexterm"></a> can be used for concurrency, but which is <a id="id362" class="indexterm"></a>the correct abstraction to use?</p><p>After working with<a id="id363" class="indexterm"></a> Akka a bit, in the beginning of your<a id="id364" class="indexterm"></a> journey toward creating highly scalable event-driven systems, you may likely start using Actors everywhere in your design. You may think that the correct way to approach every problem is to use an actor. As the old proverb goes, if you have a hammer, everything can start to look like a nail.</p><p>It turns out that deciding whether to use Actors or Futures is actually not a simple question to answer. There is a common rule of thumb I've heard people citingâ€”"Futures for Concurrency, Actors for State."</p><p>That is to say that, if you have any state, then you might immediately think of using actors, and if you have no state and only want concurrency, then you can look at futures. While that's a good rule of thumb, it's actually an oversimplification of the problem as there are several use cases where actors can give you designs that are easier to debug and maintain. You'll often want to evaluate both for your use case and consider the design simplicity.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec35"></a>Doing work in parallel</h2></div></div><hr /></div><p>To demonstrate how we can do work in parallel with <a id="id365" class="indexterm"></a>Actors and Futures, we'll<a id="id366" class="indexterm"></a> start with a simple use case. We need to do some long-running work and we need to do it many times. Earlier in this book, we looked at an example of parsing article body text from a web page. We'll revisit this example using the <code class="literal">BoilerPipe</code> library to parse the contents of a page. The article parsing logic might look like the following:</p><div class="informalexample"><pre class="programlisting">public class ArticleParser { public static Try&lt;String&gt; apply(String html) { return Try.ofFailable( () -&gt; de.l3s.boilerpipe.extractors.ArticleExtractor.INSTANCE.getText(html)
        );
    }
}

object ArticleParser { 
def apply(html: String) : String = de.l3s.boilerpipe.extractors.ArticleExtractor.INSTANCE.getText(html) 
}</pre></div><p>This gives us <a id="id367" class="indexterm"></a>some work that we can do in parallel to examine how we can scale up to better use a multicore environment using futures and actors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec59"></a>Doing work In parallel with futures</h3></div></div></div><p>Futures are highly <a id="id368" class="indexterm"></a>composable and can be a good fit for parallel processing. Using future function composition techniques examined in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span>, we know that we can do asynchronous work safely and with fairly minimal effort. If we have a collection of items we need to process, we can do it in parallel with futures in very little code. </p><p>In the following, we have a List of Strings called <code class="literal">articleList</code> containing web pages from articles and an HTML page of an article. We want to process the list with Futures for higher concurrency to better utilize system resources. We'll look at how we can do this using Java first:</p><div class="informalexample"><pre class="programlisting">        List&lt;ComposableFuture&lt;String&gt;&gt; futures = articleList
                .stream()
                .map(article -&gt;CompletableFuture.supplyAsync(() -&gt;ArticleParser.apply(article))) .collect(Collectors.toList());
        Future&lt;List&lt;String&gt;&gt;articlesFuture = com.jasongoodwin.monads.Futures.sequence(futures).get();</pre></div><p>Note that we'll use the sequence function from the better-java <code class="literal">monads</code> library to help us work with multiple futuresâ€”it contains a sequence method that will turn a list of futures into a single future containing a list of the results. Include it into your project by adding the following to <code class="literal">build.sbt</code>:</p><div class="informalexample"><pre class="programlisting">"com.jason-goodwin" % "better-monads" % "0.2.1"</pre></div><p>In the Java example, we have a list of articles, which we map into futures that will contain the completed article body. This kicks off the processing of all of the articles in the <code class="literal">articleList</code> in parallel. We use sequence to turn the List of Futures into a Future containing a list of the articles. Using Scala is similar, if more terse. Scala has its own sequence method for transforming the list of futures.</p><div class="informalexample"><pre class="programlisting">  import scala.concurrent.ExecutionContext.Implicits.global
val futures = articleList.map(artlice =&gt; { Future(ArticleParser.apply(article)) })
val articlesFuture: Future[List[String]] = 
Future.sequence(futures)</pre></div><p>We take the list of <a id="id369" class="indexterm"></a>articles and execute the parsing work in parallel by running it in futures. We take the List of Futures and then sequence them into a more usable single future containing the list of our articles. These examples show how simple it is to parallelize with futures.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec60"></a>Doing work in parallel with Actors</h3></div></div></div><p>We've looked at using <a id="id370" class="indexterm"></a>futures to do work in parallel. Now we'll look at how we can similarly do work in parallel using actors. Note that, for our example case, the code is very succinct using futures. Depending on your use case, using actors specifically for concurrency can result in more complicated code. We'll look at an equivalent example using actors to do the work.</p><p>Using the <code class="literal">ArticleParser</code> static apply method from the Future's example, we'll first create an actor that will do the work.</p><p>The following is the Java actor and message:</p><div class="informalexample"><pre class="programlisting">public class ParseArticle { public final String htmlBody; public ParseArticle(String url) { this.htmlBody = url;
    }
}
public class ArticleParseActor extends AbstractActor { private ArticleParseActor() { receive(ReceiveBuilder. match(ParseArticle.class, x -&gt;{ sender().tell(ArticleParser.apply(x.htmlBody), self());
                }
        ).
        build());
  }
}</pre></div><p>The following is the Scala actor and message:</p><div class="informalexample"><pre class="programlisting">case class ParseArticle(htmlString: String)
class ArticleParseActor extends Actor{ override def receive: Receive = { case ParseArticle(htmlString) =&gt; val body: String = ArticleParser(htmlString) sender() ! body }
}</pre></div><p>To do the work in<a id="id371" class="indexterm"></a> parallel, we need to introduce a "Router" to distribute the work across several actors; we will look at this  next.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec57"></a>Introducing Routers</h4></div></div></div><p>In Akka, a Router<a id="id372" class="indexterm"></a> is a load-balancing/routing abstraction. When a Router is created, it is given a group of actors or is asked to create a pool of actors.</p><p>Note the use of the words group and pool. While creating routers with actors, it's important to understand that there are two ways in which the collection of actors behind the router can be created. Either the router can create the actors (a Pool) or the router can be provided with the list of actors (a Group).</p><p>After the creation of the router, if the router receives a message, then it will pass that message on to one or more of the actors in its Group/Pool. There are different strategies that determine the order in which the Router selects an actor to forward its next message to.</p><p>In our case, all of our actors are local and we want a router with several actors to allow the CPU's cores to do more of our work in parallel. Routers can also be used to distribute load across clusters of servers if the actors are remote.</p><div class="mediaobject"><img src="graphics/B04006_05_01.jpg" /></div><p>For our use case <a id="id373" class="indexterm"></a>with local actors, we can create the router as a pool, having the router produce all of the actors for us. It's simple to use routers in this use caseâ€”we instantiate an actor as usual, and then call the <code class="literal">withRouter</code> method, passing in the routing strategy and how many actors we want. This is the same for either Scala or Java:</p><div class="informalexample"><pre class="programlisting">ActorRef workerRouter = system.actorOf( Props.create(ArticleParseActor.class).
withRouter(new RoundRobinPool(8)));
val workerRouter: ActorRef = system.actorOf( Props.create(classOf[ArticleParseActor]).
withRouter(new RoundRobinPool(8)))</pre></div><p>If we had a list of actors that we wanted to make a router from, then we would create the Router from a group, providing a list of the actor's paths:</p><div class="informalexample"><pre class="programlisting">ActorRef router = system.actorOf(new RoundRobinGroup(actors.map(actor -&gt;actor.path()).props()); val router = system.actorOf(new RoundRobinGroup(actors.map(actor =&gt;actor.path).props())</pre></div><p>At this point, we have the router and actors we need to be able to distribute the load across cores. Taking our list of messages and asking the router to process each of the messages will process them in parallel. We'll continue to look at the more advanced features of routers now to <a id="id374" class="indexterm"></a>understand how they work in greater detail.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec58"></a>Routing logic</h4></div></div></div><p>You'll note that we used <code class="literal">RoundRobinPool</code>/<code class="literal">RoundRobinGroup</code>â€”this covers the order in which the messages <a id="id375" class="indexterm"></a>will be delivered to the routers. There are several routing strategies that Akka comes bundled withâ€”we'll look at a few here. <code class="literal">RoundRobin</code> or <code class="literal">Random</code> are fine choices for general purpose.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Routing Strategies</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Functioning</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>Round Robin</p>
</td><td style="" align="left" valign="top">
<p>Sends a <a id="id376" class="indexterm"></a>message to each node in the <a id="id377" class="indexterm"></a>Pool/Group in order and then starts over. Randomâ€”sends messages in a random order.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Smallest Mailbox</p>
</td><td style="" align="left" valign="top">
<p>Sends<a id="id378" class="indexterm"></a> messages to the actor with the fewest messages. Remote actors have unknown mailbox sizes, so they<a id="id379" class="indexterm"></a> are assumed to have messages queuedâ€”free local Actors will be addressed first.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Scatter Gather</p>
</td><td style="" align="left" valign="top">
<p>Sends the <a id="id380" class="indexterm"></a>message to all Actors in the<a id="id381" class="indexterm"></a> Group/Pool and uses the first response received, dropping any other responses received. If you need to ensure you get a response, and you want to get it as fast as possible, you can use scatter/gather.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Tail Chopping</p>
</td><td style="" align="left" valign="top">
<p>Similar to <a id="id382" class="indexterm"></a>Scatter/Gather but, instead of sending <a id="id383" class="indexterm"></a>a message to all actors in the group/pool at once, the router waits for a small period of time for each subsequent message. Has similar benefits to scatter/gather, but can potentially reduce the load in comparison.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Consistent Hashing</p>
</td><td style="" align="left" valign="top">
<p>A key is <a id="id384" class="indexterm"></a>provided to the router, which is <a id="id385" class="indexterm"></a>then hashed. The hashed key is used to determine which node to send the data to. Hashing is used when assigning a particular "slice" of data to a particular destination. It's used in working with clusters of servers. We will look at consistent hashing strategies more in the next chapter.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>BalancingPool</p>
</td><td style="" align="left" valign="top">
<p>This is a <a id="id386" class="indexterm"></a>bit of a unique router. <code class="literal">BalancingPool</code> can only be used for local actors. The actors share <a id="id387" class="indexterm"></a>a single mailbox and take work from it in a work-stealing manner. This helps to ensure that all actors stay busy. For local clustering, this will often be the preferred routing mechanism. </p>
</td></tr></tbody></table></div><p>You can also roll your own Routing Logic, but it's unlikely you'll need to do so.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec59"></a>Sending Messages to All Actors in a Router Group/Pool</h4></div></div></div><p>Regardless of the type of <a id="id388" class="indexterm"></a>Group or Pool you use, you can always send a message to all actors with the broadcast message. For example, if your actors are connecting to a remote database and you need to change the database used in a live system during a failover, you could update all the actors in the pool/group with a broadcast message:</p><div class="informalexample"><pre class="programlisting">router.tell(new akka.routing.Broadcast(msg));
router !akka.routing.Broadcast(msg)</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec60"></a>Supervising the Routees in a Router Pool</h4></div></div></div><p>If you're creating a Pool, where the<a id="id389" class="indexterm"></a> Router creates the actors, the routees will be<a id="id390" class="indexterm"></a> created as children of the router. While creating the router, you can provide a custom supervision strategy for the router to use.</p><p>When building a router, there is a <code class="literal">withSupervisorStrategy</code> method that you call to create the Pool with your strategy. The Scala and Java API are the same. Assuming we have a SupervisorStrategy instantiated called "strategy", we do the following when creating our router:</p><div class="informalexample"><pre class="programlisting">ActorRefworkerRouter = system.actorOf(Props.create(ArticleParseActor.class). withRouter(new RoundRobinPool(8). withSupervisorStrategy(strategy)));

valworkerRouter: ActorRef = system.actorOf( Props.create(classOf[ArticleParseActor]). withRouter(new RoundRobinPool(8). withSupervisorStrategy(strategy)))</pre></div><p>As Groups are created from pre-existing actors, there is no way to supervise a group using a Router.</p><p>Apart from the primary use case of supervising a pool of actors, there is another use case for using routers with a supervision strategy. If you have a top-level actor (created with an <code class="literal">ActorSystem's actorOf</code> method), then it will be supervised by the Gaurdian Actor. If you need to have a custom supervision strategy, you can create an actor to supervise that actor or you could simply create a router and pass it your custom <code class="literal">SupervisorStrategy</code> to have the router act as the supervisor. As you don't need to define any actor behavior, this is a brief and simple approach to giving a top-level actor custom supervision.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec36"></a>Working with Dispatchers</h2></div></div><hr /></div><p>As we start to try to improve <a id="id391" class="indexterm"></a>throughput and response times of our applications, we need to understand all bottlenecks and where time is being spent in the request/response cycle. Once we apply load to an application, the threads that are available will be trying to serve all requestsâ€”understanding how those resources are used will help you improve how much throughput a service can handle with minimum latency.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec61"></a>Dispatchers explained</h3></div></div></div><p>A dispatcher decouples<a id="id392" class="indexterm"></a> a task from how and where the task will be run. Dispatchers will generally contain some threads and will handle scheduling and running events such as actor message handling and future events in those threads. Dispatchers are really what make Akka tickâ€”they are the mechanism that gets the work done.</p><p>Any time an actor or a future does work, the resources allocated by an executor/dispatcher are what does that work.</p><div class="mediaobject"><img src="graphics/B04006_05_02.jpg" /></div><p>Dispatchers control assigning work to actors. They also can assign resources to handle callbacks on futures. You'll note that future APIs accept Executors/ExecutionContexts as parameters. Because Akka dispatchers extend these APIs, the dispatchers can pull double duty.</p><p>In Akka, dispatchers implement the <code class="literal">scala.concurrent.ExecutionContextExecutor</code> interface, which, in turn, extends <code class="literal">java.util.concurrent.Executor</code> and <code class="literal">scala.concurrent.ExecutionContext</code>. Executors can be passed to Java futures and ExecutionContexts can be passed to Scala futures.</p><p>For use with futures, dispatchers can be obtained from an <code class="literal">ActorSystem</code> reference (<code class="literal">ActorSystem.dispatcher</code>). To get a dispatcher defined in configuration, you can look them up from the actor system by ID:</p><div class="informalexample"><pre class="programlisting">system.dispatcher //actor system's dispatcher
system.dispatchers.lookup("my-dispatcher"); //custom dispatcher</pre></div><p>Because we can<a id="id393" class="indexterm"></a> create and obtain these executor-backed dispatchers, we can use them to define thread-pools/fork-join pools to separate, isolate, and run our work in. We'll look at when and why we would want to do this shortly. While you don't need to understand all of the details of the executors to use them effectively, we will visit them in some detail first.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec62"></a>Executors</h3></div></div></div><p>Dispatchers are backed by <a id="id394" class="indexterm"></a>executors, so before we look more closely at dispatchers, we'll cover the two main executor typesâ€”<code class="literal">ForkJoinPool</code> and <code class="literal">ThreadPool</code>.</p><p>The thread-pool executor has a queue of work which is assigned to threads. The threads take work as they become free. Threadpools offer a greater efficiency over creating and destroying threads as they allow reuse of threads that are an expensive resource to create and destroy.</p><p>The "fork-join-pool" executor uses a divide-and-conquer algorithm to recursively split tasks into smaller pieces and then assigns the work to be run on different threads. The results are then combined. While the tasks we are submitting may not be recursively split as <code class="literal">ForkJoinTasks</code>, the fork-join-pool executor has a work-stealing algorithm that allows an idle thread to "steal" work scheduled for another thread. Work tends to not distribute and complete evenly, so work stealing will more efficiently utilize hardware.</p><p>Fork-join will almost always perform better than the thread-pool executorâ€”it should be your default choice.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec63"></a>Creating Dispatchers</h3></div></div></div><p>To define a <a id="id395" class="indexterm"></a>dispatcher in <code class="literal">application.conf</code>, we need to specify the dispatcher type and the executor. We can also specify any configuration-specific details of the executor such as how many threads to use or how many messages to process for each actor before moving on:</p><div class="informalexample"><pre class="programlisting">my-dispatcher { type=Dispatcher executor = "fork-join-executor" fork-join-executor { parallelism-min = 2 #Minimum threads parallelism-factor = 2.0 #Maximum threads per core parallelism-max = 10 #Maximum total threads } throughput = 100 #Max messages to process in an actor before moving on.
}</pre></div><p>There are four types of dispatchers that can be used which describe how threads are shared among actors.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Dispatchers</strong></span>: Default<a id="id396" class="indexterm"></a> dispatcher type. The defined executor will be used to process messages in actors. This should provide optimal performance in most cases.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>PinnedDispatcher</strong></span>: This gives<a id="id397" class="indexterm"></a> each actor its own dedicated thread. This executor creates a thread-pool executor for each actor with each executor having exactly one thread. This may sound like a good idea if you want to ensure that an actor always responds immediately, but there are very few use cases where a pinned dispatcher will perform better than sharing resources. You can try this if a single actor has to do a lot of important work; otherwise, pass on this one.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>CallingThreadDispatcher</strong></span>: This <a id="id398" class="indexterm"></a>dispatcher is unique in that it has no executor. Instead, the work is run on the calling thread. Its primary use is in testing, especially in debugging. Because the calling thread does the work, there is a clear stack trace that shows the complete context of the executed method that is useful for understanding exceptions. A lock is still obtained in the actor, so only one thread can execute code in the actor at once, but multiple threads sending messages to an actor will cause all but one thread to wait for a lock. The <code class="literal">CallingThreadDispatcher</code> is how the <code class="literal">TestActorRef </code>is able to do work synchronously in tests as demonstrated earlier in this book.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>BalancingDispatcher</strong></span>: You <a id="id399" class="indexterm"></a>will see the <code class="literal">BalancingDispatcher</code> referenced in some Akka documentationâ€”its direct use has been deprecated and replaced by the <code class="literal">BalancingPool</code> router mentioned earlier. <code class="literal">BalancingDispatcher</code> is still used in Akka, but it should only be used indirectly by a router. We will look at the <code class="literal">BalancingPool</code> in action in the Dispatcher section. The <code class="literal">BalancingDispatcher</code> is unique in that it shares a mailbox with all actors in the pool and optimally creates one thread per actor in the pool. The <code class="literal">BalancingDispatcher</code> Actors pull messages from the mailbox so that there is never a queue in one actor while another actor is idle. This is a variation on work stealing as all the actors pull from a shared mailboxâ€”it has a similar beneficial effect on performance.</p></li></ul></div><p>Actors can be created <a id="id400" class="indexterm"></a>with dispatchers that have been configured by building Props referencing the dispatcher name configured in <code class="literal">application.conf</code>:</p><div class="informalexample"><pre class="programlisting">system.actorOf(Props[MyActor].withDispatcher("my-pinned-dispatcher"))</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec64"></a>Deciding Which Dispatcher to use where</h3></div></div></div><p>We've now covered how to create dispatchers <a id="id401" class="indexterm"></a>and executors, but we don't really have a clear picture of what to do with them. The purpose of this chapter is to cover how to best utilize our hardware, so we're now going to look at how we can use dispatchers to produce an application that is more responsive to our users by being more resilient to potential performance problems.</p><p>We'll skip back to our example of an application that extracts article bodies from web pages and caches them, and that also serves cached articles to a user. For our example, let's assume that the user profiles are retrieved from an RDBMS requiring thread-blocking JDBC calls. This introduces blocking of our limited threads to aid in highlighting what we're trying to accomplish.</p><p>The first step to scaling up is to understand which use cases are most important to serve immediately and where there may be contention for the resources needed to serve those important requests. If we use only the default dispatcher, and 1,000 requests come in consisting of 500 blocking (for example, JDBC) and 500 non-blocking operations, we don't want the blocking operations to tie up all the threads needed to serve the important requests.</p><div class="mediaobject"><img src="graphics/B04006_05_03.jpg" /></div><p>In the preceding<a id="id402" class="indexterm"></a> diagram, we simplify the scale of this example to show 8 threads being used by longer running tasks such as blocking IO and heavier processing. The diagram shows the impact that it has on other requests that are waiting to be processed because all of the threads available are tied up. The other requests cannot begin processing until those resources are freed. The waiting tasks might just need to do short-lived cache reads, but they will have to wait in line for resources to become free to do the work.</p><p>This highlights that having one pool of resources distributed without order can allow riskier areas of the application to tie up resources that we need to give to our important primary use cases.</p><p>We can do better than this by isolating the resources in the areas of risk from competing with those that serve the important tasks. If we create new dispatchers and assign any long-running or blocking work to those dispatchers, we can ensure that the rest of our application remains responsive. We want to separate all of the heavy and long-running work into independent dispatchers to ensure that resources are available for other tasks in adverse situations.</p><p>By doing this, we can isolate the delays to those areas of the application. If MySQL goes on the fritz and starts taking 30 seconds to respond, at least other paths through the application will remain responsive.</p><p>This approach requires us to first examine our application's performance, understanding where the application can block and tie up resources. We need to categorize the work done in the application.</p><p>If we look at our example case, we might categorize work it into the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Article Parsing</strong></span>: Longer running CPU-intensive tasks (10% of requests)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>JDBC Profile Reads from MySQL</strong></span>: Longer running thread-blocking IO (10% of requests)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Article Retrieval</strong></span>: Simple non-blocking requests to get articles from remote in-memory datastore (80% of requests)</p></li></ul></div><p>Once we have a <a id="id403" class="indexterm"></a>picture of the types of work that the application is doing, then we want to understand if there are performance risks thereâ€”is it possible that something could cause resource utilization to spiral out of control, affecting the rest of the application? Look at both thread blocking and CPU-intensive work and evaluate if it's possible for them to cause some resource starvation in other important areas of the application:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Article Parsing</strong></span>: If someone submits several large books that have been posted online, all threads could be used up in very intensive long-running work. It is of moderate risk and can be mitigated by limiting the size of submissions.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>JDBC Profile Reads</strong></span>: If the database starts taking 30 seconds to respond, all threads could be used up waiting. It is of higher risk.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Article Retrieval</strong></span>: Article retrieval does not block and does no heavy work, so it is low-risk. It is also important to serve this traffic fast as it will account for most of the traffic.</p></li></ul></div><p>Now that we have identified where higher risk activities might be, we want to isolate any portion of work that has risk into its own dispatcher so that if/when those conditions occur, our application will not be negatively affected in other important areas. This is another example of bulkheading to isolate the impact of failure. Just a reminder, never make assumptions and always measure how changes affect your system's performance!</p><p>Now that we have categorized our application's work and risk front, we can take any high risk areas, and isolate them into their own dispatcher. The approach we will use will look like the following:</p><div class="mediaobject"><img src="graphics/B04006_05_04.jpg" /></div><p>Non-Blocking Article Reads and Akka will be okay to run in the default dispatcher at this point. If we discover other risks, then we can further separate the work later, but this is a good starting point.</p><p>Blocking IOâ€”for <a id="id404" class="indexterm"></a>example, JDBC Profile Reads for profile informationâ€”will get its own dispatcher with 50 or 100 threadsâ€”work that blocks and waits for IO (that is from a database with JDBC drivers) should be isolated from asynchronous threadpools because the work will halt all other operations in the application if all of the threads get tied up waiting for IO. This is probably the most critical of the changesâ€”we should always try to place blocking IO outside of Akka's dispatcher.</p><p>Article Parsing will get its own dispatcher with a small number of threads. We're using the dispatcher for isolation here incase very big jobs are submitted. If big jobs are submitted, then the work will halt any other work in the queue; thus, to protect against those exceptional cases, we can isolate the work. In this case, we can also use the <code class="literal">BalancingPool</code>/<code class="literal">BalancingDispatcher</code> to distribute work across a pool of article parsing actors. In addition to giving isolation, using the <code class="literal">BalancingPool</code> also gives a potential improvement in resource utilization by the <code class="literal">BalancingPool</code> work-stealing nature.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec65"></a>Default Dispatcher</h3></div></div></div><p>There are a couple of approaches that we can take with the <a id="id405" class="indexterm"></a>default dispatcher. We can either separate all work out, leaving it only for Akka to use, or we can check that only async work gets done in the default dispatcher and move any higher-risk work out. Either way, we should never block in the default dispatcher and have to be a bit careful with the work that is run in it to prevent resource starvation.</p><p>You don't need to do anything to create or use the default dispatcher/threadpool. We're done. If needed, we can configure the default dispatcher by defining it in the <code class="literal">application.conf</code> file on the classpath similar to the following:</p><div class="informalexample"><pre class="programlisting">akka { actor { default-dispatcher { # Min number of threads to cap factor-based parallelism number to parallelism-min = 8
        # The parallelism factor is used to determine thread pool size using the
        # following formula: ceil(available processors * factor). Resulting size
        # is then bounded by the parallelism-min and parallelism-max values. parallelism-factor = 3.0
        # Max number of threads to cap factor-based parallelism number to parallelism-max = 64
        # Throughput for default Dispatcher, set to 1 for as fair as possible
        throughput = 10
    }
  }
}</pre></div><p>You can override default configuration values by defining any values again in your own <code class="literal">application.conf</code> file:</p><div class="informalexample"><pre class="programlisting">akka { actor { default-dispatcher { # Throughput for default Dispatcher, set to 1 for as fair as possible throughput = 1
    }
  }
}</pre></div><p>By default, all work done by Actors will execute in this dispatcher. If you need to get the <code class="literal">ExecutionContext</code> to create futures in, you can access the default threadpool through your ActorSystem, and then supply it to futures:</p><div class="informalexample"><pre class="programlisting">ActorSystem system = ActorSystem.create();
CompletableFuture.runAsync(() -&gt;System.out.println("run in ec"), system.dispatcher());
val system = ActorSystem()
implicit val ec = system.dispatcher
val future = Future(() =&gt;println("run in ec"))</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Tip</h3><p>Note: Be careful about the work you do in futures in the default dispatcher as it will take time away from the actors themselves. We'll look at how to remedy this in the next section.</p></div><p>In Scala, classes <a id="id406" class="indexterm"></a>extending Actor already have the dispatcher as an implicit val, so you do not have to specify it if working with futures in actors. There are few cases where you want to have futures in your actorsâ€”remember that we should prefer <code class="literal">tell</code> over <code class="literal">ask</code> so you might want to evaluate your approaches if you're finding you're working with Futures a lot inside your actors.</p><p>That covers the default dispatcher and how to use it and tune it. Now, we'll look at how to add and use additional executors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec66"></a>Blocking IO dispatcher use with futures</h3></div></div></div><p>If you have any<a id="id407" class="indexterm"></a> blocking work, you want to get it out<a id="id408" class="indexterm"></a> of the main dispatcher so that actors can stay lively if your app gets saturated with blocking work.</p><p>Consider this use case: a user wants to retrieve a user profile from an RDBMS to see who posted an article. We might have a service interface that looks like the following:</p><div class="informalexample"><pre class="programlisting">import org.springframework.data.repository.CrudRepository;
import java.util.List;
public interface UserProfileRepository extends CrudRepository&lt;UserProfile, Long&gt; { List&lt;UserProfile&gt;findById(Long id); }</pre></div><p>For this example, we'll use Spring Data to access a database via JDBC. Spring Data is an arbitrary choice here for use in the example for a blocking APIâ€”it lets us demonstrate blocking IO with minimal code, but the approach could be for anything that blocks threads. This interface is actually all the code that you need to query for JPA-annotated <code class="literal">UserProfiles</code>â€”Spring supplies the implementations for you by analyzing the method name.</p><p>For our example, we have a method called <code class="literal">findById</code> that accepts an ID and blocks the calling thread while waiting for IO to come back from the database.</p><p>If we call this method in an actor, we're tying up a thread in our default dispatcher, not to mention halting the actor from doing any other work:</p><div class="informalexample"><pre class="programlisting">  //Java sender().tell(userProfileRepository.findById(id), self());
  //Scala
  sender() ! userProfileRepository.findById(id)</pre></div><p>Again, if we have <a id="id409" class="indexterm"></a>several requests that come in and hit that block<a id="id410" class="indexterm"></a> of code (maybe in a pool of actors), all the threads can be stuck waiting so that no other work is able to move forward until resources are freed.</p><p>The simplest solution in these cases is to run the blocking operations in another set of threads in a different dispatcher.</p><p>First, in our <code class="literal">application.conf</code> file we'll create a dispatcher with a bigger pool of resources:</p><div class="informalexample"><pre class="programlisting">blocking-io-dispatcher { type = Dispatcher executor = "fork-join-executor" fork-join-executor { parallelism-factor = 50.0
    parallelism-min = 10
    parallelism-max = 100
  }
}</pre></div><p>That will allow up to 50 threads per core to be created with a minimum of 10 and a maximum of 100 threads. Hundred threads is a large upper limit for a properly factored and indexed database.</p><p>For blocking IO to databases, if you have queries that take a long time to run, you should examine the run plans and fix your tables and queries instead of adding more threads. Each thread has a memory overhead, so don't arbitrarily add more threads. Measure, change, and repeat until optimal, adjusting the threadpool only after your queries, tables, and indices are optimized.</p><p>Now that we have a dispatcher configured, we need to gain access to it to be able to run the blocking queries in it. We can get a reference to a dispatcher by looking up the dispatcher from the actor system. In an actor, we would call the following:</p><div class="informalexample"><pre class="programlisting">//Java
val ec: ExecutionContext = context.system.dispatchers.lookup("blocking-io-dispatcher")
//Scala
Executor ex = context().system().dispatchers().lookup("blocking-io-dispatcher");</pre></div><p>Once we have the dispatcher references, we can use them with the future APIs to run the work there:</p><div class="informalexample"><pre class="programlisting">//Java
CompletableFuture&lt;UserProfile&gt; future = CompletableFuture.supplyAsync( () -&gt;userProfileRepository.findById(id) , ex);
//Scala
val future: Future[UserProfile] = Future{ userProfileRepository.findById(id)
  }(ec)</pre></div><p>In each of the<a id="id411" class="indexterm"></a> Scala and Java future APIs, all that we <a id="id412" class="indexterm"></a>have to do is supply the dispatcher reference as the second parameter of the future and the dispatcher will take care of the rest. Once the result is available, the future will complete.</p><p>Having the future reference, we can now use it as we normally would in an actorâ€”likely using <code class="literal">patterns.Pipe</code> to send the result to another actor asynchronously.</p><p>This use of futures is an important techniqueâ€”blocking IO will very quickly ruin your application's performance. I would recommend that you try to use non-blocking drivers instead of doing this, but if you need to use blocking drivers with chosen technologies, then this is a reasonable approach.</p><p>In the same manner as with blocking IO, any heavy computation done with results from futures can also be moved to another dispatcher to help actors stay lively.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec67"></a>Article parsing dispatcher</h3></div></div></div><p>For our last example, we'll <a id="id413" class="indexterm"></a>look at how we can assign actors to another dispatcher. This is different than taking only a piece of a task and running it in another dispatcher, like we saw in the JDBC example, because we're actually assigning actors completely to another dispatcher instead of just some work over there. This is well suited for any actors that do heavier processing.</p><p>We're going to look at two options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Defining a Dispatcher to use with an actor pool</p></li><li style="list-style-type: disc"><p>Using the <code class="literal">BalancingPool</code> router that uses <code class="literal">BalancingDispatcher</code>
</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec61"></a>Using a configured dispatcher with Actors</h4></div></div></div><p>Here we'll look at <a id="id414" class="indexterm"></a>configuring a dispatcher in our <code class="literal">application.conf</code>, and then assigning actors to that dispatcher when we create them. This<a id="id415" class="indexterm"></a> is fairly straightforward and does not vary much from many of the other activities we've looked at so far.</p><p>First, we'll create another dispatcher in our <code class="literal">application.conf</code> for the article parsing. We'll assign a smaller number of threads this time:</p><div class="informalexample"><pre class="programlisting">article-parsing-dispatcher { # Dispatcher is the name of the event-based dispatcher
  type = Dispatcher
  # What kind of ExecutionService to use
  executor = "fork-join-executor"
  # Configuration for the fork join pool
  fork-join-executor { # Min number of threads to cap factor-based parallelism number to parallelism-min = 2
    # Parallelism (threads) ... ceil(available processors * factor) parallelism-factor = 2.0 # Max number of threads to cap factor-based parallelism number to parallelism-max = 8 }
  throughput = 50
}</pre></div><p>Now, to create actors assigned to the configured dispatcher, we simply call the <code class="literal">withDispatcher</code> method while creating the Props. We'll use a range to create a list of actors, and then place them in the dispatcher:</p><div class="informalexample"><pre class="programlisting">//Java
        List&lt;ActorRef&gt;routees = Arrays.asList(1,2,3,4,5,6,7,8).stream().map(x -&gt; system.actorOf(Props.create(ArticleParseActor.class). withDispatcher("article-parsing-dispatcher"))
        ).collect(Collectors.toList());  
//Scala
val actors: List[ActorRef] = (0 to 7).map(x =&gt; { system.actorOf(Props(classOf[ArticleParseActor]). withDispatcher("article-parsing-dispatcher")) }).toList</pre></div><p>Now, we can do anything we like with actors created this way. For example, we can produce a router to use the actors so that we can easily do work in parallel with them:</p><div class="informalexample"><pre class="programlisting">//Java
Iterable&lt;String&gt;routeeAddresses = routees. stream().
                map(x -&gt;x.path().toStringWithoutAddress()).
                collect(Collectors.toList());
ActorRefworkerRouter = system.actorOf(new RoundRobinGroup(routeeAddresses).props());
//Scala valworkerRouter = system.actorOf(RoundRobinGroup( actors.map(x =&gt;x.path.toStringWithoutAddress).toList).props(), "workerRouter")
workRouter.tell( new ParseArticle(TestHelper.file) , self());</pre></div><p>This is a slightly different syntax for creating a router actor than we saw earlier. We saw an example of a poolâ€”where the router creates the routee actors. Here, we are taking pre-existing actors that we created previously and creating a router actor by passing those actors in using a group load-balancing strategy (<code class="literal">RoundRobinGroup</code>). The router groups take a list of addresses, and then produce the props you need to produce the router actor. This is very <a id="id416" class="indexterm"></a>similar to what we would do if the actors <a id="id417" class="indexterm"></a>were remote as well.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Tip</h3><p>Note: The Group can also take the name of a dispatcher if you want the router to be assigned to a dispatcher as well.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec62"></a>Using BalancingPool/BalancingDispatcher</h4></div></div></div><p>Because the actors are local, we<a id="id418" class="indexterm"></a> have a better option than using the <code class="literal">RoundRobinGroup</code> shown<a id="id419" class="indexterm"></a> previously. For local actors, we can create a router with a <code class="literal">BalancingPool</code>, which was briefly described earlier in this chapter. The <code class="literal">BalancingPool</code> will share a single mailbox across all actors in the pool and effectively offer "work-stealing" mechanics to re-distribute load to any idle actors. Using a <code class="literal">BalancingPool</code> helps ensure there are no idle actors when there is work to do because all actors pull messages from the same mailbox. Technically, it's not work stealing as the router is not re-assigning work like <code class="literal">ForkJoinPool</code> doesâ€”it's just that idle actors will pick up the next message from the shared mailbox. The end result is the sameâ€”there is no possibility for one actor to have several messages queued while another actor has none. As we can ensure more actors are actively working, this option can often lead to better resource utilization than the other balancing strategies.</p><p>The <code class="literal">BalancingPool</code> uses a special dispatcherâ€”<code class="literal">BalancingDispatcher</code>. In most cases, we want the <code class="literal">BalancingDispatcher</code> to have a number of threads equivalent to the number of actors that are used.</p><p>First, we'll configure the default <code class="literal">BalancingDispatcher</code> executors in the <code class="literal">application.conf</code> to have exactly 8 threads:</p><div class="informalexample"><pre class="programlisting">//Dispatcher for BalancingPool
pool-dispatcher { fork-join-executor { # force it to allocate exactly 8 threads parallelism-min = 8 parallelism-max = 8 }
}</pre></div><p>Then, we make a pool of eight actorsâ€”the same number as the number of threads in the pool dispatcher:</p><div class="informalexample"><pre class="programlisting">//Java ActorRefworkerRouter = system.actorOf(new BalancingPool(8).props(Props.create(ArticleParseActor.class)), "balancing-pool-router");
//Scala valworkerRouter = system.actorOf(BalancingPool(8).props(Props(classOf[ArticleParseActor])),
      "balancing-pool-router")</pre></div><p>This is a great way of <a id="id420" class="indexterm"></a>ensuring <a id="id421" class="indexterm"></a>work is balanced across all actors when working locally.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec68"></a>Optimal parallelism</h3></div></div></div><p>There is only one way to determine<a id="id422" class="indexterm"></a> for certain what the optimal level of parallelism is on your hardware: measuring. You'll almost always make incorrect assumptions about where time is spent and how changes impact systems until you actually measure and adjust.</p><p>Using a number of threads far greater than the number of cores in your processor will reduce performance, so don't arbitrarily choose large pools of actors and assume more is better. Akka has to switch processing between actors, and your executors need to balance work between threads. Your OS has to schedule CPU time to the active threads and context-switch by swapping the state of the active thread in and out. Because of the overhead, optimal parallelism for the fastest processing times may actually come in lower than you expect. The only way to know for sure what impact a change has is to measure!</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Homework</h2></div></div><hr /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Practice doing work in parallel with both Futures and Actors.</p></li><li style="list-style-type: disc"><p>Try moving the work into different dispatchers.</p></li><li style="list-style-type: disc"><p>Write down some assumptions you have about how things will perform with more and less threads.</p></li><li style="list-style-type: disc"><p>Measure the performance under high load. Measure multiple times for each test and average the results. How does raising and lowering the number of threads and actors impact performance?</p></li><li style="list-style-type: disc"><p>How did your expectations compare to your measurements?</p></li><li style="list-style-type: disc"><p>If you were to make general recommendations about optimal parallelism based on your observations, what would it be?</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>Note: it's easier to make generalizations if you have more cores. You'll probably find things behave differently than you expect.</p></div></li><li style="list-style-type: disc"><p>Can you determine how many context switches are occurring and how that impacts performance? On Linux systems, you'll find the info in <code class="literal">/proc/[pid]/status</code>. You may have to look around in <code class="literal">ps</code> to find the right Java <code class="literal">pid</code>.</p></li><li style="list-style-type: disc"><p>Consider a recent application you have worked onâ€”how would you separate the work into different dispatchers?</p></li><li style="list-style-type: disc"><p>What size of threadpools would you use for the work?</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we looked at two major concepts: scaling up a local application to take advantage of multicore hardware and isolating work into separate dispatchers to protect portions of the isolation from performance risks that may be encountered in other portions of the application.</p><p>To scale up, we need to do work concurrently, so we looked at several techniques for parallelizing work. We examined how to parallelize with futures and with actors. Then, we looked at how to examine an application to determine how separate work should be isolated into different dispatchers for different types of work such as computationally heavy work or blocking IO. Because the isolated dispatchers get tied up without impacting other ones, we can ensure that the other areas of the application remain responsive.</p><p>In the next chapter, we will build on the concepts here to look at how we can start to distribute load across multiple machines.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch06"></a>ChapterÂ 6.Â Successfully Scaling Out â€“ Clustering</h2></div></div></div><p>In the previous chapter, we described how to parallelize work to better utilize the hardware of a single physical host. We also looked at how to isolate performance problems to specific dispatchers in a host. In this chapter, we will look at what happens when we reach the limit of a physical host and need to process the work across multiple machines. This may sound like a huge feat, but Akka gives us the tools to get us started quickly.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Some of the foundational concepts used in distributed systems</p></li><li style="list-style-type: disc"><p>Introduction to Akka Cluster</p></li><li style="list-style-type: disc"><p>Using Akka Cluster to build distributed systems</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec39"></a>Introducing Akka Cluster</h2></div></div><hr /></div><p>We've briefly looked at remoting<a id="id423" class="indexterm"></a> in earlier chapters in this book. It's helpful to understand remoting a bit to see how Akka communicates over the network, but in this chapter, we're going to use Akka Cluster's mechanics instead of simple peer to peer communication to give us greater resilience and flexibility in our deployments. In this section, we'll review some clustering concepts and learn about how Akka Cluster keeps track of nodes to allow our applications to scale out as needed.</p><p>Let's start by giving a definition of what a cluster is. Wikipedia states that <span class="emphasis"><em>A computer cluster consists of a set of loosely or tightly connected computers that work together so that, in many respects, they can be viewed as a single system.</em></span> To be more specific about our definition of a cluster in this chapter, we can say that a cluster is a group of machines (likely VMs), which we will refer to as <code class="literal">nodes</code> or <code class="literal">members</code>, that are in agreement about all other nodes who are in the group.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec40"></a>One Giant Monolith or Many Micro Services?</h2></div></div><hr /></div><p>Since I started slinging code, Martin Fowler has been one of my heroes as a developer; so, when I see him reasoning about a problem I'm also pondering, I take notes.</p><p>If we're talking about microservices <a id="id424" class="indexterm"></a>and distributed systems, he has a few articles on<a id="id425" class="indexterm"></a> his site <a class="ulink" href="http://www.martinfowler.com/" target="_blank">http://www.martinfowler.com/</a>, which you might want to read.</p><p>The first valuable point is that in the life of an application, while complexity of an application is low, it can be more efficient for a small team to build a single large applicationâ€”a monolithâ€”as opposed to trying to build networked services. Start by building one application. Once complexity in the application increases, productivity can fall because teams have to do a lot of coordination of activities to get code merged, and work on features together. At this point, you can start to see productivity benefits of using smaller networked services.</p><p>The second valuable point is that building with a monolith-first approach will enable you to understand where services should be separated when you get around to splitting your services into many smaller applications. Fowler argues that you are quite likely to pick the wrong services to represent as discreet applications until you've actually been working on your system for a while.</p><p>Once you have some experience and data from running your system in production, it will be clear which pieces will benefit from being separated in terms of both performance and team velocity when adding features. As you start deploying microservices, you can scale up the more loaded services in an asymmetrical manner so that the most used pieces of the application have their own larger cluster of servers.</p><p>Luckily, Akka can make deployment decisions more of a configuration item rather than code, but having multiple code bases can greatly ease having large teams work on a codebase. It eliminates the problem of Brooks Law (adding more resources to an already late project makes it later) by eliminating communication channels and isolating code commits to separate repositories (no more merge hell).</p><p>Ultimately, you may want to defer considering building a distributed system until you have a system that is too complex to manage as a monolith, or at least until you have good data-backed justifications (performance or team effort related) for deploying in such a manner.</p><p>Regardless of whether you decide to build a monolith or services out of the gate, you may want to put different concerns into libraries from day one. You can get the benefits of having teams work on different code bases before you're ready to actually deploy separate applications. Once you want to split your application, it will be much easier to manage sharing code if you've done this from the start.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Definition of a Cluster</h2></div></div><hr /></div><p>A cluster <a id="id426" class="indexterm"></a>is a group of servers that exist and talk among themselves. Each server in a cluster is referred to as a node or member. A cluster should be able to change size dynamically and survive any failures with minimal impact so that there are two responsibilities that a cluster needs to handleâ€”failure detection and propagating a consistent view of all available members throughout the cluster.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>Failure Detection</h3></div></div></div><p>As we start to add nodes beyond one, it becomes<a id="id427" class="indexterm"></a> more likely that nodes will fail or that the network will become temporarily partitioned; thus, a cluster is a dynamic entity that can shrink when servers shut down or become unavailable and that can grow when servers are added (for example, to handle more load). Nodes of a cluster do this by sending messages to other members to determine whether those members are available or not. They determine the availability of the members on the basis of the reply or absence thereof.</p><p>If every server talked to every other server in the cluster, then a cluster's performance would not scale in a linear manner as the overhead of each additional node would exponentially increase the lines of communication needed. To reduce the complexity of monitoring the heath of other nodes, failure detection in Akka is done by only monitoring a certain number of nodes next to a node. For example, in a cluster ring of six nodes, each node might monitor the two nodes after it for failure. The default maximum for each node to monitor in Akka Cluster is five nodes:</p><div class="mediaobject"><img src="graphics/B04006_06_01.jpg" /></div><p>In Akka, the failure<a id="id428" class="indexterm"></a> detection is accomplished by sending a heartbeat from one node to another, and then accepting a response. Akka will calculate the likelihood that a node is available on the basis of the heartbeat history and current heartbeats. Akka will mark the node as unavailable and available by calculation with these figures and the tolerance thresholds configured.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec70"></a>Gossiping an Eventually Consistent View</h3></div></div></div><p>Considering handling <a id="id429" class="indexterm"></a>failure detection, each node in the cluster communicates the known state to its neighbors. Then, those neighbors pass along the known state to their neighbors and so on until the known state of that node is propagated throughout the cluster. Nodes will deliberate and come to conclusions about the members of the cluster.</p><p>If a node is inaccessible to one node, it is considered unavailable to all nodes in the cluster.</p><p>This mechanism for eventually propagating the state through the cluster is known as gossip protocol or epidemic protocol (as information spreads throughout the cluster like a virus!). Many eventually consistent data-stores, such as Riak and Cassandra, operate in a very similar manner. The Dynamo paper from Amazon was very influential in many of these data-stores.</p><p>We don't need to know<a id="id430" class="indexterm"></a> too much about the inner workings of Akka cluster at this pointâ€”we only need to understand that Akka will take care of determining if the state of the cluster changes and will take care of updating everyone in the cluster with any changes that occur.</p><p>We're going to cover many of the details of how cluster works as we build our own cluster through the rest of this chapter. If you want to get a bit more background on how Akka Cluster works, there is a document in the Akka documentation called <a id="id431" class="indexterm"></a>Cluster Specification. At the time of writing, it as available at <a class="ulink" href="http://doc.akka.io/docs/akka/snapshot/scala/cluster-usage.html" target="_blank">http://doc.akka.io/docs/akka/snapshot/scala/cluster-usage.html</a>.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec42"></a>CAP Theorem</h2></div></div><hr /></div><p>We're going to cover a stateless <a id="id432" class="indexterm"></a>worker example in this chapter, but we're also going to cover state being stored in a cluster to understand the trade-offs of design choices. Eric Brewer's often cited <span class="emphasis"><em>CAP Theorem</em></span> talks about the compromises of distributed systems and is a helpful model for reasoning about how a system deals with state and exceptional events. CAP Theorem is an acronym for the three qualities of distributed systems, as described in the following, and the compromise of choosing between them.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec71"></a>C â€“ Consistency</h3></div></div></div><p>Consistency means <a id="id433" class="indexterm"></a>that a client will return the most recent value for a given record. Consider a bank accountâ€”if you try to withdraw $400 immediately after depositing a $400 cheque, you expect the systems to give you the correct balance and allow you to withdraw the $400.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec72"></a>A â€“ Availability</h3></div></div></div><p>Availability means that a<a id="id434" class="indexterm"></a> non-failing node is able to give a reasonable response (for example, give an accurate picture of whether a write was a success or failure).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec73"></a>P â€“ Partition Tolerance</h3></div></div></div><p>Partition Tolerance <a id="id435" class="indexterm"></a>means that a system continues to operate normally if a node is removed from the network due to a temporary network failure. If data is replicated across three nodes and one of the nodes becomes temporarily unavailable, then the system can be said to be partition tolerant if the other two nodes can come to the same conclusion about the most recent record.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec74"></a>Compromises in CAP Theorem</h3></div></div></div><p>CAP theorem is often cited <a id="id436" class="indexterm"></a>as the following statement: of the threeâ€”Consistency, Availability, and Partition toleranceâ€”that a distributed system can choose any two. This is a misleading oversimplification, and if you start reading articles, you'll see a lot of conflicting rebuttals.</p><p>We'll start by assuming that we want a system that has Partition Tolerance and only talking about the compromises between Availability and Consistency. Why you ask? In a time-bound request, if a node becomes unavailable, you are really deciding between responding with an error (preferring Consistency) or continuing even though there might be inconsistency between servers (preferring Availability). Waiting around too long means the request will be abandoned so time is a factor at play and a system must make a decision. We'll look at this a bit more but Eric Brewer also wrote an article 12 years after his Cap Theorem paper that has further discussion on this point: <a class="ulink" href="http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed" target="_blank">http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed</a>:</p><div class="mediaobject"><img src="graphics/B04006_06_02.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec63"></a>CP System â€“ Preferring Consistency</h4></div></div></div><p>There are different <a id="id437" class="indexterm"></a>ways in which a consistent distributed store can be implemented. Perhaps, the simplest example of a strongly consistent data-store would be to have a master node and any number of secondary nodes on which the data is replicated. You always write to the primary node, and to ensure the most recent data is read. Data must always be read from the primary node as well. In the case of the failure of the master node, the system will no longer be available:</p><div class="mediaobject"><img src="graphics/B04006_06_03.jpg" /></div><p>Generally, some sort<a id="id438" class="indexterm"></a> of failover occurs where a secondary node becomes the new primary node. We give up availability because our system can't be read from or written to in the case of a partition, and instead goes through a failover process to elect the new primary node. Once the failover is complete, availability will be restored. Redis Sentinel, or replicated RDBMSs are great examples of strongly consistent distributed systems.</p><p>You would choose a consistent system if you need ATOMIC reads/writes, transactions, and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec64"></a>AP System â€“ Preferring Availability</h4></div></div></div><p>A system that prefers <a id="id439" class="indexterm"></a>availability and partition tolerance at the cost of consistency is said to be "eventually consistent." In highly available distributed data-stores such as Cassandra and Riak, this is a very common model.</p><p>We'll look at AP systems in more detail in this chapter because they take a bit of work to reason about, but we can look at one example of how we might implement an AP system. Let's assume that there are three replicas of the data on three nodes. When we write data, the data is written to one node and, then, it is later replicated across all three nodes. It doesn't matter which one we write into, that node will coordinate the write across the remaining nodes:</p><div class="mediaobject"><img src="graphics/B04006_06_04.jpg" /></div><p>When we read <a id="id440" class="indexterm"></a>from a node, we only need one node to read the data, so our client may choose a random node to read from. In this example, our system is eventually consistent because when we read from a node, and the data may be a bit out of date (not Consistent), but as we can read and write from any of the nodes, our system is both Partition tolerant and highly Available. If a node becomes unavailable, we can just try another node.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note03"></a>Note</h3><p>Note that this is very hard to get correct because the time and ordering of events in systems is challenging to determine. Clocks will never be perfectly synchronized across machines so other approaches are taken for ordering such as Vector clocks.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec65"></a>Consistency as a Sliding Scale</h4></div></div></div><p>Practically speaking, the<a id="id441" class="indexterm"></a> choices between the three trade-offs are not toggles but sliders. In an eventually consistent system, for example, if we have three replicas of a record we're looking for, we can have low consistency by requiring any of the nodes to give us the record. We can have greater consistency by having any two of the three return with the data. And we can have the greatest consistency by requiring asking all three nodes to provide back a result. When we get back the data from the nodes, several different mechanisms can be used to order the records, so we'll choose the newest one. However, doing this can sacrifice partition tolerance. If we need all three replicas to be available, then we can't tolerate one of the nodes disappearing. Usually, only requiring a quorum or majority of nodes to be up and give a view is a good trade-off between consistency and partition tolerance.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip13"></a>Tip</h3><p>Ordering is its own problem as often clocks are not perfectly synchronized across nodes so other ordering mechanisms are used such as Vector Clocks.</p></div><p>Similarly, in a CP system, we can sacrifice some consistency for greater availability by allowing secondary nodes to be read from. If we keep writes on the master, we still have highly consistent writes, but we allow our reads to be eventually consistent, so our database becomes AP on reads.</p><p>Based on our use <a id="id442" class="indexterm"></a>cases, we can "tune" our CAP stance to best meet our use case needs. It is even possible to use blends of these strategies in the same application in the same data-store for different types of data!</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Building Systems with Akka Cluster</h2></div></div><hr /></div><p>We will revisit<a id="id443" class="indexterm"></a> two problems in this chapterâ€”Article <a id="id444" class="indexterm"></a>Parsing and the key-value store. However, in this chapter, we're going to look at how to distribute them across multiple servers using Akka Cluster. Assuming we have built an application that needs to scale beyond a single node, and that needs higher availability, we will see how we can scale our systems up by adding more nodes.</p><p>We might not be able to build Cassandra in a day, but believe it or not, we will be able to produce a horizontally scalable distributed service in this chapter, and we will also demonstrate some of the common techniques that are used in distributed solutions while we're at it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec75"></a>Creating the Cluster</h3></div></div></div><p>In this section, we're going to <a id="id445" class="indexterm"></a>look at how to create a cluster with Akka's Cluster module. We looked at remoting earlier in this book very briefly, but we will look at cluster in much greater detail now. Akka Cluster is built on remoting, but is powerfully useful. If you use Remoting, you'll need to concern yourself with issues such as high availability in your infrastructure or code. Cluster takes care of many of these concerns for you, thus making it a great choice for building your distributed Actor systems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec66"></a>Configuring the Project</h4></div></div></div><p>First, we need to configure<a id="id446" class="indexterm"></a> Akka to be able to create a cluster. We have to do a few things to the projectâ€”first, add <code class="literal">Cluster</code> to the project and, then, add the appropriate entries in <code class="literal">application.conf</code>. You can start a new project using <code class="literal">activator new</code> as we'll go over all of the configuration needed in the project. Completed projects are available on GitHub at <a class="ulink" href="https://github.com/jasongoodwin/learning-akka/tree/master/ch6" target="_blank">https://github.com/jasongoodwin/learning-akka/tree/master/ch6</a> in both Scala and Java.</p><p>In our <code class="literal">build.sbt</code> file, we first have to add the Akka Cluster dependency:</p><div class="informalexample"><pre class="programlisting">"com.typesafe.akka" %% "akka-cluster" % "2.3.6"</pre></div><p>We'll also add the <code class="literal">contrib</code> package. This is a module of contributions from outside the Akka teamâ€”there is an Akka Cluster client in the <code class="literal">contrib</code> package that is a bit simpler to build on. We'll look at the client features a bit later:</p><div class="informalexample"><pre class="programlisting">"com.typesafe.akka" %% "akka-contrib" % "2.3.6",</pre></div><p>Now that Akka Cluster<a id="id447" class="indexterm"></a> is in the project, we need to add cluster configuration in <code class="literal">src/main/resources/application.conf</code>:</p><div class="informalexample"><pre class="programlisting">akka {  actor { provider = "akka.cluster.ClusterActorRefProvider" }
  remote { netty.tcp { hostname = "127.0.0.1" port = 2552
    }
  }
  cluster { seed-nodes = [ "akka.tcp://Akkademy@127.0.0.1:2552", "akka.tcp://Akkademy@127.0.0.1:2551"] }
  extensions = ["akka.contrib.pattern.ClusterReceptionistExtension"]
}</pre></div><p>There are a few pieces that are significant.</p><p>First, configuration for Cluster is very similar to remoting but we change the provider to <code class="literal">ClusterActorRefProvider</code>.</p><p>We specify the host and port. We're using the Akka default of 2552 and specifying the local host IP for testing purposes. To test a cluster on a single machine, you'll need to start instances on different ports, which can be done by passing in arguments to <code class="literal">sbt</code> on the command line. If you need to pass in any parameters, you can achieve this using the following:</p><div class="informalexample"><pre class="programlisting">activator run -Dakka.remote.netty.tcp.port=0</pre></div><p>Passing <code class="literal">port=0</code> will have Akka assign a random port.</p><p>We specify seed nodes. We'll look at what exactly seed nodes are in a moment, but please note that the host, port, and <code class="literal">ActorSystem</code> are described in the configuration lines for the seed-nodes. It's important to ensure that the <code class="literal">ActorSystem</code> is accurately for the cluster you are trying to join. Multiple <code class="literal">ActorSystems</code> can run in an instance, so host and port are not enough to connect successfully.</p><p>The last lineâ€”the extensions lineâ€”is to add support for the <code class="literal">contrib</code> package's cluster client, which we'll look at a bit later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec67"></a>Seed Nodes</h4></div></div></div><p>You may be wondering what <a id="id448" class="indexterm"></a>the <code class="literal">akka.cluster.seed-nodes</code> configuration is for. Because a cluster can be of any size, you may not know where all the nodes will be located. This is especially true if you're deploying in the cloud, where you can have rapidly changing deployment topology and IPs.</p><p>Thanks to the gossip protocol, we can get away with only knowing a couple of nodes. Most technologies such as Cassandra and Akka refer to these nodes as seed nodes. There is nothing special about them apart from the fact that we know where they are accessible.</p><p>To understand how this is possible, we'll have a look at how nodes join the cluster. When a new node joins the cluster, it tries to contact the first seed node. If it successfully contacts the node, it will announce its location (port and IP). The seed node will then gossip the new node's location, eventually propagating the change through the cluster. If contact to the first seed node fails, then the node will try the next seed node. As long as one seed node is available, then other nodes can join and leave without requiring any configuration changes:</p><div class="mediaobject"><img src="graphics/B04006_06_05.jpg" /></div><p>When you deploy to<a id="id449" class="indexterm"></a> production, you should define at least two seed nodes that will have a constant IP and ensure that at least one of the seed nodes is available all the time. When a node attempts to join the cluster, it will try to sequentially contact each seed node. If no seed nodes are available, then the node will not be able to join the cluster.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Tip</h3><p>When starting the cluster's seed nodes, the seed nodes can be started in any order, but the first seed node listed must be started to initialize the cluster.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec68"></a>Subscribing to Cluster Events</h4></div></div></div><p>We have enough<a id="id450" class="indexterm"></a> configuration now to create a cluster at runtime, thus, we can start building. We'll subscribe to cluster events and log any changes to the cluster ring. After writing the code, we'll test it out and then continue on to look at how we can design a distributed service and a data-store using this base.</p><p>We'll produce an actor first, calling it <code class="literal">ClusterController</code>, and use this as the basis for our other examples. Later, we'll adapt the code to take action on the events. We'll start by creating the actor, and instantiating a logger, and then the cluster object.</p><p>In Java, the actor looks like the following:</p><div class="informalexample"><pre class="programlisting">importstatic.akka.cluster.ClusterEvent.*;
public class ClusterController extends AbstractActor { protected final LoggingAdapter log = Logging.getLogger(context().system(), this);
    Cluster cluster = Cluster.get(getContext().system());
    @Override
    public void preStart() { cluster.subscribe(self(), initialStateAsEvents(), MemberEvent.class, UnreachableMember.class); }
    @Override public void postStop() { cluster.unsubscribe(self()); }
    private ClusterController(){ receive(ReceiveBuilder. match(MemberEvent.class, message -&gt; { log.info("MemberEvent: {}", message); }). match(UnreachableMember.class, message -&gt; { log.info("UnreachableMember: {}", message);
                        }).build()
        );
    }
}</pre></div><p>In Scala, the actor<a id="id451" class="indexterm"></a> looks the following:</p><div class="informalexample"><pre class="programlisting">class ClusterController extends Actor { val log = Logging(context.system, this) val cluster = Cluster(context.system)
  override def preStart() { cluster.subscribe(self, classOf[MemberEvent], classOf[UnreachableMember]) }
  override def postStop() { cluster.unsubscribe(self)
  }
  override def receive = { case x: MemberEvent =&gt; log.info("MemberEvent: {}", x) case x: UnreachableMember =&gt; log.info("UnreachableMember {}: ", x)
  }
}</pre></div><p>First, we define the logger. Then, we get a reference to the Cluster object. We'll look at the Cluster object and methods available on it throughout this chapter.</p><p>We use the Actor <code class="literal">preStart</code> and <code class="literal">postStop</code> hooks to subscribe to events that we're interested in. The unsubscribe in the <code class="literal">postStop</code> hook is necessary to prevent a leak. We're going to have our actor subscribe to the following two events:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>MemberEvent</strong></span>: This tells us when there is a change to the cluster state</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>UnreachableMember</strong></span>: This tells us when there is a node marked unreachable</p></li></ul></div><p>Then, we describe the<a id="id452" class="indexterm"></a> actor's behavior when it receives those events: to simply log them (for now). We'll examine the different events that occur in the cluster shortly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec69"></a>Starting the Cluster</h4></div></div></div><p>As a checkpoint to ensure<a id="id453" class="indexterm"></a> that everything is accurate and configured correctly, we'll try to start up a few nodes now. First, we need to make a <code class="literal">main</code> where we programmatically start the actor system and create the <code class="literal">ClusterController</code> actor.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">public class Main { public static void main(String... args) { ActorSystem system = ActorSystem.create("Akkademy"); ActorRefclusterController = system.actorOf(Props.create(ClusterController.class), "clusterController");
    }
}</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">object Main extends App { val system = ActorSystem("Akkademy")
val clusterController = system.actorOf(Props[ClusterController], "clusterController")
}</pre></div><p>Our seed node can be started simply with:</p><div class="informalexample"><pre class="programlisting">activator run</pre></div><p>However, we're going to enable <code class="literal">jmx</code> remote management of the nodes so that we can have them leave the cluster gracefully. Thus, we're going to tack on a few extra parameters â€”we'll specify the <code class="literal">jmx</code> port for the nodes and turn off <code class="literal">jmx</code> security features for use in test. We'll see why we want to enable JMX remote management shortly. With the <code class="literal">jmx</code> configuration, we will start the node like the following:</p><div class="informalexample"><pre class="programlisting">activator run \
-Dcom.sun.management.jmxremote.port=9552 \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false</pre></div><p>It will start a node on the configured port of <code class="literal">2552</code>. You'll see some logging events indicating that the first seed node is up and probably a few dead letters messages as the node attempts to connect to the other configured seed node configured. Eventually, you'll see our log statement for the <code class="literal">MemberEvent</code>:</p><div class="informalexample"><pre class="programlisting">[INFO] [06/14/2015 12:22:46.756] [Akkademy-akka.actor.default-dispatcher-3] [akka://Akkademy/user/clusterController] MemberEvent: MemberUp(Member(address = akka.tcp://Akkademy@127.0.0.1:2552, status = Up))</pre></div><p>In another terminal <a id="id454" class="indexterm"></a>window, we'll start up the second seed node on port <code class="literal">2551</code> by specifying the port as a Java argument:</p><div class="informalexample"><pre class="programlisting">activator run \
-Dakka.remote.netty.tcp.port=2551 \
-Dcom.sun.management.jmxremote.port=9551 \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false</pre></div><p>The first node running on <code class="literal">2552</code> should log the status change when the second seed node connects:</p><div class="informalexample"><pre class="programlisting">[INFO] [06/14/2015 12:24:40.745] [Akkademy-akka.actor.default-dispatcher-18] [akka://Akkademy/user/clusterController] MemberEvent: MemberUp(Member(address = akka.tcp://Akkademy@127.0.0.1:2551, status = Up))</pre></div><p>We'll add one more node now to demonstrate how we might configure nodes beyond the seed node. Because the seed nodes have defined ports, we can have Akka assign a random port by configuring it as <code class="literal">0</code>:</p><div class="informalexample"><pre class="programlisting">activator run -Dakka.remote.netty.tcp.port=0 \ -Dcom.sun.management.jmxremote.port=9553 \ -Dcom.sun.management.jmxremote.authenticate=false \ -Dcom.sun.management.jmxremote.ssl=false</pre></div><p>After a moment, you'll see the third node connect to the cluster. This is quite excitingâ€”we now have the basis for building a distributed actor system. Akka takes care of numerous things for us that would be quite hard to get right ourselves!</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip15"></a>Tip</h3><p>Again, remember that you need to start the first node in the seed node list for the cluster to initialize.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec70"></a>Leaving the Cluster Gracefully</h4></div></div></div><p>If you try shutting<a id="id455" class="indexterm"></a> down one of the nodes by killing the process, you'll notice that Akka marks it unreachable and writes several error messages. In this case, shutting down the node causes it to become unreachable and Akka will eventually mark it down. This is because we did not leave the cluster gracefully. Before removing a node from the cluster, we should announce to the cluster that the node is leaving.</p><p>We can do it programmatically by calling <code class="literal">cluster.leave</code> with the address of the node we want to remove:</p><div class="informalexample"><pre class="programlisting">cluster.leave(self().path().address());</pre></div><p>However, we don't have any API that we can use to expose this functionality currently. So, instead, we'll use <code class="literal">jmx</code> and command line tools to remove the node gracefully. We're going to use a tool <a id="id456" class="indexterm"></a>that comes with the Akka distribution: <code class="literal">akka-cluster</code>.</p><p>You may need to download the Akka distribution first to get the<a id="id457" class="indexterm"></a> akka-cluster tool. It should be available at <a class="ulink" href="http://akka.io/downloads/" target="_blank">http://akka.io/downloads/</a>. Unzip the file, and into the <code class="literal">bin</code> folder.</p><p>Now, we can issue commands to the cluster using the tool. Our principle use is to have the node leave the cluster gracefully. We can shut down the seed node on port <code class="literal">2552</code> that has JMX exposed on <code class="literal">9552</code> in the following manner:</p><div class="informalexample"><pre class="programlisting">./akka-cluster localhost 9552 leave akka.tcp://Akkademy@127.0.0.1:2552</pre></div><p>After gracefully removing the node, you'll see it change states from up to exiting and then to removed.</p><div class="informalexample"><pre class="programlisting">[INFO] [06/15/2015 20:05:21.501] [Akkademy-akka.actor.default-dispatcher-3] [akka://Akkademy/user/clusterController] MemberEvent: MemberExited(Member(address = akka.tcp://Akkademy@127.0.0.1:2552, status = Exiting)) [INFO] [06/15/2015 20:05:26.470] [Akkademy-akka.actor.default-dispatcher-17] [akka://Akkademy/user/clusterController] MemberEvent: MemberRemoved(Member(address = akka.tcp://Akkademy@127.0.0.1:2552, status = Removed),Exiting)</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>Cluster Member States</h3></div></div></div><p>Nodes that join the<a id="id458" class="indexterm"></a> cluster can be in one of a few different states. Under the hood, there is a logical leader node that coordinates some of the state changes. The cluster will logically order nodes and everyone will come to a conclusion about that order. The first node in the ordered list of nodes is the leader.</p><p>The leader responds to requests to join and leave the cluster by changing a member's state.</p><p>When joining the cluster, a joining member announces its state as "Joining." The leader responds by announcing that the member is Up. Similarly, if a node announces that it is "Leaving," then the Leader responds by changing that node's state to "Exiting" and then to "Removed." All these state changes are sent through the cluster as <code class="literal">MemberEvents</code>, which we subscribed to and logged.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec71"></a>Failure Detection</h4></div></div></div><p>There is one more path <a id="id459" class="indexterm"></a>out of the cluster that actors can takeâ€”nodes can be detected as unreachable by other members of the cluster that are performing failure detection. When a node is determined to be unreachable for any reasonâ€” for example, crashing or temporary network failureâ€”then the state of the node does not change, but it instead is marked with a <code class="literal">MemberUnreachabl</code>e flag. We subscribed to this event in our <code class="literal">ClusterController</code> so that we can become aware of this flag. If the member becomes reachable again within a reasonable period of time, then it will resume. If it stays unreachable for a configurable duration, then the leader will mark the node "Down" and it cannot rejoin the cluster.</p><p>From a functional perspective, you can simply watch for the changes in member state, but the implementation of failure detection is actually based on the probability of being unreachable (<code class="literal">phi</code>) based on data collected from the cluster. If you want to learn more, the Cluster Specification document has a link to information on how <a id="id460" class="indexterm"></a>failure detection is implemented (<a class="ulink" href="http://doc.akka.io/docs/akka/snapshot/common/cluster.html#failure-detector" target="_blank">http://doc.akka.io/docs/akka/snapshot/common/cluster.html#failure-detector</a>).</p><p>We're going to leave the values as their default, but in your deployments, you should be sure to read the documentation and adjust depending on your network reliability. <span class="strong"><strong>Amazon EC2 instances</strong></span> (<span class="strong"><strong>AWS</strong></span>)<a id="id461" class="indexterm"></a> is notoriously less reliable than a small network sitting on a rack, so you might want to be more reactive to temporary partitions in AWS than you would on your own virtualization infrastructure and network appliances. After working in large deployments in cloud environments, I've found that encountering service interruptions due to temporary network failure are more the norm than the exception in day-to-day operations.</p><p>It's worth noting that if a node is marked unreachable, then Akka cluster will not change statesâ€”no new members can join until nodes are either marked down after being unable to recover from unavailability or are restored.</p><p>If nodes becomes unavailable and are marked down, they can't rejoin the cluster after that point. Two separate clusters can result (forming what is referred to as a "split brain" scenario). Akka does not currently resolve this phenomenon; thus, once a node is downed, it needs to shut down and restart to get a new unique ID and rejoin the cluster.</p><p>This wraps up the basics of Akka cluster. We'll look at building out some examples on our cluster now.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>Routing Messages to the Cluster</h3></div></div></div><p>We looked at how<a id="id462" class="indexterm"></a> to create a cluster. Now we'll look at how to send<a id="id463" class="indexterm"></a> messages to the cluster. We're going to re-introduce our article parsing problem here and allocate a cluster of nodes to do the work.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec78"></a>Producing a Distributed Article Parse Service</h3></div></div></div><p>For our first exampleâ€”a <a id="id464" class="indexterm"></a>distributed, horizontally scalable serviceâ€”we're going to produce a cluster of article parsing services and then have a client route messages to random members of the cluster.</p><p>We've looked at producing a pool of actors that will parse an article from a web page for us in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Scaling Up</em></span>.</p><p>â€”we're going to re-use all the code and run it on our cluster example. The receive block of the actor that we want to cluster looks like the following:</p><div class="informalexample"><pre class="programlisting">//Java
match(ParseArticle.class, x -&gt;{ ArticleParser.apply(x.htmlBody). onSuccess(body -&gt; sender().tell(body, self())). onFailure(t -&gt; sender().tell(new Status.Failure(t), self()));
                }
        )
//Scala override def receive: Receive = { case ParseArticle(htmlString) =&gt; val body: String = ArticleParser(htmlString) sender() ! body
  }</pre></div><p>You can refer to <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Scaling Up</em></span> examples on GitHub for the full example. We're going to put the pool of article parsers in our cluster and start the cluster up. Once that's complete, we'll demonstrate how to talk to the cluster of services from another actor system. All that we need to do to make a cluster of services is add any dependencies missing to our cluster project, and then put the <code class="literal">ArcicleParser</code>, <code class="literal">ArticleParseActo</code>
<code class="literal">r</code>, and the <code class="literal">ParseArticle</code> messages into the application.</p><p>Once you've done that, then we can simply start the actor (or pool of actors) as has been demonstrated in the section on starting the cluster. Then, our main could possibly appear as follows:</p><div class="informalexample"><pre class="programlisting">public class Main { public static void main(String... args) { ActorSystem system = ActorSystem.create("Akkademy"); ActorRefclusterController = system.actorOf(Props.create(ClusterController.class), "clusterController");
ActorRefworkerPool = system.actorOf(new BalancingPool(5).props(Props.create(ArticleParseActor.class)), "workers");
    }
}</pre></div><p>We can start up a few nodes now as covered previously in the section on starting the cluster. For brevity, we'll do so without enabling remote management. If you're using Linux, you can do it in one go by backgrounding the tasks:</p><div class="informalexample"><pre class="programlisting">activator run &amp; activator run -Dakka.remote.netty.tcp.port=2551 &amp; activator run -Dakka.remote.netty.tcp.port=0 &amp;</pre></div><p>Now, we have a <a id="id465" class="indexterm"></a>three-node cluster running. We'll move onto the client.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec79"></a>Cluster Client for Clustered Services</h3></div></div></div><p>Building a client <a id="id466" class="indexterm"></a>to talk to stateless clustered services is fairly straightforward. Akka Cluster gives some advantages compared with traditional web services with a load-balancer in frontâ€”the cluster can be dynamically scaled up and down without changing load-balancer configuration. The client itself can route the messages to random members of the cluster, so the infrastructure requirements are simpler. Because the client is aware of the cluster, it can rebuild the list of services available to send messages to as the cluster increases or decreases in size. The client will internally load-balance requests against all the nodes in the cluster in the following manner:</p><div class="mediaobject"><img src="graphics/B04006_06_06.jpg" /></div><p>We have a three-node cluster running; thus, we can look at what we need to do to get a client to talk to it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Enable cluster<a id="id467" class="indexterm"></a> client in the server project.</p></li><li><p>The client must have the message that you want to send to the service.</p></li><li><p>The client must know about the cluster topology without being a member of the cluster itself. For this, we will use the Akka Cluster Client in the <code class="literal">Contrib</code> library.</p></li><li><p>The client must then know how to find the actors or routers it wants to send to and respond to cluster events.</p></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec72"></a>Setting up the Server Project</h4></div></div></div><p>In the server project, we <a id="id468" class="indexterm"></a>added the dependencies necessary to use the cluster client. The Cluster client is in the <code class="literal">contrib</code> package, which are contributions from outside of the Akka team. We added the following dependency:</p><div class="informalexample"><pre class="programlisting">"com.typesafe.akka" %% "akka-contrib" % "2.3.6"</pre></div><p>Then, in the configuration (<code class="literal">application.conf</code>), we added an akka extension for the client:</p><div class="informalexample"><pre class="programlisting">akka.extensions = ["akka.contrib.pattern.ClusterReceptionistExtension"]</pre></div><p>This will start the <code class="literal">ClusterReceptionist</code> on the server, which will handle all the details for our client to be able to talk to the cluster. The cluster receptionist actor is created on the root path in the server<code class="literal">â€”/user/receptionist.</code> We'll see how this is used shortly.</p><p>After doing that, our main need is to be updated to register the worker with the <code class="literal">ClusterReceptionist</code>. We'll use the balancing pool introduced in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Scaling Up</em></span> to create a pool of actors on each server.</p><p>First, we'll look at the Java code:</p><div class="informalexample"><pre class="programlisting">public class Main { public static void main(String... args) { ActorSystem system = ActorSystem.create("Akkademy"); ActorRefclusterController = system.actorOf(Props.create(ClusterController.class), "clusterController");
        // router at /user/workers
ActorRef workers = system.actorOf(new BalancingPool(5).props(Props.create(ArticleParseActor.class)), "workers");
        ((ClusterReceptionistExtension) akka.contrib.pattern.ClusterReceptionistExtension.apply(system)). registerService(workers); }
}</pre></div><p>You'll see that we have to cast the <code class="literal">ClusterReceptionistExtension</code>â€”we're calling the Scala API's apply method. This works perfectly fine for registering the workers.</p><p>The Scala <a id="id469" class="indexterm"></a>example looks a little simpler:</p><div class="informalexample"><pre class="programlisting">object Main extends App { val system = ActorSystem("Akkademy") valclusterController = system.actorOf(Props[ClusterController], "clusterController")
  // router at /user/workers val workers = system.actorOf(BalancingPool(5).props(Props[ArticleParseActor]), "workers")
ClusterReceptionistExtension(system).registerService(workers)
}</pre></div><p>That's it! If you have nodes running, you'll want to restart them after making the changes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec73"></a>Setting up the Client Project</h4></div></div></div><p>We can create a <a id="id470" class="indexterm"></a>new project for the client. Run <code class="literal">activator new</code> and select the language template of your choice.</p><p>Edit the <code class="literal">build.sbt</code> file in the new project. You'll need to add the following dependencies:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq( "com.typesafe.akka" %% "akka-actor" % "2.3.6", "com.typesafe.akka" %% "akka-cluster" % "2.3.6", "com.typesafe.akka" %% "akka-contrib" % "2.3.6"
)</pre></div><p>You can add any test dependencies you might like as well, such as <code class="literal">junit</code> or <code class="literal">scalatest.</code> There is nothing new in our dependency list here.</p><p>Next, we have to make/modify <code class="literal">application.conf</code> to ensure the provider is correct are correct and set up the mailbox for the Cluster client:</p><div class="informalexample"><pre class="programlisting">akka { actor { provider = "akka.cluster.ClusterActorRefProvider" }
contrib.cluster.client { mailbox { mailbox-type = "akka.dispatch.UnboundedDequeBasedMailbox" stash-capacity = 1000 }
  }
}</pre></div><p>Be careful about providing too many messages before letting everything get connected! Messages will be stashed in the Cluster Client.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec74"></a>Sharing the Message Class between Client and Server</h4></div></div></div><p>There are a few<a id="id471" class="indexterm"></a> different ways in which you can share messages across client and server applications. You can build them both in the same project, you can include the server project in the client or vice versa, or you can have an extra project that contains the messages that both projects share. In <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span> this was demonstrated by publishing a library to the local repository. Nexus or Artifactory can be installed to host the assets as a solution for teams on closed-source projects. Sonatype's OSS Repository and Maven Central can be used for open source projects.</p><p>If you're following along, take whichever approach you likeâ€”preferably putting the messages in their own project. For the sake of simplicity, in the example, we can change the <code class="literal">ArticleParseActor</code> to accept and return strings:</p><div class="informalexample"><pre class="programlisting">//Java
match(String.class, x -&gt; { ArticleParser.apply(x). onSuccess(body -&gt; sender().tell(body, self())). onFailure(t -&gt; sender().tell(new Status.Failure(t), self()));
//Scala
    case htmlString: String =&gt; val body: String = ArticleParser(htmlString)
      sender() ! body</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note04"></a>Note</h3><p>Changing messages over time can break your applications. Google's Protocol Buffers can be used in Akka for message serialization - you may want to learn how to utilize Protocol Buffers to managing changing messages over time.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec75"></a>Sending Messages to the Cluster</h4></div></div></div><p>Now that we<a id="id472" class="indexterm"></a> have the cluster configured to talk to the <code class="literal">contrib</code> package's Cluster Client, we can send messages to the cluster.</p><p>We'll take a random article from the Internet, grab the HTML source, and create a String variable called <code class="literal">articleToParse</code>.</p><p>We'll send that to a random member of the cluster, and we should then get back the body of the article from the service. We'll print the result. If you send it a few times, you will see it go to all members of the cluster.</p><p>The following is the Java code for the client project:</p><div class="informalexample"><pre class="programlisting">public static void main(String[] args) throws Exception { Timeout timeout = new Timeout(Duration.create(5, "seconds"));
ActorSystem system = ActorSystem.create("clientSystem");
        Set&lt;ActorSelection&gt;initialContacts = new HashSet&lt;ActorSelection&gt;();
        initialContacts.add(system.actorSelection("akka.tcp://Akkademy@127.0.0.1:2552/user/receptionist"));
initialContacts.add(system.actorSelection("akka.tcp://Akkademy@127.0.0.1:2551/user/receptionist")); ActorRef receptionist = system.actorOf(ClusterClient.defaultProps(initialContacts)); ClusterClient.Sendmsg = new ClusterClient.Send("/user/workers", articleToParse, false); Future f = Patterns.ask(receptionist, msg, timeout); String result = (String) Await.result(f, timeout.duration()); System.out.println("result: " + result);
    }</pre></div><p>And the<a id="id473" class="indexterm"></a> following is the Scala code for the client project:</p><div class="informalexample"><pre class="programlisting">def main(args: Array[String]) { val timeout = new Timeout(Duration.create(5, "seconds")) val system = ActorSystem.create("clientSystem")
valinitialContacts: Set[ActorSelection] = Set( system.actorSelection("akka.tcp://Akkademy@127.0.0.1:2552/user/receptionist"), system.actorSelection("akka.tcp://Akkademy@127.0.0.1:2551/user/receptionist") )
    import collection.JavaConversions._ val receptionist = system.actorOf(ClusterClient.defaultProps(initialContacts)) valmsg = ClusterClient.Send("/user/workers", articleToParse, false) val f = Patterns.ask(receptionist, msg, timeout) val result = Await.result(f, timeout.duration).asInstanceOf[String] println("result: " + result)
  }</pre></div><p>We'll look at what is happening in the code step by step.</p><p>First, we define a <code class="literal">timeout</code> variable to use in our test here as we will ask and wait for the result. In real situations, you will likely be using an actual actor to send and receiveâ€”this is just for the sake of example. We create the actor system for the client.</p><p>Now, we need to produce the client that talks to the receptionist in the cluster. We create the contact list for the receptionists of the seed nodes for our client to talk to. After getting the set of seed node addresses, we can then create the <code class="literal">ClusterClient</code> actor:</p><div class="informalexample"><pre class="programlisting">system.actorOf(ClusterClient.defaultProps(initialContacts))</pre></div><p>At this point, our<a id="id474" class="indexterm"></a> application is able to connect to the cluster and get information about any changes to the cluster topology. The receptionist in the remote actor system will accept a few different messages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">ClusterClient.Send</code>: This sends a message to a random node.</p></li><li style="list-style-type: disc"><p>
<code class="literal">ClusterClient.SendToAll</code>: This sends a message to all actors in the cluster.</p></li><li style="list-style-type: disc"><p>
<code class="literal">ClusterClient.Publish</code>: This sends a message to all actors subscribed to a topic.</p></li></ul></div><p>We only need to send the message to a random worker; so, <code class="literal">Send</code> is fine for our case. We make the Send object, describing which actor the message is destined for (the "workers" router running on each node of the cluster) and wrapping our message in it:</p><div class="informalexample"><pre class="programlisting">newClusterClient.Send("/user/workers", articleToParse, false)</pre></div><p>Finally, we use ask to send the message to the receptionist <code class="literal">ActorRef</code> to deliver, and to get the result back (shown calling ask method, but in Scala we can also use the '?' operator):</p><div class="informalexample"><pre class="programlisting">Patterns.ask(receptionist, msg, timeout);</pre></div><p>We take the future that ask gives us and wait for the resultâ€”again, this is only for the sake of an example. You never want to block threads by waiting in your code.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>If a node becomes unavailable when you try to send it a message, your request will time out and fail. It is your responsibility to handle timeout and retry semantics, or otherwise handle failure cases.</p></div><p>That's all that it takes to use Akka to build distributed workers. Now, there are a lot of things we would want to do to further improve this system. If there are potentially lots of messages, we would likely want to put the messages somewhere other than in the mailbox in memory. Likely, some sort of durable queue or database would be used instead of ephemeral memory. Though, for real-time processing, this isn't a bad start. For a client, we would likely want to build timeout and retry mechanics as well to ensure that we always get the work done that we need done.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec76"></a>Building a Distributed Key Value Store</h4></div></div></div><p>We've looked <a id="id475" class="indexterm"></a>at everything that it takes to build on top of Akka cluster and we looked at a small example of a stateless cluster of workers. If state is involved, the problem becomes incredibly difficult to get right.</p><p>In the next section, we'll look at the watchouts, tools, and techniques for handling distributed systems that contain state such as a key-value store.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec77"></a>Disclaimer â€“ Distributed Systems are Hard</h4></div></div></div><p>Before we go on to look at how to build a distributed key-value store, I want to give you a word of warning.</p><p>It's not terribly difficult to build distributed systems that appear to work perfectly fine. You might get confident and feel that it's not all that hard after all. You'll tout yourself soon as an expert Distributed Systems Person. But stay humbleâ€”in reality, things fail, networks partition, and services become unavailableâ€”and gracefully handling those scenarios without data loss or corruption is an incredibly difficult problem. Perhaps, even an unsolvable one with our network technology today.</p><p>How applications respond in those error cases can be more important than their primary functionality because failure is common and, in fact, is inevitable as you scale up. </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Tip</h3><p>Remember that the network is not reliable. In a cluster of 1,000 nodes running in AWS, it's very likely that there will be some service interruption somewhere in your system at any given time.</p></div><p>So, how do all of these new-fangled <code class="literal">NoSql</code> data-stores actually stack up in their claims of availability and partition tolerance then? There is an interesting series of articles called <span class="emphasis"><em>Jepsen</em></span> or <span class="emphasis"><em>Call Me Maybe</em></span> on <a class="ulink" href="http://aphyr.com" target="_blank">aphyr.com</a> that tests several distributed system's documented claims about resiliencyâ€”you might be surprised by how your favorite technology fairs in some of the tests run in the articles.</p><p>This book will not be able to explain all of the techniques or examine all of the solutions to these problems, so all that I can do as the author is to warn you that it's a real can of worms and nobody has done a perfect job at solving the distribution problem yet.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec80"></a>Designing the Cluster</h3></div></div></div><p>We are going to build <a id="id476" class="indexterm"></a>a very simple three-node data-store to start demonstrating the techniques that can be used in distributed systems. We are going to look at a couple different designs so that you understand the techniques that are used and what the problems are that distributed systems try to solve.</p><p>First, let's begin talking about our cluster and how the client interacts with it. Ideally, we need our multi-node key-value store to offer a few features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Mechanisms for replicating data to gracefully handle a node partition</p></li><li style="list-style-type: disc"><p>Mechanism for giving a consistent view of replicated dataâ€”to give the most recent update when a client requests it (consistency)</p></li><li style="list-style-type: disc"><p>Mechanism for linear scalabilityâ€”20 nodes can handle twice as much throughput as 10 nodes</p></li></ul></div><p>In terms of design goals in meeting those objectives, we would like to have a database that is highly available, partition tolerant, and able to give a consistent view of the most recent data. Achieving all three perfectly is not likely possible with our technology today, but we can take measures to try. We're lucky that a lot of very smart people have been working on these problems; thus, we have access to their research and publications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec78"></a>Basic Key-Value Store Design</h4></div></div></div><p>We've already looked at how a <a id="id477" class="indexterm"></a>single node can store an object in a map with a key associated with it. Using a <code class="literal">HashMap</code> gives approximate constant time lookups, so it's a very efficient choice for storing data in memory.</p><p>An actor will accept <code class="literal">Get</code> messages with a key, and Put messages with a key and a valueâ€”exactly as demonstrated in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Actors and Concurrency</em></span>. To recap, our node will have an actor that looks like the following:</p><div class="informalexample"><pre class="programlisting">//Java
    private AkkademyDb(){ receive(ReceiveBuilder. match(SetRequest.class, message -&gt; { log.info("Received Set request: {}", message); map.put(message.key, message.value); sender().tell(new Status.Success(message.key), self()); }). match(GetRequest.class, message -&gt; { 
                             log.info("Received Get request: {}", message); Object value = map.get(message.key); Object response = (value != null) ? value : new Status.Failure(new KeyNotFoundException(message.key)); sender().tell(response, self()); }). matchAny(o -&gt; sender().tell(new Status.Failure(new ClassNotFoundException()), self()) ).build() ); } //Scala override def receive = { case SetRequest(key, value) =&gt; log.info("received SetRequest - key: {} value: {}", key, value) map.put(key, value) sender() ! Status.Success case GetRequest(key) =&gt; log.info("received GetRequest - key: {}", key) val response: Option[Object] = map.get(key) response match{ case Some(x) =&gt; sender() ! x case None =&gt; sender() ! Status.Failure(new KeyNotFoundException(key)) } case o =&gt;Status.Failure(new ClassNotFoundException)
  }</pre></div><p>I would recommend that you add other messages for common use cases if you're going to attempt to implement this. Semantics like <code class="literal">SetIfNotExist</code>, which sends back a failure if the node is already there, is useful for handling concurrency consistentlyâ€”getting and then setting the value <a id="id478" class="indexterm"></a>if it does not exist is not at all consistent enough for a distributed workflow. Redis API docs are a good resource to look at if you want to see the types of messages and datatypes that are useful for a key-value store to handle with multiple clientsâ€”it's a simple and readable document that will go a long way to ramp you up in the problem space.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec79"></a>Coordinating Node</h4></div></div></div><p>Now that we have a picture<a id="id479" class="indexterm"></a> of how we'll store data in a node, we need to look a bit higher level at how we want messages to be handled between a client using the data-store and the cluster.</p><p>We have a client example that sends a message to a random node and that's actually quite a good start for most distributed stores because very often such systems will implement the concept of a coordinating node that can be any node in the cluster that will handle talking to other nodes in the cluster to handle the request.</p><p>It's probably unclear at this point exactly why we would do this, but let's imagine a coordinating node that needs to talk to three other nodes to get a definitive answer on what a value is.</p><div class="mediaobject"><img src="graphics/B04006_06_07.jpg" /></div><p>If we implement this logic, a <a id="id480" class="indexterm"></a>client can send the request to any node in the cluster, and that node becomes the coordinator for the request. That node then goes to the other nodes and requests the data that it needs to make a decision on what the value is that is being retrieved. So, we can continue to use the random delivery mechanism if we implement the coordination logic on the server instead of the client. Because we're not sure where the client is located, it's safer to move this responsibility into the cluster itselfâ€”we can be more confident that the nodes we need to talk to have lesser leaps across the network in the majority of circumstances. This is how Cassandra handles requests for example.</p><p>We'll look at two models: one for storing a data set across multiple nodes and one for replicating data across multiple nodes.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch06lvl4sec26"></a>Sharding for Linear Scalability</h5></div></div></div><p>The first problem we will look <a id="id481" class="indexterm"></a>to solve is how to assign a piece of a problem domain to different nodes in a cluster. In the case of storing data in a key-value store, it's easy to see how you might take slices of data (determined by the key) and assign them to different nodes. In Cassandra, a key used to determine which node data goes to is called a partition key.</p><p>For our use case of a very simple key-value store, we can take a key and hash it, and then execute modulus on the hash to get an integer value. Let's assume we have three nodes that we want to store data on. A request goes to a node in the cluster to store a key-value pairâ€”for example, <code class="literal">foo</code> as the key and <code class="literal">bar</code> as the value. The coordinating node will execute <code class="literal">hashCode()</code> on the key:</p><div class="informalexample"><pre class="programlisting">"foo".hashCode() (101574)</pre></div><p>Then, it will call the modulus operator on the <code class="literal">hashcode</code>, giving a result of <code class="literal">0</code>, <code class="literal">1</code>, or <code class="literal">2</code>:</p><div class="informalexample"><pre class="programlisting">101574 % 3 (0)</pre></div><p>Now, if we have three nodes that we want to store data on, then we know if we want to set or get a value with the key <code class="literal">foo</code> that it goes on the first node. This approach of sharding data is used in many distributed data-stores today.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec80"></a>Redundant Nodes</h4></div></div></div><p>To have high availability and partition<a id="id482" class="indexterm"></a> tolerance, we have to tolerate a node disappearing from the cluster for both reads and writes. If one node disappears, this should be a non-critical failure and the data-store should continue to operate to meet our goals.</p><p>To accomplish this, we can send all writes to three nodes and hope that the majority of them respond with an acknowledgment. If only two respond with an ok, we might be able to handle that on future reads. Now, all the intricacies of this mechanismâ€”and specifically how to determine the ordering of eventsâ€”cannot be covered here, but you can look at lamport clocks or vector clocks if you're motivated to get this right. We'll look at the mechanics at a high level here using simpler mechanics that are easier to comprehend.</p><p>Let's say a client wants to write a value for key <code class="literal">foo</code> of value <code class="literal">bar</code>, we want to persist this to three nodes. We'll try to write the value to three nodes from the coordinating node.</p><p>We can reference the previous diagramâ€”a client will make a request to write and it goes to three nodes in the cluster. To have a successful write, we might agree that at least two of the nodes need to acknowledge the write, or maybe all three do. Adjusting these values tune how it responds to partitions and node failures.</p><p>Now, if we want to retrieve the value, then we can request the data from any of the three nodes as a starting point, but what if one node goes down and misses some writes? In this case, we can request the data from all three nodes, and require the same value from at least two nodes.</p><div class="mediaobject"><img src="graphics/B04006_06_08.jpg" /></div><p>Now, we have some way of <a id="id483" class="indexterm"></a>determining what the majority of nodes think the value isâ€”we say that two nodes must have the same value to determine which it should be.</p><p>But how do we know the order of values? Was <code class="literal">bar1</code> or <code class="literal">bar2</code> written first? Which is more recent? We actually don't have any way of determining the ordering of messages, which it turns out is quite a problem. What happens if one node gets writes in a different order than another node? Cassandra has another read request type called a read repair request, which compares the data stored for a key on all of the replica nodes and tries to propagate the most recent write to the replicas.</p><p>The actual ordering of events is an interesting problem. You could start by using a timestamp in the record to determine which records are most recent, but we can't guarantee that all machines have the same clock or that events are occurring infrequently enough to trust the timestamp.</p><p>There are a couple of papers<a id="id484" class="indexterm"></a> and algorithms you can look at that describe the problem and some solutions. Some of the items you may want to look at are Vector Clocks (Used by many distributed technologies such as Akka and Cassandra) and Dotted Version Vectors (used by Basho's Riak in recent versions).</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The Dynamo paper from Amazon describes the use of <a id="id485" class="indexterm"></a>Vector Clocks in Amazon's Dynamo distributed key-value storeâ€”<a class="ulink" href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank">http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a>
</p></li><li style="list-style-type: disc"><p>Lamport wrote a paper on the problem of ordering in distributed systems<a id="id486" class="indexterm"></a> in 1978 that is worth a look as wellâ€”<a class="ulink" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf" target="_blank">http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf</a>
</p></li></ul></div></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec44"></a>Combining Sharding and Replication</h2></div></div><hr /></div><p>Once we have <a id="id487" class="indexterm"></a>approaches in place for sharding and replication, we will be able to combine the two together by first sharding data into a ring and then replicating the data to the neighboring nodes. Let's say we have five partition keys, and we want to replicate the data across three nodes; with five nodes, we end up with a topology that looks like the following, with the numbers representing the hash of the partition key as demonstrated:</p><div class="mediaobject"><img src="graphics/B04006_06_09.jpg" /></div><p>The request goes to a <a id="id488" class="indexterm"></a>random node that becomes the coordinating node. That node would then calculate key partition key and go to the three nodes that have the data set. The retrieval and handing of the data at that point is no different than what we have looked at.</p><div class="mediaobject"><img src="graphics/B04006_06_10.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec81"></a>Pre-Sharding And Redistributing Keys to New Nodes</h3></div></div></div><p>What happens if<a id="id489" class="indexterm"></a> you want to be able to add new nodes? For example, what if <a id="id490" class="indexterm"></a>you want to keep your replication factor of <code class="literal">3</code> and add <a id="id491" class="indexterm"></a>two new nodes? If our partition key is only <code class="literal">0</code>â€“<code class="literal">4</code>, then we can't move the data across new nodes.</p><p>The trick to this problem is to not use five partition keys but to use a much larger number. Cassandra has a concept of a vnodeâ€”a virtual nodeâ€”whereby a cluster has a larger number of shards than nodes out of the gate. If you start by sharding your database into 64 or 128, then you can add new nodes and move a portion of the partition keys to new nodes as they come into the cluster.</p><div class="mediaobject"><img src="graphics/B04006_06_11.jpg" /></div><p>Then the coordinating<a id="id492" class="indexterm"></a> node can talk to the new node, understanding it <a id="id493" class="indexterm"></a>has been assigned a new set of partition keys. Note that moving data around to a new node is a one-time operation and likely requires you to stop all operations on all nodes until the re-distribution of partition keys is complete. If your partition is under heavy write through the operation, it might be difficult to ensure no data loss through the operation otherwise.</p><p>It will be simpler to assign a fixed size to the cluster until you can eventually get to these features. Akka Cluster has mechanisms to only start a cluster once it reaches a certain size. If you want to try building your own distributed key-value store, you should assume it has a fixed size and a known number of partition keys, and add pre-sharding and re-distributing keys as features later because they are non-trivial problems to solve.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec45"></a>Addressing Remote Actors</h2></div></div><hr /></div><p>We've focused heavily on<a id="id494" class="indexterm"></a> implementation details, but to round out this chapter, we should have a quick look at Actor Addressing again and how to get references to remote actors.</p><p>If we have an <code class="literal">ActorRef</code>, calling <code class="literal">actorRef.path()</code> will give us the actors URLâ€”<code class="literal">akka://ActorSystem/user/actor</code>.</p><p>There are two parts to the path:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>authority</strong></span>: <code class="literal">akka://ActorSystem</code>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>path</strong></span>: <code class="literal">/user/actor</code>
</p></li></ul></div><p>Authority can be either local (<code class="literal">akka://ActorSystem</code>) or remote (<code class="literal">akka.tcp://ActorSystem@127.0.0.7</code>). The path will be the same for both local and remote actors <code class="literal">(/user/actor</code> for example).</p><p>An <code class="literal">ActorRef</code> will have an <code class="literal">ActorPath</code> with a fragment <code class="literal">#123456</code>, which is what is called the actor's UID. An <code class="literal">ActorPath</code> will notâ€”it will just have the path.</p><p>We looked at <code class="literal">ActorSystem.actorSelection</code> earlier, which will let us look up an Actor with any path and send it messages:</p><div class="informalexample"><pre class="programlisting">ActorSelectionactorSelection = actorSystem.actorSelection("akka.tcp://ActorSystem@127.0.0.7/user/my-actor");
valactorSelection = actorSystem.actorSelection("akka.tcp://ActorSystem@127.0.0.7/user/my-actor")</pre></div><p>That gives us an actor selection, which <a id="id495" class="indexterm"></a>we can send messages to. Although, the actor selection does not assume that an actor exists. If we send messages to an <code class="literal">ActorSelection</code> and the actor does not exist, the message will disappear. Thus, we can look up an actor and get an <code class="literal">ActorRef</code> for a remote actor.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec82"></a>Using akka.actor.Identify to Find a Remote Actor</h3></div></div></div><p>All actors by default <a id="id496" class="indexterm"></a>accept a messageâ€”<code class="literal">akka.actor.Identify</code>. We can<a id="id497" class="indexterm"></a> create a new Identify message and send it to an actor to get an <code class="literal">ActorRef</code>:</p><div class="informalexample"><pre class="programlisting">Identify msg = new Identify(messageId) Future&lt;ActorIdentity&gt; identity = (Future&lt;ActorIdentity&gt;) Patterns.ask(actor, msg, timeout);
valmsg = Identify(messageId) val identity: Future[ActorIdentity] = (sentinelClient ? msg).mapTo[ActorIdentity]</pre></div><p>We will receive a responseâ€”<code class="literal">ActorIdentity</code>(<code class="literal">messageId</code>, <code class="literal">Some</code>(<code class="literal">actorRef</code>)), or <code class="literal">ActorIdentity</code>((<code class="literal">path</code>, <code class="literal">client</code>), <code class="literal">None</code>)â€”showing that an actor is either present or absent. This gives us a mechanism for determining if a remote actor exists and obtaining an <code class="literal">ActorRef</code> for it.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec46"></a>Homework</h2></div></div><hr /></div><p>This chapter is a blend of theory and technique. We covered how to use Akka cluster to run work on and then how to use it to distribute datasets partitioned by key. The problems are too big to cover in an introductory chapter to Cluster, but if you try to approach some of the problems presented in this chapter, you should start to get a good handle on how people solve some of these problems today.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Build your own worker queue using Cluster.</p></li><li style="list-style-type: disc"><p>Build a distributed key-value store with replication.</p></li><li style="list-style-type: disc"><p>Try to solve the linearization problemâ€”how can you determine ordering? How can you "repair" nodes that fail and then recover?</p></li><li style="list-style-type: disc"><p>Build a distributed key-value store with sharding.</p></li><li style="list-style-type: disc"><p>Can you combine sharding and replication with minimal changes to the code you have now as described?</p></li><li style="list-style-type: disc"><p>In the sharded model, can you develop a way to redistribute data to new nodes? Is it harder to do this with replication? About the same difficulty?</p></li><li style="list-style-type: disc"><p>If you build a project, you should open source it and share your discoveries and learning!</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec47"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we covered the basics of how you might design some different distributed systems. This gives you a few models that you can use for various problemsâ€”don't simply think of sharding/partitioning when dealing with dataâ€”you can use similar techniques for many real-time system problems to be able to scale out.</p><p>If you'd like to learn more about the techniques introduced here, you should both continue your learning and try to build the solutions to these problems yourself. In my humble opinion, the best way to learn is to teach and share, so try to start a distributed computing club or otherwise get some presentations together for your peers on how these technologies workâ€”organizing your thoughts will help you get into the details and find your own way in discovering how we're moving to solve these types of distributed computing problems today.</p><p>In the next chapter, we'll discuss what happens in mailboxes when our actors get put under heavy load and look at how we can adjust mailbox configuration to adapt to those conditions.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch07"></a>ChapterÂ 7.Â Handling Mailbox Problems</h2></div></div></div><p>Congratulations! You've made it through all of the tough content now. You've learned Akka, you've learned how to scale it, and how to describe your system's behavior in those situations!</p><p>In this chapter, we will look at what happens when you start to hit the limits of your actor system and how to describe how your system should behave in those situations.</p><p>Let's start by setting the stage for the problem and then look at different approaches we can use to overcome these issues.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Overwhelming your weakest link</h2></div></div><hr /></div><p>To continue our running example, imagine we have an application that extracts articles and stores the body in our key-value store. The extracted articles are then displayed on various devices that have a reader application.</p><p>You've launched the application and have a growing user base. Everything is working fine. People can request articles to read from the device on their application; it hits a public REST API, which makes a request to the parse service. The parse service will check the store and, if the article has not been parsed, then it will parse it and then cache it.</p><p>The following figure represents the flow of articles as they are parsed and stored:</p><div class="mediaobject"><img src="graphics/B04006_07_01.jpg" /></div><p>Let's imagine a day when several good events happen. Our app shows up in the number 1 spot, for example on Hacker News, all day and we get 10x more traffic than we have ever seen.</p><p>First, we start to see timeouts in the REST API application. Response times balloon when making requests from the API. Eventually, the article parse services crash with out-of-memory errors, so we start to analyze the traffic in the application under load. Because article parsing is the most processing intensive piece of the application, lots of messages will get queued there. This is the slowest service in our data flow.</p><div class="mediaobject"><img src="graphics/B04006_07_02.jpg" /></div><p>Remember that messages go into a mailbox in memory. If a service is consuming messages slower than the rate at which they are delivered, then mailboxes will become more and more full. Let's look at the events that occurred when we saw the load, in a bit more detail to understand why they occur. We can look at different ways in which we can configure our application to make sure it stays up the next time we're overwhelmed like this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec83"></a>Ballooning response times</h3></div></div></div><p>The first thing we'll see when we start<a id="id498" class="indexterm"></a> overwhelming our slow article parse worker consumer is increasing response times. If our ArticleParser can process 100 articles in a second, and we send it 101 articles a second, then messages will slowly accumulate. After 1,000 seconds, there will be 1,000 messages queued up in the mailbox.</p><p>Once there is a queue of messages, any messages that have been received first will need to be processed before any new messages can be processed, so what we will see is response times start to grow.</p><p>The more these unhandled messages are queued, the longer it takes to process new messages.</p><div class="mediaobject"><img src="graphics/B04006_07_03.jpg" /></div><p>A slow consumer of <a id="id499" class="indexterm"></a>messages will cause downstream problems as well. If you have a very fast consumer behind a slow consumer, your response times will be primarily affected by your slowest consumer. So we have to focus on the slowest consumer to make our system respond better. One of our goals in a reactive system design is to ensure it is always responsive, so this violates the responsiveness principle.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec84"></a>Crashing</h3></div></div></div><p>If we continue to try to push <a id="id500" class="indexterm"></a>more and more messages through the system, we'll eventually have a very large number of messages in the slow message consumer's mailbox, which causes a far worse problem to occurâ€”crashes due to out-of-memory errors.</p><p>Once response times get to this point, people trying to use the service are probably going to be hitting retry again and again, piling even more messages into the mailbox of our already overburdened services.</p><p>The default mailbox is unbounded, meaning that the service will accumulate messages indefinitely. Resources are limitedâ€”the JVM only has so much memory availableâ€”so eventually the slow message consumer will have so many messages in memory that the JVM will not have the memory needed to create new objects and will crash.</p><div class="mediaobject"><img src="graphics/B04006_07_04.jpg" /></div><p>If we have a cluster of <a id="id501" class="indexterm"></a>workers, as demonstrated in the previous chapter, the crashing of one node in the cluster means that other members of the cluster will suddenly start receiving more messages. The effect is usually a cascading oneâ€”more messages go to the other nodes and eventually they will crash as well. When the whole system goes down, then we're completely unavailable.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Resiliency</h2></div></div><hr /></div><p>We've covered the reactive tenets <a id="id502" class="indexterm"></a>in previous chapters. The behavior of our application violates a couple of the reactive tenets: resiliency and responsiveness.</p><p>We'll ignore responsiveness for now and focus on how we can change our application to stay up instead of crashing when it's overwhelmed.</p><p>The crashing is caused by an unbounded mailbox, so we can start by changing the mailbox of the actor. An unbounded mailbox is an un-defensive positionâ€”we assert that our application will always catch up and handle messages if we don't put a limit on its size.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec85"></a>Mailboxes</h3></div></div></div><p>Up to this point, we've largely<a id="id503" class="indexterm"></a> ignored mailboxes. We've simply known that messages get placed there, and then messages are processed. That's a perfectly fine level of abstraction for you until you're facing a reasonably large scale usage. That's why this chapter is at the end of this bookâ€”you're introduced to the mailbox very early, but you might not need to tune it until you're handling real traffic.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec81"></a>Configuring mailboxes</h4></div></div></div><p>Mailboxes are configured in<a id="id504" class="indexterm"></a> Akka in one of several different ways. You can refer to the <a id="id505" class="indexterm"></a>Akka Mailboxes documentation (<a class="ulink" href="https://doc.akka.io/docs/akka/snapshot/scala/mailboxes.html" target="_blank">https://doc.akka.io/docs/akka/snapshot/scala/mailboxes.html</a>) if you need more details.</p><p>In nearly all cases, actors get their own mailboxes, with the exception being <code class="literal">BalancingDispatcher</code> used by <code class="literal">BalancingPool</code>, which shares a mailbox between all of its actors as covered in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Scaling Up</em></span>. So there are two areas where an Actor's mailbox is determinedâ€”in the actor configuration and in the dispatcher configuration.</p><p>We'll cover the different ways in which the mailbox configuration can be set.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch07lvl4sec27"></a>Selecting a mailbox in deployment configuration</h5></div></div></div><p>We've <a id="id506" class="indexterm"></a>programmatically defined<a id="id507" class="indexterm"></a> and instantiated actors. Akka's deployment configuration can also be used to configure actors and routers from the configuration file.</p><p>You can define an actor's mailbox (by actor path) in the deployment configuration. If this is defined, this will take priority over any other configured mailboxes. In application.conf, you would define an actor's mailbox like the following:</p><div class="informalexample"><pre class="programlisting">akka.actor.deployment { /myactor { mailbox = default-mailbox } }</pre></div><p>The actor created at <code class="literal">/user/myactor</code> would then have the default mailbox:</p><div class="informalexample"><pre class="programlisting">ActorRefclusterController = system.actorOf(Props.create(MyActor.class), "myactor"); system.actorOf(Props[MyActor], "myactor")</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch07lvl4sec28"></a>Selecting a mailbox in code</h5></div></div></div><p>You can also <a id="id508" class="indexterm"></a>define which mailbox is used in code. <code class="literal">Props</code> has a <code class="literal">withMailbox</code> method<a id="id509" class="indexterm"></a> that can be called to assign a mailbox when the actor is created:</p><div class="informalexample"><pre class="programlisting">ActorRefclusterController = system.actorOf(Props.create(MyActor.class).withMailbox("default-mailbox")); system.actorOf(Props[MyActor].withMailbox("default-mailbox")</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec82"></a>Deciding which mailbox to use</h4></div></div></div><p>The default mailbox <a id="id510" class="indexterm"></a>will work with all use cases including <code class="literal">BalancingPool/BalancingDispatcher</code>, where a mailbox is shared between multiple actors.</p><p>Unless you're using the <code class="literal">BalancingPool</code>, you will always have a single consumer of messages from the mailbox.</p><div class="mediaobject"><img src="graphics/B04006_07_05.jpg" /></div><p>Instead of using the default mailbox, in this case you can use <code class="literal">SingleConsumerOnlyUnboundedMailbox</code>, which can be more efficient than the default mailbox in most cases (remember to always measure performance related changes). The only time you cannot use this mailbox is with <code class="literal">BalancingPool/BalancingDispatcher</code>, where multiple actors consume messages from the same mailbox. The queue implementation is single-consumer only.</p><p>First we'll define a mailbox in our application.conf:</p><div class="informalexample"><pre class="programlisting">akka.actor.mymailbox{ mailbox-type = "akka.dispatch.SingleConsumerOnlyUnboundedMailbox" }</pre></div><p>Then we can make the actors with the mailbox:</p><div class="informalexample"><pre class="programlisting">ActorRefclusterController = system.actorOf(Props.create(MyActor.class).withMailbox("akka.actor.mymailbox")); system.actorOf(Props[MyActor].withMailbox("akka.actor.mymailbox")</pre></div><p>We will often need to <a id="id511" class="indexterm"></a>decide whether we want to use a bounded or unbounded mailbox. Unbounded mailboxes are preferable in most cases for performance reasons, but what we've set out to do in our example is to use a bounded mailbox to drop messages. We don't want to run out of memory if we get overwhelmedâ€”we would rather drop some messages.</p><p>There are two types of bounded mailboxesâ€”blocking and non-blocking. All mailboxes are backed by queues. Blocking versus non-blocking in this case means that the delivery of a message to a full mailbox will either cause the thread to wait until there is room (blocking) or will drop the message (non-blocking.) We've decided to drop the messages so we can settle on the <code class="literal">NonBlockingBoundedMailbox</code>. We'll add the mailbox in our configuration:</p><div class="informalexample"><pre class="programlisting">akka.actor.boundedmailbox{ mailbox-type = "akka.dispatch.NonBlockingBoundedMailbox" mailbox-capacity = 1000000 }</pre></div><p>And then instantiate the actors with it:</p><div class="informalexample"><pre class="programlisting">ActorRefclusterController = system.actorOf(Props.create(MyActor.class).withMailbox("akka.actor.boundedmailbox")); system.actorOf(Props[MyActor].withMailbox("akka.actor.boundedmailbox")</pre></div><p>Now, if our system gets overwhelmed, we'll lose some messages, but things will stay up.</p><p>What happens if messages get dropped? Well, your systems that communicate with downstream systems should have timeout and retry semantics baked in. You can expect that messages will get dropped occasionally, so if you need at least once processing, you need to build your systems to keep track of requests and retry them if they fail for any reason. In the case of our example application, the client will probably get an error, so the user can choose to retry. In your own systems, timeout and retry mechanisms can easily be built.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch07lvl4sec29"></a>Prioritizing messages in mailboxes</h5></div></div></div><p>There are two other <a id="id512" class="indexterm"></a>families of mailboxes that you should be aware of: priority<a id="id513" class="indexterm"></a> mailboxes and control aware mailboxes. They both serve a similar purpose: allowing the ordering of messages.</p><p>Priority mailboxes allow messages to be prioritized and sorted after they are delivered to the mailbox. This has a fairly significant performance overhead: the queue that backs the mailboxâ€”java <code class="literal">BlockingPriorityQueue</code>â€”has to reorder messages as they come in, which means that both producers and consumers of the queue have to wait around while messages are shuffled around. Fortunately, there aren't many cases where reordering messages is important, so you won't need to use these mailboxes in most use cases.</p><p>There is one case, though, that would be common, and that's if you need to give your actor some sort of control message to let them know that something has changed that will affect how they process any queued messages.</p><p>Fortunately, there is another mailbox typeâ€”a <code class="literal">ControlMessageAware</code> mailboxâ€”that handles messages with an efficient queue but allows any message that extends <code class="literal">akka.dispatch.Controlmessage</code> goes to the front of the queue. This is a much better solution than priority mailboxes and should be your preference if you need to get a message to an actor in front of the rest of the queue without more complex ordering.</p><p>We don't need to look at these in depth as they are very rarely used, but it's important to understand that they do exist. The Akka documentation covers their use in greater detail.</p><p>As one final note, it's worth mentioning that if none of the mailboxes fit your use case, then you can create your own.</p></div></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec50"></a>Staying responsive under load</h2></div></div><hr /></div><p>We've now looked at how we can drop messages if we get overwhelmed. This lets our application stay up instead of running out of memory if the mailbox gets too full.</p><p>Let's take a minute to look at what happens with our application once it gets under a very heavy load now.</p><p>The application is humming along, and then some promotion of your app happens again and sends way more traffic to the<a id="id514" class="indexterm"></a> site than we anticipate or are provisioned to handle. Just as before, more messages start coming in than we have the capacity to handle, so they begin to build up in the mailbox. It starts to take longer to handle a given message because we have to handle the backlog of messages in the mailbox first.</p><p>Eventually, under the continued heavy load, the mailbox will reach the bounded limit we configured. At this point, it will start dropping messages. If we had used the blocking bounded mailbox, then the thread would sit and wait until the message could be placed in the mailbox. Either way, now we have a way of ensuring our application doesn't crash.</p><p>But is this a good solution? We<a id="id515" class="indexterm"></a> can look at the bounded mailbox capacity at a few levels and determine how we can expect our applications to behave:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If we have a very small bounded mailbox, any spikes in traffic will cause messages to be lost, which the application might be able to respond to in a reasonable amount of time</p></li><li style="list-style-type: disc"><p>If we have a very large bounded mailbox, the requests will likely time out before the actor can reply to them</p></li></ul></div><p>In either case, the user has to wait for the timeout to occur. If the mailbox is very small, the dropped message will simply disappear and, so, anyone waiting on a reply will timeout and fail. If the mailbox is very large or unbounded, even if the message is eventually processed, anyone waiting for a reply will eventually timeout and fail, for example, in their browser or dependent application. You'll have to evaluate your use case to see if either of these are suitableâ€”if you don't care about the response or can tolerate messages being lost during spikes in traffic, then these may be acceptable.</p><p>For most cases, in real-time systems, waiting for very long periods of time is not acceptable, especially waiting just to receive an error.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec86"></a>Circuit breakers</h3></div></div></div><p>With responsiveness as a <a id="id516" class="indexterm"></a>goal in our systems, any of the situations where we make users wait for failure are not really acceptable. Similarly, with resiliency as a goal, allowing systems to become overwhelmed with messages to the point that a component fails completely is not acceptable either.</p><p>Circuit breaker is a pattern where some path through your application is monitored for the latency of the responses or error. Messages pass through the circuit breaker as they normally would, with the response time on the messages being measured. This state is "closed."</p><div class="mediaobject"><img src="graphics/B04006_07_06.jpg" /></div><p>Once a certain latency <a id="id517" class="indexterm"></a>threshold is reached, the circuit breaker will change states to 'open' and will immediately fail all requests.</p><div class="mediaobject"><img src="graphics/B04006_07_07.jpg" /></div><p>Then, after a period of time, the circuit breaker will change states to "'half-open'" and try sending a request.</p><div class="mediaobject"><img src="graphics/B04006_07_08.jpg" /></div><p>If the request comes back<a id="id518" class="indexterm"></a> quickly, we can assume that the service has recovered and the circuit breaker can change states back to "open".</p><p>It turns out that this is exactly what we want.</p><p>If the circuit breaker opens, in this condition this system gains the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Responsiveness</strong></span>: The service will respond with failures quickly</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Resiliency</strong></span>: Instead of overwhelming downstream services until they crash, the circuit breaker will let them recover</p></li></ul></div><p>Note that the circuit breaker will also respond to errors the same way as timeouts. If many errors are occurring, it will also cause the circuit breaker to open. The Akka circuit breaker does not discriminate between timeouts and other failures (this is probably what we want!) but you can certainly implement your own if you want to change that behavior. If a downstream system starts failing under heavy load, we can often make similar assumptionsâ€”that it needs time to recover from the loadâ€”so, often the circuit breaker pattern will be a good idea to implement in order to protect downstream systems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec83"></a>Circuit breaker listeners</h4></div></div></div><p>We might not know exactly how <a id="id519" class="indexterm"></a>and when our circuit breakers will trip when we put them into production. So, what we want to do is to collect data. Remember, we always want to measure any assertions we make about how things actually perform as we're often very, very wrong.</p><p>Fortunately, the circuit breaker has hooks that let us add behavior on the different events that occurâ€”<code class="literal">onOpen</code>, <code class="literal">onClose</code>, and <code class="literal">onHalfOpen</code>.</p><p>You want to alert, or at least log, on these events so that you can determine how your circuit breakers are behaving.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec84"></a>Circuit breaker examples</h4></div></div></div><p>Circuit breakers work<a id="id520" class="indexterm"></a> on futures, not on actors, so they have a use beyond only using them for actors. Even if you're not using Akka in your project, you should consider whether circuit breakers can be used to protect your systems.</p><p>We'll have a look at a simple <code class="literal">CircuitBreaker</code> example now in front of a service that takes some time to respond. For the example, we'll use a local actor, but we'll add a delay to the response to simulate network time and processing time.</p><p>To see the circuit breaker in action, we'll make a producer that produces messages at a slightly faster rate than the target actor can handle. We'll make a producer that produces messages every 50 ms and we'll make the consumer take 70 ms to respond. This way, messages will slowly queue and the response times will get larger and larger until the circuit breaker trips.</p><p>We'll use the key-value store example again and introduce the 70 ms delay.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">                        match(GetRequest.class, message -&gt; { Thread.sleep(70); //slow down the actor's response Object value = map.get(message.key); Object response = (value != null) ? value : new Status.Failure(new KeyNotFoundException(message.key)); sender().tell(response, self());</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">    case GetRequest(key) =&gt; Thread.sleep(70) val response: Option[Object] = map.get(key) response match { case Some(x) =&gt; sender() ! x case None =&gt; sender() ! Status.Failure(new KeyNotFoundException(key)) }</pre></div><p>In our calling class, we'll create a circuit breaker that will trip when latency becomes greater than one second.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">CircuitBreaker breaker = new CircuitBreaker(system.scheduler(), 10, FiniteDuration.create(1, "second"), FiniteDuration.create(1, "second"), system.dispatcher()). onOpen(() -&gt; { System.out.println("circuit breaker opened!"); }). onClose(() -&gt; { System.out.println("circuit breaker opened!"); }). onHalfOpen(() -&gt; { System.out.println("circuit breaker opened!"); });</pre></div><p>In <a id="id521" class="indexterm"></a>Scala:</p><div class="informalexample"><pre class="programlisting">val breaker = new CircuitBreaker(system.scheduler, maxFailures = 10, callTimeout = 1 seconds, resetTimeout = 1 seconds). onOpen(println("circuit breaker opened!")). onClose(println("circuit breaker closed!")). onHalfOpen(println("circuit breaker half-open"))</pre></div><p>You can see the parameter names in the Scala exampleâ€”they are equivalent. We build the CircuitBreaker with the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Max number of failures before the breaker trips (either timeout or failure in the future)</p></li><li style="list-style-type: disc"><p>The call timeout (what latency to fail at)</p></li><li style="list-style-type: disc"><p>The reset timeout (how long to wait before changing to half-open and trying a request)</p></li></ul></div><p>Then, we also register a log event on the circuit breaker opening, changing state to half open and changing the state to close.</p><p>Using the circuit breaker is simpleâ€”we supply a <code class="literal">0-argument</code> lambda that returns a future (a <code class="literal">producer</code> function.) For our example, we'll use <code class="literal">ask</code>.</p><p>We'll make a call every 50 ms, and the actor will respond in 70 ms, so the messages will queue. Then the mailbox will fill, response times will balloon, and eventually the circuit breaker will open.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">        Timeout timeout = Timeout.apply(2000); ActorRefdb = system.actorOf(Props.create(SlowAkkademyDb.class)); Await.result(Patterns.ask(db, new SetRequest("key", "value"),  timeout), timeout.duration()); for(inti=0; i&lt;10000000; i++){ Future future = breaker.callWithCircuitBreaker(() -&gt;Patterns.ask(db, new GetRequest("key"),  timeout)); toJava(future).handle((x,t) -&gt; { if(t != null){ System.out.println("got it: " + x); }else{ System.out.println("error: " + t.toString()); } return null; }); Thread.sleep(50); }</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">  implicit val timeout = Timeout(2 seconds) valdb = system.actorOf(Props[FastSlowAkkademyDb]) Await.result(db ? SetRequest("key", "value"), 2 seconds) (1 to 1000000).map(x =&gt; { Thread.sleep(50) valaskFuture = breaker.withCircuitBreaker(db ? GetRequest("key")) askFuture.map(x =&gt; "got it: " + x).recover({ case t =&gt; "error: " + t.toString }).foreach(x =&gt;println(x)) })</pre></div><p>In some cases, you<a id="id522" class="indexterm"></a> might want to roll out your own circuit breaker or be careful with what you consider to be a failure in a future. The circuit breaker counts any and all failures and will trip after the maxFailures is reached. If your futures fail in ways that you don't want your circuit breaker to fail, you can wrap the responses in a <code class="literal">Try</code> instead of failing the future so that the future is successful.</p><p>There is one more strategy that you can think about to overcome overwhelming your consumers. If you have a hot producerâ€”something that will endlessly send requestsâ€”then you might want to turn the way you supply messages around so that actors ask for messages to process instead of simply receiving endless piles of messages.</p><p>Another related conceptâ€”"Back-Pressure"â€”talks about slowing down the flow of messages to what the slowest consumer can handle to avoid overwhelming downstream systems. You can certainly implement something like this yourself but the Reactive Streams proposal deals with this specific problem with a defined standard.</p><p>From <a class="ulink" href="https://www.reactive-streams.org/" target="_blank">https://www.reactive-streams.org/</a>â€”Reactive Streams<a id="id523" class="indexterm"></a> is an initiative to <a id="id524" class="indexterm"></a>provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.</p><p>There are now <a id="id525" class="indexterm"></a>multiple implementations of Reactive Streams, including one from the Akka team (Akka Streams). Reactive Streams is a fairly large topic, so we won't introduce the technologies here, but know that people are working on this problem actively and it might be worth looking at Reactive Streamsâ€”in particular if you have "hot" producers that have a nearly endless supply of requests that they can make.</p><p>Reactive Streams take a blend of approaches, both receiving requests with a mechanism to slow flow down if a service becomes overwhelmed (back-pressure) and asking for extra work if there is capacity in the pipe line.</p><p>Reactive Streams is an exciting topic, but is still in its infancy at the time of writing. Akka Streams is still marked experimental but is nearing GA and Typesafe are spending a lot of time in holding seminars and letting people know about the progress in the space.</p><p>You can learn more about Reactive Streams <a id="id526" class="indexterm"></a>at <a class="ulink" href="http://www.reactive-streams.org/" target="_blank">http://www.reactive-streams.org/</a>.</p><p>The Akka Streams Reactive Streams<a id="id527" class="indexterm"></a> implementation documentation can be found at <a class="ulink" href="http://doc.akka.io/docs/akka-stream-and-http-experimental/snapshot/" target="_blank">http://doc.akka.io/docs/akka-stream-and-http-experimental/snapshot/</a>.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec51"></a>Homework</h2></div></div><hr /></div><p>You should try to build an application that overwhelms a mailbox and then try different approaches to stop the mailbox from being overwhelmed.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Try overwhelming a mailbox in a local actor system (you can sleep the actor's thread by a few milliseconds to simulate the effect processing has on throughput). See how the application behaves.</p></li><li style="list-style-type: disc"><p>Try overwhelming a mailbox in a distributed application built with cluster. Try sending very large messages instead of implementing delays. What do you observe in the health of the cluster when it is overwhelmed with messages? What happens to the health of the cluster when the network is overwhelmed?</p></li><li style="list-style-type: disc"><p>Can you think of a solution to the observed issue of the network reaching saturation?</p></li><li style="list-style-type: disc"><p>Try to implement reactive streams and see if you can stop any errors from occurring. (It will take some effort to learn reactive streams as the material is not covered here.)</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec52"></a>Summary</h2></div></div><hr /></div><p>This chapter is at the end stages of this book because you might not need to think of mailbox too much in your day to day activities. It's important to understand the effects that changes to the mailbox have in your systems. Implementing a bounded mailbox might seem like a good choice to stop you systems from crashing, but we want to respond to the user as fast as possibleâ€”even in failure scenariosâ€”so it will often be better to fail quickly instead of drop messages once your systems are at their capacity. This chapter introduced you a few of the tools you can use to adapt your applications once they are running at very high scale and are being pushed to their limit.</p><p>In the next chapter, we will be learning about behavior-driven testing and development. We will also take a look at domain modeling with actors and classes.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch08"></a>ChapterÂ 8.Â Testing and Design</h2></div></div></div><p>While both testing and design-related items have been demonstrated throughout this book, they were presented as secondary to the specific details of the toolkit that were being introduced. Now that much of the Akka toolkit has been introduced, we're going to examine some general approaches to design and testing in somewhat greater detail.</p><p>Testing and design may seem like unrelated topics, but they have a tendency to affect one another. For code to be testable, it has to be reasonably designed. Also, if code is well designed, it will inherently be easy to make assertions about its behavior and to test them.</p><p>On the topic of testing, we will explore the basic concepts in <a id="id528" class="indexterm"></a>
<span class="strong"><strong>Behavior Driven Development </strong></span>(<span class="strong"><strong>BDD</strong></span>)â€”and see how we can both document and test our Actors with those approaches. Good testing approaches are one of the most powerful tools for documenting and describing our code. Tests cannot go out of date or deviate from the application's behaviorâ€”generally, as soon as they have lost their validity, they will fail and, therefore, force the engineer to change them to reflect the application's behavior.</p><p>On the topic of design, we will cover a few basic strategies on the level of code in actors that can help ease the task of testing their behavior. However, we will also examine how we can keep our application flexible and easy to maintain as it grows by creating context boundaries around different pieces of our application. We'll examine how and where we may want to make those boundaries and will look at how it relates to scaling in Akka.</p><p>We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Domain-driven design and modeling with Actors and Classes</p></li><li style="list-style-type: disc"><p>Behavior-driven testing and development</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec53"></a>Example problem</h2></div></div><hr /></div><p>For this chapter, we're going to pick up a new problem from scratch so that we can go over the process of doing some analysis and design and use that work to test and build. For the example in this chapter, we'll look at how we might build pieces of a chatroom application. You work in an organization and have been asked to produce something for use within the office. As it's meant for use inside a private network, the client can talk to the server using <code class="literal">Akka remoting</code>.</p><p>Looking at the macro level, our supported feature set might look something like the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Application will have a lobby where different chatrooms are displayed</p></li><li style="list-style-type: disc"><p>From the lobby, users can join a chatroom or leave a chatroom</p></li><li style="list-style-type: disc"><p>When a user joins a chatroom, they will receive a recent history of the chat</p></li><li style="list-style-type: disc"><p>Obviously, whenever someone posts, everyone will receive the update that who is in the room</p></li></ul></div><p>The user client will be written by some other team, and then it will interact with our application. As it's a native application, or a swing application, we don't need an HTTP API and we can use actor remoting to interact with the actors.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec54"></a>Approaching application design</h2></div></div><hr /></div><p>There are arguably a<a id="id529" class="indexterm"></a> couple of approaches that can be taken when writing codeâ€”the more traditional waterfall approaches where design and analysis are done upfront, and then code is built, or the Agile, especially Extreme Programming, camps, where you might keep upfront analysis to a minimum, and instead iteratively build and refactor your code to good design as you go.</p><p>Realistically, it's never one case or the other as you'll always do some analysis upfront, and you'll always make discoveries as you build that will force you to rethink and redesign your solution until completion. However, looking at some projects a few years after inception I can say that when you're starting a new project, you want to get the application foundation designed correctly or you'll be building on a rickety tower for years to come.</p><p>As we're starting a new piece of work here, I think it's prudent to look at the design before we begin. We'll work from the top down to see how we can slice the application into separate components to be able to build and test each one in isolation. By separating pieces of the domain into distinct modules, we can ensure we build simpler pieces. You can assign a developer to work on one piece, and he/she will be able to pick it up and understand it in a few days without needing to understand the entire system from front to back.</p><p>To begin designing our chat application, we can look at how we might create a domain model to represent what we're trying to build in a way that is simple and clear. Using object-oriented approaches, we aim to build classes that blend behavior and data while not knowing too much about the pieces it interacts with. Creating classes that have these qualities allows our application to change and grow over time with minimal cost.</p><p>Looking at the brief <a id="id530" class="indexterm"></a>description of requirements, it's easy to identify a few major entities of the domain:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Chatroom</strong></span>: A <a id="id531" class="indexterm"></a>chatroom has a topic or name that uniquely identifies it.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>User</strong></span>: When a<a id="id532" class="indexterm"></a> user registers, they acquire a username.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lobby</strong></span>: A lobby<a id="id533" class="indexterm"></a> contains a list of chatrooms. It may contain a list of active users as well. Likely one lobby exists but, as our application scales, it's possible that we may network together multiple offices or create different lobbies for different teams.</p></li></ul></div><p>I also find it very helpful to talk about where state may exist in the problem upfront. Because we have an asynchronous environment where several users are interacting with server state at the same time, it will help us decide how to best use Akka to build the application. The following areas could have state:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lobby</strong></span>: It will contain a list of all chatrooms</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Chatroom</strong></span>: It will contain a history of messages and a list of all current users who need to receive updates to the chat</p></li></ul></div><p>We know that Akka is a very good choice for encapsulating state in concurrent systems, so likely these areas are good targets to implement with actors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec87"></a>High-Level design</h3></div></div></div><p>Our chatroom will have <a id="id534" class="indexterm"></a>a client/server model. We now know that it has a client that is accessed by a user, and then on the server side we have a lobby and a chatroom as distinct elements of the domain. By creating a clear context boundary around those three elements, we can look at any one of them in isolation.</p><div class="mediaobject"><img src="graphics/B04006_08_01.jpg" /></div><p>We can look at the <a id="id535" class="indexterm"></a>interactions of the components of the domain in the following way:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Client gets a list of chatrooms from the lobby</p></li><li style="list-style-type: disc"><p>When new chatrooms come online, they announce that they are available so that clients can see them</p></li><li style="list-style-type: disc"><p>Clients can join the chatrooms</p></li><li style="list-style-type: disc"><p>Clients can post messages to the chat chatrooms</p></li><li style="list-style-type: disc"><p>Clients will receive updates from the chat chatrooms</p></li></ul></div><p>We'll look at turning this into specifications shortly, but by listing out basic interactions we can identify the components of the problem. Listing the components, we can draw context boundaries that separate them, allowing us to work on each of these components in isolation from the other elements. We also gain the ability to easily test these components if we don't couple them together.</p><p>As one final benefit, with <a id="id536" class="indexterm"></a>what we know about Akka's location transparency, if we keep the chatroom separate from the lobby we could likely run chatrooms on different servers. One lobby could let everyone know what rooms are available, and then we could scale the chatrooms out as needed. Now that we have a picture of the higher-level components, we can pick one of the components and focus on designing it.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec55"></a>Designing, building, and testing the Domain model</h2></div></div><hr /></div><p>Designing, building, and testing <a id="id537" class="indexterm"></a>are very much intertwined pieces of the <a id="id538" class="indexterm"></a>development process. There are numerous approaches that <a id="id539" class="indexterm"></a>we could take. I'm going to prescribe some upfront analysis describing the domain model and its behaviors, and then use that written analysis to extract the domain model and produce tests. In the following section, we'll look specifically at the chatroom and how users interact with it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec88"></a>Specifications</h3></div></div></div><p>I'm going to make the <a id="id540" class="indexterm"></a>assumption that you have used a chatroom of some sort before, such as Slack, Hipchat, Google Hangouts, or Campfire. If you haven't used any of those tools, you should evaluate introducing one into your development teamâ€”group chat can be a real boon for engineering teams. We'll focus on an individual chatroom design for the moment, and we can start by describing our expectations for the behavior of the chatroom. A few simple statements about the application's behavior in different contexts can easily be used as lightweight specifications that can drive our building and testing.</p><p>Behavioral specifications can be used for lightweight design documentation and tests. A useful format for writing specifications is the Given When Then format:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given the world is in a particular state</p></li><li style="list-style-type: disc"><p>When some event occurs</p></li><li style="list-style-type: disc"><p>Then some observable outcome is expected</p></li></ul></div><p>In this format, we are describing the context or state of the application, the event that occurs in the application or to the application, and then the consequence or observable outcome of that action. You might be able to see how unit tests are often informally broken up into those three distinct concerns as wellâ€”setup, action, and assertion.</p><p>For a chatroom actor, we might define the behavior for a few simple scenarios in the following way.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scenario</strong></span>: User <a id="id541" class="indexterm"></a>Joins Chatroom:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given a chatroom has no users, when it receives a request from a user to join the chatroom, then it should add the user to its list of joined users</p></li><li style="list-style-type: disc"><p>Given a chatroom has a chat history, when a user joins the chatroom, then it should receive the last 10 posts to the chatroom from the history</p></li></ul></div></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scenario</strong></span>: Post to chatroom:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given a chatroom has a joined user, when the chatroom receives a request to post to the chatroom from a user in the room, then it should update the chat history</p></li><li style="list-style-type: disc"><p>Given a chatroom has a joined user, when the chatroom receives a request to post to the chatroom, then it should notify the joined users</p></li></ul></div></li></ul></div><p>These are basic and incomplete specifications, but there is enough here to demonstrate. We can add more specifications later and change the behavior of the application to accommodate those additions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec89"></a>Designing the Domain model</h3></div></div></div><p>Now that we have this <a id="id542" class="indexterm"></a>written down, we can actually use this to both design and test. The great thing about specifications and the language that we use when talking to each other about the problem domain is that it makes designing and naming quite simple. <span class="emphasis"><em>Eric Evans</em></span>, in his book <span class="emphasis"><em>Domain Driven Design</em></span>, describes the words that we and the users use when talking about the application and calls that the <a id="id543" class="indexterm"></a>
<span class="strong"><strong>Ubiquitous Language</strong></span>. The great thing about the ubiquitous language that we are using is that it hints at both the structure and the names that we may want to use in our domain model.</p><p>If we revisit the specifications we just wrote for the chatroom, we can pull out all the pieces of the domain model described with our ubiquitous language and just make a list of those elements:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Chatroom</p></li><li style="list-style-type: disc"><p>User</p></li><li style="list-style-type: disc"><p>Join chatroom request</p></li><li style="list-style-type: disc"><p>Joined users</p></li><li style="list-style-type: disc"><p>Post to chatroom</p></li><li style="list-style-type: disc"><p>Chat history</p></li></ul></div><p>Quite incredibly, by writing down the specifications, we've described most of the domain model! We can look at the specifications and pull out everything we can identify with the words that we use to describe the things. The only piece left is deciding how to arrange it all together. We know that, in object-oriented programming, we want to group behavior and data wherever possible, so we'll use that as a heuristic for placing related data and behavior in classes. And we know that Akka helps us deal with state, so we'll also use that heuristic to understand what would benefit from being an actor.</p><p>We can deduce <a id="id544" class="indexterm"></a>the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Chat room has a list of user references called <code class="literal">joinedUsers</code>, which can change (state)</p></li><li style="list-style-type: disc"><p>Chat room has a list of posts called <code class="literal">chatHistory</code>, which can change (state)</p></li><li style="list-style-type: disc"><p>Join request contains a user reference</p></li></ul></div><p>The chatroom itself will probably benefit from being an actor as it contains state. Nothing else needs to have any mutating state, so we can use immutable objects for the other elements we identified. We can get to building and testing now that we have an idea of what our domain model looks like and now that we have specifications describing its behavior.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec90"></a>Testing and building the Domain model</h3></div></div></div><p>Now that we have <a id="id545" class="indexterm"></a>identified the elements of the domain, we can proceed with <a id="id546" class="indexterm"></a>testing and building. Often developer unit testing and building the items to be tested benefit from being done together as one task. It's easier to capture all the small edge cases in tests if you write the tests while building the behavior, so you end up with a nice set of unit tests that describe the behavior you've expressed when all is said and done. If you've never used the Test Driven and Behavior Driven approaches, I would encourage experimenting with these approaches while you work as you are much more likely to end up with a useful set of tests than if you approach testing after you finish building.</p><p>The approach that I'll introduce is to take the specification, write a test that translates the specification, and then fill out the code to make that test/specification pass.</p><p>First, we know that users exist remotely, so a good place to start is by modeling that remote item. We'll have some sort of user entity representation somewhere else, but the chatroom doesn't need to be concerned with it necessarily. The chatroom only needs to know where to send updates to and information to get the entity information for display. We don't have the user entity modeled at this point, so we'll just use a simple <code class="literal">UserRef</code> in our case.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">public class UserRef { public final ActorRef actor;
    public final String username;
    public UserRef(ActorRef actor, String username) { this.actor = actor;
this.username = username;
    }
}</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">case class UserRef(actor: ActorRef, name: String)</pre></div><p>The <code class="literal">UserRef</code> will <a id="id547" class="indexterm"></a>have the name to display and then an actor ref that we can send updates to. This is all the user info that the chatroom itself will need at this point in time.</p><p>The chatroom has to keep two pieces of data: joined users and chat history. Because these items represent state, and multiple users will be trying to access and change the state, we can guess that the chatroom itself would benefit from being an actor. Because the chatroom will be an actor, we'll model the Post request and Join request as immutable messages. We'll call them<a id="id548" class="indexterm"></a> starting with a verb name (this may be a small deviation from Java naming conventions but is common with message names). This is expressive of the intent of the message. Then we will have the message include any data relevant to the request.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">public class Messages { static public class JoinChatroom { public final UserRefuserRef;
        public JoinChatroom(UserRefuserRef) { this.userRef = userRef;
        }
    }
    static public class PostToChatroom{ public final String line, username;
        public PostToChatroom(String line, String username) { this.line = line;
this.username = username;
        }
    }
}</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">case class JoinChatroom(userRef: UserRef)
case class PostToChatroom(line: String, username: String)</pre></div><p>Now that we have the messages, we can build the skeleton of the chatroom. We won't implement any logic yetâ€”just create the actor. Because we also know the state, we can add those fields to the actor as well at this point:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Chatroom has a list of user references called <code class="literal">joinedUsers</code>, which can change (state)</p></li><li style="list-style-type: disc"><p>Chatroom<a id="id549" class="indexterm"></a> has a list of posts called <code class="literal">chatHistory</code>, which <a id="id550" class="indexterm"></a>can change (state)</p></li></ul></div><p>In Java:</p><div class="informalexample"><pre class="programlisting">public class Chatroom extends AbstractActor{ List&lt;Messages.PostToChatroom&gt;chatHistory = new ArrayList&lt;Messages.PostToChatroom&gt;();
    List&lt;UserRef&gt;joinedUsers = new ArrayList&lt;UserRef&gt;();
    @Override public PartialFunction&lt;Object, BoxedUnit&gt; receive() { return ReceiveBuilder. matchAny(o -&gt;System.out.println("received unknown message")).build();
    }
}</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">class Chatroom extends Actor {
var joinedUsers: Seq[UserRef] = Seq.empty
var chatHistory: Seq[PostToChatroom] = Seq.empty

override def receive = {
case _ =&gt;
println("received unknown message ")
  }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec91"></a>Building by specification</h3></div></div></div><p>Revisiting the <a id="id551" class="indexterm"></a>specifications we wrote, we can start to build the class and the tests. We'll take one of the specifications here and show how we might build the test. Then, we'll implement the behavior. The class can be built by adding each specification one at a time. After completing one specification here, we'll take a look at different ways of testing Actors.</p><p>Scenario: User Joins Chatroom</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given a chatroom has no users, when it receives a request from a user to join the chatroom, then it should add the user to its list of joined users</p></li></ul></div><p>In Java, we'll continue to use Junit, but C supports <span class="emphasis"><em>Given, When, Then</em></span> style of specification testing <a id="id552" class="indexterm"></a>with appropriate annotationsâ€”it's worth taking a look if you're starting a new project:</p><div class="informalexample"><pre class="programlisting">public class ChatroomTest extends TestCase { static ActorSystem system = ActorSystem.apply(); @Test public void testShouldAddUserToJoinedUsersWhenJoiningTest() { //Given a Chatroom has no users Props props = Props.create(Chatroom.class); TestActorRef&lt;Chatroom&gt; ref = TestActorRef.create(system, props, "testA"); Chatroom chatroom = ref.underlyingActor(); assertEquals(chatroom.joinedUsers.size(), 0); //When it recieves a request from a user to join the chatroom UserRefuserRef = new UserRef(system.deadLetters(), "user"); Messages.JoinChatroom request = new Messages.JoinChatroom(userRef); ref.tell(request, system.deadLetters()); //It should add the UserRef to its list of joined users assertEquals(chatroom.joinedUsers.get(0), userRef); }
}</pre></div><p>Note that we can start the test name with the word "should"â€”as Dan North writes, this helps us write descriptive test names that will print useful information when the tests run. The actual structure of the test reflects our given when the format is as shown in the comments. The comments themselves may not be necessary, but here this demonstrates how the specification relates to the code.</p><p>In Scala, we have better DSLs with the common testing tools, so we can more directly structure our test to reflect the specification:</p><div class="informalexample"><pre class="programlisting">class ChatroomSpec extends FunSpec with Matchers { val system = ActorSystem()
  describe("Given a Chatroom has no users"){ val props: Props = Props.create(classOf[Chatroom]) val ref: TestActorRef[Chatroom] = TestActorRef.create(system, props, "testA") val chatroom: Chatroom = ref.underlyingActor chatroom.joinedUsers.size should equal(0)
    describe("when it receives a request from a user to join the chatroom"){ val userRef: UserRef = new UserRef(system.deadLetters, "user") val request: JoinChatroom = JoinChatroom(userRef)
      ref ! userRef
      it("should add the UserRef to the list of joined users"){ chatroom.joinedUsers.head should equal(userRef) }
    }
  }
}</pre></div><p>This maps more directly<a id="id553" class="indexterm"></a> to the <span class="emphasis"><em>Given When Then</em></span> format to show how you might use <code class="literal">FunSpec</code> to layer your tests. While this demonstrates the specification quite directly, in real scenarios I would avoid creating too much nesting and duplicate things instead so that your tests aren't bleedingâ€”unlike your production code, duplication can be appropriate in tests. There are several ways in which you can structure tests using <code class="literal">ScalaTest</code>â€”check out the API and see which suits you best.</p><p>At this point, we need to run the test and ensure that it fails with the expected problem. Running the failing test is an important step as it gives us confidence that our test is validating the correct thing. Here we can see the test failing because there are no joined users in the list, as expected. Then, when it passes, we know that the behavior is correctly implemented to meet the specification:</p><div class="informalexample"><pre class="programlisting">[info]   - should add the UserRef to the list of joined users *** FAILED ***
[info]     java.util.NoSuchElementException: head of empty list</pre></div><p>At this point, we've covered the basics of designing and testing a new project. To recap, we can draw a lot of the design from the way we describe it. We've identified where state exists, and in any case where we identified state in a concurrent environment, we can decide to implement it with an actor. Any behavior that doesn't have mutable state accessed from multiple places at the same time, we can probably simplify by using plain objects. As an example, maybe we want to represent the <code class="literal">ChatHistory</code> in a class instead of simply a list. As the <code class="literal">ChatHistory</code> is only accessed by the chatroom, the <code class="literal">ChatHistory</code> object could be a plain object implementing <code class="literal">getRecentHistory</code> with a simple unsynchronized method as the actor safely handles only one message at a time.</p><p>After checking the test fails, you can implement the behavior, then ensure the test passes in a traditional TDD/BDD manner, and then move on to implement the next specification in the same wayâ€”building the test and then implementing the behavior. Each edge case you find and build for should have a corresponding test. In my opinion, this is the most reliable way to build maintainable code.</p><p>Next, we'll look at some different aspects of the <span class="emphasis"><em>akka-testkit</em></span> module that we can use to help us build clear and expressive tests.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec56"></a>Testing actors</h2></div></div><hr /></div><p>The <span class="emphasis"><em>akka-testkit</em></span> module is a <a id="id554" class="indexterm"></a>component of Akka that gives us several tools to test our Actors. We'll extend our chatroom example to look at a couple of tools in the testkit that can improve on our testing.</p><p>We'll cover two major concerns hereâ€“unit-testing underlying actor behavior and testing Actor responses.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec92"></a>Testing Actor behavior and state</h3></div></div></div><p>We've looked at synchronous <a id="id555" class="indexterm"></a>testing previously but, to recap here, using <code class="literal">TestActorRef</code> gives us a way to test request and response with Actors without needing to await<a id="id556" class="indexterm"></a> messages. Using Awaits is a more flexible and realistic approach to testing Actors, but for testing Actor behavior in isolation, there are a couple of approaches we can use.</p><p>In the previous example, you'll note that we don't wait for the message to be processed. Because we created the actor using Akka Testkit's <code class="literal">TestActorRef</code>, the Actor will use the calling thread (via <code class="literal">CallingThreadDispatcher</code>) to process the message, so we immediately get free synchronous testing by creating the actor with <code class="literal">TestActorRef</code>. This is the first thing that Akka testkit gives us; we've already demonstrated it.</p><p>Next, testkit's <code class="literal">TestActorRef</code> gives us access to the object behind the <code class="literal">ActorRef</code>, which gives us the ability to inspect it in ways we normally cannot and do not want to use. Without this, we'd have to use messages to check the internal state of the actor for validation in the tests. At this point, then, we might have to add features only for the sake of being able to test the actor accurately, which is not desirable. If we can access the underlying actor, then we can test its state with minimal code and less test-induced design damage.</p><p>We'll look at how we can use this feature of testkit to shape how we might write and test actor code when using the <code class="literal">TestActorRef</code>. We know that the <code class="literal">Akka TestActorRef</code> gives us access to the underlying actor, and that if we can get access to the underlying actor, we can validate any fields and methods exposed in that actor. But if we construct our actors with the behavior in a method instead of in the receive block, then we can actually test an actor like a plain class. This can be a real benefit to creating clear and simple tests of Actor behavior without worrying too much about sending and receiving messages. We want to validate the integration as well, but for scoping in on just the behavior, we can test the underlying object itself. Let's take a look at the test we created previously and see how we can use the access to the underlying actor to our advantage.</p><p>First, we'll look at the implementation of the behavior in the last specification:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scenario</strong></span>: User Joins chatroom</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given a chatroom has no users, when it receives a request from a user to join the chatroom, then it should add the user to its list of joined users.</p></li></ul></div></li></ul></div><p>We'll write a <a id="id557" class="indexterm"></a>method in the <a id="id558" class="indexterm"></a>actor to express the behavior.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">public class Chatroom extends AbstractActor{ List&lt;Messages.PostToChatroom&gt;chatHistory = new ArrayList&lt;Messages.PostToChatroom&gt;(); List&lt;UserRef&gt;joinedUsers = new ArrayList&lt;UserRef&gt;(); @Override public PartialFunction&lt;Object, BoxedUnit&gt; receive() { return ReceiveBuilder. match(Messages.JoinChatroom.class, this::joinChatroom). matchAny(o -&gt;System.out.println("received unknown message")).build();
    }
    public void joinChatroom(Messages.JoinChatroommsg) { joinedUsers.add(msg.userRef); }
}</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">class Chatroom extends Actor { varjoinedUsers: Seq[UserRef] = Seq.empty varchatHistory: Seq[PostToChatroom] = Seq.empty override def receive: Receive = { case x: JoinChatroom =&gt;
joinChatroom(x)
    case _ =&gt;
println("unimplemented")
  }
def joinChatroom(joinChatroom: JoinChatroom) { joinedUsers = joinedUsers :+ joinChatroom.userRef }
}</pre></div><p>Note that the behavior is placed into a method instead of the receive block itself. With the behavior expressed in a method, we can test and change it without worrying about the actual delivery of the message. In the test, then, we can use <code class="literal">Akka testkitTestActorRef</code> to get and test the underlying actor behavior.</p><p>In Java:</p><div class="informalexample"><pre class="programlisting">    @Test public void testShouldAddUserToJoinedUsersWhenJoiningTest() { Props props = Props.create(Chatroom.class);
TestActorRef&lt;Chatroom&gt; ref = TestActorRef.create(ActorSystem.apply(), props, "testA");
        Chatroom chatroom = ref.underlyingActor();
UserRefuserRef = new UserRef(system.deadLetters(), "user"); Messages.JoinChatroom request = new Messages.JoinChatroom(userRef);
chatroom.joinChatroom(request);
assertEquals(chatroom.joinedUsers.get(0), userRef);
    }</pre></div><p>In <a id="id559" class="indexterm"></a>Scala:</p><div class="informalexample"><pre class="programlisting">describe("Given a Chatroom has no users (Unit example)"){ val props: Props = Props.create(classOf[Chatroom])
val ref: TestActorRef[Chatroom] = TestActorRef.create(ActorSystem(), props, "testA")
val chatroom: Chatroom = ref.underlyingActor
chatroom.joinedUsers.size should equal(0)
    describe("when it receives a request from a user to join the chatroom"){ valuserRef: UserRef = new UserRef(system.deadLetters, "user") chatroom.joinChatroom(JoinChatroom(userRef))
      it("should add the UserRef to the list of joined users"){ chatroom.joinedUsers.head should equal(userRef) }
    }
  }</pre></div><p>You can see in this case that it's <a id="id560" class="indexterm"></a>not much simplerâ€”but instead of sending the message, we just call the method directly instead. If we have several methods we want to test inside an actor, this can greatly help us decompose and test smaller-grained details of its behavior.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec93"></a>Testing Message flow</h3></div></div></div><p>Being able to test the <a id="id561" class="indexterm"></a>underlying behavior in an actor is obviously useful, but what if we want to test sending and receiving messages in more complex situations? What happens if we want to mock another actor's behavior to ensure that the integration points are successfully built?</p><p>Let's look at a couple of scenarios where other actors are involved, and we'll look at two main approaches: using the test class as an actor and using a mock probe as an actor.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec85"></a>Using the test Itself as an Actor</h4></div></div></div><p>Now we're going <a id="id562" class="indexterm"></a>to look at<a id="id563" class="indexterm"></a> how to have the test class itself receive messages so that we don't need to examine any extra external actors when checking for message flow from an actor under test. First, let's take the following specification.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Scenario: User joins chatroom</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given a chatroom has a chat history, when a user joins the chatroom, then it should receive the last 10 posts to the chatroom from the history.</p></li></ul></div></li></ul></div><p>In this case, we <a id="id564" class="indexterm"></a>want to ensure that, when a user joins the chatroom, they receive the<a id="id565" class="indexterm"></a> updates from the history. We have two actors involved then: The chatroom and the User actor that is referenced in the <code class="literal">UserRef</code>. Because we don't care about any of the details of the user actor, all we want to do is test that a message comes out of the chatroom actor with the appropriate data. The simplest approach for testing interaction between one actor and the subject is to use the test itself as the receiver. Akka testkit lets the test itself receive messages, so where you're testing responses, you can express the assertions with an API that is made for doing so:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void testShouldSendHistoryWhenUserJoin() { new JavaTestKit(system) {{ //Given Props props = Props.create(Chatroom.class);
TestActorRef&lt;Chatroom&gt; ref = TestActorRef.create(system, props); Chatroom chatroom = ref.underlyingActor(); Messages.PostToChatroom msg = new Messages.PostToChatroom("test", "user");
chatroom.chatHistory.add(msg);
            //When
UserRef userRef = new UserRef(system.deadLetters(), "user"); Messages.JoinChatroom request = new Messages.JoinChatroom(userRef); ref.tell(request, getRef()); //Then List expected = new ArrayList&lt;Messages.PostToChatroom&gt;(); expected.add(msg); expectMsgEquals(duration("1 second"), expected); }};
    }</pre></div><p>For Java, the points to note here are that we send the message with the test ref as the senderâ€”<code class="literal">ref.tell</code>(<code class="literal">request</code>, <code class="literal">getRef()</code>), and, then, the test itself expects a message with one of the <code class="literal">expectMsg*</code> methods. We check for exact equality, but you can test the class type for example.</p><p>In Scala, instead of creating an anonymous TestKit object as in Java, the test class itself works, which makes for a nicer syntax.</p><p>We have to change the test class definition:</p><div class="informalexample"><pre class="programlisting">classChatroomSpec(_system: ActorSystem) extends TestKit(_system) with ImplicitSender
  with Matchers with FunSpecLike {</pre></div><p>Then the class becomes an actor, so the specification can look like the following:</p><div class="informalexample"><pre class="programlisting">  describe("Given a Chatroom has a history"){ val props = Props.create(classOf[Chatroom]) val ref = TestActorRef.create(system, props) val chatroom: Chatroom = ref.underlyingActor valmsg = PostToChatroom("test", "user") chatroom.chatHistory = chatroom.chatHistory.+:(msg) describe("When a user joins the chatroom"){ val userRef = UserRef(system.deadLetters, "user") val request = JoinChatroom(userRef) ref ! request it("(the user) should receive the history"){ expectMsg(1 second, List(msg)) }
    }
  }</pre></div><p>That's a bit<a id="id566" class="indexterm"></a> clearer than the Java syntaxâ€”knowing that the test is an actor, then when <a id="id567" class="indexterm"></a>we call tell, we know that the test itself will implicitly be the sender and, hence, receive the reply. The only point to mention is the <code class="literal">expectMsg</code> methodâ€”this will stop the test and await the noted reply. The test will fail if the expectation is not met in the time passed in the method call.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec86"></a>Using TestProbes as mock Actors</h4></div></div></div><p>Next, we'll look at<a id="id568" class="indexterm"></a> the post message specification for the <a id="id569" class="indexterm"></a>chatroom and look at how we can mock an external actor in a test.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scenario</strong></span>: Post to chatroom:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Given a chatroom has a joined user, when the chatroom receives a request to post to the chatroom, then it should notify the joined users</p></li></ul></div></li></ul></div><p>This gives us an opportunity to look at the joined user as a mock that expects a message and see how that might look in code.</p><p>Here it is in Java:</p><div class="informalexample"><pre class="programlisting">    @Test
    public void testShouldSendUpdateWhenUserPosts() { //Given
        Props props = Props.create(Chatroom.class); TestActorRef&lt;Chatroom&gt; ref = TestActorRef.create(system, props); Chatroom chatroom = ref.underlyingActor();
        final TestProbe probe = new TestProbe(system); UserRefuserRef = new UserRef(probe.ref(), "user");
chatroom.joinChatroom(new Messages.JoinChatroom(userRef)); 
        //When
Messages.PostToChatroommsg = new Messages.PostToChatroom("test", "user"); ref.tell(msg, probe.ref());
        //Then
probe.expectMsg(msg);
    }</pre></div><p>In Scala:</p><div class="informalexample"><pre class="programlisting">describe("Given a Chatroom has a joined user"){ val props = Props.create(classOf[Chatroom]) val ref = TestActorRef.create(system, props) val chatroom: Chatroom = ref.underlyingActor
val probe: TestProbe = new TestProbe(system) valuserRef: UserRef = new UserRef(probe.ref, "user") chatroom.joinChatroom(JoinChatroom(userRef))
    describe("when someone posts to the chatroom"){ val msg = PostToChatroom("test", "user") ref.tell(msg, probe.ref) it("(joined user) should get an update"){ probe.expectMsg(msg)
      }
    }
  }</pre></div><p>You'll notice that this<a id="id570" class="indexterm"></a> looks quite similar to the previous test, except <a id="id571" class="indexterm"></a>that the test probe is sent as the joined user, and then the assertions are made with the <code class="literal">TestProbe</code> as well (<code class="literal">probe.expectMsg</code>). <code class="literal">TestProbes</code> have additional behavior such as the ability to send messages, so they truly can be used to both mock out any Actor behavior and make assertions about receipt. They're a powerful tool to keep in your toolbox when working with actors.</p></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec57"></a>Testing Advice</h2></div></div><hr /></div><p>We've looked at<a id="id572" class="indexterm"></a> some techniques to test on different levels. We've looked at how to unit test the code in an actor, then how to test an actor from the perspective of the test sending the actor messages, and, finally, how to create test probes to mock the interaction from an actor to our actor under test. Using test probes, we could certainly test many different integration scenarios.</p><p>It can be hard to know what to test and what not to test. The best advice I heard was probably from Kent Beck in a response to a thread on test coverage on Stack Overflow. He said, <span class="emphasis"><em>I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence</em></span>. The thread is available at <a class="ulink" href="http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests" target="_blank">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a>.</p><p>What I would take<a id="id573" class="indexterm"></a> from that in relation to testing your actors is to target the biggest bang for your buck. You don't need to test both the underlying behavior and the integration of an Actor to be confident that it works and that you won't introduce regressions, so test accordingly. Test where you need to be confident that it works.</p><p>Because the <code class="literal">TestActorRef</code> uses the <code class="literal">CallingThreadDispatcher</code>, you have mechanisms that will let you test your actors synchronously without using <code class="literal">Thread.Sleep.expectMsgon</code> probes or in the test when using the test as a sender gives you another way to wait longer than needed. Using mechanisms like these can be better than putting sleep in your tests because your tests will stay fast-running. It's very important to have a test suite that takes as little time as possible to runâ€”if you let a few suites get into your code that <code class="literal">callThread.sleep</code>, the cost in breaking flow or the avoidance of running the whole suite can get higher. </p><p>It can be a bit harder to write the tests to be fast, but I'd recommend prioritizing speed when writing your tests because you want your team to really be able to lean on the tests for confidence. Figure out how to get your tests to run without any calls to <code class="literal">Thread.sleep</code>â€”it's almost always possible with the tools Akka gives us.</p><p>If you are using mechanisms such as Sleep, the other thing to look out for is flaky tests. It's possible to write tests that usually pass and then intermittently fail. If someone picks up the code after you and they randomly see tests failing, it'll very likely cost them some time trying to understand if they broke something in the code or not. Again, tests where the test thread has to wait for an external event can be the cause of these tests that intermittently fail. It's better to rearrange the test so that the test or a probe is in the middle of the behavior to be able to catch the event when it occurs and make assertions then, instead of waiting an arbitrary period and then validating the outcomes. In complex cases, you can use things such as Java's <code class="literal">CountDownLatch</code> to wait for several events to finish.</p><p>If you're not experienced with writing tests, I'd just like to note here that the objectives in your production code can be relaxed a bit when testing. Specifically, duplication in your tests is fine. Do not worry about factoring out duplication if having a similar setup over and over documents the API and behavior very clearly in each specification.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec58"></a>Homework</h2></div></div><hr /></div><p>To ensure you can see how to work with the tools provided, I would recommend that you do finish implementing the specifications and some others:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Ensure when a user posts, it receives back an OK.</p></li><li style="list-style-type: disc"><p>Ensure that, when a user is joined and posts, the user does not receive its own update.</p></li><li style="list-style-type: disc"><p>Continue to design the application. If you were to replace the <code class="literal">ChatHistory</code> with its own class instead of a simple list, and were to implement a <code class="literal">getRecentHistory</code> function, would a plain class be enough? What would the benefits be of using an actor, if any? What would the drawbacks be?</p></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec59"></a>Summary</h2></div></div><hr /></div><p>Testing and designing with Actors has a bit of a learning curve. The most important thing to realize about Actors is that they are not always the best approachâ€”plain classes should be used when it's simpler to do so. But, in the domain, where is state and concurrency exist together, then Actors are generally a safe bet. Actors can be more involved to build and test than simple classes. There are excellent tools to help us build actors and their tests, though, and this chapter rounds out the end of this book by covering some of those tools, not only in the process of designing and testing, but also in using the technology available to better express our test cases.</p><p>In the next chapter, we will look at some extra features in Akka, some items related to deployment and monitoring, and some steps you can take in your continuing journey.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>ChapterÂ 9.Â A Journey's End</h2></div></div></div><p>You have made it to the Journey's end. You are now armed with a bit of knowledge about building concurrent and distributed systems with Akka and Scala or Java8.</p><p>I expect a wide variety of readers to be hereâ€”some with distributed computing experience, and some with none. Either way, the material requires practice to master. </p><p>The Akka toolkit is quite large and the documentation is a very thorough and useful reference to all of its parts. This book has hopefully showed you why and when to use many of Akka's different tools. This chapter will highlight a few outstanding features and modules that you may want to be aware of, and some next steps, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Other Akka features and modules:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Logging</p></li><li style="list-style-type: disc"><p>Event Bus</p></li><li style="list-style-type: disc"><p>Agents</p></li><li style="list-style-type: disc"><p>Akka Persistence</p></li><li style="list-style-type: disc"><p>Akka I/O</p></li><li style="list-style-type: disc"><p>Akka Streams and Akka HTTP</p></li></ul></div></li><li style="list-style-type: disc"><p>Next steps:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Learning about Domain Driven Design</p></li><li style="list-style-type: disc"><p>Deployment tools</p></li><li style="list-style-type: disc"><p>Monitoring logs and events</p></li></ul></div></li></ul></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec60"></a>Other Akka Features and Modules</h2></div></div><hr /></div><p>From the<a id="id574" class="indexterm"></a> outset, this book has said that it will not cover every last corner of the Akka toolkit, but instead focus on helping you learn about distributed computing using Akka. Akka is quite a large tool kit, and all of the most important core pieces have been well covered.</p><p>Now that we're at the end of our journey here, it's a good time to highlight a few areas of the toolkit that you might want to take a look at in more depth. I'll give a brief introduction to them here so you're aware of some of the interesting extensions.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec94"></a>Logging in Akka</h3></div></div></div><p>We briefly <a id="id575" class="indexterm"></a>introduced logging <a id="id576" class="indexterm"></a>in Akka early in the book, but we'll review logging again here briefly to show how to use more advanced features. Akka by default will log to the console; however, it offers an event handler for <code class="literal">slf4j</code> that is available by importing an slf4j backend into your project such as <code class="literal">Logback</code>.</p><p>To use the <code class="literal">slf4j</code> logger, you'll need to provide the Akka <code class="literal">slf4j</code> module (it's not in the Akka core), and you'll also need to provide an <code class="literal">slf4j</code> backend such as <code class="literal">Logback</code>. You can add these dependencies to your <code class="literal">build.sbt</code> file using the following code:</p><div class="informalexample"><pre class="programlisting">"ch.qos.logback" % "logback-classic" % "1.0.0" % "runtime",
"com.typesafe.akka" %% "akka-slf4j" % "2.3.11"</pre></div><p>Then, in your application configuration (the <code class="literal">application.conf file</code>), you can declare the Akka <code class="literal">slf4j</code> event handler to be used as follows:</p><div class="informalexample"><pre class="programlisting">akka {
  event-handlers = ["akka.event.slf4j.Slf4jEventHandler"]
loglevel = "DEBUG"
}</pre></div><p>You can put a <code class="literal">logback.xml</code> file into your project's resources folder to enable fine-grained log control and more extended control over appenders. If you wanted to log to both a file (<code class="literal">logs/app.log</code>) and the console, a basic configuration will look like this:</p><div class="informalexample"><pre class="programlisting">&lt;configuration&gt;
&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
&lt;file&gt;logs/app.log&lt;/file&gt;

&lt;encoder&gt;
&lt;pattern&gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern&gt;
&lt;/encoder&gt;
&lt;/appender&gt;

&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
&lt;encoder&gt;
&lt;pattern&gt;%msg%n&lt;/pattern&gt;
&lt;/encoder&gt;
&lt;/appender&gt;

&lt;root level="debug"&gt;
&lt;appender-ref ref="FILE" /&gt;
&lt;appender-ref ref="STDOUT" /&gt;
&lt;/root&gt;
&lt;/configuration&gt;</pre></div><p>To use<a id="id577" class="indexterm"></a> Akka<a id="id578" class="indexterm"></a> logging in the application, you can either create a logger explicitly, passing in an <code class="literal">ActorSystem</code> object:</p><div class="informalexample"><pre class="programlisting">//java
LoggingAdapter log = Logging.getLogger(getContext().system(), this);

//scala
val log = Logging(context.system, this)</pre></div><p>Or, if using Scala, you can mix in the logging trait into your actor:</p><div class="informalexample"><pre class="programlisting">class MyActor extends Actor with akka.actor.ActorLogging {
  log.info("actor startup: {}", self.toString)
}</pre></div><p>Note that Akka will accept a variable length argument list as parameters in the messages, where it will replace each pair of brackets,{}, with the parameters in the order they are provided. Exceptions can be logged by passing them as the first argument:</p><div class="informalexample"><pre class="programlisting">#+BEGIN_SRC
//java
log.debug("params {} {} {}", param1, param2, param3);
log.error(e, "exception encountered: "); //exceptions are first arg

//scala
log.debug("params {} {} {}", param1, param2, param3)
log.info(e, "exception encountered: ") //exceptions are first arg
#+END_SRC</pre></div><p>There are performance benefits to letting logger handle the string interpolation, as it will execute the interpolation only if the log level is set so that the logger will actually log the event. If the event is not logged, then the string interpolation will not occur. Thus, this is generally better than doing something such as this:</p><div class="informalexample"><pre class="programlisting">#+BEGIN_SRC
log.debug("this actor is " + self().toString);
#+END_SRC</pre></div><p>The preceding code will always create the joined string in memory, even if the message is never logged.</p><p>This covers <a id="id579" class="indexterm"></a>almost everything you'll need to know about logging in <a id="id580" class="indexterm"></a>Akka. For additional information on configuring logging, you will want to check the <code class="literal">Logback</code> documentation. Rolling log files, multiple appenders, and other advanced features can be handled by configuring <code class="literal">Logback</code>, especially using <code class="literal">logback.xml</code>. For very advanced use cases, <code class="literal">Logback</code> also supports configurations written in the groovy programming language.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec95"></a>Message Channels and EventBus</h3></div></div></div><p>The <code class="literal">EventBus</code> object <a id="id581" class="indexterm"></a>in Akka can be used to publish and subscribe to events to <a id="id582" class="indexterm"></a>send messages to <a id="id583" class="indexterm"></a>multiple actors. Pub/Sub approaches <a id="id584" class="indexterm"></a>can be built with very little code by sending subscribe messages to an actor that will in turn hold a list of actors. However, Akka also describes a mechanism to handle this, where you listen for a topic.</p><p>Eventbus is a part of the core Akka library, so no extra imports are required.</p><p>Using an event bus requires choosing and extending a classifier that will describe the event type and how to target subscribers. Classifiers are described in the documentation referenced at the end of this section.</p><p>IRemember you can always use actor hierarchies to send messages with actorSelection as well. Event Bus should come to mind if you have very specific topic subscription to handle that hierarchies are not suitable for.</p><p>To use the event bus, there are three types that we're concerned with foremost and that we'll declare as types in Scala, or define with type arguments in Java, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Classifier Type</strong></span>: what the topic type is for the message</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Event Type</strong></span>: what data type is provided on the publish event:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Needs a topic (you'll define the logic for the topic)</p></li><li style="list-style-type: disc"><p>Optionally needs some other data to publish</p></li></ul></div></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Subscriber Type</strong></span>
</p></li></ul></div><p>Multiple Classifiers are available. As a quick example, assume we have a message called <code class="literal">EventBusMessage</code>, and we want to use the Event Bus to have actors subscribe and publish to them. The event bus doesn't need to use actorsâ€”it can implement any pub/sub behavior you require. A simple <code class="literal">LookupClassifier</code> object will describe the type of the event, the topic/classifier type, and how to lookup the classification of the topic for subscribers. In the case of <code class="literal">LookupClassifier</code>, the subscribers need to have an ordering.</p><p>A simple <a id="id585" class="indexterm"></a>Java message <a id="id586" class="indexterm"></a>might look<a id="id587" class="indexterm"></a> like<a id="id588" class="indexterm"></a> this:</p><div class="informalexample"><pre class="programlisting">public class EventBusMessage {
    public final String topic;
    public final String msg;

    public EventBusMessage(String topic, String msg) {
this.topic = topic;
        this.msg = msg;
    }
}</pre></div><p>The following are the Java and Scala event bus examples:</p><div class="informalexample"><pre class="programlisting">public class JavaLookupClassifier extends LookupEventBus&lt;EventBusMessage, ActorRef, String&gt; {

    @Override public String classify(EventBusMessage event) {
        return event.topic;
    }

    @Override public void publish(EventBusMessage event, ActorRef subscriber) {
subscriber.tell(event.msg, ActorRef.noSender());
    }

    @Override public int compareSubscribers(ActorRef a, ActorRef b) {
        return a.compareTo(b);
    }

    // determines the initial size of the index data structure
    @Override public intmapSize() {
        return 128;
    }
}

class ScalaLookupClassifier extends EventBus with LookupClassification {
    type Event = EventBusMessage
    type Classifier = String
    type Subscriber = ActorRef

    override protected def classify(event: Event): Classifier = event.topic

    override protected def publish(event: Event, subscriber: Subscriber): Unit = {
      subscriber ! event.msg
    }

    override protected def compareSubscribers(a: Subscriber, b: Subscriber): Int =
a.compareTo(b)

    //initial size of the index data structure
    override protected defmapSize: Int = 128
}</pre></div><p>The preceding<a id="id589" class="indexterm"></a> code implements some pretty basic logic such as how to<a id="id590" class="indexterm"></a> determine the topic, what to do with<a id="id591" class="indexterm"></a> a publish event for any relevant<a id="id592" class="indexterm"></a> subscribers, and a requirementâ€”how to compare subscribers. Also, the beginning size for the map needs to be declared, although it will adjust automatically as needed.</p><p>You might use it like this:</p><div class="informalexample"><pre class="programlisting">JavaLookupClassifier lookupBus = new JavaLookupClassifier;
lookupBus.subscribe(myActor, "greetings");
lookupBus.publish(new EventBusMessage("time", System.currentTimeMillis().toString));
lookupBus.publish(new EventBusMessage("greetings", "hello"));

val lookupBus = new JavaLookupClassifier
lookupBus.subscribe(myActor, "greetings")
lookupBus.publish(new EventBusMessage("time", System.currentTimeMillis().toString))
lookupBus.publish(new EventBusMessage("greetings", "hello"))</pre></div><p>In this case, our actor subscribes to the topic greetings. Then, we publish an event with the topic time and the topic greetings. As you can probably guess, the only message that gets to the actor will be the one sent with the topic "greetings."</p><p>The Akka documentation has examples and explanation for the classifiers if you want to further explore using <a id="id593" class="indexterm"></a>Akka's Event Bus features. The Akka documentation can be found here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://doc.akka.io/docs/akka/snapshot/java/event-bus.html" target="_blank">http://doc.akka.io/docs/akka/snapshot/java/event-bus.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://doc.akka.io/docs/akka/snapshot/scala/event-bus.html" target="_blank">http://doc.akka.io/docs/akka/snapshot/scala/event-bus.html</a>
</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec96"></a>Agents</h3></div></div></div><p>The Akka Agent module <a id="id594" class="indexterm"></a>is inspired by Clojure's Agents, which are reactive<a id="id595" class="indexterm"></a> constructs to help handle shared access to state. A better way to think about the Agent is much like a Java <code class="literal">AtomicInteger</code>, but for any value or type. It holds that state, and allows you to execute atomic operations on the value stored in a thread-safe manner, while allowing access to read the value safely.</p><p>More formally put, Agents provide a single storage location for a single value and allow modification of that value by providing a function. Agents allow safe atomic and transactional access to their value, giving a mechanism for safe concurrent access to state much like an actor would.</p><p>The advantage of Agents is that they are a bit lighter weight than using actors to encapsulate state. If you see a single stateful value or object that you need to safely handle, you can consider if an Agent might be a good fit, especially if you're thinking about how to make operations atomic (that is, checking the value, and then setting the value if it meets a certain condition where race conditions would be problematic). Thus, when you need to access a single value from across threads, Agents offer a nice alternative. to Actors.</p><p>Agents are not a core feature in Akka, and so they are in a separate module that you need to place in your project's <code class="literal">build.sbt</code> file:</p><div class="informalexample"><pre class="programlisting">"com.typesafe.akka" %% "akka-agent" % "2.3.6"</pre></div><p>A fairly standard example is a bank account withdrawal where we first need to check to see if there is enough money in the bank account; and then, if there is, we can withdraw the money. Because two threads could check the account, and then deduct the money from the account, we need the account check-and-set operation to be one atomic operation so that we ensure the value isn't modified after it's read.</p><p>If we used an integer shared across threads, it would be possible to do something like this if two people try to withdraw $20 from an account at the same time:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Account has $25.</p></li><li><p>Husband and wife try $20 withdrawal simultaneously.</p></li><li><p>Husband checks to see if account has more than $20. Account has $25.</p></li><li><p>Wife checks to see if account has more than $20. Account has $25.</p></li><li><p>Husband withdraws $20, setting account to $5.</p></li><li><p>Wife withdraws $20, setting account to $5 (illegal!.).</p></li></ol></div><p>Because the account had enough money in it when both threads checked the account, both threads proceeded to try to withdraw the money. However, when the second thread deducted the amount, it didn't see that someone else had already taken the money. The bank has now lost $20 and would not know where it went! The application would generally appear to act normal, but if two transactions happen at the same time, money disappears and nobody notices. If this happened a few hundred thousand times before someone caught the issue, the bank could have potentially lost hundreds of thousands of dollars!</p><p>We need the check and set operation to be atomic (one complete unit of work) to provide this functionality safely. Doing this with an actor is certainly possible as the actor will only handle one message at a time, but it's a bit more succinct to do this with an agent.</p><p>Agents use actors and<a id="id596" class="indexterm"></a> threads in their underlying implementation, so <a id="id597" class="indexterm"></a>we need to provide an execution context for them. We'll create an actor system and use its dispatcher to create the agent with the $25 in the account:</p><div class="informalexample"><pre class="programlisting">import akka.actor.ActorSystem;
import akka.agent.Agent;

//Java
ActorSystem system = ActorSystem.create();
Agent&lt;Integer&gt; account = Agent.create(25, dispatcher);

//Scala
val system = ActorSystem()
implicit valec = system.dispatcher
val account = Agent(25)</pre></div><p>You can get the value with <code class="literal">Agent.get()</code> or <code class="literal">Agent.apply</code>:</p><div class="informalexample"><pre class="programlisting">Integer currentValue = account.get();
valcurrentValue = account()</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Tip</h3><p>Note that getting the value will immediately return the value, although operations may be pending.</p></div><p>To update the value with the check-and-set operation, we can provide a function (int =&gt;int) describing the operation using send. For Java, you need to provide a Mapper function:</p><div class="informalexample"><pre class="programlisting">//Java
final Integer ammountToWithdraw = 20;
account.send(new akka.dispatch.Mapper&lt;Integer, Integer&gt;() {
            public Integer apply(Integer i) {
                if(ammountToWithdraw&lt;= i)
                    return i - ammountToWithdraw;
                else
                    return i;
            }
        });

//Scala
valammountToWithdraw = 20
account.send { i =&gt;
  if(i&gt;= 20) {
i - 20
  } else i
}</pre></div><p>These operations are fire-and-forget, and they run in the other thread pool, so you would need to complete a future if you want to get the result of the operation back from the agent. The <code class="literal">alter</code> method is identical, except it returns the result of the operation in future.</p><p>Scala offers us <a id="id598" class="indexterm"></a>some extra flexibility to be able to complete this operation. In <a id="id599" class="indexterm"></a>Scala, you can use a transaction block to allow multiple agents to participate in one atomic operation, and return the result of that block. If we want to move money from one account to another, for example, then the transaction block can be used to have multiple agents interact, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import scala.concurrent.stm._
val wifeAccount = Agent(25)
val husbandAccount = Agent(0)
val wasSuccess = atomic { txn =&gt;
  if(wifeAccount() &gt;= 20) {
wifeAccount.send(_ - 20)
husbandAccount.send(_ + 20)
    true
  } else false
}</pre></div><p>Agents can be a useful little abstraction to have in your tool belt. Again, think of places you could use <code class="literal">AtomicInteger</code>. Now, you have an <code class="literal">AtomicAnything</code> object and it's called an Agent.</p><p>Documentation for<a id="id600" class="indexterm"></a> Agents can be found here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://doc.akka.io/docs/akka/snapshot/java/agents.html" target="_blank">http://doc.akka.io/docs/akka/snapshot/java/agents.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://doc.akka.io/docs/akka/snapshot/scala/agents.html" target="_blank">http://doc.akka.io/docs/akka/snapshot/scala/agents.html</a>
</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec97"></a>Akka Persistence</h3></div></div></div><p>Another module<a id="id601" class="indexterm"></a> that may be of interest is Akka Persistence. Akka Persistence <a id="id602" class="indexterm"></a>gives a mechanism to maintain actor state through crashes/JVM restarts or restarts of the actor by a supervisor.</p><p>It's common to misunderstand the name of the library to mean that it has a mechanism to use external persistence mechanisms such as databases and key-value stores. You would not use Akka persistence to store user information or account information, for example.</p><p>Remember that, by default, when an actor restarts, it loses any internal state and only keeps its constructor arguments. Akka Persistence offers the ability to add a journal of events that an actor has encountered so that an actor can be run through those events again after restarting to restore its state. By re-applying the journal of events, the actor will fast-forward, recollecting any internal state. For instance, if you're building a metrics library, an in-memory counter collecting latency information from an endpoint would be able to more accurately collect data by using persistence. If the actor restarted, it would be able to roll forward through events since its last flush, and then pass that information along successfully.</p><p>Note that the<a id="id603" class="indexterm"></a> Akka Persistence module is marked experimental at the <a id="id604" class="indexterm"></a>time of writing (Akka 2.4 was released GA a couple weeks before the last editing was completed on this book.) Binary compatibility is not guaranteed across minor versions while modules are marked experimental; thus, it should be added to a project with some caution that understands the state of the component. More information is available on Akka Persistence in the Akka documentation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec98"></a>Akka I/O</h3></div></div></div><p>Akka I/O <a id="id605" class="indexterm"></a>was introduced in Akka 2.2, which was a joint effort from the Akka and <a id="id606" class="indexterm"></a>Spray teams based on Spray's underlying I/O module. It offers some lower-level TCP and Socket abstractions to build your own network communication. As Akka itself tries to raise the level of abstraction, this book has focused on introducing Akka as a toolkit that takes care of network communication concerns for you. However, if you want to handle TCP communication yourself, then there are tools in Akka that can help you do so.</p><p>Handling your own TCP communication is a fairly advanced topic and is beyond the scope of this book, but there are some libraries that you can read, such as the Brando Redis client library, that will give some good examples of how to handle TCP communication using Akka I/O. It can be accessed <a id="id607" class="indexterm"></a>at <a class="ulink" href="https://github.com/chrisdinn/brando" target="_blank">https://github.com/chrisdinn/brando</a>. Redis communication is a good example for analysis as it is quite simple.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec99"></a>Akka streams and HTTP</h3></div></div></div><p>Akka Streams<a id="id608" class="indexterm"></a> have been <a id="id609" class="indexterm"></a>discussed briefly in the chapter on Mailbox-related items. Streams is one of the more interesting new modules in Akka as a reactive streams implementation. Akka HTTP is built on top of Akka Streams with help from the Spray team.</p><p>Akka Streams and Reactive Streams in general are a more advanced topic. If you would like to explore Akka Streams, I would recommend beginning with learning about Reactive Streams. As Akka HTTP <a id="id610" class="indexterm"></a>is built on Akka Streams, you would likely want to learn about <a id="id611" class="indexterm"></a>Akka Streams before exploring this topic. Akka HTTP, as the name suggests, offers an abstraction to build HTTP Client or Server applications.</p></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec61"></a>Deployment Tools</h2></div></div><hr /></div><p>One last<a id="id612" class="indexterm"></a> topic to bring up is the deployment of applications. Because this is a book targeting developers, it does not cover deployment of applications from the infrastructure perspectives.</p><p>Because Akka Cluster helps applications talk to each other, your work is basically done once your application is able to build clusters. But building new application nodes at the infrastructure level can be an intensive feat.</p><p>At a minimum, I'd recommend you look at tools such as Puppet, Chef, Salt, and Ansibe right out of the gateâ€”don't wait until you deploy to start handling these concerns. Get to deployment automation in your dev and QA environments. The problem with these tools is that they may still be too oriented to server inventories. Thus, tools such as Mesos and ConductR, which abstract away the multiple nodes underneath, might be the right approach. They will help you treat multiple nodes in a datacenter like a pool of resources, rather than distinct entities. Whatever approach you take, as a rule of thumb nobody should ever need to log into your servers once your DevOps concerns are sufficiently mature.</p><p>It's a big area to cover and is a specialization on its own more in the field of operations, but you don't need a dedicated DevOps engineer to make this happenâ€”you just need to work beside your operations team as a Developer/Engineer to start to grow the discipline. Start a group that meets for a couple hours a week and tries to nail down how to get your dev and QA environments under automation. Once you've got that covered, you can start to look at how to tie in new nodes to a cluster in your production deployment environment once you see how the general automation practices work. You'll be doing your team a big service if you can plant the seed.</p><p>A brief example of what <code class="literal">ConductR</code> can do is that it will take your infrastructure and "bundle" applications and handle replication of the "bundles" across the infrastructure for you, as shown in following figure:</p><div class="mediaobject"><img src="graphics/B04006_09_01.jpg" /></div><p>Have a look at the <a id="id613" class="indexterm"></a>ConductR whitepaper from Typesafe if you'd like to understand the problems with yesterday's approaches in the context of applications today. It's a problem area that has a lot of intense activity, and Typesafe has tools and approaches that integrate with applications on which you build the Typesafe platform.</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec62"></a>Monitoring Logs and Events</h2></div></div><hr /></div><p>Finally, after talking<a id="id614" class="indexterm"></a> about deployment, we need to quickly glance over how to<a id="id615" class="indexterm"></a> monitor your application. There are probably three major concerns to examine to ensure your application is maintainable:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Events and Metrics</strong></span>: Number of successes, failures, amount of traffic, and latency.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Logs</strong></span>: Internal application behavior and details of failures.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Health</strong></span>: Is it up? Is it healthy? And, is it working as expected?</p></li></ul></div><p>For general event and metrics, tools like Statsd or Metrics can be used to put internal counters and timers in your app and "ship them" to another service where graphs are produced. AppDynamics and NewRelic are partners of Typesafe and offer SaaS solutions for similar concerns if you don't want to handle these in house.</p><p>Logs at scale can be very difficult to handle, and I've seen some big systems be set to Error or even Off. Whatever approach you take, you probably don't want to be scrubbing through multiple files<a id="id616" class="indexterm"></a> on many different servers to understand what's going on with your application. The <a id="id617" class="indexterm"></a>ELK stackâ€”<a id="id618" class="indexterm"></a>Elasticsearch, Logstash, and Kibanaâ€”is a very <a id="id619" class="indexterm"></a>good stack of tools that will allow an<a id="id620" class="indexterm"></a> agent to send log events to a cluster of Logstash services where events are indexed and then put into Elasticseach for fast queying. Kibana sits in front of Elasticsearch as a very capable frontend to query and analyze log events. I would really recommend this type of solution, even if it's not ELK. You want a centralized log collection in your systems to improve its maintainability.</p><p>Being able to "see inside" your running systems is critical to understand the health of your live systems. Being able to interpret the events requires views of the data that are easy to understand. NewRelic is easy to get started with as it's a SaaS model. If you don't mind working with infrastructure more, tools such as Graphite can visualize events collected with statsd to help you recognize trends in your data related to performance or errors, for example. Here is a screenshot from the Graphite </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec1000"></a>Next Steps</h3></div></div></div><p>To really grow with the material in this book, you'll need to keep venturing forward on your journey. I have to assume that you want to learn about building distributed things if you're reading this book. In this next section, I'll provide a few more activities and resources outside of the Akka documentation that you might want to check out to help you understand other related concerns.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec100"></a>Writing some Actor Code</h3></div></div></div><p>At this point, if you <a id="id621" class="indexterm"></a>have not already, I would strongly advise that you go back over the homework problems in each section and try to accomplish the tasks.</p><p>The initial chapters up to <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Actor Lifecycle â€“ Handling State and Failure</em></span>, in particular, are enough to work from for quite a while. Build a local concurrent application with Akka first. This material, and what you will certainly build on from it, is the most important foundational work.</p><p>
<a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Scaling Up</em></span>, and further chapters, while I believe they are the most interesting pieces, are more advanced topics, and I myself have worked on very large systems with Akka that have employed very few of the techniques only because some of the modules, like clusters, are newer, or they may not be needed for some use cases (for example, adjusting the mailbox configuration.)</p><p>While I've talked about<a id="id622" class="indexterm"></a> Akka as a distribution toolkit a lot in this book, it arguably has a use as both a concurrency framework and a distribution toolkit. Understanding when to use each is a fine balancing act, and you should always prefer simplicity until you have a good reason to make a change. Very often, using futures will be enough for concurrency. Thus, it takes a fairly critical examination of the problems to employ Akka's actors in the right places, and I've seen a few cases where Actors were probably a worse decision than simply using futures. It's only through experience that you'll develop the foresight to understand where the right place is to use Actors.</p><p>Certainly, though Akka will seldom be a bad choice for distribution problems, I would definitely learn the material in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Successfully Scaling Out â€“ Clustering</em></span>, with zeal to be confident enough with Cluster to employ it in your projects. Tools like Zookeeper can coordinate nodes in a cluster, Principles of Reactive Programming. It also covers a rather broad set of concerns as far as systems coordinating and talking; not only understanding who is available and who isn't, but also how to get messages between systems without introducing much complexity to the code that you must yourself maintain.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec101"></a>Coursera Courses</h3></div></div></div><p>I reviewed some courses on <a id="id623" class="indexterm"></a>Coursera while reaching the end of writing this book. There are a couple of courses that I thought might be helpful to someone trying to learn a bit more about how Akka works, or to advance their own Distributed Computing skills and knowledge.</p><p>The second iteration of the <span class="emphasis"><em>Principles of Reactive Programming</em></span> course on Coursera from Ã‰cole Polytechnique FÃ©dÃ©rale de Lausanne wrapped up around the time I was finishing this book. The last couple of weeks cover Akka, Cluster, and related topics. I feel that it would be a good piece of material to review for anyone looking for some more information on Reactive Programming in general, and to have some more homework assigned to them to help them learn. It might reiterate some of the concepts in this book, but will certainly<a id="id624" class="indexterm"></a> help to re-enforce the topics. It can be found at <a class="ulink" href="https://www.coursera.org/course/reactive" target="_blank">https://www.coursera.org/course/reactive</a>.</p><p>The Functional Programming in Scala course is also great for learning about functional programming if you're currently a Java Developer. It can be accessed at <a class="ulink" href="https://www.coursera.org/course/progfun" target="_blank">https://www.coursera.org/course/progfun</a>.</p><p>One of the best courses you could take to accompany this book is Cloud Computing Concepts from the University of Illinois at Urbana-Champaign covers. It covers many of the topics that the Akka team used to build Cluster. Concepts such as Gossip Protocol (week 2) and time and ordering concepts such as Vector Clocks, used to achieve a consistent view of the cluster (week 4), are covered in great detail in this course. Understanding these concepts in detail will certainly help you in your journey. This course can be found<a id="id625" class="indexterm"></a> here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Part 1</strong></span>: <a class="ulink" href="https://www.coursera.org/course/cloudcomputing" target="_blank">https://www.coursera.org/course/cloudcomputing</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Part 2</strong></span>: <a class="ulink" href="https://www.coursera.org/course/cloudcomputing2" target="_blank">https://www.coursera.org/course/cloudcomputing2</a>
</p></li></ul></div></div></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">
<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec63"></a>Summary</h2></div></div><hr /></div><p>We've had a good look at how to use Akka throughout this book. This book has tried to be a read that shows you how to build distributed systems, and has covered many of the concerns that you should understand once you step into the world of high-scale distributed computing. This last chapter highlighted some areas of Akka that you should be aware of, some deployment concerns, and additional areas of education that you can move on to as the next steps in your personal journey. I hope that this book has been helpful in introducing the concepts that you need to get off the ground using Akka. It's an interesting and powerful toolkit. While the documentation covers how to use Akka, it doesn't always show you where and when you want to use the different portions of the framework. I hope that this book covered the "why" and "when" so that you understand how great these tools are, and how they can help you.</p><p>Congratulations on making it to the end and good luck on your journey!</p></div></div></div></div>
ï»¿<div class="reader-container col-sm-12 col-lg-offset-1 col-lg-10 col-xl-offset-2 col-xl-8"><div class="row"><div style="position:relative;" class="book-content">

    <div id="backindex">
      <h1 class="title">Index</h1>
      <h2>A</h2>
      <ul>
        <li>Actor<ul><li>about / <a href="#ch01lvl1sec10" title="What's an Actor anyway?" class="link">What's an Actor anyway?</a>, <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li><li>creating / <a href="#ch01lvl1sec13" title="Creating your first Actor" class="link">Creating your first Actor</a>, <a href="#ch02lvl1sec19" title="Creating an actor" class="link">Creating an actor</a></li><li>responding, via Future / <a href="#ch02lvl1sec20" title="Having an Actor respond via a future" class="link">Having an Actor respond via a future</a></li><li>remote access, enabling to / <a href="#ch02lvl1sec20" title="Enabling remoting" class="link">Enabling remoting</a></li><li>messaging patterns / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a></li><li>terminating / <a href="#ch04lvl1sec28" title="Terminating or killing an Actor" class="link">Terminating or killing an Actor</a></li><li>killing / <a href="#ch04lvl1sec28" title="Terminating or killing an Actor" class="link">Terminating or killing an Actor</a></li><li>selecting, for Concurrency / <a href="#ch05lvl1sec34" title="Choosing Futures or Actors for concurrency" class="link">Choosing Futures or Actors for concurrency</a></li><li>working in parallel with / <a href="#ch05lvl1sec35" title="Doing work in parallel" class="link">Doing work in parallel</a>, <a href="#ch05lvl1sec35" title="Doing work in parallel with Actors" class="link">Doing work in parallel with Actors</a></li><li>testing / <a href="#ch08lvl1sec56" title="Testing actors" class="link">Testing actors</a></li><li>test, using as / <a href="#ch08lvl1sec56" title="Using the test Itself as an Actor" class="link">Using the test Itself as an Actor</a></li></ul></li>
        <li>Actor, anatomy<ul><li>about / <a href="#ch02lvl1sec18" title="Anatomy of an Actor" class="link">Anatomy of an Actor</a></li><li>Java Actor API / <a href="#ch02lvl1sec18" title="Java Actor API" class="link">Java Actor API</a></li><li>Scala Actor API / <a href="#ch02lvl1sec18" title="Scala Actor API" class="link">Scala Actor API</a></li></ul></li>
        <li>Actor Behavior<ul><li>testing / <a href="#ch08lvl1sec56" title="Testing Actor behavior and state" class="link">Testing Actor behavior and state</a></li></ul></li>
        <li>Actor Code<ul><li>writing / <a href="#ch09lvl1sec62" title="Writing some Actor Code" class="link">Writing some Actor Code</a></li></ul></li>
        <li>Actor model<ul><li>about / <a href="#ch01lvl1sec10" title="Actor Model origins" class="link">Actor Model origins</a>, <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li><li>examples / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li></ul></li>
        <li>Actor response, defining to message<ul><li>about / <a href="#ch01lvl1sec13" title="Defining Actor response to the Message" class="link">Defining Actor response to the Message</a></li><li>in Java / <a href="#ch01lvl1sec13" title="Java â€“ AkkademyDb.java" class="link">Java â€“ AkkademyDb.java</a></li><li>in Scala / <a href="#ch01lvl1sec13" title="Scala â€“ AkkademyDb.scala" class="link">Scala â€“ AkkademyDb.scala</a></li></ul></li>
        <li>Actors<ul><li>Configured Dispatcher, using with / <a href="#ch05lvl1sec36" title="Using a configured dispatcher with Actors" class="link">Using a configured dispatcher with Actors</a></li></ul></li>
        <li>Actor State<ul><li>testing / <a href="#ch08lvl1sec56" title="Testing Actor behavior and state" class="link">Testing Actor behavior and state</a></li></ul></li>
        <li>Actor system<ul><li>about / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li><li>main method, used for starting / <a href="#ch02lvl1sec20" title="Main" class="link">Main</a></li></ul></li>
        <li>Agent module<ul><li>about / <a href="#ch09lvl1sec60" title="Agents" class="link">Agents</a></li><li>references / <a href="#ch09lvl1sec60" title="Agents" class="link">Agents</a></li></ul></li>
        <li>Akka<ul><li>about / <a href="#ch01lvl1sec10" title="What is Akka" class="link">What is Akka</a></li><li>examples / <a href="#ch01lvl1sec11" title="What we will build" class="link">What we will build</a>, <a href="#ch01lvl1sec11" title="Example 2 â€“ getting lots of work done" class="link">Example 2 â€“ getting lots of work done</a></li><li>adding, to build.sbt / <a href="#ch01lvl1sec13" title="Adding Akka to build.sbt" class="link">Adding Akka to build.sbt</a></li></ul></li>
        <li>akka-cluster tool<ul><li>reference link / <a href="#ch06lvl1sec43" title="Leaving the Cluster Gracefully" class="link">Leaving the Cluster Gracefully</a></li></ul></li>
        <li>akka.actor.Identify<ul><li>used, for finding remote actor / <a href="#ch06lvl1sec45" title="Using akka.actor.Identify to Find a Remote Actor" class="link">Using akka.actor.Identify to Find a Remote Actor</a></li></ul></li>
        <li>akka.cluster.seed-nodes configuration / <a href="#ch06lvl1sec43" title="Seed Nodes" class="link">Seed Nodes</a></li>
        <li>Akka application<ul><li>creating / <a href="#ch01lvl1sec13" title="Creating your first Akka application â€“ setting up the SBT project" class="link">Creating your first Akka application â€“ setting up the SBT project</a></li></ul></li>
        <li>Akka Cluster / <a href="#ch01lvl1sec10" title="The Evolution of distribution and location transparency" class="link">The Evolution of distribution and location transparency</a><ul><li>about / <a href="#ch06lvl1sec39" title="Introducing Akka Cluster" class="link">Introducing Akka Cluster</a></li><li>systems, building with / <a href="#ch06lvl1sec43" title="Building Systems with Akka Cluster" class="link">Building Systems with Akka Cluster</a></li><li>creating / <a href="#ch06lvl1sec43" title="Creating the Cluster" class="link">Creating the Cluster</a></li><li>project, configuring / <a href="#ch06lvl1sec43" title="Configuring the Project" class="link">Configuring the Project</a></li><li>starting / <a href="#ch06lvl1sec43" title="Starting the Cluster" class="link">Starting the Cluster</a></li><li>leaving / <a href="#ch06lvl1sec43" title="Leaving the Cluster Gracefully" class="link">Leaving the Cluster Gracefully</a></li></ul></li>
        <li>Akka features, and modules<ul><li>about / <a href="#ch09lvl1sec60" title="Other Akka Features and Modules" class="link">Other Akka Features and Modules</a></li><li>logging / <a href="#ch09lvl1sec60" title="Logging in Akka" class="link">Logging in Akka</a></li><li>EventBus object / <a href="#ch09lvl1sec60" title="Message Channels and EventBus" class="link">Message Channels and EventBus</a></li><li>Message Channels / <a href="#ch09lvl1sec60" title="Message Channels and EventBus" class="link">Message Channels and EventBus</a></li><li>Agent / <a href="#ch09lvl1sec60" title="Agents" class="link">Agents</a></li><li>Akka Persistence / <a href="#ch09lvl1sec60" title="Akka Persistence" class="link">Akka Persistence</a></li><li>Akka I/O / <a href="#ch09lvl1sec60" title="Akka I/O" class="link">Akka I/O</a></li><li>Akka Streams / <a href="#ch09lvl1sec60" title="Akka streams and HTTP" class="link">Akka streams and HTTP</a></li><li>Akka HTTP / <a href="#ch09lvl1sec60" title="Akka streams and HTTP" class="link">Akka streams and HTTP</a></li></ul></li>
        <li>Akka HTTP / <a href="#ch01lvl1sec10" title="The Evolution of distribution and location transparency" class="link">The Evolution of distribution and location transparency</a><ul><li>about / <a href="#ch09lvl1sec60" title="Akka streams and HTTP" class="link">Akka streams and HTTP</a></li></ul></li>
        <li>Akka I/O<ul><li>about / <a href="#ch09lvl1sec60" title="Akka I/O" class="link">Akka I/O</a></li><li>reference link / <a href="#ch09lvl1sec60" title="Akka I/O" class="link">Akka I/O</a></li></ul></li>
        <li>Akka IO / <a href="#ch01lvl1sec10" title="The Evolution of distribution and location transparency" class="link">The Evolution of distribution and location transparency</a></li>
        <li>Akka Mailboxes<ul><li>reference link / <a href="#ch07lvl1sec49" title="Configuring mailboxes" class="link">Configuring mailboxes</a></li></ul></li>
        <li>Akka Persistence<ul><li>about / <a href="#ch09lvl1sec60" title="Akka Persistence" class="link">Akka Persistence</a></li></ul></li>
        <li>Akka Streams<ul><li>about / <a href="#ch09lvl1sec60" title="Akka streams and HTTP" class="link">Akka streams and HTTP</a></li></ul></li>
        <li>Akka Streams Reactive Streams<ul><li>reference link / <a href="#ch07lvl1sec50" title="Circuit breaker examples" class="link">Circuit breaker examples</a></li></ul></li>
        <li>Akka testkit<ul><li>about / <a href="#ch01lvl1sec13" title="Akka Testkit" class="link">Akka Testkit</a></li><li>Java source code / <a href="#ch01lvl1sec13" title="Java" class="link">Java</a></li><li>Scala source code / <a href="#ch01lvl1sec13" title="Scala" class="link">Scala</a></li></ul></li>
        <li>Amazon EC2 instances (AWS) / <a href="#ch06lvl1sec43" title="Failure Detection" class="link">Failure Detection</a></li>
        <li>Amazon Web Server (AWS) / <a href="#ch04lvl1sec27" title="The network is reliable" class="link">The network is reliable</a></li>
        <li>application design<ul><li>approaching / <a href="#ch08lvl1sec54" title="Approaching application design" class="link">Approaching application design</a></li></ul></li>
        <li>Article Parsing Dispatcher / <a href="#ch05lvl1sec36" title="Article parsing dispatcher" class="link">Article parsing dispatcher</a></li>
        <li>Ask message pattern<ul><li>about / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Ask message pattern" class="link">Ask message pattern</a></li><li>example application, designing with / <a href="#ch03lvl1sec24" title="Designing with Ask" class="link">Designing with Ask</a></li><li>callbacks execute, in another execution context / <a href="#ch03lvl1sec24" title="Callbacks execute in another execution context" class="link">Callbacks execute in another execution context</a></li><li>timeouts, need for / <a href="#ch03lvl1sec24" title="Timeouts are required" class="link">Timeouts are required</a></li><li>timeout stacktraces, drawbacks / <a href="#ch03lvl1sec24" title="Timeout stacktraces aren't useful" class="link">Timeout stacktraces aren't useful</a></li><li>hidden overhead / <a href="#ch03lvl1sec24" title="Ask has overhead" class="link">Ask has overhead</a></li><li>complexity of Actors / <a href="#ch03lvl1sec24" title="Complexity of Actors and Ask" class="link">Complexity of Actors and Ask</a></li></ul></li>
      </ul>
      <h2>B</h2>
      <ul>
        <li>BalancingDispatcher / <a href="#ch05lvl1sec36" title="Creating Dispatchers" class="link">Creating Dispatchers</a><ul><li>using / <a href="#ch05lvl1sec36" title="Using BalancingPool/BalancingDispatcher" class="link">Using BalancingPool/BalancingDispatcher</a></li></ul></li>
        <li>BalancingPool / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a><ul><li>using / <a href="#ch05lvl1sec36" title="Using BalancingPool/BalancingDispatcher" class="link">Using BalancingPool/BalancingDispatcher</a></li></ul></li>
        <li>Ballooning Response Times<ul><li>about / <a href="#ch07lvl1sec48" title="Ballooning response times" class="link">Ballooning response times</a></li></ul></li>
        <li>become() method / <a href="#ch04lvl1sec29" title="Hotswap: Become/Unbecome" class="link">Hotswap: Become/Unbecome</a></li>
        <li>Behavior<ul><li>defining, in Finite State Machine (FSM) / <a href="#ch04lvl1sec29" title="Defining behavior in FSMs" class="link">Defining behavior in FSMs</a></li></ul></li>
        <li>Blocking<ul><li>versus Event-Driven APIs / <a href="#ch02lvl1sec20" title="Blocking versus event-driven APIs" class="link">Blocking versus event-driven APIs</a></li></ul></li>
        <li>broker<ul><li>about / <a href="#ch04lvl1sec28" title="Redundancy" class="link">Redundancy</a></li></ul></li>
        <li>build.sbt<ul><li>Akka, adding to / <a href="#ch01lvl1sec13" title="Adding Akka to build.sbt" class="link">Adding Akka to build.sbt</a></li><li>modifying / <a href="#ch02lvl1sec20" title="Modifying build.sbt" class="link">Modifying build.sbt</a></li></ul></li>
      </ul>
      <h2>C</h2>
      <ul>
        <li>CallingThreadDispatcher / <a href="#ch05lvl1sec36" title="Creating Dispatchers" class="link">Creating Dispatchers</a></li>
        <li>CAP Theorem<ul><li>about / <a href="#ch06lvl1sec42" title="CAP Theorem" class="link">CAP Theorem</a></li><li>consistency / <a href="#ch06lvl1sec42" title="C â€“ Consistency" class="link">C â€“ Consistency</a></li><li>availability / <a href="#ch06lvl1sec42" title="A â€“ Availability" class="link">A â€“ Availability</a></li><li>partition tolerance / <a href="#ch06lvl1sec42" title="P â€“ Partition Tolerance" class="link">P â€“ Partition Tolerance</a></li></ul></li>
        <li>Circuit Breaker Listeners<ul><li>about / <a href="#ch07lvl1sec50" title="Circuit breaker listeners" class="link">Circuit breaker listeners</a></li></ul></li>
        <li>Circuit Breakers<ul><li>about / <a href="#ch07lvl1sec50" title="Circuit breakers" class="link">Circuit breakers</a></li><li>examples / <a href="#ch07lvl1sec50" title="Circuit breaker examples" class="link">Circuit breaker examples</a></li></ul></li>
        <li>client<ul><li>producing / <a href="#ch02lvl1sec20" title="Producing the client" class="link">Producing the client</a></li><li>building / <a href="#ch02lvl1sec20" title="Building the client" class="link">Building the client</a></li></ul></li>
        <li>cluster<ul><li>about / <a href="#ch06lvl1sec41" title="Definition of a Cluster" class="link">Definition of a Cluster</a></li><li>failure detection / <a href="#ch06lvl1sec41" title="Failure Detection" class="link">Failure Detection</a></li><li>messages, routing to / <a href="#ch06lvl1sec43" title="Routing Messages to the Cluster" class="link">Routing Messages to the Cluster</a></li><li>designing / <a href="#ch06lvl1sec43" title="Designing the Cluster" class="link">Designing the Cluster</a></li><li>basic key-value store design / <a href="#ch06lvl1sec43" title="Basic Key-Value Store Design" class="link">Basic Key-Value Store Design</a></li></ul></li>
        <li>cluster client, building for clustered services<ul><li>about / <a href="#ch06lvl1sec43" title="Cluster Client for Clustered Services" class="link">Cluster Client for Clustered Services</a></li><li>server project, setting up / <a href="#ch06lvl1sec43" title="Setting up the Server Project" class="link">Setting up the Server Project</a></li><li>client project, setting up / <a href="#ch06lvl1sec43" title="Setting up the Client Project" class="link">Setting up the Client Project</a></li><li>Message class, sharing between client and server / <a href="#ch06lvl1sec43" title="Sharing the Message Class between Client and Server" class="link">Sharing the Message Class between Client and Server</a></li><li>messages, sending to cluster / <a href="#ch06lvl1sec43" title="Sending Messages to the Cluster" class="link">Sending Messages to the Cluster</a></li><li>distributed key value store, building / <a href="#ch06lvl1sec43" title="Building a Distributed Key Value Store" class="link">Building a Distributed Key Value Store</a></li></ul></li>
        <li>cluster events<ul><li>subscribing to / <a href="#ch06lvl1sec43" title="Subscribing to Cluster Events" class="link">Subscribing to Cluster Events</a></li></ul></li>
        <li>cluster member states<ul><li>about / <a href="#ch06lvl1sec43" title="Cluster Member States" class="link">Cluster Member States</a></li><li>failure detection / <a href="#ch06lvl1sec43" title="Failure Detection" class="link">Failure Detection</a></li></ul></li>
        <li>Cluster Specification<ul><li>reference link / <a href="#ch06lvl1sec41" title="Gossiping an Eventually Consistent View" class="link">Gossiping an Eventually Consistent View</a></li></ul></li>
        <li>code<ul><li>validating, with unit tests / <a href="#ch01lvl1sec13" title="Validating the code with unit tests" class="link">Validating the code with unit tests</a></li><li>mailboxes, sending in / <a href="#ch07lvl1sec49" title="Selecting a mailbox in code" class="link">Selecting a mailbox in code</a></li></ul></li>
        <li>compromises, in CAP theorem<ul><li>about / <a href="#ch06lvl1sec42" title="Compromises in CAP Theorem" class="link">Compromises in CAP Theorem</a></li><li>CP system / <a href="#ch06lvl1sec42" title="CP System â€“ Preferring Consistency" class="link">CP System â€“ Preferring Consistency</a></li><li>AP system / <a href="#ch06lvl1sec42" title="AP System â€“ Preferring Availability" class="link">AP System â€“ Preferring Availability</a></li><li>consistency, as sliding state / <a href="#ch06lvl1sec42" title="Consistency as a Sliding Scale" class="link">Consistency as a Sliding Scale</a></li></ul></li>
        <li>Concurrency<ul><li>Actor, selecting for / <a href="#ch05lvl1sec34" title="Choosing Futures or Actors for concurrency" class="link">Choosing Futures or Actors for concurrency</a></li><li>Futures, selecting for / <a href="#ch05lvl1sec34" title="Choosing Futures or Actors for concurrency" class="link">Choosing Futures or Actors for concurrency</a></li></ul></li>
        <li>Conditional Statements<ul><li>about / <a href="#ch04lvl1sec29" title="Conditional statements" class="link">Conditional statements</a></li></ul></li>
        <li>Configured Dispatcher<ul><li>using, with Actors / <a href="#ch05lvl1sec36" title="Using a configured dispatcher with Actors" class="link">Using a configured dispatcher with Actors</a></li></ul></li>
        <li>Consistent Hashing / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li>
        <li>Coursera Courses<ul><li>about / <a href="#ch09lvl1sec62" title="Coursera Courses" class="link">Coursera Courses</a></li><li>references / <a href="#ch09lvl1sec62" title="Coursera Courses" class="link">Coursera Courses</a></li></ul></li>
        <li>crashing<ul><li>about / <a href="#ch07lvl1sec48" title="Crashing" class="link">Crashing</a></li></ul></li>
      </ul>
      <h2>D</h2>
      <ul>
        <li>DB<ul><li>preparing / <a href="#ch02lvl1sec20" title="Preparing the DB and messages" class="link">Preparing the DB and messages</a></li><li>starting / <a href="#ch02lvl1sec20" title="Starting the DB" class="link">Starting the DB</a></li></ul></li>
        <li>DB Functionality<ul><li>implementing / <a href="#ch02lvl1sec20" title="Implementing the DB functionality" class="link">Implementing the DB functionality</a></li></ul></li>
        <li>default dispatcher<ul><li>about / <a href="#ch05lvl1sec36" title="Default Dispatcher" class="link">Default Dispatcher</a></li></ul></li>
        <li>dependencies<ul><li>adding, from Maven Central / <a href="#ch01lvl1sec13" title="Adding other Dependencies from Maven Central" class="link">Adding other Dependencies from Maven Central</a></li></ul></li>
        <li>Deployment Configuration<ul><li>mailboxes, sending in / <a href="#ch07lvl1sec49" title="Selecting a mailbox in deployment configuration" class="link">Selecting a mailbox in deployment configuration</a></li></ul></li>
        <li>deployment tools<ul><li>about / <a href="#ch09lvl1sec61" title="Deployment Tools" class="link">Deployment Tools</a></li></ul></li>
        <li>dispatchers<ul><li>working with / <a href="#ch05lvl1sec36" title="Working with Dispatchers" class="link">Working with Dispatchers</a>, <a href="#ch05lvl1sec36" title="Dispatchers explained" class="link">Dispatchers explained</a></li><li>creating / <a href="#ch05lvl1sec36" title="Creating Dispatchers" class="link">Creating Dispatchers</a></li><li>about / <a href="#ch05lvl1sec36" title="Creating Dispatchers" class="link">Creating Dispatchers</a></li><li>deciding, for usage / <a href="#ch05lvl1sec36" title="Deciding Which Dispatcher to use where" class="link">Deciding Which Dispatcher to use where</a></li></ul></li>
        <li>distributed article parse service<ul><li>producing / <a href="#ch06lvl1sec43" title="Producing a Distributed Article Parse Service" class="link">Producing a Distributed Article Parse Service</a></li></ul></li>
        <li>Distributed Computing<ul><li>Fallacies / <a href="#ch04lvl1sec27" title="The 8 Fallacies of Distributed Computing" class="link">The 8 Fallacies of Distributed Computing</a></li></ul></li>
        <li>Distributed System<ul><li>composing / <a href="#ch02lvl1sec20" title="Composing a Distributed System â€“ AkkademyDb and client" class="link">Composing a Distributed System â€“ AkkademyDb and client</a></li></ul></li>
        <li>distributed systems<ul><li>reference link / <a href="#ch06lvl1sec40" title="One Giant Monolith or Many Micro Services?" class="link">One Giant Monolith or Many Micro Services?</a>, <a href="#ch06lvl1sec43" title="Redundant Nodes" class="link">Redundant Nodes</a></li></ul></li>
        <li>distribution<ul><li>evolution / <a href="#ch01lvl1sec10" title="The Evolution of distribution and location transparency" class="link">The Evolution of distribution and location transparency</a></li></ul></li>
        <li>domain, entities<ul><li>chatroom / <a href="#ch08lvl1sec54" title="Approaching application design" class="link">Approaching application design</a></li><li>user / <a href="#ch08lvl1sec54" title="Approaching application design" class="link">Approaching application design</a></li><li>lobby / <a href="#ch08lvl1sec54" title="Approaching application design" class="link">Approaching application design</a></li></ul></li>
        <li>domain model<ul><li>designing / <a href="#ch08lvl1sec55" title="Designing, building, and testing the Domain model" class="link">Designing, building, and testing the Domain model</a>, <a href="#ch08lvl1sec55" title="Designing the Domain model" class="link">Designing the Domain model</a></li><li>building / <a href="#ch08lvl1sec55" title="Designing, building, and testing the Domain model" class="link">Designing, building, and testing the Domain model</a>, <a href="#ch08lvl1sec55" title="Testing and building the Domain model" class="link">Testing and building the Domain model</a></li><li>testing / <a href="#ch08lvl1sec55" title="Designing, building, and testing the Domain model" class="link">Designing, building, and testing the Domain model</a>, <a href="#ch08lvl1sec55" title="Testing and building the Domain model" class="link">Testing and building the Domain model</a></li><li>specifications / <a href="#ch08lvl1sec55" title="Specifications" class="link">Specifications</a></li><li>building, by specification / <a href="#ch08lvl1sec55" title="Building by specification" class="link">Building by specification</a></li></ul></li>
        <li>Domain Specific Languages (DSL)<ul><li>about / <a href="#ch03lvl1sec24" title="Ask message pattern" class="link">Ask message pattern</a></li></ul></li>
        <li>Drunken Sushi Chef<ul><li>about / <a href="#ch04lvl1sec28" title="Supervision strategies and the drunken sushi chef" class="link">Supervision strategies and the drunken sushi chef</a></li></ul></li>
      </ul>
      <h2>E</h2>
      <ul>
        <li>Eclipse<ul><li>about / <a href="#ch01lvl1sec12" title="Eclipse" class="link">Eclipse</a></li><li>project, preparing for / <a href="#ch01lvl1sec12" title="Preparing the project for Eclipse" class="link">Preparing the project for Eclipse</a></li><li>project, importing into / <a href="#ch01lvl1sec12" title="Importing the project into Eclipse" class="link">Importing the project into Eclipse</a></li></ul></li>
        <li>Eclipse (Scala-Ide)<ul><li>installing / <a href="#ch01lvl1sec12" title="Installing Eclipse (Scala-Ide)" class="link">Installing Eclipse (Scala-Ide)</a>, <a href="#ch01lvl1sec12" title="Preparing the project for Eclipse" class="link">Preparing the project for Eclipse</a></li></ul></li>
        <li>Elasticsearch<ul><li>about / <a href="#ch09lvl1sec62" title="Monitoring Logs and Events" class="link">Monitoring Logs and Events</a></li></ul></li>
        <li>environment<ul><li>setting up / <a href="#ch01lvl1sec12" title="Setting up your environment" class="link">Setting up your environment</a></li></ul></li>
        <li>Event-Driven APIs<ul><li>versus Blocking / <a href="#ch02lvl1sec20" title="Blocking versus event-driven APIs" class="link">Blocking versus event-driven APIs</a></li></ul></li>
        <li>Event-Driven Programming Models<ul><li>about / <a href="#ch02lvl1sec20" title="Promises, futures, and event-driven programming models" class="link">Promises, futures, and event-driven programming models</a></li></ul></li>
        <li>EventBus object<ul><li>about / <a href="#ch09lvl1sec60" title="Message Channels and EventBus" class="link">Message Channels and EventBus</a></li><li>references / <a href="#ch09lvl1sec60" title="Message Channels and EventBus" class="link">Message Channels and EventBus</a></li></ul></li>
        <li>events<ul><li>monitoring / <a href="#ch09lvl1sec62" title="Monitoring Logs and Events" class="link">Monitoring Logs and Events</a></li></ul></li>
        <li>Eventually Consistent View<ul><li>about / <a href="#ch06lvl1sec41" title="Gossiping an Eventually Consistent View" class="link">Gossiping an Eventually Consistent View</a></li></ul></li>
        <li>example application<ul><li>designing, with Ask message pattern / <a href="#ch03lvl1sec24" title="Designing with Ask" class="link">Designing with Ask</a></li></ul></li>
        <li>example problem<ul><li>stage, setting with / <a href="#ch03lvl1sec23" title="Setting the stage with an example problem" class="link">Setting the stage with an example problem</a></li></ul></li>
        <li>executors<ul><li>about / <a href="#ch05lvl1sec36" title="Executors" class="link">Executors</a></li></ul></li>
      </ul>
      <h2>F</h2>
      <ul>
        <li>failure<ul><li>about / <a href="#ch04lvl1sec28" title="Failure" class="link">Failure</a></li><li>isolating / <a href="#ch04lvl1sec28" title="Isolating failure" class="link">Isolating failure</a></li></ul></li>
        <li>Failure Cases, Futures<ul><li>handling / <a href="#ch02lvl1sec20" title="Handling failure cases" class="link">Handling failure cases</a></li><li>code, executing / <a href="#ch02lvl1sec20" title="Executing code in the failure case" class="link">Executing code in the failure case</a></li><li>recovering from failure / <a href="#ch02lvl1sec20" title="Recovering from failure" class="link">Recovering from failure</a></li><li>recovering from failure, asynchronously / <a href="#ch02lvl1sec20" title="Recovering from failure asynchronously" class="link">Recovering from failure asynchronously</a></li></ul></li>
        <li>failure detection, Cluster Specification document<ul><li>reference link / <a href="#ch06lvl1sec43" title="Failure Detection" class="link">Failure Detection</a></li></ul></li>
        <li>Fallacies, of Distributed Computing<ul><li>about / <a href="#ch04lvl1sec27" title="The 8 Fallacies of Distributed Computing" class="link">The 8 Fallacies of Distributed Computing</a></li><li>reliable network / <a href="#ch04lvl1sec27" title="The network is reliable" class="link">The network is reliable</a></li><li>zero latency / <a href="#ch04lvl1sec27" title="Latency is zero" class="link">Latency is zero</a></li><li>infinite bandwidth / <a href="#ch04lvl1sec27" title="Bandwidth is infinite" class="link">Bandwidth is infinite</a></li><li>secure network / <a href="#ch04lvl1sec27" title="The network is secure" class="link">The network is secure</a></li><li>network topology doesn't change / <a href="#ch04lvl1sec27" title="Network topology doesn't change" class="link">Network topology doesn't change</a></li><li>one administrator / <a href="#ch04lvl1sec27" title="There is one administrator" class="link">There is one administrator</a></li><li>zero transport cost / <a href="#ch04lvl1sec27" title="Transport cost is zero" class="link">Transport cost is zero</a></li><li>homogeneous network / <a href="#ch04lvl1sec27" title="The network is homogeneous" class="link">The network is homogeneous</a></li></ul></li>
        <li>fault-tolerance<ul><li>evolution / <a href="#ch01lvl1sec10" title="The Evolution of supervision and fault tolerance in Erlang" class="link">The Evolution of supervision and fault tolerance in Erlang</a></li></ul></li>
        <li>Finite State Machines (FSM)<ul><li>about / <a href="#ch04lvl1sec29" title="Finite State Machines (FSM)" class="link">Finite State Machines (FSM)</a></li><li>Behavior, defining in / <a href="#ch04lvl1sec29" title="Defining behavior in FSMs" class="link">Defining behavior in FSMs</a></li></ul></li>
        <li>Forward message pattern<ul><li>about / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Forward" class="link">Forward</a></li></ul></li>
        <li>Future Cheat Sheet<ul><li>about / <a href="#ch02lvl1sec20" title="Future cheat-sheet" class="link">Future cheat-sheet</a></li></ul></li>
        <li>Futures<ul><li>about / <a href="#ch02lvl1sec20" title="Promises, futures, and event-driven programming models" class="link">Promises, futures, and event-driven programming models</a>, <a href="#ch02lvl1sec20" title="Understanding futures and promises" class="link">Understanding futures and promises</a></li><li>Actor, responding via / <a href="#ch02lvl1sec20" title="Having an Actor respond via a future" class="link">Having an Actor respond via a future</a></li><li>failure, expressing in types / <a href="#ch02lvl1sec20" title="Future â€“ expressing failure and latency in types" class="link">Future â€“ expressing failure and latency in types</a></li><li>latency, expressing in types / <a href="#ch02lvl1sec20" title="Future â€“ expressing failure and latency in types" class="link">Future â€“ expressing failure and latency in types</a></li><li>Java8 examples, preparing / <a href="#ch02lvl1sec20" title="Preparing for the Java example" class="link">Preparing for the Java example</a></li><li>Scala examples, preparing / <a href="#ch02lvl1sec20" title="Preparing for Scala examples" class="link">Preparing for Scala examples</a></li><li>anatomy / <a href="#ch02lvl1sec20" title="Anatomy of a future" class="link">Anatomy of a future</a></li><li>Success Cases, handling / <a href="#ch02lvl1sec20" title="Handling success cases" class="link">Handling success cases</a></li><li>Failure Cases, handling / <a href="#ch02lvl1sec20" title="Handling failure cases" class="link">Handling failure cases</a></li><li>composing / <a href="#ch02lvl1sec20" title="Composing futures" class="link">Composing futures</a></li><li>operatoions, chaining together / <a href="#ch02lvl1sec20" title="Chaining operations together" class="link">Chaining operations together</a></li><li>combining / <a href="#ch02lvl1sec20" title="Combining futures" class="link">Combining futures</a></li><li>selecting, for Concurrency / <a href="#ch05lvl1sec34" title="Choosing Futures or Actors for concurrency" class="link">Choosing Futures or Actors for concurrency</a></li><li>working in parallel with / <a href="#ch05lvl1sec35" title="Doing work in parallel" class="link">Doing work in parallel</a>, <a href="#ch05lvl1sec35" title="Doing work In parallel with futures" class="link">Doing work In parallel with futures</a></li><li>IO Dispatcher Use, blocking with / <a href="#ch05lvl1sec36" title="Blocking IO dispatcher use with futures" class="link">Blocking IO dispatcher use with futures</a></li></ul></li>
      </ul>
      <h2>H</h2>
      <ul>
        <li>high level design<ul><li>about / <a href="#ch08lvl1sec54" title="High-Level design" class="link">High-Level design</a></li></ul></li>
      </ul>
      <h2>I</h2>
      <ul>
        <li>IDE<ul><li>installing / <a href="#ch01lvl1sec12" title="Installing an IDE" class="link">Installing an IDE</a></li></ul></li>
        <li>installation, Eclipse (Scala-Ide) / <a href="#ch01lvl1sec12" title="Installing Eclipse (Scala-Ide)" class="link">Installing Eclipse (Scala-Ide)</a></li>
        <li>installation, IntelliJ CE<ul><li>about / <a href="#ch01lvl1sec12" title="Install IntelliJ CE" class="link">Install IntelliJ CE</a></li></ul></li>
        <li>installation, Java<ul><li>on Windows / <a href="#ch01lvl1sec12" title="Installing on Windows" class="link">Installing on Windows</a></li><li>on OSX / <a href="#ch01lvl1sec12" title="Installing on OS X" class="link">Installing on OS X</a></li><li>on Linux / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li><li>on Unix / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li></ul></li>
        <li>installation, Scala / <a href="#ch01lvl1sec12" title="Installing Scala" class="link">Installing Scala</a></li>
        <li>installation, Typesafe Activator<ul><li>about / <a href="#ch01lvl1sec12" title="Installing Typesafe Activator" class="link">Installing Typesafe Activator</a></li><li>on Windows / <a href="#ch01lvl1sec12" title="Windows" class="link">Windows</a></li><li>on Linux / <a href="#ch01lvl1sec12" title="Linux/Unix/OS X" class="link">Linux/Unix/OS X</a></li><li>on Unix / <a href="#ch01lvl1sec12" title="Linux/Unix/OS X" class="link">Linux/Unix/OS X</a></li><li>on OSX / <a href="#ch01lvl1sec12" title="OS X" class="link">OS X</a></li></ul></li>
        <li>integrated development environment (IDE)<ul><li>about / <a href="#ch01lvl1sec09" title="Chapter overview" class="link">Chapter overview</a></li></ul></li>
        <li>integration tests / <a href="#ch02lvl1sec20" title="Testing" class="link">Testing</a></li>
        <li>IntelliJ CE<ul><li>installing / <a href="#ch01lvl1sec12" title="Install IntelliJ CE" class="link">Install IntelliJ CE</a></li></ul></li>
        <li>IO Dispatcher Use<ul><li>blocking, with Futures / <a href="#ch05lvl1sec36" title="Blocking IO dispatcher use with futures" class="link">Blocking IO dispatcher use with futures</a></li></ul></li>
      </ul>
      <h2>J</h2>
      <ul>
        <li>Java<ul><li>configuration, ensuring / <a href="#ch01lvl1sec12" title="Ensuring Java is configured in your environment" class="link">Ensuring Java is configured in your environment</a></li></ul></li>
        <li>Java, installing<ul><li>about / <a href="#ch01lvl1sec12" title="Installing Java â€“ Oracle JDK8" class="link">Installing Java â€“ Oracle JDK8</a></li><li>on Windows / <a href="#ch01lvl1sec12" title="Installing on Windows" class="link">Installing on Windows</a></li><li>on OSX / <a href="#ch01lvl1sec12" title="Installing on OS X" class="link">Installing on OS X</a></li><li>on Linux / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li><li>on Unix / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li></ul></li>
        <li>Java8 examples<ul><li>about / <a href="#ch02lvl1sec20" title="Java example" class="link">Java example</a></li><li>Scala Futures / <a href="#ch02lvl1sec20" title="Working with Scala futures" class="link">Working with Scala futures</a></li><li>test case / <a href="#ch02lvl1sec20" title="Test case" class="link">Test case</a></li><li>Actor Creation / <a href="#ch02lvl1sec20" title="Actor creation" class="link">Actor creation</a></li></ul></li>
        <li>Java Actor API<ul><li>about / <a href="#ch02lvl1sec18" title="Java Actor API" class="link">Java Actor API</a></li></ul></li>
        <li>Java Database Connectivity (JDBC)<ul><li>about / <a href="#ch02lvl1sec20" title="Blocking versus event-driven APIs" class="link">Blocking versus event-driven APIs</a></li></ul></li>
        <li>Java SE 8, Lambda Quick Start<ul><li>reference link / <a href="#ch01lvl1sec12" title="Installing Java â€“ Oracle JDK8" class="link">Installing Java â€“ Oracle JDK8</a></li></ul></li>
      </ul>
      <h2>K</h2>
      <ul>
        <li>keys<ul><li>redistributing, to nodes / <a href="#ch06lvl1sec44" title="Pre-Sharding And Redistributing Keys to New Nodes" class="link">Pre-Sharding And Redistributing Keys to New Nodes</a></li></ul></li>
        <li>Kibana<ul><li>about / <a href="#ch09lvl1sec62" title="Monitoring Logs and Events" class="link">Monitoring Logs and Events</a></li></ul></li>
      </ul>
      <h2>L</h2>
      <ul>
        <li>language<ul><li>selecting / <a href="#ch01lvl1sec12" title="Choosing a language" class="link">Choosing a language</a></li></ul></li>
        <li>Linux<ul><li>Java, installing on / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li><li>Typesafe Activator, installing on / <a href="#ch01lvl1sec12" title="Linux/Unix/OS X" class="link">Linux/Unix/OS X</a></li></ul></li>
        <li>linux tar.gz JDK distribution, Oracle<ul><li>download link / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li></ul></li>
        <li>Lists of Futures<ul><li>dealing with / <a href="#ch02lvl1sec20" title="Dealing with lists of futures" class="link">Dealing with lists of futures</a></li></ul></li>
        <li>location transparency<ul><li>evolution / <a href="#ch01lvl1sec10" title="The Evolution of distribution and location transparency" class="link">The Evolution of distribution and location transparency</a></li></ul></li>
        <li>logging, in Akka<ul><li>about / <a href="#ch09lvl1sec60" title="Logging in Akka" class="link">Logging in Akka</a></li></ul></li>
        <li>logs<ul><li>monitoring / <a href="#ch09lvl1sec62" title="Monitoring Logs and Events" class="link">Monitoring Logs and Events</a></li></ul></li>
        <li>Logstash<ul><li>about / <a href="#ch09lvl1sec62" title="Monitoring Logs and Events" class="link">Monitoring Logs and Events</a></li></ul></li>
      </ul>
      <h2>M</h2>
      <ul>
        <li>mailbox<ul><li>about / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li></ul></li>
        <li>mailboxes<ul><li>about / <a href="#ch07lvl1sec49" title="Mailboxes" class="link">Mailboxes</a></li><li>configuring / <a href="#ch07lvl1sec49" title="Configuring mailboxes" class="link">Configuring mailboxes</a></li><li>selecting, in Deployment Configuration / <a href="#ch07lvl1sec49" title="Selecting a mailbox in deployment configuration" class="link">Selecting a mailbox in deployment configuration</a></li><li>selecting, in code / <a href="#ch07lvl1sec49" title="Selecting a mailbox in code" class="link">Selecting a mailbox in code</a></li><li>deciding, for configuration / <a href="#ch07lvl1sec49" title="Deciding which mailbox to use" class="link">Deciding which mailbox to use</a></li><li>messages, prioritizing in / <a href="#ch07lvl1sec49" title="Prioritizing messages in mailboxes" class="link">Prioritizing messages in mailboxes</a></li></ul></li>
        <li>mailing address<ul><li>about / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li></ul></li>
        <li>main method<ul><li>used, for starting actor system / <a href="#ch02lvl1sec20" title="Main" class="link">Main</a></li></ul></li>
        <li>Maven Central<ul><li>dependencies, adding from / <a href="#ch01lvl1sec13" title="Adding other Dependencies from Maven Central" class="link">Adding other Dependencies from Maven Central</a></li></ul></li>
        <li>message<ul><li>about / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li><li>making / <a href="#ch01lvl1sec13" title="Making the Message first" class="link">Making the Message first</a></li><li>making, in Java / <a href="#ch01lvl1sec13" title="Java" class="link">Java</a></li><li>making, in Scala / <a href="#ch01lvl1sec13" title="Scala" class="link">Scala</a></li></ul></li>
        <li>message-passing<ul><li>about / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li></ul></li>
        <li>Message Channels<ul><li>about / <a href="#ch09lvl1sec60" title="Message Channels and EventBus" class="link">Message Channels and EventBus</a></li></ul></li>
        <li>message flow<ul><li>testing / <a href="#ch08lvl1sec56" title="Testing Message flow" class="link">Testing Message flow</a></li></ul></li>
        <li>message passing<ul><li>about / <a href="#ch01lvl1sec10" title="Actors and Message passing" class="link">Actors and Message passing</a></li></ul></li>
        <li>messages<ul><li>preparing / <a href="#ch02lvl1sec20" title="Preparing the DB and messages" class="link">Preparing the DB and messages</a></li><li>about / <a href="#ch02lvl1sec20" title="The messages" class="link">The messages</a></li><li>publishing / <a href="#ch02lvl1sec20" title="Publishing the messages" class="link">Publishing the messages</a></li><li>immutable / <a href="#ch03lvl1sec24" title="Messages should be immutable" class="link">Messages should be immutable</a></li><li>stashing, between states / <a href="#ch04lvl1sec29" title="Stashing messages between states" class="link">Stashing messages between states</a></li><li>routing, to cluster / <a href="#ch06lvl1sec43" title="Routing Messages to the Cluster" class="link">Routing Messages to the Cluster</a></li><li>prioritizing, in mailboxes / <a href="#ch07lvl1sec49" title="Prioritizing messages in mailboxes" class="link">Prioritizing messages in mailboxes</a></li></ul></li>
        <li>messaging delivery<ul><li>about / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a></li></ul></li>
        <li>messaging patterns, Actor<ul><li>Ask / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Ask message pattern" class="link">Ask message pattern</a></li><li>Tell / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Tell" class="link">Tell</a></li><li>Forward / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Forward" class="link">Forward</a></li><li>Pipe / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Pipe" class="link">Pipe</a></li></ul></li>
        <li>microservices<ul><li>reference link / <a href="#ch06lvl1sec40" title="One Giant Monolith or Many Micro Services?" class="link">One Giant Monolith or Many Micro Services?</a></li></ul></li>
        <li>Mock Actors<ul><li>TestProbes, using as / <a href="#ch08lvl1sec56" title="Using TestProbes as mock Actors" class="link">Using TestProbes as mock Actors</a></li></ul></li>
        <li>Moore's Law<ul><li>about / <a href="#ch05lvl1sec32" title="Moore's law" class="link">Moore's law</a></li></ul></li>
        <li>multicore architecture, as distribution problem<ul><li>about / <a href="#ch05lvl1sec33" title="Multicore architecture as a distribution problem" class="link">Multicore architecture as a distribution problem</a></li></ul></li>
      </ul>
      <h2>N</h2>
      <ul>
        <li>node<ul><li>coordinating / <a href="#ch06lvl1sec43" title="Coordinating Node" class="link">Coordinating Node</a></li></ul></li>
        <li>nodes<ul><li>keys, redistributing to / <a href="#ch06lvl1sec44" title="Pre-Sharding And Redistributing Keys to New Nodes" class="link">Pre-Sharding And Redistributing Keys to New Nodes</a></li></ul></li>
      </ul>
      <h2>O</h2>
      <ul>
        <li>Offline State<ul><li>about / <a href="#ch04lvl1sec29" title="Online/Offline state" class="link">Online/Offline state</a></li></ul></li>
        <li>Online State<ul><li>about / <a href="#ch04lvl1sec29" title="Online/Offline state" class="link">Online/Offline state</a></li></ul></li>
        <li>Optimal Parallelism<ul><li>about / <a href="#ch05lvl1sec36" title="Optimal parallelism" class="link">Optimal parallelism</a></li></ul></li>
        <li>Oracle Java8 lambda primer<ul><li>reference link / <a href="#ch02lvl1sec20" title="Skills check-point" class="link">Skills check-point</a></li></ul></li>
        <li>OSX<ul><li>Java, installing on / <a href="#ch01lvl1sec12" title="Installing on OS X" class="link">Installing on OS X</a></li><li>Typesafe Activator, installing on / <a href="#ch01lvl1sec12" title="OS X" class="link">OS X</a></li></ul></li>
        <li>OSX JDK8 installer (dmg), Oracle<ul><li>download link / <a href="#ch01lvl1sec12" title="Installing on OS X" class="link">Installing on OS X</a></li></ul></li>
      </ul>
      <h2>P</h2>
      <ul>
        <li>Pinned Dispatcher / <a href="#ch05lvl1sec36" title="Creating Dispatchers" class="link">Creating Dispatchers</a></li>
        <li>Pipe message pattern<ul><li>about / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Pipe" class="link">Pipe</a></li></ul></li>
        <li>pre-sharding<ul><li>about / <a href="#ch06lvl1sec44" title="Pre-Sharding And Redistributing Keys to New Nodes" class="link">Pre-Sharding And Redistributing Keys to New Nodes</a></li></ul></li>
        <li>project<ul><li>creating / <a href="#ch01lvl1sec12" title="Creating a new project" class="link">Creating a new project</a></li><li>preparing, for Eclipse / <a href="#ch01lvl1sec12" title="Preparing the project for Eclipse" class="link">Preparing the project for Eclipse</a></li><li>importing, into Eclipse / <a href="#ch01lvl1sec12" title="Importing the project into Eclipse" class="link">Importing the project into Eclipse</a></li><li>scaffolding / <a href="#ch02lvl1sec20" title="Scaffolding the project" class="link">Scaffolding the project</a></li><li>sketching / <a href="#ch03lvl1sec23" title="Sketching the project" class="link">Sketching the project</a></li><li>core functionality / <a href="#ch03lvl1sec23" title="Core functionality" class="link">Core functionality</a></li></ul></li>
        <li>Promises<ul><li>about / <a href="#ch02lvl1sec20" title="Promises, futures, and event-driven programming models" class="link">Promises, futures, and event-driven programming models</a>, <a href="#ch02lvl1sec20" title="Understanding futures and promises" class="link">Understanding futures and promises</a></li></ul></li>
        <li>Props<ul><li>about / <a href="#ch02lvl1sec19" title="Props" class="link">Props</a></li></ul></li>
      </ul>
      <h2>R</h2>
      <ul>
        <li>Reactive Manifesto<ul><li>about / <a href="#ch02lvl1sec16" title="Reactive system design" class="link">Reactive system design</a></li><li>reference link / <a href="#ch02lvl1sec16" title="Reactive system design" class="link">Reactive system design</a></li></ul></li>
        <li>Reactive platform<ul><li>about / <a href="#ch02lvl1sec16" title="Reactive system design" class="link">Reactive system design</a></li></ul></li>
        <li>Reactive Streams<ul><li>about / <a href="#ch07lvl1sec50" title="Circuit breaker examples" class="link">Circuit breaker examples</a></li><li>URL / <a href="#ch07lvl1sec50" title="Circuit breaker examples" class="link">Circuit breaker examples</a></li><li>reference link / <a href="#ch07lvl1sec50" title="Circuit breaker examples" class="link">Circuit breaker examples</a></li></ul></li>
        <li>Reactive System Design<ul><li>about / <a href="#ch02lvl1sec16" title="Reactive system design" class="link">Reactive system design</a></li></ul></li>
        <li>Reactive Tenet Correlation<ul><li>about / <a href="#ch02lvl1sec17" title="Reactive Tenet Correlation" class="link">Reactive Tenet Correlation</a></li></ul></li>
        <li>Reactive Tenets<ul><li>about / <a href="#ch02lvl1sec17" title="The 4 reactive tenets" class="link">The 4 reactive tenets</a></li><li>Responsive / <a href="#ch02lvl1sec17" title="Responsive" class="link">Responsive</a></li><li>Elastic / <a href="#ch02lvl1sec17" title="Elastic" class="link">Elastic</a></li><li>Resilient / <a href="#ch02lvl1sec17" title="Resilient" class="link">Resilient</a></li><li>Event-Driven/Message-Driven / <a href="#ch02lvl1sec17" title="Event-driven/message-driven" class="link">Event-driven/message-driven</a></li></ul></li>
        <li>Red Hat Enterprise Linux (RHEL) / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li>
        <li>redundancy<ul><li>about / <a href="#ch04lvl1sec28" title="Redundancy" class="link">Redundancy</a></li></ul></li>
        <li>redundant nodes / <a href="#ch06lvl1sec43" title="Redundant Nodes" class="link">Redundant Nodes</a></li>
        <li>remote access<ul><li>enabling, to Actor / <a href="#ch02lvl1sec20" title="Enabling remoting" class="link">Enabling remoting</a></li></ul></li>
        <li>remote actor<ul><li>addressing / <a href="#ch06lvl1sec45" title="Addressing Remote Actors" class="link">Addressing Remote Actors</a></li><li>finding, akka.actor.Identify used / <a href="#ch06lvl1sec45" title="Using akka.actor.Identify to Find a Remote Actor" class="link">Using akka.actor.Identify to Find a Remote Actor</a></li></ul></li>
        <li>resiliency<ul><li>about / <a href="#ch07lvl1sec49" title="Resiliency" class="link">Resiliency</a></li></ul></li>
        <li>responsive<ul><li>staying, under load / <a href="#ch07lvl1sec50" title="Staying responsive under load" class="link">Staying responsive under load</a></li></ul></li>
        <li>Restarts<ul><li>used, for transition through states / <a href="#ch04lvl1sec29" title="Using restarts to transition through states" class="link">Using restarts to transition through states</a></li></ul></li>
        <li>right Scala version<ul><li>obtaining, with %% / <a href="#ch01lvl1sec13" title="A note on getting the right Scala version with %%" class="link">A note on getting the right Scala version with %%</a></li></ul></li>
        <li>Round-trip Delay Time (RTD or RTT) / <a href="#ch04lvl1sec29" title="Finite State Machines (FSM)" class="link">Finite State Machines (FSM)</a></li>
        <li>Round Robin / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li>
        <li>Routees<ul><li>supervising, in Router Pool / <a href="#ch05lvl1sec35" title="Supervising the Routees in a Router Pool" class="link">Supervising the Routees in a Router Pool</a></li></ul></li>
        <li>Router<ul><li>about / <a href="#ch05lvl1sec35" title="Introducing Routers" class="link">Introducing Routers</a></li></ul></li>
        <li>Router Group/Pool<ul><li>messages, sending to actor / <a href="#ch05lvl1sec35" title="Sending Messages to All Actors in a Router Group/Pool" class="link">Sending Messages to All Actors in a Router Group/Pool</a></li></ul></li>
        <li>Router Pool<ul><li>Routees, supervising in / <a href="#ch05lvl1sec35" title="Supervising the Routees in a Router Pool" class="link">Supervising the Routees in a Router Pool</a></li></ul></li>
        <li>Routing Logic<ul><li>about / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li></ul></li>
        <li>Routing Strategies<ul><li>Round Robin / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li><li>Smallest Mailbox / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li><li>Scatter Gather / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li><li>Tail Chopping / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li><li>Consistent Hashing / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li><li>BalancingPool / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li></ul></li>
      </ul>
      <h2>S</h2>
      <ul>
        <li>sbteclipse github project<ul><li>reference link / <a href="#ch01lvl1sec12" title="Preparing the project for Eclipse" class="link">Preparing the project for Eclipse</a></li></ul></li>
        <li>SBT Project<ul><li>setting up / <a href="#ch01lvl1sec13" title="Creating your first Akka application â€“ setting up the SBT project" class="link">Creating your first Akka application â€“ setting up the SBT project</a></li></ul></li>
        <li>Scala<ul><li>installing / <a href="#ch01lvl1sec12" title="Installing Scala" class="link">Installing Scala</a></li></ul></li>
        <li>Scala-Ide<ul><li>download link / <a href="#ch01lvl1sec12" title="Installing Eclipse (Scala-Ide)" class="link">Installing Eclipse (Scala-Ide)</a></li></ul></li>
        <li>Scala Actor API<ul><li>about / <a href="#ch02lvl1sec18" title="Scala Actor API" class="link">Scala Actor API</a></li></ul></li>
        <li>Scala example<ul><li>about / <a href="#ch02lvl1sec20" title="Scala example" class="link">Scala example</a></li><li>test case / <a href="#ch02lvl1sec20" title="Test case" class="link">Test case</a></li><li>Actor Creation / <a href="#ch02lvl1sec20" title="Actor creation" class="link">Actor creation</a></li></ul></li>
        <li>Scala Futures<ul><li>working with / <a href="#ch02lvl1sec20" title="Working with Scala futures" class="link">Working with Scala futures</a></li></ul></li>
        <li>Scatter Gather / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li>
        <li>sharding, and replication<ul><li>combining / <a href="#ch06lvl1sec44" title="Combining Sharding and Replication" class="link">Combining Sharding and Replication</a></li></ul></li>
        <li>sharding, for linear scalability / <a href="#ch06lvl1sec43" title="Sharding for Linear Scalability" class="link">Sharding for Linear Scalability</a></li>
        <li>simple build tool (SBT) / <a href="#ch01lvl1sec12" title="Installing Typesafe Activator" class="link">Installing Typesafe Activator</a>, <a href="#ch01lvl1sec13" title="Creating your first Akka application â€“ setting up the SBT project" class="link">Creating your first Akka application â€“ setting up the SBT project</a></li>
        <li>skills Check-point<ul><li>about / <a href="#ch02lvl1sec20" title="Skills check-point" class="link">Skills check-point</a></li></ul></li>
        <li>Sleeping<ul><li>about / <a href="#ch02lvl1sec20" title="Note on sleeping" class="link">Note on sleeping</a></li></ul></li>
        <li>Smallest Mailbox / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li>
        <li>stage<ul><li>setting, with example problem / <a href="#ch03lvl1sec23" title="Setting the stage with an example problem" class="link">Setting the stage with an example problem</a></li></ul></li>
        <li>Stash Leaks<ul><li>about / <a href="#ch04lvl1sec29" title="Stash leaks" class="link">Stash leaks</a></li></ul></li>
        <li>State<ul><li>about / <a href="#ch04lvl1sec29" title="State" class="link">State</a></li><li>Online State / <a href="#ch04lvl1sec29" title="Online/Offline state" class="link">Online/Offline state</a></li><li>Offline State / <a href="#ch04lvl1sec29" title="Online/Offline state" class="link">Online/Offline state</a></li></ul></li>
        <li>State Container<ul><li>defining / <a href="#ch04lvl1sec29" title="Defining the state container" class="link">Defining the state container</a></li></ul></li>
        <li>States<ul><li>defining / <a href="#ch04lvl1sec29" title="Defining states" class="link">Defining states</a></li></ul></li>
        <li>states<ul><li>messages, stashing between / <a href="#ch04lvl1sec29" title="Stashing messages between states" class="link">Stashing messages between states</a></li></ul></li>
        <li>Success Cases, Futures<ul><li>handling / <a href="#ch02lvl1sec20" title="Handling success cases" class="link">Handling success cases</a></li><li>code, executing with result / <a href="#ch02lvl1sec20" title="Executing code with the result" class="link">Executing code with the result</a></li><li>result, transforming / <a href="#ch02lvl1sec20" title="Transforming the result" class="link">Transforming the result</a></li><li>result, transforming asynchronously / <a href="#ch02lvl1sec20" title="Transforming the result asynchronously" class="link">Transforming the result asynchronously</a></li></ul></li>
        <li>supervision<ul><li>evolution / <a href="#ch01lvl1sec10" title="The Evolution of supervision and fault tolerance in Erlang" class="link">The Evolution of supervision and fault tolerance in Erlang</a></li><li>about / <a href="#ch04lvl1sec28" title="Supervision" class="link">Supervision</a></li><li>actor lifecycle / <a href="#ch04lvl1sec28" title="Actor lifecycle" class="link">Actor lifecycle</a></li><li>messages, in restart / <a href="#ch04lvl1sec28" title="Messages in restart, stop" class="link">Messages in restart, stop</a></li><li>messages, in stop / <a href="#ch04lvl1sec28" title="Messages in restart, stop" class="link">Messages in restart, stop</a></li><li>lifecycle monitoring / <a href="#ch04lvl1sec28" title="Lifecycle monitoring and DeathWatch" class="link">Lifecycle monitoring and DeathWatch</a></li><li>DeathWatch / <a href="#ch04lvl1sec28" title="Lifecycle monitoring and DeathWatch" class="link">Lifecycle monitoring and DeathWatch</a></li></ul></li>
        <li>Supervision Hierarchies<ul><li>about / <a href="#ch04lvl1sec28" title="Supervision hierarchies" class="link">Supervision hierarchies</a></li></ul></li>
        <li>supervision strategies<ul><li>about / <a href="#ch04lvl1sec28" title="Supervision strategies and the drunken sushi chef" class="link">Supervision strategies and the drunken sushi chef</a></li></ul></li>
        <li>supervisor strategies<ul><li>defining / <a href="#ch04lvl1sec28" title="Defining supervisor strategies" class="link">Defining supervisor strategies</a></li></ul></li>
        <li>systems<ul><li>building, with Akka Cluster / <a href="#ch06lvl1sec43" title="Building Systems with Akka Cluster" class="link">Building Systems with Akka Cluster</a></li></ul></li>
      </ul>
      <h2>T</h2>
      <ul>
        <li>Tail Chopping / <a href="#ch05lvl1sec35" title="Routing logic" class="link">Routing logic</a></li>
        <li>Tell message pattern<ul><li>about / <a href="#ch03lvl1sec24" title="Messaging delivery" class="link">Messaging delivery</a>, <a href="#ch03lvl1sec24" title="Tell" class="link">Tell</a></li><li>designing with / <a href="#ch03lvl1sec24" title="Designing with Tell" class="link">Designing with Tell</a>, <a href="#ch03lvl1sec24" title="Handling replies with Tell " class="link">Handling replies with Tell </a>, <a href="#ch03lvl1sec24" title="Scheduling a Tell Timeout" class="link">Scheduling a Tell Timeout</a>, <a href="#ch03lvl1sec24" title="Avoiding Ask with an Anonymous Actor" class="link">Avoiding Ask with an Anonymous Actor</a></li></ul></li>
        <li>test<ul><li>using, as Actor / <a href="#ch08lvl1sec56" title="Using the test Itself as an Actor" class="link">Using the test Itself as an Actor</a></li></ul></li>
        <li>testing<ul><li>advice / <a href="#ch08lvl1sec57" title="Testing Advice" class="link">Testing Advice</a></li></ul></li>
        <li>TestProbes<ul><li>using, as Mock Actors / <a href="#ch08lvl1sec56" title="Using TestProbes as mock Actors" class="link">Using TestProbes as mock Actors</a></li></ul></li>
        <li>tests<ul><li>running / <a href="#ch01lvl1sec13" title="Running the test" class="link">Running the test</a></li><li>threads, blocking in / <a href="#ch02lvl1sec20" title="Blocking threads in tests" class="link">Blocking threads in tests</a></li></ul></li>
        <li>threads<ul><li>blocking, in tests / <a href="#ch02lvl1sec20" title="Blocking threads in tests" class="link">Blocking threads in tests</a></li></ul></li>
        <li>Transitioning State / <a href="#ch04lvl1sec29" title="Transitioning state" class="link">Transitioning state</a></li>
        <li>Typesafe Activator<ul><li>download link / <a href="#ch01lvl1sec12" title="Windows" class="link">Windows</a></li></ul></li>
        <li>Typesafe Activator, installing<ul><li>about / <a href="#ch01lvl1sec12" title="Installing Typesafe Activator" class="link">Installing Typesafe Activator</a></li><li>on Windows / <a href="#ch01lvl1sec12" title="Windows" class="link">Windows</a></li><li>on Linux / <a href="#ch01lvl1sec12" title="Linux/Unix/OS X" class="link">Linux/Unix/OS X</a></li><li>on Unix / <a href="#ch01lvl1sec12" title="Linux/Unix/OS X" class="link">Linux/Unix/OS X</a></li><li>on OSX / <a href="#ch01lvl1sec12" title="OS X" class="link">OS X</a></li></ul></li>
      </ul>
      <h2>U</h2>
      <ul>
        <li>Ubiquitous Language / <a href="#ch08lvl1sec55" title="Designing the Domain model" class="link">Designing the Domain model</a></li>
        <li>unbecome() method / <a href="#ch04lvl1sec29" title="Hotswap: Become/Unbecome" class="link">Hotswap: Become/Unbecome</a></li>
        <li>unit tests<ul><li>code, validating with / <a href="#ch01lvl1sec13" title="Validating the code with unit tests" class="link">Validating the code with unit tests</a></li></ul></li>
        <li>Unix<ul><li>Java, installing on / <a href="#ch01lvl1sec12" title="Installing on Linux or Unix (Universal instructions)" class="link">Installing on Linux or Unix (Universal instructions)</a></li><li>Typesafe Activator, installing on / <a href="#ch01lvl1sec12" title="Linux/Unix/OS X" class="link">Linux/Unix/OS X</a></li></ul></li>
      </ul>
      <h2>V</h2>
      <ul>
        <li>Vector Clocks<ul><li>reference link / <a href="#ch06lvl1sec43" title="Redundant Nodes" class="link">Redundant Nodes</a></li></ul></li>
        <li>Virtual Machine (VM) / <a href="#ch04lvl1sec27" title="The network is homogeneous" class="link">The network is homogeneous</a></li>
      </ul>
      <h2>W</h2>
      <ul>
        <li>Windows<ul><li>Java, installing on / <a href="#ch01lvl1sec12" title="Installing on Windows" class="link">Installing on Windows</a></li><li>Typesafe Activator, installing on / <a href="#ch01lvl1sec12" title="Windows" class="link">Windows</a></li></ul></li>
        <li>windows JDK8 installer (dmg), Oracle<ul><li>download link / <a href="#ch01lvl1sec12" title="Installing on Windows" class="link">Installing on Windows</a></li></ul></li>
      </ul>
    </div>
  </div></div></div>
</div></div></div></body></html>
